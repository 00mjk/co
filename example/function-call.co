
// fun f_int_int_(z int, x ...int) int
// fun f_int_(x ...int) int
// fun f_int_int(x, y int) int
fun f_int_f32_int_(a int, b f32, x ...u32) int

// list1 [int] // ok; calls parseType -> parseListType

fun entry(x int, y ...int) f32 {
  // note: effective type of y here is [int]

  ls list<u32>

  // z = u32[][3, 4]
  z = u32[3, 4] // E: "unexpected ,, expecting ]"

  // ok:
  // f_int_f32_int_(1, 2.3)          // ok (empty rest)
  // f_int_f32_int_(1, 2.3, y...)    // ok (spread y int[] as rest)
  // f_int_f32_int_(1, 2.3, ls...)   // ok (spread ls int[] as rest)
  // f_int_f32_int_(1, 2.3, [3, 4]...)  // ok (spread _ int[] as rest)
  // f_int_f32_int_(1, 2.3, 3, 4)       // ok (synthetic rest; sugar for above)


  // errors, argument count:
  // f_int_f32_int_(1, y...) // E: not enough arguments
  // f_int_f32_int_(1) // E: not enough arguments
  // f_int_f32_int_(1, 2, 3, y...) // E: too many arguments

  // errors, argument types:
  // f_int_f32_int_(y...) // E:
  // f_int_f32_int_(1, 2.3, y) // E: cannot use y (type [int]) as type int


  // TODO:

  // // ok: spread of tuples onto fixed arguments --TODO--
  // t1 = (1, 2.3, 3, 4)
  // f_int_f32_int_(t1...)

  // // ok: spread of array
  // a [int] = [3, 4, 5]
  // f_int_f32_int_(1, 2.3, a...)

  0
}
