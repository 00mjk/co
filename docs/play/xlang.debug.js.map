{"version":3,"file":"xlang.debug.js","sources":["../src/btree.ts","../src/token.ts","../src/utf8.ts","../src/unicode.ts","../src/termstyle.ts","../src/error.ts","../src/path.ts","../src/strtou.ts","../src/int64.ts","../src/intparse.ts","../src/util.ts","../src/scanner.ts","../src/types.ts","../src/num.ts","../src/ast.ts","../src/parser.ts","../src/bind.ts","../src/pos.ts","../src/bytestr.ts","../src/typeset.ts","../src/ast_repr.ts","../src/universe.ts","../src/typecompat.ts","../src/resolve.ts","../src/ir/reg.ts","../src/ir/op.ts","../src/ir/consteval.ts","../src/ir/opt_cf.ts","../src/ir/postorder.ts","../src/ir/ssa.ts","../src/ir/opselect.ts","../src/ir/repr.ts","../src/ir/localslot.ts","../src/ir/builder.ts","../src/time.ts","../src/ir/copyelim.ts","../src/ir/phielim.ts","../src/ir/rewrite.ts","../src/ir/lower.ts","../src/ir/deadcode.ts","../src/ir/shortcircuit.ts","../src/ir/reg_desiredstate.ts","../src/intgraph.ts","../src/ir/regalloc.ts","../src/ir/passes.ts","../src/ir/config.ts","../src/arch/arch.ts","../src/arch/covm.ts","../src/arch/all.ts","../src/int64_rand.ts","../src/test.ts","../src/int64_test.ts","../src/scanner_test.ts","../src/scan_num_test.ts","../src/intgraph_test.ts","../src/main.ts"],"sourcesContent":["export interface BTreeNode<T> {\n  k  :ArrayLike<byte>\n  v  :T\n  L? :BTreeNode<T>\n  R? :BTreeNode<T>\n}\n\nexport class BTree<T> {\n  readonly root :BTreeNode<T>\n  constructor(root :BTreeNode<T>) {\n    this.root = root\n  }\n\n  get(key :ArrayLike<byte>) :T|null {\n    return lookup(key, this.root)\n  }\n}\n\n// function lookup<T>(key :ArrayLike<byte>, n :BTreeNode<T>) :T|null {\n//   let c = bufcmp(key, n.k)\n//   return (\n//     (c == -1) ? n.L ? lookup(key, n.L) : null :\n//     (c == 1) ? n.R ? lookup(key, n.R) : null :\n//     (key.length == n.k.length) ? n.v :\n//     null\n//   )\n// }\n\nfunction lookup<T>(key :ArrayLike<byte>, n :BTreeNode<T>) :T|null {\n  while (n) {\n    const c = bufcmp(key, n.k)\n    if (c == -1) {\n      n = n.L as BTreeNode<T>\n    } else if (c == 1) {\n      n = n.R as BTreeNode<T>\n    } else if (key.length == n.k.length) {\n      return n.v\n    } else {\n      break\n    }\n  }\n  return null\n}\n\nfunction bufcmp(a :ArrayLike<byte>, b :ArrayLike<byte>) :int {\n  const aL = a.length, bL = b.length, L = (aL < bL ? aL : bL)\n  for (let i = 0; i != L; ++i) {\n    if (a[i] < b[i]) { return -1 }\n    if (b[i] < a[i]) { return 1 }\n  }\n  return (\n    aL < bL ? -1 :\n    bL < aL ? 1 :\n    0\n  )\n}\n","import { BTree } from './btree'\n\nexport function tokIsKeyword(t :token) :bool {\n  return token.keyword_beg < t && t < token.keyword_end\n}\n\nexport function hasIntValue(t :token) :bool {\n  return t == token.CHAR\n}\n\nexport function hasByteValue(t :token) :bool {\n  return (\n    (token.literal_beg < t && t < token.literal_end) ||\n    t == token.COMMENT\n  )\n}\n\n// Operator precedences\nexport enum prec {\n  LOWEST, // = := ! <- ->\n  OROR,     // ||\n  ANDAND,    // &&\n  CMP,    // == != < <= > >=\n  ADD,    // + - | ^\n  MUL,    // * / % & &^ << >>\n}\n\nexport enum token {\n  // Special tokens\n  ILLEGAL = 0,\n  EOF,\n  COMMENT,\n\n  literal_beg,\n  // Identifiers and basic type literals\n  // (these tokens stand for classes of literals)\n  NAME,    // main\n  NAMEAT,  // @foo, @\n  literal_num_beg,\n  literal_int_beg,\n  CHAR,    // 'a'\n  INT,     // 12345\n  INT_BIN, // 0b1010\n  INT_OCT, // 0o6737\n  INT_HEX, // 0xBE3f\n  literal_int_end,\n  FLOAT,   // 123.45\n  // RATIO,   // 22/7\n  literal_num_end,\n  STRING,  // \"abc\"\n  STRING_MULTI, // \"ab\\nc\" â€” multi-line\n  STRING_PIECE, // \"a ${...} b\" -- the \"a \" part (\" b\" is STRING)\n  literal_end,\n\n  // Delimiters\n  delim_beg,\n  LPAREN,    // (\n  LBRACKET,  // [\n  LBRACE,    // {\n  COMMA,     // ,\n  DOT,       // .\n  PERIODS,   // ..\n  ELLIPSIS,  // ...\n  RPAREN,    // )\n  RBRACKET,  // ]\n  RBRACE,    // }\n  SEMICOLON, // ;\n  COLON,     // :\n  delim_end,\n\n  // Operators\n  operator_beg,\n\n  // prec.LOWEST\n  ASSIGN,         // =\n  assignop_beg,\n  ADD_ASSIGN,     // +=\n  SUB_ASSIGN,     // -=\n  MUL_ASSIGN,     // *=\n  QUO_ASSIGN,     // /=\n  REM_ASSIGN,     // %=\n  AND_ASSIGN,     // &=\n  OR_ASSIGN,      // |=\n  XOR_ASSIGN,     // ^=\n  SHL_ASSIGN,     // <<=\n  SHR_ASSIGN,     // >>=\n  AND_NOT_ASSIGN, // &^=\n  assignop_end,\n  INC,            // ++\n  DEC,            // --\n  SET_ASSIGN,     // :=\n  NOT,            // !\n  ARROWL,         // <-\n  ARROWR,         // ->\n\n  cmpop_beg,\n  // prec.OR\n  OROR, // ||\n  \n  // prec.AND\n  ANDAND, // &&\n\n  // prec.CMP\n  EQL, // ==\n  NEQ, // !=\n  LSS, // <\n  LEQ, // <=\n  GTR, // >\n  GEQ, // >=\n  cmpop_end,\n\n  // prec.ADD\n  ADD, // +\n  SUB, // -\n  OR,  // |\n  XOR, // ^  \"NOT\" when unary, \"XOR\" when binary\n  \n  // prec.MUL\n  MUL,     // *\n  QUO,     // /\n  REM,     // %\n  AND,     // &\n  AND_NOT, // &^  equiv to `x & (^y)` (or `x & ~y` in C)\n  SHL,     // <<\n  SHR,     // >>  (arithmetic when signed, logical when unsigned)\n\n  operator_end,\n\n  // Keywords\n  keyword_beg,\n  BREAK,\n  //CASE,\n  //CHAN,\n  //CONST,\n  CONTINUE,\n  DEFAULT,\n  DEFER,\n  ELSE,\n  ENUM,\n  FALLTHROUGH,\n  FOR,\n  FUN,\n  GO,\n  //GOTO,\n  IF,\n  IMPORT,\n  INTERFACE,\n  IN,\n  //MAP,\n  //PACKAGE,\n  //RANGE,\n  RETURN,\n  SELECT,\n  //STRUCT,\n  SWITCH,\n  SYMBOL,\n  TYPE,\n  // VAR,\n  WHILE,\n  keyword_end,\n} // enum T\n\n\n// Keywords\n// When you add, change or remove a keyword, make sure to run gen-btree.js\n// with the changes and update the code below.\n// Keyword token names should be the UPPER-CASE version of the actual keyword\n// name. This convention is used to populate tokenStrings.\n\n\nconst tokenStrings = new Map<token, string>([\n  [token.NAMEAT, \"@\"],\n\n  [token.ADD, \"+\"],\n  [token.SUB, \"-\"],\n  [token.MUL, \"*\"],\n  [token.QUO, \"/\"],\n  [token.REM, \"%\"],\n\n  [token.AND,     \"&\"],\n  [token.OR,      \"|\"],\n  [token.XOR,     \"^\"],\n  [token.SHL,     \"<<\"],\n  [token.SHR,     \">>\"],\n  [token.AND_NOT, \"&^\"],\n\n  [token.ADD_ASSIGN, \"+=\"],\n  [token.SUB_ASSIGN, \"-=\"],\n  [token.MUL_ASSIGN, \"*=\"],\n  [token.QUO_ASSIGN, \"/=\"],\n  [token.REM_ASSIGN, \"%=\"],\n\n  [token.AND_ASSIGN,     \"&=\"],\n  [token.OR_ASSIGN,      \"|=\"],\n  [token.XOR_ASSIGN,     \"^=\"],\n  [token.SHL_ASSIGN,     \"<<=\"],\n  [token.SHR_ASSIGN,     \">>=\"],\n  [token.AND_NOT_ASSIGN, \"&^=\"],\n\n  [token.ANDAND, \"&&\"],\n  [token.OROR,   \"||\"],\n  [token.ARROWL, \"<-\"],\n  [token.ARROWR, \"->\"],\n  [token.INC,    \"++\"],\n  [token.DEC,    \"--\"],\n\n  [token.EQL,    \"==\"],\n  [token.LSS,    \"<\"],\n  [token.GTR,    \">\"],\n  [token.ASSIGN, \"=\"],\n  [token.NOT,    \"!\"],\n\n  [token.NEQ,        \"!=\"],\n  [token.LEQ,        \"<=\"],\n  [token.GEQ,        \">=\"],\n  [token.SET_ASSIGN, \":=\"],\n  [token.ELLIPSIS,   \"...\"],\n  [token.PERIODS,    \"..\"],\n\n  [token.LPAREN,   \"(\"],\n  [token.LBRACKET, \"[\"],\n  [token.LBRACE,   \"{\"],\n  [token.COMMA,    \",\"],\n  [token.DOT,      \".\"],\n\n  [token.RPAREN,    \")\"],\n  [token.RBRACKET,  \"]\"],\n  [token.RBRACE,    \"}\"],\n  [token.SEMICOLON, \";\"],\n  [token.COLON,     \":\"],\n]) // tokenStrings\n\nfor (let i = token.keyword_beg+1; i < token.keyword_end; ++i) {\n  const t = token[i] as string\n  tokenStrings.set((token as any)[t] as token, t.toLowerCase())\n}\n\n// tokstr returns a printable version of the token\n//\nexport function tokstr(t :token) :string {\n  return tokenStrings.get(t) || token[t].toLowerCase()\n}\n\n// BEGIN generated by gen-keywords.js\nconst cdat = new Uint8Array([\n  103,111,100,101,102,101,114,98,114,101,97,107,99,111,110,116,105,110,117,101\n  ,100,101,102,97,117,108,116,101,110,117,109,101,108,115,101,102,97,108,108\n  ,116,104,114,111,117,103,104,102,111,114,102,117,110,114,101,116,117,114,110\n  ,105,109,112,111,114,116,105,102,105,110,105,110,116,101,114,102,97,99,101\n  ,115,119,105,116,99,104,115,101,108,101,99,116,115,121,109,98,111,108,116\n  ,121,112,101,119,104,105,108,101]);\nconst keywords = new BTree<token>(\n  { k: cdat.subarray(0,2) /*go*/, v: token.GO,\n    L:{ k: cdat.subarray(2,7) /*defer*/, v: token.DEFER,\n      L:{ k: cdat.subarray(7,12) /*break*/, v: token.BREAK,\n        R:{ k: cdat.subarray(12,20) /*continue*/, v: token.CONTINUE,\n          R:{ k: cdat.subarray(20,27) /*default*/, v: token.DEFAULT}}},\n      R:{ k: cdat.subarray(27,31) /*enum*/, v: token.ENUM,\n        L:{ k: cdat.subarray(31,35) /*else*/, v: token.ELSE},\n        R:{ k: cdat.subarray(35,46) /*fallthrough*/, v: token.FALLTHROUGH,\n          R:{ k: cdat.subarray(46,49) /*for*/, v: token.FOR,\n            R:{ k: cdat.subarray(49,52) /*fun*/, v: token.FUN}}}}},\n    R:{ k: cdat.subarray(52,58) /*return*/, v: token.RETURN,\n      L:{ k: cdat.subarray(58,64) /*import*/, v: token.IMPORT,\n        L:{ k: cdat.subarray(64,66) /*if*/, v: token.IF},\n        R:{ k: cdat.subarray(66,68) /*in*/, v: token.IN,\n          R:{ k: cdat.subarray(68,77) /*interface*/, v: token.INTERFACE}}},\n      R:{ k: cdat.subarray(77,83) /*switch*/, v: token.SWITCH,\n        L:{ k: cdat.subarray(83,89) /*select*/, v: token.SELECT},\n        R:{ k: cdat.subarray(89,95) /*symbol*/, v: token.SYMBOL,\n          R:{ k: cdat.subarray(95,99) /*type*/, v: token.TYPE,\n            R:{ k: cdat.subarray(99,104) /*while*/, v: token.WHILE}}}}}}\n)\n// END generated by gen-keywords.js\n\n// lookupKeyword maps an identifier to its keyword token or NAME\n// (if not a keyword).\n//\nexport function lookupKeyword(ident :ArrayLike<byte>) :token {\n  return keywords.get(ident) || token.NAME\n}\n","// UTF-8\n//\n// codepoint -> UTF-8 bytes\n//   encode         (dst WArrayLike<byte>, offset int, codepoint) -> nwrite int\n//   encodeString   (src string) -> Uint8Array\n//   encodeAsString (codepoint) -> string\n//\n// UTF-8 bytes -> codepoint\n//   decode         (src ArrayLike<byte>, offset int, DecodeResult) -> ok bool\n//   decodeToString (src ArrayLike<byte>) -> string\n//\n// misc\n//   byteSize(codepoint) -> size int\n//\n\nexport const\n  UniError = 0xFFFD,   // the \"error\" Rune or \"Unicode replacement character\"\n  UniSelf  = 0x80,     // characters below UniSelf are represented as\n                       // themselves in a single byte.\n  UTFMax   = 4         // Maximum number of bytes of a UTF8-encoded char\n\nconst\n  maxCp        = 0x10FFFF, // Maximum valid Unicode code point.\n  // Code points in the surrogate range are not valid for UTF-8.\n  surrogateMin = 0xD800,\n  surrogateMax = 0xDFFF,\n  // rune1Max = 1<<8 - 1  // 0x80\n  rune2Max = 1<<11 - 1 // 0x400\n  // rune3Max = 1<<16 - 1  // 0x8000\n\nexport interface DecodeResult {\n  c :int // codepoint -- UniError on error\n  w :int // width in bytes -- may be 0 on error\n}\n\nexport function decode(\n  src    :ArrayLike<byte>,\n  offset :int,\n  r      :DecodeResult\n) :bool {\n  const b = src[offset]\n\n  if (b < UniSelf) {\n    r.c = isNaN(b) ? UniError : b\n    r.w = 1\n  } else {\n    const end = src.length\n\n    if ((b >> 5) == 0x6) {\n      r.c = offset + 2 > end ? UniError :\n            ((b << 6) & 0x7ff) +\n            ((src[++offset]) & 0x3f),\n      r.w = 2\n    } else if ((b >> 4) == 0xe) {\n      r.c = offset + 3 > end ? UniError :\n            ((b << 12) & 0xffff) +\n            ((src[++offset] << 6) & 0xfff) +\n            ((src[++offset]) & 0x3f),\n      r.w = 3\n    } else if ((b >> 3) == 0x1e) {\n      r.c=  offset + 4 > end ? UniError :\n            ((b << 18) & 0x1fffff) +\n            ((src[++offset] << 12) & 0x3ffff) +\n            ((src[++offset] << 6) & 0xfff) +\n             (src[++offset] & 0x3f),\n      r.w = 4\n    } else {\n      return false\n    }\n  }\n\n  return true\n}\n\ninterface TextDecoderOptions {\n  fatal?: boolean\n  ignoreBOM?: boolean\n}\ninterface TextDecodeOptions {\n  stream?: boolean\n}\n\ndeclare class TextDecoder {\n  constructor(utfLabel?: string, options?: TextDecoderOptions)\n  encoding: string\n  fatal: boolean\n  ignoreBOM: boolean\n  decode(input?: ArrayBufferView, options?: TextDecodeOptions): string\n}\n\n\nexport let decodeToString :(src :ArrayLike<byte>) => string\n\nif (typeof TextDecoder != 'undefined') {\n  const dec = new TextDecoder('utf-8')\n  decodeToString = (src :ArrayLike<byte>) => dec.decode(\n    (src as any).buffer != undefined ? src as Uint8Array :\n    new Uint8Array(src)\n  )\n} else if (typeof Buffer != 'undefined') {\n  // nodejs\n  decodeToString = (src :ArrayLike<byte>) => {\n    let buf :Buffer\n    if (src instanceof Buffer) {\n      buf = src\n    } else if (\n      (src as any).buffer &&\n      (src as any).byteOffset !== undefined &&\n      (src as any).byteLength !== undefined\n    ) {\n      buf = Buffer.from(\n        (src as any).buffer as ArrayBuffer,\n        (src as any).byteOffset as int,\n        (src as any).byteLength as int\n      )\n    } else {\n      buf = Buffer.allocUnsafe(src.length)\n      for (let i = 0; i < src.length; ++i) {\n        buf[i] = src[i]\n      }\n    }\n    return buf.toString('utf8')\n  }\n} else {\n  // todo: fallback implementation\n  panic('missing TextDecoder')\n}\n\n\ndeclare class TextEncoder  {\n  constructor(utfLabel?: string)\n    // utfLabel ignored since Firefox >=48 and Chrome >=53 (always utf-8)\n  encoding :string // always \"utf-8\"\n  encode(input? :string, options? :TextEncodeOptions) :Uint8Array\n}\n\ninterface TextEncodeOptions {\n  stream?: boolean\n}\n\nexport let encodeString :(src :string) => Uint8Array\n\nif (typeof TextEncoder != 'undefined') {\n  const enc = new TextEncoder('utf-8')\n  encodeString = (s :string) => enc.encode(s)\n} else if (typeof Buffer != 'undefined') {\n  encodeString = (s :string) => Buffer.from(s, 'utf8') as Uint8Array\n} else {\n  // todo: fallback implementation\n  panic('missing TextEncoder')\n}\n\n\n// encode writes into b (which must be large enough) the UTF-8 encoding\n// of the character. Never writes more than UTFMax bytes.\n// Returns the number of bytes written.\n//\nexport function encode(b :WArrayLike<byte>, offs :int, cp :int) :int {\n  if (cp < UniSelf) {\n    b[offs] = cp\n    return 1\n  }\n  if (cp < 0x800) {\n    b[offs]   = (cp >> 6)   | 0xc0\n    b[++offs] = (cp & 0x3f) | 0x80\n    return 2\n  }\n  if (cp > maxCp || (surrogateMin <= cp && cp <= surrogateMax)) {\n    // invalid codepoint\n    cp = UniError\n  }\n  if (cp < 0x10000) {\n    b[offs]   = (cp >> 12)         | 0xe0\n    b[++offs] = ((cp >> 6) & 0x3f) | 0x80\n    b[++offs] = (cp & 0x3f)        | 0x80\n    return 3\n  }\n  b[offs]   = (cp >> 18)         | 0xf0\n  b[++offs] = ((cp >> 12) & 0x3f)| 0x80\n  b[++offs] = ((cp >> 6) & 0x3f) | 0x80\n  b[++offs] = (cp & 0x3f)        | 0x80\n  return 4\n}\n\nexport function byteSize(cp :int) :int {\n  return (\n    (cp < 0x80) ? 1 :\n    (cp < 0x800) ? 2 :\n    (cp < 0x10000) ? 3 :\n    4\n  )\n}\n\nexport function encodeAsString(cp :int) :string {\n  if (cp < 0 || cp > maxCp) {\n    panic(`invalid unicode code point ${cp}`)\n  }\n  if (cp < 0x10000) {\n    return String.fromCharCode(cp)\n  }\n  cp -= 0x10000\n  return String.fromCharCode(\n    (cp >> 10) + surrogateMin,\n    (cp % rune2Max) + 0xDC00\n  )\n}\n","import * as utf8 from './utf8'\n\nexport const\n  MaxRune         = 0x10FFFF  // Maximum valid Unicode code point\n, MaxASCII        = 0x007F    // maximum ASCII value\n, MaxLatin1       = 0x00FF    // maximum Latin-1 value\n, ReplacementChar = 0xFFFD    // Represents invalid code points\n\n\nconst fmt4 = '0000'\n\nexport function repr(cp :int) :string {\n  let s = cp.toString(16)\n  if (cp <= 0xFFFF) {\n    s = fmt4.substr(0, fmt4.length - s.length) + s\n  }\n  let str = JSON.stringify(utf8.encodeAsString(cp))\n  str = str.substr(1, str.length-2)\n  return `U+${s} '${str}'`\n}\n\nexport function isValid(c :int) :bool {\n  return c >= 0 && c <= MaxRune\n}\n\nexport function isSurrogate(c :int) :bool {\n  return 0xD800 <= c && c <= 0xDFFF\n}\n\n// the rest of this file was generated by misc/gen-unicode-data.js\n\nexport function isLetter(c :int) :bool {\n  return (\n    0x41 <= c && c <= 0x1E943 && ( // LATIN CAPITAL LETTER A..ADLAM SMALL LETTER SHA\n    (0x41 <= c && c <= 0x5A) || // LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z\n    (0x61 <= c && c <= 0x7A) || // LATIN SMALL LETTER A..LATIN SMALL LETTER Z\n    c == 0xB5 || // MICRO SIGN\n    (0xC0 <= c && c <= 0xD6) || // LATIN CAPITAL LETTER A WITH GRAVE..LATIN CAPITAL LETTER O WITH DIAERESIS\n    (0xD8 <= c && c <= 0xF6) || // LATIN CAPITAL LETTER O WITH STROKE..LATIN SMALL LETTER O WITH DIAERESIS\n    (0xF8 <= c && c <= 0x1BA) || // LATIN SMALL LETTER O WITH STROKE..LATIN SMALL LETTER EZH WITH TAIL\n    (0x1BC <= c && c <= 0x1BF) || // LATIN CAPITAL LETTER TONE FIVE..LATIN LETTER WYNN\n    c == 0x1C4 || // LATIN CAPITAL LETTER DZ WITH CARON\n    (0x1C6 <= c && c <= 0x1C7) || // LATIN SMALL LETTER DZ WITH CARON..LATIN CAPITAL LETTER LJ\n    (0x1C9 <= c && c <= 0x1CA) || // LATIN SMALL LETTER LJ..LATIN CAPITAL LETTER NJ\n    (0x1CC <= c && c <= 0x1F1) || // LATIN SMALL LETTER NJ..LATIN CAPITAL LETTER DZ\n    (0x1F3 <= c && c <= 0x293) || // LATIN SMALL LETTER DZ..LATIN SMALL LETTER EZH WITH CURL\n    (0x295 <= c && c <= 0x2AF) || // LATIN LETTER PHARYNGEAL VOICED FRICATIVE..LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL\n    (0x370 <= c && c <= 0x373) || // GREEK CAPITAL LETTER HETA..GREEK SMALL LETTER ARCHAIC SAMPI\n    (0x376 <= c && c <= 0x377) || // GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA..GREEK SMALL LETTER PAMPHYLIAN DIGAMMA\n    (0x37B <= c && c <= 0x37D) || // GREEK SMALL REVERSED LUNATE SIGMA SYMBOL..GREEK SMALL REVERSED DOTTED LUNATE SIGMA SYMBOL\n    c == 0x37F || // GREEK CAPITAL LETTER YOT\n    c == 0x386 || // GREEK CAPITAL LETTER ALPHA WITH TONOS\n    (0x388 <= c && c <= 0x38A) || // GREEK CAPITAL LETTER EPSILON WITH TONOS..GREEK CAPITAL LETTER IOTA WITH TONOS\n    c == 0x38C || // GREEK CAPITAL LETTER OMICRON WITH TONOS\n    (0x38E <= c && c <= 0x3A1) || // GREEK CAPITAL LETTER UPSILON WITH TONOS..GREEK CAPITAL LETTER RHO\n    (0x3A3 <= c && c <= 0x3F5) || // GREEK CAPITAL LETTER SIGMA..GREEK LUNATE EPSILON SYMBOL\n    (0x3F7 <= c && c <= 0x481) || // GREEK CAPITAL LETTER SHO..CYRILLIC SMALL LETTER KOPPA\n    (0x48A <= c && c <= 0x52F) || // CYRILLIC CAPITAL LETTER SHORT I WITH TAIL..CYRILLIC SMALL LETTER EL WITH DESCENDER\n    (0x531 <= c && c <= 0x556) || // ARMENIAN CAPITAL LETTER AYB..ARMENIAN CAPITAL LETTER FEH\n    (0x561 <= c && c <= 0x587) || // ARMENIAN SMALL LETTER AYB..ARMENIAN SMALL LIGATURE ECH YIWN\n    (0x10A0 <= c && c <= 0x10C5) || // GEORGIAN CAPITAL LETTER AN..GEORGIAN CAPITAL LETTER HOE\n    c == 0x10C7 || // GEORGIAN CAPITAL LETTER YN\n    c == 0x10CD || // GEORGIAN CAPITAL LETTER AEN\n    (0x13A0 <= c && c <= 0x13F5) || // CHEROKEE LETTER A..CHEROKEE LETTER MV\n    (0x13F8 <= c && c <= 0x13FD) || // CHEROKEE SMALL LETTER YE..CHEROKEE SMALL LETTER MV\n    (0x1C80 <= c && c <= 0x1C88) || // CYRILLIC SMALL LETTER ROUNDED VE..CYRILLIC SMALL LETTER UNBLENDED UK\n    (0x1D00 <= c && c <= 0x1D2B) || // LATIN LETTER SMALL CAPITAL A..CYRILLIC LETTER SMALL CAPITAL EL\n    (0x1D6B <= c && c <= 0x1D77) || // LATIN SMALL LETTER UE..LATIN SMALL LETTER TURNED G\n    (0x1D79 <= c && c <= 0x1D9A) || // LATIN SMALL LETTER INSULAR G..LATIN SMALL LETTER EZH WITH RETROFLEX HOOK\n    (0x1E00 <= c && c <= 0x1F15) || // LATIN CAPITAL LETTER A WITH RING BELOW..GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA\n    (0x1F18 <= c && c <= 0x1F1D) || // GREEK CAPITAL LETTER EPSILON WITH PSILI..GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA\n    (0x1F20 <= c && c <= 0x1F45) || // GREEK SMALL LETTER ETA WITH PSILI..GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA\n    (0x1F48 <= c && c <= 0x1F4D) || // GREEK CAPITAL LETTER OMICRON WITH PSILI..GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA\n    (0x1F50 <= c && c <= 0x1F57) || // GREEK SMALL LETTER UPSILON WITH PSILI..GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI\n    c == 0x1F59 || // GREEK CAPITAL LETTER UPSILON WITH DASIA\n    c == 0x1F5B || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA\n    c == 0x1F5D || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA\n    (0x1F5F <= c && c <= 0x1F7D) || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI..GREEK SMALL LETTER OMEGA WITH OXIA\n    (0x1F80 <= c && c <= 0x1F87) || // GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1F90 <= c && c <= 0x1F97) || // GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1FA0 <= c && c <= 0x1FA7) || // GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1FB0 <= c && c <= 0x1FB4) || // GREEK SMALL LETTER ALPHA WITH VRACHY..GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FB6 <= c && c <= 0x1FBB) || // GREEK SMALL LETTER ALPHA WITH PERISPOMENI..GREEK CAPITAL LETTER ALPHA WITH OXIA\n    c == 0x1FBE || // GREEK PROSGEGRAMMENI\n    (0x1FC2 <= c && c <= 0x1FC4) || // GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI..GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FC6 <= c && c <= 0x1FCB) || // GREEK SMALL LETTER ETA WITH PERISPOMENI..GREEK CAPITAL LETTER ETA WITH OXIA\n    (0x1FD0 <= c && c <= 0x1FD3) || // GREEK SMALL LETTER IOTA WITH VRACHY..GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA\n    (0x1FD6 <= c && c <= 0x1FDB) || // GREEK SMALL LETTER IOTA WITH PERISPOMENI..GREEK CAPITAL LETTER IOTA WITH OXIA\n    (0x1FE0 <= c && c <= 0x1FEC) || // GREEK SMALL LETTER UPSILON WITH VRACHY..GREEK CAPITAL LETTER RHO WITH DASIA\n    (0x1FF2 <= c && c <= 0x1FF4) || // GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI..GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FF6 <= c && c <= 0x1FFB) || // GREEK SMALL LETTER OMEGA WITH PERISPOMENI..GREEK CAPITAL LETTER OMEGA WITH OXIA\n    c == 0x2102 || // DOUBLE-STRUCK CAPITAL C\n    c == 0x2107 || // EULER CONSTANT\n    (0x210A <= c && c <= 0x2113) || // SCRIPT SMALL G..SCRIPT SMALL L\n    c == 0x2115 || // DOUBLE-STRUCK CAPITAL N\n    (0x2119 <= c && c <= 0x211D) || // DOUBLE-STRUCK CAPITAL P..DOUBLE-STRUCK CAPITAL R\n    c == 0x2124 || // DOUBLE-STRUCK CAPITAL Z\n    c == 0x2126 || // OHM SIGN\n    c == 0x2128 || // BLACK-LETTER CAPITAL Z\n    (0x212A <= c && c <= 0x212D) || // KELVIN SIGN..BLACK-LETTER CAPITAL C\n    (0x212F <= c && c <= 0x2134) || // SCRIPT SMALL E..SCRIPT SMALL O\n    c == 0x2139 || // INFORMATION SOURCE\n    (0x213C <= c && c <= 0x213F) || // DOUBLE-STRUCK SMALL PI..DOUBLE-STRUCK CAPITAL PI\n    (0x2145 <= c && c <= 0x2149) || // DOUBLE-STRUCK ITALIC CAPITAL D..DOUBLE-STRUCK ITALIC SMALL J\n    c == 0x214E || // TURNED SMALL F\n    (0x2183 <= c && c <= 0x2184) || // ROMAN NUMERAL REVERSED ONE HUNDRED..LATIN SMALL LETTER REVERSED C\n    (0x2C00 <= c && c <= 0x2C2E) || // GLAGOLITIC CAPITAL LETTER AZU..GLAGOLITIC CAPITAL LETTER LATINATE MYSLITE\n    (0x2C30 <= c && c <= 0x2C5E) || // GLAGOLITIC SMALL LETTER AZU..GLAGOLITIC SMALL LETTER LATINATE MYSLITE\n    (0x2C60 <= c && c <= 0x2C7B) || // LATIN CAPITAL LETTER L WITH DOUBLE BAR..LATIN LETTER SMALL CAPITAL TURNED E\n    (0x2C7E <= c && c <= 0x2CE4) || // LATIN CAPITAL LETTER S WITH SWASH TAIL..COPTIC SYMBOL KAI\n    (0x2CEB <= c && c <= 0x2CEE) || // COPTIC CAPITAL LETTER CRYPTOGRAMMIC SHEI..COPTIC SMALL LETTER CRYPTOGRAMMIC GANGIA\n    (0x2CF2 <= c && c <= 0x2CF3) || // COPTIC CAPITAL LETTER BOHAIRIC KHEI..COPTIC SMALL LETTER BOHAIRIC KHEI\n    (0x2D00 <= c && c <= 0x2D25) || // GEORGIAN SMALL LETTER AN..GEORGIAN SMALL LETTER HOE\n    c == 0x2D27 || // GEORGIAN SMALL LETTER YN\n    c == 0x2D2D || // GEORGIAN SMALL LETTER AEN\n    (0xA640 <= c && c <= 0xA66D) || // CYRILLIC CAPITAL LETTER ZEMLYA..CYRILLIC SMALL LETTER DOUBLE MONOCULAR O\n    (0xA680 <= c && c <= 0xA69B) || // CYRILLIC CAPITAL LETTER DWE..CYRILLIC SMALL LETTER CROSSED O\n    (0xA722 <= c && c <= 0xA76F) || // LATIN CAPITAL LETTER EGYPTOLOGICAL ALEF..LATIN SMALL LETTER CON\n    (0xA771 <= c && c <= 0xA787) || // LATIN SMALL LETTER DUM..LATIN SMALL LETTER INSULAR T\n    (0xA78B <= c && c <= 0xA78E) || // LATIN CAPITAL LETTER SALTILLO..LATIN SMALL LETTER L WITH RETROFLEX HOOK AND BELT\n    (0xA790 <= c && c <= 0xA7AE) || // LATIN CAPITAL LETTER N WITH DESCENDER..LATIN CAPITAL LETTER SMALL CAPITAL I\n    (0xA7B0 <= c && c <= 0xA7B7) || // LATIN CAPITAL LETTER TURNED K..LATIN SMALL LETTER OMEGA\n    c == 0xA7FA || // LATIN LETTER SMALL CAPITAL TURNED M\n    (0xAB30 <= c && c <= 0xAB5A) || // LATIN SMALL LETTER BARRED ALPHA..LATIN SMALL LETTER Y WITH SHORT RIGHT LEG\n    (0xAB60 <= c && c <= 0xAB65) || // LATIN SMALL LETTER SAKHA YAT..GREEK LETTER SMALL CAPITAL OMEGA\n    (0xAB70 <= c && c <= 0xABBF) || // CHEROKEE SMALL LETTER A..CHEROKEE SMALL LETTER YA\n    (0xFB00 <= c && c <= 0xFB06) || // LATIN SMALL LIGATURE FF..LATIN SMALL LIGATURE ST\n    (0xFB13 <= c && c <= 0xFB17) || // ARMENIAN SMALL LIGATURE MEN NOW..ARMENIAN SMALL LIGATURE MEN XEH\n    (0xFF21 <= c && c <= 0xFF3A) || // FULLWIDTH LATIN CAPITAL LETTER A..FULLWIDTH LATIN CAPITAL LETTER Z\n    (0xFF41 <= c && c <= 0xFF5A) || // FULLWIDTH LATIN SMALL LETTER A..FULLWIDTH LATIN SMALL LETTER Z\n    (0x10400 <= c && c <= 0x1044F) || // DESERET CAPITAL LETTER LONG I..DESERET SMALL LETTER EW\n    (0x104B0 <= c && c <= 0x104D3) || // OSAGE CAPITAL LETTER A..OSAGE CAPITAL LETTER ZHA\n    (0x104D8 <= c && c <= 0x104FB) || // OSAGE SMALL LETTER A..OSAGE SMALL LETTER ZHA\n    (0x10C80 <= c && c <= 0x10CB2) || // OLD HUNGARIAN CAPITAL LETTER A..OLD HUNGARIAN CAPITAL LETTER US\n    (0x10CC0 <= c && c <= 0x10CF2) || // OLD HUNGARIAN SMALL LETTER A..OLD HUNGARIAN SMALL LETTER US\n    (0x118A0 <= c && c <= 0x118DF) || // WARANG CITI CAPITAL LETTER NGAA..WARANG CITI SMALL LETTER VIYO\n    (0x1D400 <= c && c <= 0x1D454) || // MATHEMATICAL BOLD CAPITAL A..MATHEMATICAL ITALIC SMALL G\n    (0x1D456 <= c && c <= 0x1D49C) || // MATHEMATICAL ITALIC SMALL I..MATHEMATICAL SCRIPT CAPITAL A\n    (0x1D49E <= c && c <= 0x1D49F) || // MATHEMATICAL SCRIPT CAPITAL C..MATHEMATICAL SCRIPT CAPITAL D\n    c == 0x1D4A2 || // MATHEMATICAL SCRIPT CAPITAL G\n    (0x1D4A5 <= c && c <= 0x1D4A6) || // MATHEMATICAL SCRIPT CAPITAL J..MATHEMATICAL SCRIPT CAPITAL K\n    (0x1D4A9 <= c && c <= 0x1D4AC) || // MATHEMATICAL SCRIPT CAPITAL N..MATHEMATICAL SCRIPT CAPITAL Q\n    (0x1D4AE <= c && c <= 0x1D4B9) || // MATHEMATICAL SCRIPT CAPITAL S..MATHEMATICAL SCRIPT SMALL D\n    c == 0x1D4BB || // MATHEMATICAL SCRIPT SMALL F\n    (0x1D4BD <= c && c <= 0x1D4C3) || // MATHEMATICAL SCRIPT SMALL H..MATHEMATICAL SCRIPT SMALL N\n    (0x1D4C5 <= c && c <= 0x1D505) || // MATHEMATICAL SCRIPT SMALL P..MATHEMATICAL FRAKTUR CAPITAL B\n    (0x1D507 <= c && c <= 0x1D50A) || // MATHEMATICAL FRAKTUR CAPITAL D..MATHEMATICAL FRAKTUR CAPITAL G\n    (0x1D50D <= c && c <= 0x1D514) || // MATHEMATICAL FRAKTUR CAPITAL J..MATHEMATICAL FRAKTUR CAPITAL Q\n    (0x1D516 <= c && c <= 0x1D51C) || // MATHEMATICAL FRAKTUR CAPITAL S..MATHEMATICAL FRAKTUR CAPITAL Y\n    (0x1D51E <= c && c <= 0x1D539) || // MATHEMATICAL FRAKTUR SMALL A..MATHEMATICAL DOUBLE-STRUCK CAPITAL B\n    (0x1D53B <= c && c <= 0x1D53E) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL D..MATHEMATICAL DOUBLE-STRUCK CAPITAL G\n    (0x1D540 <= c && c <= 0x1D544) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL I..MATHEMATICAL DOUBLE-STRUCK CAPITAL M\n    c == 0x1D546 || // MATHEMATICAL DOUBLE-STRUCK CAPITAL O\n    (0x1D54A <= c && c <= 0x1D550) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL S..MATHEMATICAL DOUBLE-STRUCK CAPITAL Y\n    (0x1D552 <= c && c <= 0x1D6A5) || // MATHEMATICAL DOUBLE-STRUCK SMALL A..MATHEMATICAL ITALIC SMALL DOTLESS J\n    (0x1D6A8 <= c && c <= 0x1D6C0) || // MATHEMATICAL BOLD CAPITAL ALPHA..MATHEMATICAL BOLD CAPITAL OMEGA\n    (0x1D6C2 <= c && c <= 0x1D6DA) || // MATHEMATICAL BOLD SMALL ALPHA..MATHEMATICAL BOLD SMALL OMEGA\n    (0x1D6DC <= c && c <= 0x1D6FA) || // MATHEMATICAL BOLD EPSILON SYMBOL..MATHEMATICAL ITALIC CAPITAL OMEGA\n    (0x1D6FC <= c && c <= 0x1D714) || // MATHEMATICAL ITALIC SMALL ALPHA..MATHEMATICAL ITALIC SMALL OMEGA\n    (0x1D716 <= c && c <= 0x1D734) || // MATHEMATICAL ITALIC EPSILON SYMBOL..MATHEMATICAL BOLD ITALIC CAPITAL OMEGA\n    (0x1D736 <= c && c <= 0x1D74E) || // MATHEMATICAL BOLD ITALIC SMALL ALPHA..MATHEMATICAL BOLD ITALIC SMALL OMEGA\n    (0x1D750 <= c && c <= 0x1D76E) || // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL..MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA\n    (0x1D770 <= c && c <= 0x1D788) || // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA..MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA\n    (0x1D78A <= c && c <= 0x1D7A8) || // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL..MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA\n    (0x1D7AA <= c && c <= 0x1D7C2) || // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA..MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA\n    (0x1D7C4 <= c && c <= 0x1D7CB) || // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL..MATHEMATICAL BOLD SMALL DIGAMMA\n    (0x1E900 <= c && c <= 0x1E943) // ADLAM CAPITAL LETTER ALIF..ADLAM SMALL LETTER SHA\n  ))\n}\n\nexport function isDigit(c :int) :bool {\n  return (\n    0x30 <= c && c <= 0x1E959 && ( // DIGIT ZERO..ADLAM DIGIT NINE\n    (0x30 <= c && c <= 0x39) || // DIGIT ZERO..DIGIT NINE\n    (0x660 <= c && c <= 0x669) || // ARABIC-INDIC DIGIT ZERO..ARABIC-INDIC DIGIT NINE\n    (0x6F0 <= c && c <= 0x6F9) || // EXTENDED ARABIC-INDIC DIGIT ZERO..EXTENDED ARABIC-INDIC DIGIT NINE\n    (0x7C0 <= c && c <= 0x7C9) || // NKO DIGIT ZERO..NKO DIGIT NINE\n    (0x966 <= c && c <= 0x96F) || // DEVANAGARI DIGIT ZERO..DEVANAGARI DIGIT NINE\n    (0x9E6 <= c && c <= 0x9EF) || // BENGALI DIGIT ZERO..BENGALI DIGIT NINE\n    (0xA66 <= c && c <= 0xA6F) || // GURMUKHI DIGIT ZERO..GURMUKHI DIGIT NINE\n    (0xAE6 <= c && c <= 0xAEF) || // GUJARATI DIGIT ZERO..GUJARATI DIGIT NINE\n    (0xB66 <= c && c <= 0xB6F) || // ORIYA DIGIT ZERO..ORIYA DIGIT NINE\n    (0xBE6 <= c && c <= 0xBEF) || // TAMIL DIGIT ZERO..TAMIL DIGIT NINE\n    (0xC66 <= c && c <= 0xC6F) || // TELUGU DIGIT ZERO..TELUGU DIGIT NINE\n    (0xCE6 <= c && c <= 0xCEF) || // KANNADA DIGIT ZERO..KANNADA DIGIT NINE\n    (0xD66 <= c && c <= 0xD6F) || // MALAYALAM DIGIT ZERO..MALAYALAM DIGIT NINE\n    (0xDE6 <= c && c <= 0xDEF) || // SINHALA LITH DIGIT ZERO..SINHALA LITH DIGIT NINE\n    (0xE50 <= c && c <= 0xE59) || // THAI DIGIT ZERO..THAI DIGIT NINE\n    (0xED0 <= c && c <= 0xED9) || // LAO DIGIT ZERO..LAO DIGIT NINE\n    (0xF20 <= c && c <= 0xF29) || // TIBETAN DIGIT ZERO..TIBETAN DIGIT NINE\n    (0x1040 <= c && c <= 0x1049) || // MYANMAR DIGIT ZERO..MYANMAR DIGIT NINE\n    (0x1090 <= c && c <= 0x1099) || // MYANMAR SHAN DIGIT ZERO..MYANMAR SHAN DIGIT NINE\n    (0x17E0 <= c && c <= 0x17E9) || // KHMER DIGIT ZERO..KHMER DIGIT NINE\n    (0x1810 <= c && c <= 0x1819) || // MONGOLIAN DIGIT ZERO..MONGOLIAN DIGIT NINE\n    (0x1946 <= c && c <= 0x194F) || // LIMBU DIGIT ZERO..LIMBU DIGIT NINE\n    (0x19D0 <= c && c <= 0x19D9) || // NEW TAI LUE DIGIT ZERO..NEW TAI LUE DIGIT NINE\n    (0x1A80 <= c && c <= 0x1A89) || // TAI THAM HORA DIGIT ZERO..TAI THAM HORA DIGIT NINE\n    (0x1A90 <= c && c <= 0x1A99) || // TAI THAM THAM DIGIT ZERO..TAI THAM THAM DIGIT NINE\n    (0x1B50 <= c && c <= 0x1B59) || // BALINESE DIGIT ZERO..BALINESE DIGIT NINE\n    (0x1BB0 <= c && c <= 0x1BB9) || // SUNDANESE DIGIT ZERO..SUNDANESE DIGIT NINE\n    (0x1C40 <= c && c <= 0x1C49) || // LEPCHA DIGIT ZERO..LEPCHA DIGIT NINE\n    (0x1C50 <= c && c <= 0x1C59) || // OL CHIKI DIGIT ZERO..OL CHIKI DIGIT NINE\n    (0xA620 <= c && c <= 0xA629) || // VAI DIGIT ZERO..VAI DIGIT NINE\n    (0xA8D0 <= c && c <= 0xA8D9) || // SAURASHTRA DIGIT ZERO..SAURASHTRA DIGIT NINE\n    (0xA900 <= c && c <= 0xA909) || // KAYAH LI DIGIT ZERO..KAYAH LI DIGIT NINE\n    (0xA9D0 <= c && c <= 0xA9D9) || // JAVANESE DIGIT ZERO..JAVANESE DIGIT NINE\n    (0xA9F0 <= c && c <= 0xA9F9) || // MYANMAR TAI LAING DIGIT ZERO..MYANMAR TAI LAING DIGIT NINE\n    (0xAA50 <= c && c <= 0xAA59) || // CHAM DIGIT ZERO..CHAM DIGIT NINE\n    (0xABF0 <= c && c <= 0xABF9) || // MEETEI MAYEK DIGIT ZERO..MEETEI MAYEK DIGIT NINE\n    (0xFF10 <= c && c <= 0xFF19) || // FULLWIDTH DIGIT ZERO..FULLWIDTH DIGIT NINE\n    (0x104A0 <= c && c <= 0x104A9) || // OSMANYA DIGIT ZERO..OSMANYA DIGIT NINE\n    (0x11066 <= c && c <= 0x1106F) || // BRAHMI DIGIT ZERO..BRAHMI DIGIT NINE\n    (0x110F0 <= c && c <= 0x110F9) || // SORA SOMPENG DIGIT ZERO..SORA SOMPENG DIGIT NINE\n    (0x11136 <= c && c <= 0x1113F) || // CHAKMA DIGIT ZERO..CHAKMA DIGIT NINE\n    (0x111D0 <= c && c <= 0x111D9) || // SHARADA DIGIT ZERO..SHARADA DIGIT NINE\n    (0x112F0 <= c && c <= 0x112F9) || // KHUDAWADI DIGIT ZERO..KHUDAWADI DIGIT NINE\n    (0x11450 <= c && c <= 0x11459) || // NEWA DIGIT ZERO..NEWA DIGIT NINE\n    (0x114D0 <= c && c <= 0x114D9) || // TIRHUTA DIGIT ZERO..TIRHUTA DIGIT NINE\n    (0x11650 <= c && c <= 0x11659) || // MODI DIGIT ZERO..MODI DIGIT NINE\n    (0x116C0 <= c && c <= 0x116C9) || // TAKRI DIGIT ZERO..TAKRI DIGIT NINE\n    (0x11730 <= c && c <= 0x11739) || // AHOM DIGIT ZERO..AHOM DIGIT NINE\n    (0x118E0 <= c && c <= 0x118E9) || // WARANG CITI DIGIT ZERO..WARANG CITI DIGIT NINE\n    (0x11C50 <= c && c <= 0x11C59) || // BHAIKSUKI DIGIT ZERO..BHAIKSUKI DIGIT NINE\n    (0x11D50 <= c && c <= 0x11D59) || // MASARAM GONDI DIGIT ZERO..MASARAM GONDI DIGIT NINE\n    (0x16A60 <= c && c <= 0x16A69) || // MRO DIGIT ZERO..MRO DIGIT NINE\n    (0x16B50 <= c && c <= 0x16B59) || // PAHAWH HMONG DIGIT ZERO..PAHAWH HMONG DIGIT NINE\n    (0x1D7CE <= c && c <= 0x1D7FF) || // MATHEMATICAL BOLD DIGIT ZERO..MATHEMATICAL MONOSPACE DIGIT NINE\n    (0x1E950 <= c && c <= 0x1E959) // ADLAM DIGIT ZERO..ADLAM DIGIT NINE\n  ))\n}\n\nexport function isWhitespace(c :int) :bool {\n  return (\n    0x0 <= c && c <= 0x3000 && ( // <control>..IDEOGRAPHIC SPACE\n    (0x0 <= c && c <= 0x20) || // <control>..SPACE\n    (0x7F <= c && c <= 0xA0) || // <control>..NO-BREAK SPACE\n    c == 0x1680 || // OGHAM SPACE MARK\n    (0x2000 <= c && c <= 0x200A) || // EN QUAD..HAIR SPACE\n    (0x2028 <= c && c <= 0x2029) || // LINE SEPARATOR..PARAGRAPH SEPARATOR\n    c == 0x202F || // NARROW NO-BREAK SPACE\n    c == 0x205F || // MEDIUM MATHEMATICAL SPACE\n    c == 0x3000 // IDEOGRAPHIC SPACE\n  ))\n}\n\n\nexport function isEmojiPresentation(c :int) :bool {\n  return (\n    0x231A <= c && c <= 0x1F9E6 && ( // WATCH..SOCKS\n    (0x231A <= c && c <= 0x231B) || // WATCH..HOURGLASS\n    (0x23E9 <= c && c <= 0x23EC) || // BLACK RIGHT-POINTING DOUBLE TRIANGLE..BLACK DOWN-POINTING DOUBLE TRIANGLE\n    c == 0x23F0 || // <unknown>\n    c == 0x23F3 || // <unknown>\n    (0x25FD <= c && c <= 0x25FE) || // WHITE MEDIUM SMALL SQUARE..BLACK MEDIUM SMALL SQUARE\n    (0x2614 <= c && c <= 0x2615) || // UMBRELLA WITH RAIN DROPS..HOT BEVERAGE\n    (0x2648 <= c && c <= 0x2653) || // ARIES..PISCES\n    c == 0x267F || // <unknown>\n    c == 0x2693 || // <unknown>\n    c == 0x26A1 || // <unknown>\n    (0x26AA <= c && c <= 0x26AB) || // MEDIUM WHITE CIRCLE..MEDIUM BLACK CIRCLE\n    (0x26BD <= c && c <= 0x26BE) || // SOCCER BALL..BASEBALL\n    (0x26C4 <= c && c <= 0x26C5) || // SNOWMAN WITHOUT SNOW..SUN BEHIND CLOUD\n    c == 0x26CE || // <unknown>\n    c == 0x26D4 || // <unknown>\n    c == 0x26EA || // <unknown>\n    (0x26F2 <= c && c <= 0x26F3) || // FOUNTAIN..FLAG IN HOLE\n    c == 0x26F5 || // <unknown>\n    c == 0x26FA || // <unknown>\n    c == 0x26FD || // <unknown>\n    c == 0x2705 || // <unknown>\n    (0x270A <= c && c <= 0x270B) || // RAISED FIST..RAISED HAND\n    c == 0x2728 || // <unknown>\n    c == 0x274C || // <unknown>\n    c == 0x274E || // <unknown>\n    (0x2753 <= c && c <= 0x2755) || // BLACK QUESTION MARK ORNAMENT..WHITE EXCLAMATION MARK ORNAMENT\n    c == 0x2757 || // <unknown>\n    (0x2795 <= c && c <= 0x2797) || // HEAVY PLUS SIGN..HEAVY DIVISION SIGN\n    c == 0x27B0 || // <unknown>\n    c == 0x27BF || // <unknown>\n    (0x2B1B <= c && c <= 0x2B1C) || // BLACK LARGE SQUARE..WHITE LARGE SQUARE\n    c == 0x2B50 || // <unknown>\n    c == 0x2B55 || // <unknown>\n    c == 0x1F004 || // <unknown>\n    c == 0x1F0CF || // <unknown>\n    c == 0x1F18E || // <unknown>\n    (0x1F191 <= c && c <= 0x1F19A) || // SQUARED CL..SQUARED VS\n    (0x1F1E6 <= c && c <= 0x1F1FF) || // REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z\n    c == 0x1F201 || // <unknown>\n    c == 0x1F21A || // <unknown>\n    c == 0x1F22F || // <unknown>\n    (0x1F232 <= c && c <= 0x1F236) || // SQUARED CJK UNIFIED IDEOGRAPH-7981..SQUARED CJK UNIFIED IDEOGRAPH-6709\n    (0x1F238 <= c && c <= 0x1F23A) || // SQUARED CJK UNIFIED IDEOGRAPH-7533..SQUARED CJK UNIFIED IDEOGRAPH-55B6\n    (0x1F250 <= c && c <= 0x1F251) || // CIRCLED IDEOGRAPH ADVANTAGE..CIRCLED IDEOGRAPH ACCEPT\n    (0x1F300 <= c && c <= 0x1F320) || // CYCLONE..SHOOTING STAR\n    (0x1F32D <= c && c <= 0x1F335) || // HOT DOG..CACTUS\n    (0x1F337 <= c && c <= 0x1F37C) || // TULIP..BABY BOTTLE\n    (0x1F37E <= c && c <= 0x1F393) || // BOTTLE WITH POPPING CORK..GRADUATION CAP\n    (0x1F3A0 <= c && c <= 0x1F3C4) || // CAROUSEL HORSE..SURFER\n    c == 0x1F3C5 || // <unknown>\n    (0x1F3C6 <= c && c <= 0x1F3CA) || // TROPHY..SWIMMER\n    (0x1F3CF <= c && c <= 0x1F3D3) || // CRICKET BAT AND BALL..TABLE TENNIS PADDLE AND BALL\n    (0x1F3E0 <= c && c <= 0x1F3F0) || // HOUSE BUILDING..EUROPEAN CASTLE\n    c == 0x1F3F4 || // <unknown>\n    (0x1F3F8 <= c && c <= 0x1F43E) || // BADMINTON RACQUET AND SHUTTLECOCK..PAW PRINTS\n    c == 0x1F440 || // <unknown>\n    (0x1F442 <= c && c <= 0x1F4F7) || // EAR..CAMERA\n    c == 0x1F4F8 || // <unknown>\n    (0x1F4F9 <= c && c <= 0x1F4FC) || // VIDEO CAMERA..VIDEOCASSETTE\n    c == 0x1F4FF || // <unknown>\n    (0x1F500 <= c && c <= 0x1F53D) || // TWISTED RIGHTWARDS ARROWS..DOWN-POINTING SMALL RED TRIANGLE\n    (0x1F54B <= c && c <= 0x1F54E) || // KAABA..MENORAH WITH NINE BRANCHES\n    (0x1F550 <= c && c <= 0x1F567) || // CLOCK FACE ONE OCLOCK..CLOCK FACE TWELVE-THIRTY\n    c == 0x1F57A || // <unknown>\n    (0x1F595 <= c && c <= 0x1F596) || // REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS\n    c == 0x1F5A4 || // <unknown>\n    (0x1F5FB <= c && c <= 0x1F5FF) || // MOUNT FUJI..MOYAI\n    c == 0x1F600 || // <unknown>\n    (0x1F601 <= c && c <= 0x1F610) || // GRINNING FACE WITH SMILING EYES..NEUTRAL FACE\n    c == 0x1F611 || // <unknown>\n    (0x1F612 <= c && c <= 0x1F614) || // UNAMUSED FACE..PENSIVE FACE\n    c == 0x1F615 || // <unknown>\n    c == 0x1F616 || // <unknown>\n    c == 0x1F617 || // <unknown>\n    c == 0x1F618 || // <unknown>\n    c == 0x1F619 || // <unknown>\n    c == 0x1F61A || // <unknown>\n    c == 0x1F61B || // <unknown>\n    (0x1F61C <= c && c <= 0x1F61E) || // FACE WITH STUCK-OUT TONGUE AND WINKING EYE..DISAPPOINTED FACE\n    c == 0x1F61F || // <unknown>\n    (0x1F620 <= c && c <= 0x1F62B) || // ANGRY FACE..TIRED FACE\n    c == 0x1F62C || // <unknown>\n    c == 0x1F62D || // <unknown>\n    (0x1F62E <= c && c <= 0x1F633) || // FACE WITH OPEN MOUTH..FLUSHED FACE\n    c == 0x1F634 || // <unknown>\n    (0x1F635 <= c && c <= 0x1F64F) || // DIZZY FACE..PERSON WITH FOLDED HANDS\n    (0x1F680 <= c && c <= 0x1F6C5) || // ROCKET..LEFT LUGGAGE\n    c == 0x1F6CC || // <unknown>\n    c == 0x1F6D0 || // <unknown>\n    (0x1F6D1 <= c && c <= 0x1F6D2) || // OCTAGONAL SIGN..SHOPPING TROLLEY\n    (0x1F6EB <= c && c <= 0x1F6EC) || // AIRPLANE DEPARTURE..AIRPLANE ARRIVING\n    (0x1F6F4 <= c && c <= 0x1F6F8) || // SCOOTER..FLYING SAUCER\n    (0x1F910 <= c && c <= 0x1F91E) || // ZIPPER-MOUTH FACE..HAND WITH INDEX AND MIDDLE FINGERS CROSSED\n    c == 0x1F91F || // <unknown>\n    (0x1F920 <= c && c <= 0x1F92F) || // FACE WITH COWBOY HAT..SHOCKED FACE WITH EXPLODING HEAD\n    c == 0x1F930 || // <unknown>\n    (0x1F931 <= c && c <= 0x1F93A) || // BREAST-FEEDING..FENCER\n    (0x1F93C <= c && c <= 0x1F93E) || // WRESTLERS..HANDBALL\n    (0x1F940 <= c && c <= 0x1F945) || // WILTED FLOWER..GOAL NET\n    (0x1F947 <= c && c <= 0x1F94B) || // FIRST PLACE MEDAL..MARTIAL ARTS UNIFORM\n    c == 0x1F94C || // <unknown>\n    (0x1F950 <= c && c <= 0x1F96B) || // CROISSANT..CANNED FOOD\n    (0x1F980 <= c && c <= 0x1F997) || // CRAB..CRICKET\n    c == 0x1F9C0 || // <unknown>\n    (0x1F9D0 <= c && c <= 0x1F9E6) // FACE WITH MONOCLE..SOCKS\n  ))\n}\n\nexport function isEmojiModifierBase(c :int) :bool {\n  return (\n    0x261D <= c && c <= 0x1F9DD && ( // <unknown>..ELF\n    c == 0x261D || // <unknown>\n    c == 0x26F9 || // <unknown>\n    (0x270A <= c && c <= 0x270D) || // RAISED FIST..WRITING HAND\n    c == 0x1F385 || // <unknown>\n    (0x1F3C2 <= c && c <= 0x1F3C4) || // SNOWBOARDER..SURFER\n    c == 0x1F3C7 || // <unknown>\n    c == 0x1F3CA || // <unknown>\n    (0x1F3CB <= c && c <= 0x1F3CC) || // WEIGHT LIFTER..GOLFER\n    (0x1F442 <= c && c <= 0x1F443) || // EAR..NOSE\n    (0x1F446 <= c && c <= 0x1F450) || // WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN\n    (0x1F466 <= c && c <= 0x1F469) || // BOY..WOMAN\n    c == 0x1F46E || // <unknown>\n    (0x1F470 <= c && c <= 0x1F478) || // BRIDE WITH VEIL..PRINCESS\n    c == 0x1F47C || // <unknown>\n    (0x1F481 <= c && c <= 0x1F483) || // INFORMATION DESK PERSON..DANCER\n    (0x1F485 <= c && c <= 0x1F487) || // NAIL POLISH..HAIRCUT\n    c == 0x1F4AA || // <unknown>\n    (0x1F574 <= c && c <= 0x1F575) || // MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY\n    c == 0x1F57A || // <unknown>\n    c == 0x1F590 || // <unknown>\n    (0x1F595 <= c && c <= 0x1F596) || // REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS\n    (0x1F645 <= c && c <= 0x1F647) || // FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY\n    (0x1F64B <= c && c <= 0x1F64F) || // HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS\n    c == 0x1F6A3 || // <unknown>\n    (0x1F6B4 <= c && c <= 0x1F6B6) || // BICYCLIST..PEDESTRIAN\n    c == 0x1F6C0 || // <unknown>\n    c == 0x1F6CC || // <unknown>\n    c == 0x1F918 || // <unknown>\n    (0x1F919 <= c && c <= 0x1F91C) || // CALL ME HAND..RIGHT-FACING FIST\n    c == 0x1F91E || // <unknown>\n    c == 0x1F91F || // <unknown>\n    c == 0x1F926 || // <unknown>\n    c == 0x1F930 || // <unknown>\n    (0x1F931 <= c && c <= 0x1F939) || // BREAST-FEEDING..JUGGLING\n    (0x1F93D <= c && c <= 0x1F93E) || // WATER POLO..HANDBALL\n    (0x1F9D1 <= c && c <= 0x1F9DD) // ADULT..ELF\n  ))\n}\n\nexport function isEmojiModifier(c :int) :bool {\n  return (\n    (0x1F3FB <= c && c <= 0x1F3FF) // EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6\n  )\n}\n","// provides styling via shell color codes\n//\n// A Style object provides a number of functions named after their effect,\n// like \"boldRed\". A style function takes a single argument which is interpreted\n// as a string, and returns a string with the appropriate style codes\n// surrounding the string argument.\n//\n// Additionally, each such function has two properties: open and close, each\n// which are strings containing the starting (or ending) code(s) for the\n// appropriate style.\n//\n// Examples:\n//\n//   style.boldRed(\"hello\")    // => \"\\x1b[1;31mhello\\x1b[0;39m\"\n//   stdoutStyle.cyan(\"hello\") // => \"\\x1b[36mhello\\x1b[39m\"\n//\n\n// progressively support nodejs\ninterface has_isTTY { isTTY? :bool }\ndeclare var process :undefined | {\n  env :{[k:string]:string},\n  stdout: has_isTTY,\n  stderr: has_isTTY,\n}\nconst TERM = typeof process != 'undefined' && process.env.TERM || ''\n\nexport type StyleFun = (s: string) => string\n\nfunction sfn(open :string, close :string) :StyleFun {\n  open = '\\x1b[' + open + 'm'\n  close = '\\x1b[' + close + 'm'\n  return (s :string) => open + s + close\n}\n\n// number of colors that the terminal probably supports\nexport const termColorSupport :number = (\n  TERM && ['xterm','screen','vt100'].some(s => TERM.indexOf(s) != -1) ? (\n    TERM.indexOf('256color') != -1 ? 256 :\n    16\n  ) : 0\n)\n\nconst passThrough = ((s :string) => s) as StyleFun\n\nexport interface Style {\n  'clear'         :string\n\n  'bold'          :StyleFun\n  'italic'        :StyleFun\n  'underline'     :StyleFun\n  'inverse'       :StyleFun\n\n  'white'         :StyleFun\n  'grey'          :StyleFun\n  'black'         :StyleFun\n\n  'blue'          :StyleFun\n  'cyan'          :StyleFun\n  'green'         :StyleFun\n  'magenta'       :StyleFun\n  'purple'        :StyleFun\n  'pink'          :StyleFun\n  'red'           :StyleFun\n  'yellow'        :StyleFun\n  'lightyellow'   :StyleFun\n  'orange'        :StyleFun\n}\n\nexport const noStyle :Style = {\n  // no colors\n  'clear'         : \"\",\n\n  'bold'          : passThrough,\n  'italic'        : passThrough,\n  'underline'     : passThrough,\n  'inverse'       : passThrough,\n\n  'white'         : passThrough,\n  'grey'          : passThrough,\n  'black'         : passThrough,\n  'blue'          : passThrough,\n  'cyan'          : passThrough,\n  'green'         : passThrough,\n  'magenta'       : passThrough,\n  'purple'        : passThrough,\n  'pink'          : passThrough,\n  'red'           : passThrough,\n  'yellow'        : passThrough,\n  'lightyellow'   : passThrough,\n  'orange'        : passThrough,\n}\n\nexport const style :Style = (\n  termColorSupport == 0 ? noStyle :\n  termColorSupport < 256 ? {\n    // 16 colors\n    'clear'         : \"\\e[0m\",\n\n    'bold'          : sfn('1', '22'),\n    'italic'        : sfn('3', '23'),\n    'underline'     : sfn('4', '24'),\n    'inverse'       : sfn('7', '27'),\n\n    'white'         : sfn('37', '39'),\n    'grey'          : sfn('90', '39'),\n    'black'         : sfn('30', '39'),\n    'blue'          : sfn('34', '39'),\n    'cyan'          : sfn('36', '39'),\n    'green'         : sfn('32', '39'),\n    'magenta'       : sfn('35', '39'),\n    'purple'        : sfn('35', '39'),\n    'pink'          : sfn('35', '39'),\n    'red'           : sfn('31', '39'),\n    'yellow'        : sfn('33', '39'),\n    'lightyellow'   : sfn('93', '39'),\n    'orange'        : sfn('33', '39'),\n  } : {\n    // 256 colors\n    'clear'         : \"\\e[0m\",\n\n    'bold'          : sfn('1', '22'),\n    'italic'        : sfn('3', '23'),\n    'underline'     : sfn('4', '24'),\n    'inverse'       : sfn('7', '27'),\n\n    'white'         : sfn('38;2;255;255;255', '39'),\n    'grey'          : sfn('38;5;244', '39'),\n    'black'         : sfn('38;5;16',  '39'),\n    'blue'          : sfn('38;5;75',  '39'), // '38;2;120;160;255'\n    'cyan'          : sfn('38;5;87',  '39'),\n    'green'         : sfn('38;5;84',  '39'),\n    'magenta'       : sfn('38;5;213', '39'),\n    'purple'        : sfn('38;5;141', '39'),\n    'pink'          : sfn('38;5;211', '39'),\n    'red'           : sfn('38;2;255;110;80', '39'),\n    'yellow'        : sfn('38;5;227', '39'),\n    'lightyellow'   : sfn('38;5;229', '39'),\n    'orange'        : sfn('38;5;215', '39'),\n  }\n)\n\n// demo\n// for (let k in style) {\n//   if (k != 'clear') {\n//     console.log((style as any)[k](k))\n//   }\n// }\n// for (let mod of ['bold','italic','underline','inverse']) {\n//   for (let col of [\n//     'white','grey','black','blue','cyan','green','magenta','red','yellow'\n//   ]) {\n//     console.log(\n//       (style as any)[col](\n//         (style as any)[mod](mod + ' ' + col)\n//       )\n//     )\n//   }\n// }\n// ;(process as any).exit(0)\n\n// streamStyle returns the most appropriate Style object for `w`\nexport function streamStyle(w :has_isTTY) {\n  return termColorSupport && w.isTTY ? style : noStyle\n}\n\nexport const stdoutStyle = (\n  typeof process != 'undefined' && streamStyle(process.stdout) || noStyle\n)\n\nexport const stderrStyle = (\n  typeof process != 'undefined' && streamStyle(process.stderr) || noStyle\n)\n\nexport const stdoutSupportsStyle = stdoutStyle !== noStyle\nexport const stderrSupportsStyle = stderrStyle !== noStyle\n","import { Position } from './pos'\nimport { termColorSupport, style, noStyle } from './termstyle'\n\n// error codes\nclass _errors {\n  E_SYNTAX  = 'syntax'\n  E_CONV    = 'type or value conversion'\n  E_RESOLVE = 'reference resolution'\n  E_UNUSED_VAR   = 'declared and not used'\n  E_UNUSED_PARAM = 'unused parameter'\n  E_UNUSED_FIELD = 'unused field'\n}\nexport const errors = new _errors()\n\n// error code type\nexport type ErrorCode = keyof(_errors)\n\n// An ErrorHandler may be provided to Scanner.init. If a syntax error is\n// encountered and a handler was installed, the handler is called with a\n// position and an error message. The position points to the beginning of\n// the offending token.\n//\nexport type ErrorHandler = (pos :Position, msg :string, c :ErrorCode) => void\n\n// ErrorReporter serves as a base for other types that report source errors.\n//\nexport class ErrorReporter {\n  errorCount :number = 0\n\n  constructor(\n    public defaultErrCode :ErrorCode,\n    public errh :ErrorHandler|null = null,\n  ) {}\n\n  errorAt(msg :string, position :Position, code? :ErrorCode) {\n    if (this.errh) {\n      this.errh(position, msg, code || this.defaultErrCode)\n    }\n    this.errorCount++\n\n    // when compiling in debug mode, also show stack trace when reporting error\n    if (DEBUG) {\n      if (this.errh) {\n        let e = new Error()\n        let maxlen = 0, SP = '                              '\n        const S = termColorSupport ? style : noStyle\n        let v = (e.stack||'').split('\\n').slice(2).map(s => {\n          let m = /\\s+at\\s+([^\\s]+)\\s+\\((.+)\\)/.exec(s)\n          if (!m) { return [s, null] }\n          let p = m[2].lastIndexOf('/src/')\n          if (p != -1) {\n            m[2] = m[2].substr(p+1)\n          }\n          maxlen = Math.max(m[1].length, maxlen)\n          return [m[1], m[2]]\n        })\n        console.error(\n          v.map(s => {\n            if (!s[1]) { return S.italic(String(s[0])) }\n            let f = s[0] as string\n            return S.grey(\n              '  ' + f + SP.substr(0,maxlen - f.length) + '  ' + s[1]\n            )\n          }).join('\\n')\n        )\n      }\n    }\n  }\n}\n","// TODO: to support good old windows...\n// const iswin32 = typeof process != 'undefined' && process.platform == 'win32'\n// and check for \\ in paths.\n\n\nconst SL = 0x2F  // '/'\n    , DOT = 0x2E // .'\n\n\n// dir returns the directory part of a path, or \".\" if no directory part.\n//\nexport function dir(path :string) :string {\n  if (path.indexOf('/') == -1) {\n    return '.'\n  }\n  path = clean(path)\n  let p = path.lastIndexOf('/')\n  return (\n    p == -1 ? '.' :\n    p == path.length - 1 ? path : // \"/\"\n    path.substr(0, p)\n  )\n}\n\nTEST(\"dir\", () => {\n  assert(dir(\"/a/b/c\") == \"/a/b\")\n  assert(dir(\"a/b/c\") == \"a/b\")\n  assert(dir(\"a/b\") == \"a\")\n  assert(dir(\"/\") == \"/\")\n  assert(dir(\"a\") == \".\")\n  assert(dir(\"\") == \".\")\n})\n\n\nclass lazybuf {\n  // The code in this class has been ported from Go and the following\n  // license applies:\n  //   Copyright 2009 The Go Authors. All rights reserved.\n  //   Use of this source code is governed by a BSD-style\n  //   license that can be found in the LICENSE file.\n  //   https://golang.org/LICENSE\n\n  buf :string|null = null\n  w   :int = 0\n\n  constructor(\n    public s :string,\n  ) {}\n\n  index(i :int) :int {\n    return this.buf !== null ? this.buf.charCodeAt(i) : this.s.charCodeAt(i)\n  }\n\n  append(c :int) {\n    if (this.buf === null) {\n      if (this.w < this.s.length && this.s.charCodeAt(this.w) == c) {\n        this.w++\n        return\n      }\n      this.buf = this.s.substr(0, this.w)\n    }\n    if (this.w < this.buf.length-1) {\n      // w was reverted\n      this.buf = this.buf.substr(0, this.w)\n    }\n    this.buf += String.fromCharCode(c) // ugh, javascript...\n    this.w++\n  }\n\n  toString() :string {\n    return (\n      this.buf === null ? this.s.substr(0,this.w) :\n      this.buf.substr(0, this.w)\n    )\n  }\n}\n\n\n// clean\n//\nexport function clean(path :string) :string {\n  // The code in this function has been ported from Go and the following\n  // license applies:\n  //   Copyright 2009 The Go Authors. All rights reserved.\n  //   Use of this source code is governed by a BSD-style\n  //   license that can be found in the LICENSE file.\n  //   https://golang.org/LICENSE\n\n  if (path == \"\") {\n    return \".\"\n  }\n\n  const rooted = path.charCodeAt(0) == SL\n  const n = path.length\n\n  // Invariants:\n  //  reading from path; r is index of next byte to process.\n  //  writing to buf; w is index of next byte to write.\n  //  dotdot is index in buf where .. must stop, either because\n  //    it is the leading slash or it is a leading ../../.. prefix.\n  let out = new lazybuf(path)\n  let r = 0, dotdot = 0\n\n  if (rooted) {\n    out.append(SL)\n    r = 1\n    dotdot = 1\n  }\n\n  while (r < n) {\n    const c0 = path.charCodeAt(r)\n    if (c0 == SL) {\n      // empty path element\n      r++\n    } else if (c0 == DOT && (r+1 == n || path.charCodeAt(r+1) == SL)) {\n      // . element\n      r++\n    } else if (\n      c0 == DOT &&\n      path.charCodeAt(r+1) == DOT &&\n      (r+2 == n || path.charCodeAt(r+2) == SL)\n    ) {\n      // .. element: remove to last /\n      r += 2\n      if (out.w > dotdot) {\n        // can backtrack\n        out.w--\n        while (out.w > dotdot && out.index(out.w) != SL) {\n          out.w--\n        }\n      } else if (!rooted) {\n        // cannot backtrack, but not rooted, so append .. element.\n        if (out.w > 0) {\n          out.append(SL)\n        }\n        out.append(DOT)\n        out.append(DOT)\n        dotdot = out.w\n      }\n    } else {\n      // real path element.\n      // add slash if needed\n      if (rooted && out.w != 1 || !rooted && out.w != 0) {\n        out.append(SL)\n      }\n      // copy element\n      // for (; r < n && path.charCodeAt(r) != SL; r++) {\n      //   out.append(path.charCodeAt(r))\n      // }\n      let c :int\n      for (; r < n; r++) {\n        c = path.charCodeAt(r)\n        if (c == SL) {\n          break\n        }\n        out.append(c)\n      }\n    }\n  }\n\n  // Turn empty string into \".\"\n  if (out.w == 0) {\n    return \".\"\n  }\n\n  return out.toString()\n}\n\nTEST(\"clean\", () => {\n  function t(input :string, expect :string) {\n    const result = clean(input)\n    assert(result == expect,\n      `expected ${JSON.stringify(input)} => ${JSON.stringify(expect)}` +\n      ` but instead got ${JSON.stringify(result)}`)\n  }\n  t(\"a/c\", \"a/c\")\n  t(\"a/c/\", \"a/c\")\n  t(\"/a/c\", \"/a/c\")\n  t(\"a//c\", \"a/c\")\n  t(\"a/c/.\", \"a/c\")\n  t(\"a/c/b/..\", \"a/c\")\n  t(\"/../a/c\", \"/a/c\")\n  t(\"/../a/b/../././/c\", \"/a/c\")\n  t(\"\", \".\")\n  t(\"/\", \"/\")\n})\n\n\n// isAbs returns true if the path is absolute\n//\nexport function isAbs(path :string) :bool {\n  return path.charCodeAt(0) == SL\n}\n\nTEST(\"isAbs\", () => {\n  assert(isAbs(\"/foo/bar\") === true)\n  assert(isAbs(\"foo/bar\") === false)\n})\n\n\n// join glues paths together\n//\nexport function join(...paths :string[]) :string {\n  let s = ''\n  for (let i = 0; i < paths.length; i++) {\n    if (paths[i] != '') {\n      return clean((i == 0 ? paths : paths.slice(i)).join('/'))\n    }\n  }\n  return s\n}\n\nTEST(\"join\", () => {\n  function t(inputs :string[], expect :string) {\n    const result = join.apply(null, inputs)\n    assert(result == expect,\n      `expected ${JSON.stringify(inputs)} => ${JSON.stringify(expect)}` +\n      ` but instead got ${JSON.stringify(result)}`)\n  }\n  t([\"a\", \"b\", \"c\"], \"a/b/c\")\n  t([\"a\", \"b/c\"], \"a/b/c\")\n  t([\"a/b/\", \"c\"], \"a/b/c\")\n  t([\"a/b//\", \"//c\"], \"a/b/c\")\n  t([\"/a/b//\", \"//c\"], \"/a/b/c\")\n  t([\"/a/b//\", \"//c/\"], \"/a/b/c\")\n  t([\"\", \"\"], \"\")\n  t([\"a\", \"\"], \"a\")\n  t([\"\", \"a\"], \"a\")\n})\n","// strtou parses an unsigned integer from a byte array.\n// The maximum value this function can produce is Number.MAX_SAFE_INTEGER\n//\n// Note on performance: In benchmarks with nodejs 8.1.3, this is roughly 2.5x\n// faster than parseInt(String.fromCharCode ...)\n//\nexport function strtou(\n  b :ArrayLike<byte>,\n  base :int,\n  start :int,\n  end :int,\n) :int {\n  assert(base >= 2)\n  assert(base <= 36)\n\n  var cutoff = Math.floor(Number.MAX_SAFE_INTEGER / base)\n  var cutlim = Number.MAX_SAFE_INTEGER % base\n  var acc = 0 // accumulator\n  var i = start, c = 0\n\n  while (i < end) {\n    c = b[i]\n\n    if (c >= 0x30 && c <= 0x39) { // 0..9\n      c -= 0x30\n    } else if (c >= 0x41 && c <= 0x5A) { // A..Z\n      c -= 0x41 - 10\n    } else if (c >= 0x61 && c <= 0x7A) { // a..z\n      c -= 0x61 - 10\n    } else {\n      return -1\n    }\n\n    if (c >= base) {\n      return -1\n    }\n\n    if (acc > cutoff || (acc == cutoff && c > cutlim)) {\n      return -1 // overflow\n    } else {\n      acc = (acc * base) + c\n    }\n\n    i++\n  }\n\n  return acc\n}\n\n\nTEST(\"strtou\", () => {\n  function t(input :string, base :int, expect :int) {\n    let buf = Uint8Array.from(\n      input as any as ArrayLike<number>,\n      (_: number, k: number) => input.charCodeAt(k)\n    )\n    let output = strtou(buf, base, 0, buf.length)\n    assert(\n      output === expect,\n      `strtou32(\"${input}\", ${base}) => ${output}; expected ${expect}`\n    )\n  }\n\n  t(\"\", 10, 0)\n  t(\"0\", 10, 0)\n  t(\"000000000000\", 10, 0)\n  t(\"1\", 10, 1)\n  t(\"00000000000000000000000000000000000000000000000001\", 10, 1)\n  t(\"123\", 10, 123)\n  t(\"4294967295\", 10, 4294967295)  // 0xFFFFFFFF\n  t(Number.MAX_SAFE_INTEGER.toString(10), 10, Number.MAX_SAFE_INTEGER)\n  t((Number.MAX_SAFE_INTEGER+1).toString(10), 10, -1)\n\n  t(\"0\", 16, 0x0)\n  t(\"FF\", 16, 0xFF)\n  t(\"DEADBEEF\", 16, 0xDEADBEEF)\n  t(\"deadbeef\", 16, 0xdeadbeef)\n  t(\"dEaDbEef\", 16, 0xdeadbeef)\n  t(\"0000DEADBEEF\", 16, 0xDEADBEEF)\n\n  // invalid chars\n  t(\"x123\", 10, -1)\n  t(\"-123\", 10, -1)\n})\n","//\n// 64-bit integer math\n//\n// Based on Google Closure Library's goog/math/long.js\n// and long.js https://github.com/dcodeIO/long.js\n//\n// Google Closure Library is licensed as follows:\n//   Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//   Apache License, Version 2.0 (the \"License\"); you may not use this file\n//   except in compliance with the License.\n//   You may obtain a copy of the License at\n//   https://github.com/google/closure-library/blob/master/LICENSE\n//\n// long.js is licensed as follows:\n//   Apache License, Version 2.0 (the \"License\"); you may not use this file\n//   except in compliance with the License.\n//   You may obtain a copy of the License at\n//   https://github.com/dcodeIO/long.js/blob/master/LICENSE\n//\n//\nimport { strtou } from './strtou'\n\nexport interface Int64 {\n  eq(x :Int64) :bool   // this == x\n  neq(x :Int64) :bool  // this != x\n  eqz() :bool          // this == 0\n  cmp(x :Int64) :int   // this <> x  ->  -1 | 0 | 1\n  lt(x :Int64) :bool   // this < x\n  lte(x :Int64) :bool  // this <= x\n  gt(x :Int64) :bool   // this > x\n  gte(x :Int64) :bool  // this >= x\n\n  readonly isSigned :bool\n  isNeg() :bool  // true if negative (always false for UInt64)\n  isPos() :bool  // true if positive (always true for UInt64)\n  isOdd() :bool  // true if odd number\n  isZero() :bool // true if zero\n\n  neg() :Int64 // -N negation\n\n  not() :Int64             // ~N bitwise not\n  mod(x :Int64) :Int64     // this % x\n  and(x :Int64) :Int64     // this & x\n  or(x :Int64) :Int64      // this | x\n  xor(x :Int64) :Int64     // this ^ x\n  shl(nbits :int) :Int64   // \n  shr_s(nbits :int) :Int64 // sign-replicating/arithmetic shift right\n  shr_u(nbits :int) :Int64 // zero-replicating/logical shift right\n  shr(nbits :int) :Int64 // shr_s for SInt64, shr_u for UInt64\n\n  add(x :Int64) :Int64 // this + x\n  sub(x :Int64) :Int64 // this - x\n  mul(x :Int64) :Int64 // this * x\n  div(x :Int64) :Int64 // this / x\n\n  popcnt() :int  // count number of set bits\n\n  toSigned() :SInt64\n  toUnsigned() :UInt64\n  toInt32() :int\n  toUInt32() :int\n  toFloat64() :number\n  toBytesLE() :Uint8Array\n  toBytesBE() :Uint8Array\n  toString(radix? :int) :string // radix defaults to 10\n\n  _low :int\n  _high :int\n}\n\nexport interface Int64Cons {\n  readonly MIN  :Int64\n  readonly MAX  :Int64\n  readonly ZERO :Int64  // 0\n  readonly ONE  :Int64  // 1\n\n  fromInt32(v :int) :Int64\n  fromFloat64(v :number) :Int64\n  maybeFromFloat64(v :number) :Int64|null\n  fromStr(str :string, radix :int) :Int64\n  fromByteStr(b :ArrayLike<byte>, radix :int) :Int64\n  fromByteStr0(b :ArrayLike<byte>, radix :int, start :int, end :int) :Int64\n  fromBytesLE(b :ArrayLike<byte>) :Int64\n  fromBytesBE(b :ArrayLike<byte>) :Int64\n}\n\n// ===========================================================================\n\n// WebAssembly routines for envs that support it\ninterface Uint64Wasm {\n  mul(alo :int, ahi :int, mlo: int, mhi :int) :int  // returns lower\n  div_u(alo :int, ahi :int, dlo: int, dhi :int) :int  // returns lower\n  div_s(alo :int, ahi :int, dlo: int, dhi :int) :int  // returns lower\n  rem_u(alo :int, ahi :int, dlo: int, dhi :int) :int  // returns lower\n  rem_s(alo :int, ahi :int, dlo: int, dhi :int) :int  // returns lower\n  popcnt(lo :int, hi :int) :int\n  get_high() :int\n}\n\nvar wasm :Uint64Wasm\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    //!<wasmdata src=\"int64.wast\">\n    0,97,115,109,1,0,0,0,1,19,3,96,0,1,127,96,2,127,127,1,127,96,4,127,127,\n    127,127,1,127,3,8,7,0,1,2,2,2,2,2,6,6,1,127,1,65,0,11,7,59,7,8,103,101,\n    116,95,104,105,103,104,0,0,3,109,117,108,0,2,5,100,105,118,95,115,0,3,5,\n    100,105,118,95,117,0,4,5,114,101,109,95,115,0,5,5,114,101,109,95,117,0,6,\n    6,112,111,112,99,110,116,0,1,10,218,1,7,4,0,35,0,11,16,1,1,126,32,0,173,\n    32,1,173,66,32,134,132,123,167,11,38,1,1,126,32,0,173,32,1,173,66,32,134,\n    132,32,2,173,32,3,173,66,32,134,132,126,33,4,32,4,66,32,135,167,36,0,32,4,\n    167,11,38,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,\n    134,132,127,33,4,32,4,66,32,135,167,36,0,32,4,167,11,38,1,1,126,32,0,173,\n    32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,33,4,32,4,66,\n    32,135,167,36,0,32,4,167,11,38,1,1,126,32,0,173,32,1,173,66,32,134,132,32,\n    2,173,32,3,173,66,32,134,132,129,33,4,32,4,66,32,135,167,36,0,32,4,167,11,\n    38,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,\n    132,130,33,4,32,4,66,32,135,167,36,0,32,4,167,11\n    //!</wasmdata>\n  ])), {}).exports as any as Uint64Wasm\n} catch (_) {\n  // no wasm support\n  wasm = null as any as Uint64Wasm\n}\n\nconst _TWO_PWR_16_DBL = 1 << 16\nconst _TWO_PWR_32_DBL = _TWO_PWR_16_DBL * _TWO_PWR_16_DBL\nconst _TWO_PWR_64_DBL = _TWO_PWR_32_DBL * _TWO_PWR_32_DBL\nconst _TWO_PWR_63_DBL = _TWO_PWR_64_DBL / 2\n\ntype _Int64Cons = typeof SInt64 | typeof UInt64\n\nclass Int64Base {\n  _low :int\n  _high :int\n\n  constructor(low :int, high :int) {\n    this._low = low | 0    // force into 32 signed bits\n    this._high = high | 0  // force into 32 signed bits\n  }\n\n  eq(x :Int64) :bool {\n    if (\n      this.constructor !== x.constructor && // mixing signed/unsigned\n      this._high >>> 31 == 1 &&\n      x._high >>> 31 == 1\n    ) {\n      return false\n    }\n    return (this._high == x._high) && (this._low == x._low)\n  }\n\n  neq(x :Int64) :bool {\n    return (this._high != x._high) || (this._low != x._low)\n  }\n\n  eqz() :bool {\n    return this._high == 0 && this._low == 0\n  }\n\n  lt(x :Int64) :bool {\n    return (this as any as Int64).cmp(x) < 0\n  }\n\n  lte(x :Int64) :bool {\n    return (this as any as Int64).cmp(x) <= 0\n  }\n\n  gt(x :Int64) :bool {\n    return (this as any as Int64).cmp(x) > 0\n  }\n\n  gte(x :Int64) :bool {\n    return (this as any as Int64).cmp(x) >= 0\n  }\n\n  not() :Int64 { // ~N bitwise not\n    return new (<_Int64Cons>this.constructor)(~this._low, ~this._high)\n  }\n\n  mod(x :Int64) :Int64 { // this % x\n    return (this as any as Int64).sub((this as any as Int64).div(x).mul(x))\n  }\n\n  and(x :Int64) :Int64 { // this & x\n    return new (<_Int64Cons>this.constructor)(\n      this._low & x._low,\n      this._high & x._high\n    )\n  }\n\n  or(x :Int64) :Int64 { // this | x\n    return new (<_Int64Cons>this.constructor)(\n      this._low | x._low,\n      this._high | x._high\n    )\n  }\n\n  xor(x :Int64) :Int64 { // this ^ x\n    return new (<_Int64Cons>this.constructor)(\n      this._low ^ x._low,\n      this._high ^ x._high\n    )\n  }\n\n  // shl returns an Int64 with bits shifted to the left by nbits\n  //\n  shl(nbits :int) :Int64 {\n    nbits &= 63\n    if (nbits == 0) {\n      return this as any as Int64\n    }\n    let low = this._low\n    if (nbits < 32) {\n      return new (<_Int64Cons>this.constructor)(\n        low << nbits,\n        (this._high << nbits) | (low >>> (32 - nbits))\n      )\n    }\n    return new (<_Int64Cons>this.constructor)(0, low << (nbits - 32))\n  }\n\n  // shr_s returns an Int64 with bits shifted to the right by nbits.\n  // The new leading bits match the current sign bit.\n  //\n  shr_s(nbits :int) :Int64 {\n    nbits &= 63\n    if (nbits == 0) {\n      return this as any as Int64\n    }\n    let high = this._high\n    if (nbits < 32) {\n      return new (<_Int64Cons>this.constructor)(\n        (this._low >>> nbits) | (high << (32 - nbits)),\n        high >> nbits\n      )\n    }\n    return new (<_Int64Cons>this.constructor)(\n      high >> (nbits - 32),\n      high >= 0 ? 0 : -1\n    )\n  }\n\n  // shr_u returns an Int64 with its bits logically\n  // shifted to the right by nbits.\n  //\n  shr_u(nbits :int) :Int64 {\n    nbits &= 63;\n    if (nbits === 0) {\n      return this as any as Int64\n    }\n    let high = this._high\n    if (nbits < 32) {\n        return new (<_Int64Cons>this.constructor)(\n          (this._low >>> nbits) | (high << (32 - nbits)),\n          high >>> nbits\n        )\n    }\n    if (nbits === 32) {\n      return new (<_Int64Cons>this.constructor)(high, 0)\n    }\n    return new (<_Int64Cons>this.constructor)(high >>> (nbits - 32), 0)\n  }\n\n  add(x :Int64) :Int64 { // this + x\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks\n    let a48 = this._high >>> 16\n      , a32 = this._high & 0xFFFF\n      , a16 = this._low >>> 16\n      , a00 = this._low & 0xFFFF\n      , b48 = x._high >>> 16\n      , b32 = x._high & 0xFFFF\n      , b16 = x._low >>> 16\n      , b00 = x._low & 0xFFFF\n      , c48 = 0\n      , c32 = 0\n      , c16 = 0\n      , c00 = 0\n    ;\n    c00 += a00 + b00\n    c16 += c00 >>> 16\n    c00 &= 0xFFFF\n    c16 += a16 + b16\n    c32 += c16 >>> 16\n    c16 &= 0xFFFF\n    c32 += a32 + b32\n    c48 += c32 >>> 16\n    c32 &= 0xFFFF\n    c48 += a48 + b48\n    c48 &= 0xFFFF;\n    return new (<_Int64Cons>this.constructor)(\n      (c16 << 16) | c00,\n      (c48 << 16) | c32\n    )\n  }\n\n  sub(x :Int64) :Int64 {\n    return this.add(x.neg())\n  }\n\n  mul(x :Int64) :Int64 {\n    let n = this as any as Int64,\n        I = <_Int64Cons>n.constructor\n\n    if (n.eqz() || x.eqz()) {\n      return I.ZERO\n    }\n\n    if (n.eq(I.MIN)) {\n      return x.isOdd() ? I.MIN : I.ZERO\n    }\n\n    if (x.eq(I.MIN)) {\n      return n.isOdd() ? I.MIN : I.ZERO\n    }\n\n    if (n.isNeg()) {\n      if (x.isNeg()) {\n        return n.neg().mul(x.neg())\n      }\n      return n.neg().mul(x).neg()\n    }\n\n    if (x.isNeg()) {\n      return n.mul(x.neg()).neg()\n    }\n\n    // If both longs are small, use float multiplication\n    if (n.lt(S64_TWO_PWR_24) && x.lt(S64_TWO_PWR_24)) {\n      return SInt64.fromFloat64(n.toFloat64() * x.toFloat64())\n    }\n\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n    let a48 = n._high >>> 16\n      , a32 = n._high & 0xFFFF\n      , a16 = n._low >>> 16\n      , a00 = n._low & 0xFFFF\n      , b48 = x._high >>> 16\n      , b32 = x._high & 0xFFFF\n      , b16 = x._low >>> 16\n      , b00 = x._low & 0xFFFF\n      , c48 = 0\n      , c32 = 0\n      , c16 = 0\n      , c00 = 0\n    ;\n    c00 += a00 * b00\n    c16 += c00 >>> 16\n    c00 &= 0xFFFF\n    c16 += a16 * b00\n    c32 += c16 >>> 16\n    c16 &= 0xFFFF\n    c16 += a00 * b16\n    c32 += c16 >>> 16\n    c16 &= 0xFFFF\n    c32 += a32 * b00\n    c48 += c32 >>> 16\n    c32 &= 0xFFFF\n    c32 += a16 * b16\n    c48 += c32 >>> 16\n    c32 &= 0xFFFF\n    c32 += a00 * b32\n    c48 += c32 >>> 16\n    c32 &= 0xFFFF\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48\n    c48 &= 0xFFFF\n\n    return new I((c16 << 16) | c00, (c48 << 16) | c32)\n  }\n\n  popcnt() :int {\n    return popcnt32(this._low) + popcnt32(this._high)\n  }\n\n  isOdd() :bool {\n    return (this._low & 1) == 1\n  }\n\n  isZero() :bool {\n    return this._low == 0 && this._high == 0\n  }\n\n  // toUInt32 returns the lower part as a 32-bit unsigned value\n  //\n  toUInt32() {\n    return (this._low >= 0) ? this._low : _TWO_PWR_32_DBL + this._low\n  }\n\n  // toBytesLE encodes this integer in little-endian byte order\n  //\n  toBytesLE() :Uint8Array {\n    let b = new Uint8Array(8)\n      , i = 0\n    b[i]   = this._low        & 0xff\n    b[++i] = this._low >>>  8 & 0xff\n    b[++i] = this._low >>> 16 & 0xff\n    b[++i] = this._low >>> 24\n    b[++i] = this._high        & 0xff\n    b[++i] = this._high >>>  8 & 0xff\n    b[++i] = this._high >>> 16 & 0xff\n    b[++i] = this._high >>> 24\n    return b\n  }\n\n  // toBytesLE encodes this integer in big-endian byte order\n  //\n  toBytesBE() :Uint8Array {\n    let b = new Uint8Array(8)\n      , i = 0\n    b[i]   = this._high >>> 24\n    b[++i] = this._high >>> 16 & 0xff\n    b[++i] = this._high >>>  8 & 0xff\n    b[++i] = this._high        & 0xff\n    b[++i] = this._low >>> 24\n    b[++i] = this._low >>> 16 & 0xff\n    b[++i] = this._low >>>  8 & 0xff\n    b[++i] = this._low        & 0xff\n    return b\n  }\n}\n\n\n// popcnt32 returns the number of set bits in n\n//\nfunction popcnt32(n :int) :int {\n  n = n - ((n >> 1) & 0x55555555)\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n  return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\n\nfunction fromStr(\n  I :Int64Cons,\n  zero :Int64,\n  str :string,\n  radix :int,\n) :Int64 {\n  if (str.length == 0) {\n    throw new Error('empty string')\n  }\n\n  if (!radix) {\n    radix = 10\n  } else if (radix < 2 || 36 < radix) {\n    throw new Error('radix out of range')\n  }\n\n  if (str.charCodeAt(0) == 0x2D) { // -\n    return fromStr(I, zero, str.substr(1), radix).neg()\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  let radixToPower = UInt64.fromFloat64(Math.pow(radix, 8))\n  let result = zero\n\n  for (let i = 0; i < str.length; i += 8) {\n    let size = Math.min(8, str.length - i)\n    let value = parseInt(str.substring(i, i + size), radix)\n    if (size < 8) {\n      let power = I.fromFloat64(Math.pow(radix, size))\n      result = result.mul(power).add(I.fromFloat64(value))\n    } else {\n      result = result.mul(radixToPower)\n      result = result.add(I.fromFloat64(value))\n    }\n  }\n\n  return result\n}\n\n\n// fromByteStr0 interprets a literal number from a byte array.\n// The bytes must only contain ASCII digits (no \"-\" or whitespace.)\n//\nfunction fromByteStr0(\n  I :Int64Cons,\n  zero :Int64,\n  buf :ArrayLike<byte>,\n  radix :int,\n  start :int,\n  end :int,\n) :Int64 {\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  let radixToPower = I.fromFloat64(Math.pow(radix, 8))\n  let result = zero\n\n  for (let i = start; i < end; i += 8) {\n    let size = Math.min(8, end - i)\n    let value = strtou(buf, radix, i, i + size)\n    if (size < 8) {\n      let power = I.fromFloat64(Math.pow(radix, size))\n      result = result.mul(power).add(I.fromFloat64(value))\n    } else {\n      result = result.mul(radixToPower)\n      result = result.add(I.fromFloat64(value))\n    }\n  }\n\n  return result\n}\n\n// fromBytes returns an Int64 representing the given ASCII string\n// in the byte array buf, interpreted in radix.\n// If the first byte is \"-\" (0x2D \"hyphen\"), then the number is interpreted\n// as being negative.\n//\nfunction fromByteStr(\n  I :Int64Cons,\n  zero :Int64,\n  buf :ArrayLike<byte>,\n  radix :int,\n ) :Int64 {\n  if (buf.length == 0) {\n    throw new Error('empty byte array')\n  }\n  if (!radix) {\n    radix = 10\n  } else if (radix < 2 || 36 < radix) {\n    throw new Error('radix out of range')\n  }\n  if (buf[0] == 0x2D) { // -\n    return fromByteStr0(I, zero, buf, radix, 1, buf.length).neg()\n  }\n  return fromByteStr0(I, zero, buf, radix, 0, buf.length)\n}\n\n\nfunction toString(n :Int64, radix? :int) :string {\n  if (!radix) {\n    radix = 10\n  } else if (radix < 2 || 36 < radix) {\n    throw new Error('radix out of range')\n  }\n\n  if (n.eqz()) {\n    return '0'\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  let radixToPower = UInt64.fromFloat64(Math.pow(radix, 6))\n  let rem = n\n  let result = ''\n\n  while (true) {\n    // The right shifting fixes negative values in the case when\n    // intval >= 2^31; for more details see\n    // https://github.com/google/closure-library/pull/498\n    let remDiv = rem.div(radixToPower)\n      , intval = rem.sub(remDiv.mul(radixToPower)).toInt32() >>> 0\n      , digits = intval.toString(radix)\n    rem = remDiv\n    if (rem.eqz()) {\n      return digits + result\n    }\n    while (digits.length < 6) {\n      digits = '0' + digits\n    }\n    result = '' + digits + result\n  }\n}\n\n\n// ===========================================================================\n\n\nexport class SInt64 extends Int64Base implements Int64 {\n  static readonly MIN    :SInt64  // -9223372036854775808\n  static readonly MAX    :SInt64  // 9223372036854775807\n  static readonly ZERO   :SInt64  // 0\n  static readonly ONE    :SInt64  // 1\n  static readonly ONENEG :SInt64  // -1\n\n  // fromInt32 create a SInt64 representing the 32-bit signed integer v\n  //\n  static fromInt32(v :int) :SInt64 {\n    let iv = v | 0  // convert to i32\n    assert(Math.round(v) === v, 'value should be a 32-bit integer')\n    if (-128 <= iv && iv < 128) {\n      let s = _SInt64_cache.get(iv)\n      if (!s) {\n        s = new SInt64(iv, iv < 0 ? -1 : 0)\n        _SInt64_cache.set(iv, s)\n      }\n      return s\n    }\n    return new SInt64(iv, iv < 0 ? -1 : 0)\n  }\n\n  // fromFloat64 returns a SInt64 representing the given number v which\n  // can be any JS number. NaN results in zero, Infinity to SInt64.MAX and\n  // -Infinity SInt64.MIN\n  //\n  static fromFloat64(v :number) :SInt64 {\n    if (isNaN(v)) {\n      return S64_ZERO\n    }\n    if (v <= -_TWO_PWR_63_DBL) {\n      return S64_MIN\n    }\n    if (v + 1 >= _TWO_PWR_63_DBL) {\n      return S64_MAX\n    }\n    if (v < 0) {\n      return this.fromFloat64(-v).neg()\n    }\n    return new SInt64((v % _TWO_PWR_32_DBL) | 0, (v / _TWO_PWR_32_DBL) | 0)\n  }\n\n  // maybeFromFloat64 is like fromFloat64, but returns null if v can not be\n  // losslessly represented (i.e. if v < SInt64.MIN, v > SInt64.MAX, or nan.)\n  //\n  static maybeFromFloat64(v :number) :SInt64|null {\n    if (isNaN(v) || v < -_TWO_PWR_63_DBL || v + 1 > _TWO_PWR_63_DBL) {\n      return null\n    }\n    if (v == -_TWO_PWR_63_DBL) {\n      return S64_MIN\n    }\n    if (v + 1 == _TWO_PWR_63_DBL) {\n      return S64_MAX\n    }\n    if (v < 0) {\n      v = -v\n      if (v + 1 >= _TWO_PWR_63_DBL) {\n        return null\n      }\n      return (\n        new SInt64((v % _TWO_PWR_32_DBL) | 0, (v / _TWO_PWR_32_DBL) | 0)\n      ).neg()\n    }\n    return new SInt64((v % _TWO_PWR_32_DBL) | 0, (v / _TWO_PWR_32_DBL) | 0)\n  }\n\n  // fromStr returns a SInt64 representing of the given string,\n  // interpreted in radix.\n  //\n  static fromStr(str :string, radix :int) :SInt64 {\n    return fromStr(this, S64_ZERO, str, radix)\n  }\n\n  // fromBytesUnchecked interprets a number from a byte array.\n  // The bytes must only contain digits (no \"-\" or whitespace.)\n  //\n  static fromByteStr0(\n    buf :ArrayLike<byte>,\n    radix :int,\n    start :int,\n    end :int,\n  ) :SInt64 {\n    return fromByteStr0(this, S64_ZERO, buf, radix, start, end)\n  }\n\n  // fromBytes returns an Int64 representing the given ASCII string\n  // in the byte array buf, interpreted in radix.\n  // If the first byte is \"-\" (0x2D \"hyphen\"), then the number is interpreted\n  // as being negative.\n  //\n  static fromByteStr(buf :ArrayLike<byte>, radix :int) :SInt64 {\n    return fromByteStr(this, S64_ZERO, buf, radix)\n  }\n\n  // fromBytesLE interprets 8 bytes in little-endian byte order\n  //\n  static fromBytesLE(b :ArrayLike<byte>) :Int64 {\n    return new (<_Int64Cons>this)(\n      b[0]       |\n      b[1] <<  8 |\n      b[2] << 16 |\n      b[3] << 24,\n      b[4]       |\n      b[5] <<  8 |\n      b[6] << 16 |\n      b[7] << 24\n    )\n  }\n\n  // fromBytesBE interprets 8 bytes in big-endian byte order\n  //\n  static fromBytesBE(b :ArrayLike<byte>) :Int64 {\n    return new (<_Int64Cons>this)(\n      b[4] << 24 |\n      b[5] << 16 |\n      b[6] <<  8 |\n      b[7],\n      b[0] << 24 |\n      b[1] << 16 |\n      b[2] <<  8 |\n      b[3]\n    )\n  }\n\n  readonly isSigned :bool = true\n\n  isNeg() :bool {\n    return this._high < 0\n  }\n\n  isPos() :bool {\n    return this._high >= 0\n  }\n\n  cmp(x :Int64) :int { // this <> x  ->  -1 | 0 | 1\n    if (this.eq(x)) {\n      return 0\n    }\n    let thisNeg = this.isNeg()\n    let xNeg = x.isNeg()\n    if (thisNeg && !xNeg) {\n      return -1\n    }\n    if (!thisNeg && xNeg) {\n      return 1\n    }\n    // at this point the sign bits are the same\n    return this.sub(x).isNeg() ? -1 : 1\n  }\n\n  neg() :SInt64 { // -N negation\n    return this.eq(S64_MIN) ? S64_MIN : this.not().add(S64_ONE)\n  }\n\n  div(x :Int64) :SInt64 {\n    if (x.eqz()) {\n      throw new Error('division by zero')\n    }\n\n    if (this.eqz()) {\n      return S64_ZERO\n    }\n\n    if (this.eq(S64_MIN)) {\n      if (x.eq(S64_ONE) || x.eq(S64_NEGONE)) {\n        return S64_MIN  // recall that -MIN_VALUE == MIN_VALUE\n      }\n      if (x.eq(S64_MIN)) {\n        return S64_ONE\n      }\n      // At this point, we have |x| >= 2, so |this/x| < |MIN_VALUE|.\n      let halfThis = this.shr_s(1)\n      let approx = halfThis.div(x).shl(1)\n      if (approx.eq(S64_ZERO)) {\n        return x.isNeg() ? S64_ONE : S64_NEGONE\n      }\n      let rem = this.sub(x.mul(approx))\n      let result = approx.add(rem.div(x))\n      return result\n    }\n\n    if (x.eq(S64_MIN)) {\n      return S64_ZERO\n    }\n\n    if (this.isNeg()) {\n      return x.isNeg() ?\n        this.neg().div(x.neg()) :\n        this.neg().div(x).neg()\n    }\n    if (x.isNeg()) {\n      return this.div(x.neg()).neg()\n    }\n\n    // Repeat the following until the remainder is less than x:  find a\n    // floating-point that approximates remainder / x *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical\n    // that the approximate value is less than or equal to the real value so\n    // that the remainder never becomes negative.\n    let res = S64_ZERO\n    let rem :SInt64 = this\n    while (rem.gte(x)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      let approx = Math.max(1, Math.floor(rem.toFloat64() / x.toFloat64()))\n\n      // We will tweak the approximate result by changing it in the 48-th digit\n      // or the smallest non-fractional digit, whichever is larger.\n      let log2 = Math.ceil(Math.log(approx) / Math.LN2)\n      let delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48)\n\n      // Decrease the approximation until it is smaller than the remainder.\n      // Note that if it is too large, the product overflows and is negative.\n      let approxRes = SInt64.fromFloat64(approx)\n      let approxRem = approxRes.mul(x)\n      while (approxRem.isNeg() || approxRem.gt(rem)) {\n        approx -= delta\n        approxRes = SInt64.fromFloat64(approx)\n        approxRem = approxRes.mul(x)\n      }\n\n      // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n      if (approxRes.eqz()) {\n        approxRes = S64_ONE\n      }\n\n      res = res.add(approxRes)\n      rem = rem.sub(approxRem)\n    }\n    return res\n  }\n\n  shr(nbits :int) :Int64 {\n    return this.shr_s(nbits)\n  }\n\n  toSigned() {\n    return this\n  }\n  \n  toUnsigned() {\n    return new UInt64(this._low, this._high)\n  }\n\n  // toInt32 assumes this is a 32-bit integer and returns the lower part\n  //\n  toInt32() {\n    return this._low\n  }\n\n  // toFloat64 returns the closest floating-point representation to this value\n  //\n  toFloat64() {\n    return this._high * _TWO_PWR_32_DBL + (this._low >>> 0)\n    // return this._high * _TWO_PWR_32_DBL + this.toUInt32()\n  }\n\n  toString(radix? :int) :string {\n    if (this.isNeg()) {\n      if (!radix) { radix = 10 }\n      if (this.eq(S64_MIN)) {\n        // We need to change the value before it can be negated, so we\n        // remove the bottom-most digit in this base and then recurse to do\n        // the rest.\n        let radixLong = SInt64.fromFloat64(radix)\n        let div = this.div(radixLong)\n        let rem = div.mul(radixLong).sub(this)\n        return div.toString(radix) + rem.toInt32().toString(radix)\n      }\n      return '-' + toString(this.neg(), radix)\n    }\n    return toString(this, radix)\n  }\n}\n\n// ===========================================================================\n\nexport class UInt64 extends Int64Base {\n  static readonly MIN  :UInt64  //\n  static readonly MAX  :UInt64  // \n  static readonly ZERO :UInt64  // 0\n  static readonly ONE  :UInt64  // 1\n\n  // fromInt32 create a UInt64 representing the 32-bit integer v.\n  // if v is negative, overflow rules apply.\n  //\n  static fromInt32(v :int) :UInt64 {\n    let u = v >>> 0\n    assert(Math.round(v) === v, 'value should be a 32-bit integer')\n    if (0 <= v && v < 256) {\n      let s = _UInt64_cache.get(u)\n      if (!s) {\n        _UInt64_cache.set(u, s = new UInt64(u, 0))\n      }\n      return s\n    }\n    return new UInt64(u | 0, v < 0 ? -1 : 0)\n  }\n\n  // fromFloat64 returns a UInt64 representing the given number v which\n  // can be any JS number.\n  // NaN and -Infinity results in zero, Infinity results in UInt64.MAX.\n  //\n  static fromFloat64(v :number) :UInt64 {\n    if (v <= 0 || isNaN(v)) {\n      return U64_ZERO\n    }\n    if (v >= _TWO_PWR_64_DBL) {\n      return U64_MAX\n    }\n    return new UInt64(v % _TWO_PWR_32_DBL, v / _TWO_PWR_32_DBL)\n  }\n\n  // maybeFromFloat64 is like fromFloat64, but returns null if v can not be\n  // losslessly represented (i.e. if v < UInt64.MIN, v > UInt64.MAX, or nan.)\n  //\n  static maybeFromFloat64(v :number) :UInt64|null {\n    if (v < 0 || v > _TWO_PWR_64_DBL || isNaN(v)) {\n      return null\n    }\n    if (v == 0) {\n      return U64_ZERO\n    }\n    if (v == _TWO_PWR_64_DBL) {\n      return U64_MAX\n    }\n    return new UInt64(v % _TWO_PWR_32_DBL, v / _TWO_PWR_32_DBL)\n  }\n\n  // fromStr returns a UInt64 representing of the given string,\n  // interpreted in radix.\n  //\n  static fromStr(str :string, radix :int) :SInt64 {\n    return fromStr(this, U64_ZERO, str, radix)\n  }\n\n  // fromBytesUnchecked interprets a number from a byte array.\n  // The bytes must only contain digits (no \"-\" or whitespace.)\n  //\n  static fromByteStr0(\n    buf :ArrayLike<byte>,\n    radix :int,\n    start :int,\n    end :int,\n  ) :UInt64 {\n    return fromByteStr0(this, U64_ZERO, buf, radix, start, end)\n  }\n\n  // fromBytes returns an Int64 representing the given ASCII string\n  // in the byte array buf, interpreted in radix.\n  // If the first byte is \"-\" (0x2D \"hyphen\"), then the number is interpreted\n  // as being negative, and is subject to the overflow rules of UInt64.\n  //\n  static fromByteStr(buf :ArrayLike<byte>, radix :int) :UInt64 {\n    return fromByteStr(this, U64_ZERO, buf, radix)\n  }\n\n  // These are replaced later with common implementations\n  static fromBytesLE(_ :ArrayLike<byte>) :Int64 { return U64_ZERO }\n  static fromBytesBE(_ :ArrayLike<byte>) :Int64 { return U64_ZERO }\n\n  readonly isSigned :bool = false\n  isNeg() :bool { return false }\n  isPos() :bool { return true }\n\n  cmp(x :Int64) :int { // this <> x  ->  -1 | 0 | 1\n    if (this.eq(x)) {\n      return 0\n    }\n    if (x.isNeg()) {\n      return 1\n    }\n    // at this point the sign bits are the same.\n    // both are positive if at least one is unsigned (`this` is unsigned)\n    return (\n      (x._high >>> 0) > (this._high >>> 0) ||\n      ( x._high === this._high && (x._low >>> 0) > (this._low >>> 0) )\n      ? -1 : 1\n    )\n  }\n\n  neg() :UInt64 {\n    return this.not().add(S64_ONE)\n  }\n\n  div(x :Int64) :UInt64 {\n    if (x.eqz()) {\n      throw new Error('division by zero')\n    }\n    if (this.eqz()) {\n      // e.g. 0 / 3 = 0\n      return U64_ZERO\n    }\n\n    if (x.constructor !== UInt64) {\n      x = x.toUnsigned()\n    }\n\n    if (x.gt(this)) {\n      // e.g. 4 / 5 = 0\n      return U64_ZERO\n    }\n\n    if (x.gt(this.shr_u(1))) {\n      // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return U64_ONE\n    }\n\n    // Repeat the following until the remainder is less than x:  find a\n    // floating-point that approximates remainder / x *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical\n    // that the approximate value is less than or equal to the real value so\n    // that the remainder never becomes negative.\n    let res = U64_ZERO\n    let rem :UInt64 = this\n    while (rem.gte(x)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      let approx = Math.max(1, Math.floor(rem.toFloat64() / x.toFloat64()))\n\n      // We will tweak the approximate result by changing it in the 48-th digit\n      // or the smallest non-fractional digit, whichever is larger.\n      let log2 = Math.ceil(Math.log(approx) / Math.LN2)\n      let delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48)\n\n      // Decrease the approximation until it is smaller than the remainder.\n      // Note that if it is too large, the product overflows and is negative.\n      let approxRes = SInt64.fromFloat64(approx)\n      let approxRem = approxRes.mul(x)\n      while (approxRem.isNeg() || approxRem.gt(rem)) {\n        approx -= delta\n        approxRes = UInt64.fromFloat64(approx)\n        approxRem = approxRes.mul(x)\n      }\n\n      // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n      if (approxRes.eqz()) {\n        approxRes = S64_ONE\n      }\n\n      res = res.add(approxRes)\n      rem = rem.sub(approxRem)\n    }\n    return res\n  }\n\n  shr(nbits :int) :Int64 {\n    return this.shr_u(nbits)\n  }\n\n  toSigned() {\n    return new SInt64(this._low, this._high)\n  }\n\n  toUnsigned() {\n    return this\n  }\n\n  toInt32() {\n    return this._low >>> 0\n  }\n\n  toFloat64() {\n    return ((this._high >>> 0) * _TWO_PWR_32_DBL) + (this._low >>> 0)\n  }\n\n  toString(radix? :int) :string {\n    return toString(this, radix)\n  }\n}\n\nUInt64.fromBytesLE = SInt64.fromBytesLE\nUInt64.fromBytesBE = SInt64.fromBytesBE\n\n// ===========================================================================\n\n// use wasm support if present\nif (wasm != null) {\n  if (DEBUG) {\n    // in debug builds, include the fallback implementations\n    // as undocumented properties so that we can tests them\n\n    let SInt64x = SInt64.prototype as any\n    let UInt64x = UInt64.prototype as any\n\n    SInt64x._js_mul = SInt64.prototype.mul\n    SInt64x._js_div = SInt64.prototype.div\n    UInt64x._js_div = UInt64.prototype.div\n    SInt64x._js_mod = SInt64.prototype.mod\n    UInt64x._js_mod = UInt64.prototype.mod\n    SInt64x._js_popcnt = Int64Base.prototype.popcnt\n  }\n\n  SInt64.prototype.mul = function mul(m :Int64) :SInt64 {\n    let low = wasm.mul(this._low, this._high, m._low, m._high)\n    return new SInt64(low, wasm.get_high())\n  }\n\n  UInt64.prototype.mul = function mul(m :Int64) :UInt64 {\n    let low = wasm.mul(this._low, this._high, m._low, m._high)\n    return new UInt64(low, wasm.get_high())\n  }\n\n  SInt64.prototype.div = function div(d :Int64) :SInt64 {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (this._high === -0x80000000 && d._low === -1 && d._high === -1) {\n      // be consistent with non-wasm code path\n      return this\n    }\n    let low = wasm.div_s(this._low, this._high, d._low, d._high)\n    return new SInt64(low, wasm.get_high())\n  }\n\n  UInt64.prototype.div = function div(d :Int64) :UInt64 {\n    let low = wasm.div_u(this._low, this._high, d._low, d._high)\n    return new UInt64(low, wasm.get_high())\n  }\n\n  SInt64.prototype.mod = function mod(d :Int64) :SInt64 {\n    let low = wasm.rem_s(this._low, this._high, d._low, d._high)\n    return new SInt64(low, wasm.get_high())\n  }\n\n  UInt64.prototype.mod = function mod(d :Int64) :UInt64 {\n    let low = wasm.rem_u(this._low, this._high, d._low, d._high)\n    return new UInt64(low, wasm.get_high())\n  }\n\n  Int64Base.prototype.popcnt = function popcnt() :int {\n    return wasm.popcnt(this._low, this._high)\n  }\n}\n\nSInt64.prototype.shr = Int64Base.prototype.shr_s\nUInt64.prototype.shr = Int64Base.prototype.shr_u\n\nconst S64_TWO_PWR_24 = new SInt64((1 << 24) | 0, 0)\n\nconst S64_MAX    = new SInt64(0xFFFFFFFF | 0, 0x7FFFFFFF | 0)\nconst S64_MIN    = new SInt64(0, 0x80000000 | 0)\nconst S64_ZERO   = new SInt64(0 | 0, 0)\nconst S64_ONE    = new SInt64(1 | 0, 0)\nconst S64_NEGONE = new SInt64(-1 | 0, -1)\n\nconst U64_MAX  = new UInt64(0xFFFFFFFF | 0, 0xFFFFFFFF | 0)\nconst U64_ZERO = new UInt64(0 | 0, 0)\nconst U64_ONE  = new UInt64(1 | 0, 0)\n\n;(SInt64 as any).MIN = S64_MIN\n;(SInt64 as any).MAX = S64_MAX\n;(SInt64 as any).ZERO = S64_ZERO\n;(SInt64 as any).ONE = S64_ONE\n;(SInt64 as any).ONENEG = S64_NEGONE\n\n;(UInt64 as any).MIN = U64_ZERO\n;(UInt64 as any).MAX = U64_MAX\n;(UInt64 as any).ZERO = U64_ZERO\n;(UInt64 as any).ONE = U64_ONE\n\nlet _SInt64_cache = new Map<int,SInt64>([\n  [-1, S64_NEGONE],\n  [0, S64_ZERO],\n  [1, S64_ONE],\n])\n\nlet _UInt64_cache = new Map<int,UInt64>([\n  [0, U64_ZERO],\n  [1, U64_ONE],\n])\n\n\n// f64ToS32pair converts a signed f64 to a pair [low:i32, high:i32]\n//\nexport function f64ToS32pair(v :number) :[int,int] {\n  if (v <= -_TWO_PWR_63_DBL) {\n    return [S64_MIN._low, S64_MIN._high]\n  }\n  if (v + 1 >= _TWO_PWR_63_DBL) {\n    return [S64_MAX._low, S64_MAX._high]\n  }\n\n  if (v < 0) {\n    v = -v\n    let low = (v % _TWO_PWR_32_DBL) | 0\n    let high = (v / _TWO_PWR_32_DBL) | 0\n\n    // neg: if n.eq(S64_MIN) { return S64_MIN }\n    if (high == S64_MIN._high && low == S64_MIN._low) {\n      return [ S64_MIN._low, S64_MIN._high ]\n    }\n    // n.not().add(S64_ONE)\n    let n = (new SInt64(~low, ~high)).add(S64_ONE)\n    return [n._low, n._high]\n  }\n  return [\n    (v % _TWO_PWR_32_DBL) | 0,\n    (v / _TWO_PWR_32_DBL) | 0\n  ]\n}\n","import { Int64, UInt64, SInt64 } from './int64'\n// import { debuglog as dlog } from './util'\n\nconst u64MaxByRadix = [\n  '', '',\n  '1111111111111111111111111111111111111111111111111111111111111111',\n    // base 2\n  '11112220022122120101211020120210210211220', // base 3\n  '33333333333333333333333333333333',          // base 4\n  '2214220303114400424121122430',              // base 5\n  '3520522010102100444244423',                 // base 6\n  '45012021522523134134601',                   // base 7\n  '1777777777777777777777',                    // base 8\n  '145808576354216723756',                     // base 9\n  '18446744073709551615',                      // base 10\n  '335500516a429071284',                       // base 11\n  '839365134a2a240713',                        // base 12\n  '219505a9511a867b72',                        // base 13\n  '8681049adb03db171',                         // base 14\n  '2c1d56b648c6cd110',                         // base 15\n  'ffffffffffffffff',                          // base 16\n  '67979g60f5428010',                          // base 17\n  '2d3fgb0b9cg4bd2f',                          // base 18\n  '141c8786h1ccaagg',                          // base 19\n  'b53bjh07be4dj0f',                           // base 20\n  '5e8g4ggg7g56dif',                           // base 21\n  '2l4lf104353j8kf',                           // base 22\n  '1ddh88h2782i515',                           // base 23\n  'l12ee5fn0ji1if',                            // base 24\n  'c9c336o0mlb7ef',                            // base 25\n  '7b7n2pcniokcgf',                            // base 26\n  '4eo8hfam6fllmo',                            // base 27\n  '2nc6j26l66rhof',                            // base 28\n  '1n3rsh11f098rn',                            // base 29\n  '14l9lkmo30o40f',                            // base 30\n  'nd075ib45k86f',                             // base 31\n  'fvvvvvvvvvvvv',                             // base 32\n  'b1w8p7j5q9r6f',                             // base 33\n  '7orp63sh4dphh',                             // base 34\n  '5g24a25twkwff',                             // base 35\n  '3w5e11264sgsf',                             // base 36\n]\n\nconst _U32_CUTOFF = 0xFFFFFFFF >>> 0\n\nexport class IntParser {\n  int32val :int = 0\n  int64val :Int64 | null = null\n\n  private _ndigits = 0      // total digit count\n  private _ndigitsChunk = 0 // digit count per i32 chunk\n  private _radix = 10\n  private _signed :bool = false\n  private _neg :bool = false\n  private _s32cutoff = 0 | 0\n\n  init(radix :int, signed :bool, negative :bool) {\n    assert(signed || (!signed && !negative), 'invalid unsigned and negative')\n\n    this.int32val = 0\n    this.int64val = null\n\n    this._ndigits = 0\n    this._ndigitsChunk = 0\n    this._radix = radix\n    this._signed = signed\n    this._neg = negative\n\n    if (signed) {\n      this._s32cutoff = negative ? 0x80000000 : 0x7FFFFFFF\n      this.parseval = this.parseval_s32\n    } else {\n      this.parseval = this.parseval_u32\n    }\n  }\n\n  // parsedigit parses an ASCII digit\n  //\n  parsedigit(c :int) {\n    let n = 37  // max base + 1 since we compare with base/radix later\n    if (c >= 0x30 && c <= 0x39) { // 0..9\n      n = c - 0x30\n    } else if (c >= 0x41 && c <= 0x5A) { // A..Z\n      n = c - (0x41 - 10)\n    } else if (c >= 0x61 && c <= 0x7A) { // a..z\n      n = c - (0x61 - 10)\n    }\n    if (n <= this._radix) {\n      return this.parseval(n)\n    }\n  }\n\n  // parseval parses a digit value\n  //\n  // It is dynamically redirected to a parsing function depending on the\n  // current magnitude of the number and if its signed or negative.\n  //\n  parseval :(n :int)=>void\n\n\n  private parseval_s32(n :int) {\n    let p = this\n    let nextval = (p.int32val * p._radix) + n\n    if (nextval > this._s32cutoff) {\n      // i32 -> i64\n      p.int64val = SInt64.fromInt32(p.int32val)\n      p.int32val = n\n      p._ndigits = p._ndigitsChunk\n      p._ndigitsChunk = 1\n      p.parseval = p.parseval_s64\n      // dlog(`[intParser] s32 -> s64  starting at ${p.int64val}`)\n    } else {\n      p.int32val = nextval\n      p._ndigitsChunk++\n    }\n  }\n\n  private parseval_s64(n :int) {\n    let p = this\n    let nextval = (p.int32val * p._radix) + n\n    if (nextval > this._s32cutoff) {\n      // i64 -> big\n      let radixToPower = UInt64.fromFloat64(\n        Math.pow(p._radix, p._ndigitsChunk)\n      )\n      p.int64val = (p.int64val as SInt64).mul(radixToPower).add(\n        SInt64.fromFloat64(p.int32val)\n      )\n      p.int32val = n\n      p._ndigits += p._ndigitsChunk\n      p._ndigitsChunk = 1\n      p.parseval = p.parseval_sbig\n      // dlog(`[intParser] s64 -> sbig  starting at ${p.int64val}`)\n    } else {\n      p.int32val = nextval\n      p._ndigitsChunk++\n    }\n  }\n\n\n  private parseval_u32(n :int) {\n    let p = this\n    let nextval = (p.int32val * p._radix) + n\n    if (nextval > _U32_CUTOFF) {\n      // i32 -> i64\n      p.int64val = UInt64.fromInt32(p.int32val)\n      p.int32val = n\n      p._ndigits = p._ndigitsChunk\n      p._ndigitsChunk = 1\n      p.parseval = p.parseval_u64\n      // dlog(`[intParser] u32 -> u64  starting at ${p.int64val}`)\n    } else {\n      p.int32val = nextval\n      p._ndigitsChunk++\n    }\n  }\n\n  private parseval_u64(n :int) {\n    let p = this\n    let nextval = (p.int32val * p._radix) + n\n    if (nextval > _U32_CUTOFF) {\n      // i64 -> big\n      let radixToPower = UInt64.fromFloat64(\n        Math.pow(p._radix, p._ndigitsChunk)\n      )\n      p.int64val = (p.int64val as UInt64).mul(radixToPower).add(\n        UInt64.fromFloat64(p.int32val)\n      )\n      p.int32val = n\n      p._ndigits += p._ndigitsChunk\n      p._ndigitsChunk = 1\n      p.parseval = p.parseval_ubig\n      // dlog(`[intParser] u64 -> ubig  starting at ${p.int64val}`)\n    } else {\n      p.int32val = nextval\n      p._ndigitsChunk++\n    }\n  }\n\n  private parseval_ubig(_n :int) {\n    // not implemented\n    this._ndigitsChunk++\n  }\n\n  private parseval_sbig(_n :int) {\n    // not implemented\n    this._ndigitsChunk++\n  }\n\n  private overflow() :bool {\n    let p = this\n    p.int32val = NaN\n    p.int64val = null\n    return false\n  }\n\n  // finalize performs any final parsing required\n  //\n  finalize() :bool {\n    let p = this\n\n    if (!p.int64val) {\n      if (p._neg) {\n        p.int32val = -p.int32val\n      }\n      return true  // valid\n    }\n\n    assert(p._ndigitsChunk > 0, 'started int64val but did not read digit')\n\n    let power = UInt64.fromFloat64(Math.pow(p._radix, p._ndigitsChunk))\n\n    if (power._high >= p._radix) {\n      return p.overflow()\n    }\n\n    if (p._signed) {\n      if (p.parseval === p.parseval_sbig) {\n        if (p._ndigitsChunk > 1) {\n          // did transition into big and contains at least one digit past i64\n          return p.overflow()\n        }\n      } else if (p.int64val._high != 0 && p.int32val != 0) {\n        // special case for -0x8000000000000001 (SINT64_MIN - 1)\n        return p.overflow()\n      }\n\n      let n = p.int64val.mul(power).add(SInt64.fromInt32(p.int32val))\n\n      if (n._high < 0 && (!p._neg || n._low != 0 || n._high != -2147483648)) {\n        assert(n.lt(SInt64.ZERO)) // make sure it actually overflowed\n        // Note on (n._low != 0 || n._high != -2147483648):\n        // checks for the specific case of exactly SInt64.MIN which does\n        // cause overflow because of the sign bit.\n        return p.overflow()\n      }\n\n      p.int64val = n\n\n    } else {\n      // unsigned\n      let ndigits = p._ndigits + p._ndigitsChunk\n      let maxstr = u64MaxByRadix[p._radix]\n\n      if (\n        (p.parseval === p.parseval_ubig && p._ndigitsChunk > 1) ||\n        ndigits > maxstr.length\n      ) {\n        return p.overflow()\n      }\n\n      if (ndigits == maxstr.length && p.int64val._high == 0) {\n        let maxstr_low = maxstr.substr(0, p._ndigits)\n        let low = p.int64val._low >>> 0\n        if (maxstr_low < low.toString(p._radix)) {\n          return p.overflow()\n        }\n      }\n\n      p.int64val = p.int64val.mul(power).add(UInt64.fromInt32(p.int32val))\n\n      if (p.int64val._high == 0) {\n        // overflowed by just a bit\n        return p.overflow()\n      }\n    }\n\n    p.int32val = NaN\n\n    if (p._neg) {\n      assert(p._signed)\n      p.int64val = p.int64val.neg()\n    }\n\n    return true\n  }\n\n}\n","// export function SplitFileExt(path :string) :[string, string] {\n//   let p = path.lastIndexOf('/')\n//   p = path.lastIndexOf('.', p == -1 ? 0 : p)\n//   return p == -1 ? [path, ''] : [path.substr(0, p), path.substr(p)]\n// }\n\n// export function SplitPath(path :string) :[string, string] {\n//   const p = path.lastIndexOf('/')\n//   return p == -1 ? ['.', path] : [path.substr(0, p), path.substr(p+1)]\n// }\n\nexport function search(n :number, f :(n:number)=>bool) :int {\n  // Define f(-1) == false and f(n) == true.\n  // Invariant: f(i-1) == false, f(j) == true.\n  let i = 0, j = n\n  while (i < j) {\n    const mid = i + (((j-i)/2) >> 0) // avoid overflow and truncate to int\n    // i â‰¤ h < j\n    if (!f(mid)) {\n      i = mid + 1 // preserves f(i-1) == false\n    } else {\n      j = mid // preserves f(j) == true\n    }\n  }\n  // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n  return i\n}\n\n// bufcopy creates a new buffer containing bytes with some additional space.\n//\nfunction bufcopy(bytes :ArrayLike<byte>, addlSize :int) {\n  const size = bytes.length + addlSize\n  const b2 = new Uint8Array(size)\n  b2.set(bytes, 0)\n  // const b = Buffer.allocUnsafe(size)\n  // this.buffer.copy(b)\n  return b2\n}\n\n\n// asciibuf creates a byte array from a string of ASCII characters.\n// The string must only contain character values in the range [0-127].\n//\nexport function asciibuf(s :string) :Uint8Array {\n  return Uint8Array.from(\n    s as any as ArrayLike<number>,\n    (_: number, k: number) => s.charCodeAt(k)\n  )\n}\n\n\n// asciistr creates a string from bytes representing ASCII characters.\n// The byte array must only contain values in the range [0-127].\n//\nexport function asciistr(b :ArrayLike<byte>) :string {\n  return String.fromCharCode.apply(null, b)\n}\n\n\n// asciistrn is just like asciistr but implements efficient parsing of\n// subarrays and only works with Uint8Array\n//\nexport var asciistrn :(b :Uint8Array, start :int, end :int)=>string = (\n  typeof Buffer == 'function' ?\n  function asciistrn(b :Uint8Array, start :int, end :int) :string {\n    // make use of faster nodejs Buffer implementation\n    return (new (Buffer as any)(\n      b.buffer,\n      b.byteOffset + start,\n      end - start,\n    )).toString('ascii')\n  } :\n  function asciistrn(b :Uint8Array, start :int, end :int) :string {\n    // fallback implementation\n    b = start > 0 && end < b.length ? b.subarray(start, end) : b\n    return String.fromCharCode.apply(null, b)\n  }\n)\n\n\n// bufcmp compares two arrays of bytes\n//\nexport function bufcmp(\n  a       :ArrayLike<byte>,\n  b       :ArrayLike<byte>,\n  aStart  :int = 0,\n  aEnd    :int = a.length,\n  bStart  :int = 0,\n  bEnd    :int = b.length,\n) :int {\n  if (a === b) {\n    return 0\n  }\n  var ai = aStart, bi = bStart\n  for (; ai != aEnd && bi != bEnd; ++ai, ++bi) {\n    if (a[ai] < b[bi]) { return -1 }\n    if (b[bi] < a[ai]) { return 1 }\n  }\n  var aL = aEnd - aStart, bL = bEnd - bStart\n  return (\n    aL < bL ? -1 :\n    bL < aL ? 1 :\n    0\n  )\n}\n\n\n// asbuf returns a byte buffer for a\n// \nexport let asbuf :(a :ArrayLike<byte>) => Uint8Array\n\n\nif (typeof Buffer != 'undefined') {\n\n  asbuf = (a :ArrayLike<byte>) => {\n    if (a instanceof Buffer || a instanceof Uint8Array) {\n      return a as Uint8Array\n    }\n\n    if (\n      (a as any).buffer &&\n      (a as any).byteOffset !== undefined &&\n      (a as any).byteLength !== undefined\n    ) {\n      return Buffer.from(\n        (a as any).buffer as ArrayBuffer,\n        (a as any).byteOffset as int,\n        (a as any).byteLength as int\n      ) as Uint8Array\n    }\n\n    const buf = Buffer.allocUnsafe(a.length)\n    for (let i = 0; i < a.length; ++i) {\n      buf[i] = a[i]\n    }\n    return buf as Uint8Array\n  }\n\n  // function asnodebuf(a :ArrayLike<byte>) :Buffer {\n  //   return (a instanceof Buffer) ? a : new Buffer(asbuf(a))\n  // }\n\n  // bufcmp1 = (a, b, aStart, aEnd, bStart, bEnd) => {\n  //   if (a === b) {\n  //     return 0\n  //   }\n\n  //   // Note: although TS type decarations may say that Buffer.compare\n  //   // only accepts a Buffer, in fact it also accepts a Uint8Array.\n  //   if (a instanceof Buffer &&\n  //       (b instanceof Buffer || b instanceof Uint8Array))\n  //   {\n  //     return a.compare(b as Buffer, bStart, bEnd, aStart, aEnd)\n  //   }\n\n  //   if (b instanceof Buffer &&\n  //       (a instanceof Buffer || a instanceof Uint8Array))\n  //   {\n  //     return b.compare(a as Buffer, aStart, aEnd, bStart, bEnd)\n  //   }\n\n  //   const abuf = asnodebuf(a)\n  //   const bbuf = asbuf(b) as Buffer\n\n  //   return abuf.compare(bbuf, bStart, bEnd, aStart, aEnd)\n  // }\n}\n\n\nexport class AppendBuffer {\n  buffer :Uint8Array\n  length :int // current offset\n\n  constructor(size :int) {\n    this.length = 0\n    this.buffer = new Uint8Array(size)\n  }\n\n  reset() {\n    this.length = 0\n  }\n\n  // Make sure there's space for at least `size` additional bytes\n  reserve(addlSize :int) {\n    if (this.length + addlSize >= this.buffer.length) {\n      this._grow(addlSize)\n    }\n  }\n\n  subarray() :Uint8Array {\n    return this.buffer.subarray(0, this.length)\n  }\n\n  // slice() :Uint8Array {\n  //   return this.buffer.slice(0, this.length)\n  // }\n  // slice(start :int = 0, end? :int) :Uint8Array {\n  //   const _end = end === undefined ? this.length : Math.min(this.length, end)\n  //   if (this.buffer.length - (_end - start) < 128) {\n  //     // trade memory usage for speed by avoiding allocation & copy\n  //     return this.buffer.subarray(start, _end)\n  //   }\n  //   return this.buffer.slice(start, _end)\n  // }\n\n  append(b :int) :void {\n    if (this.length >= this.buffer.length) {\n      this._grow()\n    }\n    this.buffer[this.length++] = b\n  }\n\n  appendRange(src :Uint8Array, srcStart :int, srcEnd? :int) :void {\n    const end = (srcEnd === undefined) ? src.length : srcEnd\n    const size = end - srcStart\n    if (this.length + size >= this.buffer.length) {\n      this._grow(size)\n    }\n    this.buffer.set(src.subarray(srcStart, srcEnd), this.length)\n    this.length += size\n  }\n\n  private _grow(minAddlSize :int = 8) {\n    this.buffer = bufcopy(\n      this.buffer,\n      Math.min(minAddlSize, this.buffer.length)\n    )\n  }\n}\n\n// debug function\nexport const debuglog = DEBUG ? function(...v :any[]) {\n  let e = new Error()\n  let prefix = ''\n\n  if (e.stack) {\n    // let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)/.exec(e.stack.split(/\\n/, 3)[2])\n    let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)\\s+\\(.+\\/src\\/(.+)\\)/.exec(\n      e.stack.split(/\\n/, 3)[2]\n    )\n    if (m) {\n      const fun = m[1]\n      const origin = m[2]\n      if (origin) {\n        const filename = origin.split('.ts:', 1)[0]\n        const trmsg = String(v[0])\n        if (trmsg.indexOf('TODO:') == 0 || trmsg.indexOf('TODO ') == 0) {\n          // message start with \"TODO\"\n          prefix = 'TODO src/' + origin + ' ' + fun + '>'\n          v[0] = trmsg.substr(5).replace(/^\\s*/, '')\n        } else {\n          prefix = filename + '/' + fun + '>'\n        }\n      } else {\n        prefix = fun + '>'\n      }\n    } else {\n      prefix = 'DEBUG>'\n    }\n  }\n\n  v.splice(0, 0, prefix)\n  console.log.apply(console, v)\n} : function(..._ :any[]){}\n\n\n// is2pow returns true if n is a power-of-two number.\n// n must be a positive non-zero integer.\n//\nexport function is2pow(n :int) :bool {\n  assert(n > 0)\n  return (n & (n - 1)) == 0\n}\n","import { Pos, Position, SrcFile } from './pos'\nimport * as utf8 from './utf8'\nimport * as unicode from './unicode'\nimport { ErrorCode, ErrorReporter, ErrorHandler } from './error'\nimport { token, lookupKeyword, prec } from './token'\nimport * as path from './path'\nimport { Int64 } from './int64'\nimport { IntParser } from './intparse'\nimport {\n  AppendBuffer,\n  bufcmp,\n  asciibuf,\n  asciistr,\n  asciistrn,\n  // debuglog as dlog,\n} from './util'\n\n\nexport enum Mode {\n  None = 0,\n\n  ScanComments = 1, // do not skip comments; produce token.COMMENT\n\n  CopySource = 2,\n    // copy slices of source data for tokens with literal values instead of\n    // referencing the source buffer. This means slightly lower speed but\n    // less memory usage since when scanning is done, the source code memory\n    // can be reclaimed. If you plan to keep the source code around after\n    // scanning (common case) you should leave this disabled.\n}\n\nconst linePrefix = asciibuf('//!line ')\n\nenum istrOne { OFF, WAIT, CONT }\n\n// A Scanner holds the scanner's internal state while processing a given text.\n// It must be initialized via init before use or resue.\n//\nexport class Scanner extends ErrorReporter {\n  // immutable state (only changed by init())\n  // Note: `undefined as any as X` is a workaround for a TypeScript issue\n  // where members are otherwise not initialized at construction which causes\n  // duplicate struct definitions in v8.\n  public sfile :SrcFile = undefined as any as SrcFile // source file handle\n  public sdata :Uint8Array = undefined as any as Uint8Array // source data\n  public dir   :string = ''   // directory portion of file.name\n  public mode  :Mode = 0      // scanning mode\n\n  // scanning state\n  private ch         :int = -1 // current character (unicode; -1=EOF)\n  protected offset   :int = 0  // character offset\n  private rdOffset   :int = 0  // reading offset (position after current char)\n  private lineOffset :int = 0  // current line offset\n  private insertSemi :bool = false // insert a semicolon before next newline\n  private parenL     :int = 0  // parenthesis level, for string interpolation\n  private interpStrL :int = 0  // string interpolation level\n  private istrOne    :istrOne = istrOne.OFF // string interpolation\n  private byteval    :Uint8Array|null = null // value for some string tokens\n  private intParser  = new IntParser()\n\n  // public scanning state (read-only)\n  public pos       :Pos = 0  // token start position\n  public startoffs :int = 0  // token start offset\n  public endoffs   :int = 0  // token end offset\n  public tok       :token = token.EOF\n  public prec      :prec = prec.LOWEST\n  public hash      :int = 0 // hash value for current token (if NAME*)\n  public int32val  :int = 0 // value for some tokens (char and int lits)\n  public int64val  :Int64|null = null  // value for large int tokens\n  public floatval  :number = +0.0  // IEEE 754-2008 float\n\n  // sparse buffer state (not reset by s.init)\n  private appendbuf  :AppendBuffer|null = null // for string literals\n\n  // public state - ok to modify\n  public errorCount :int = 0 // number of errors encountered\n\n  constructor() {\n    super('E_SYNTAX')\n  }\n\n  // Init prepares the scanner s to tokenize the text sdata by setting the\n  // scanner at the beginning of sdata. The scanner uses the file set file\n  // for position information and it adds line information for each line.\n  // It is ok to re-use the same file when re-scanning the same file as\n  // line information which is already present is ignored. Init causes a\n  // panic if the file size does not match the sdata size.\n  //\n  // Calls to Scan will invoke the error handler errh if they encounter a\n  // syntax error and errh is not nil. Also, for each error encountered,\n  // the Scanner field ErrorCount is incremented by one. The mode parameter\n  // determines how comments are handled.\n  //\n  // Note that Init may call errh if there is an error in the first character\n  // of the file.\n  //\n  init(\n    sfile :SrcFile,\n    sdata :Uint8Array,\n    errh? :ErrorHandler|null,\n    mode  :Mode =Mode.None,\n  ) {\n    const s = this\n    // Explicitly initialize all fields since a scanner may be reused\n    if (sfile.size != sdata.length) {\n      panic(\n        `file size (${sfile.size}) `+\n        `does not match source size (${sdata.length})`\n      )\n    }\n    s.sfile = sfile\n    s.dir = path.dir(sfile.name)\n    s.sdata = sdata\n    s.errh = errh || null\n    s.mode = mode\n  \n    s.ch = 0x20 /*' '*/\n    s.tok = token.EOF\n    s.offset = 0\n    s.rdOffset = 0\n    s.lineOffset = 0\n    s.insertSemi = false\n    s.errorCount = 0\n    s.parenL = 0\n    s.interpStrL = 0\n    s.byteval = null\n  \n    s.readchar()\n  }\n\n  // setOffset sets the read offset.\n  // it's only safe to call this outside of next() and readchar()\n  //\n  setOffset(offs :int) {\n    const s = this\n    s.offset = s.rdOffset = offs\n  }\n\n  private _r :utf8.DecodeResult = {c:0,w:0}\n\n  // Read the next Unicode char into s.ch.\n  // s.ch < 0 means end-of-file.\n  private readchar() {\n    const s = this\n\n    if (s.rdOffset < s.sdata.length) {\n      s.offset = s.rdOffset\n      \n      if (s.ch == 0xA /*\\n*/ ) {\n        s.lineOffset = s.offset\n        s.sfile.addLine(s.offset)\n      }\n\n      s._r.w = 1\n      s._r.c = s.sdata[s.rdOffset]\n\n      if (s._r.c >= 0x80) {\n        // uncommon case: non-ASCII character\n        if (!utf8.decode(s.sdata, s.rdOffset, s._r)) {\n          s.errorAtOffs('invalid UTF-8 encoding', s.offset)\n        } else if (s._r.c == 0) {\n          s.errorAtOffs('illegal NUL byte in input', s.offset)\n        }\n      }\n\n      s.rdOffset += s._r.w\n      s.ch = s._r.c\n    } else {\n      s.offset = s.sdata.length\n      if (s.ch == 0xA /*\\n*/) {\n        s.lineOffset = s.offset\n        s.sfile.addLine(s.offset)\n      }\n      s.ch = -1 // eof\n    }\n  }\n\n  // undobyte \"puts back\" the last-read byte.\n  // note that this does NOT fully update scanner state -- after calling this\n  // function, you should either call readchar() to update s.ch and s.offset\n  // or call next().\n  //\n  private undobyte() {\n    const s = this\n    assert(s.ch < 0x80)\n    s.rdOffset -= 1\n    s.offset -= 1\n    s.endoffs = s.offset\n  }\n\n  // gotchar reads the next character and returns true if s.ch == ch\n  private gotchar(ch :int) :bool {\n    const s = this\n    if (s.ch == ch) {\n      s.readchar()\n      return true\n    }\n    return false\n  }\n\n  currentPosition() :Position {\n    const s = this\n    return s.sfile.position(s.sfile.pos(s.offset))\n  }\n\n  // byteValue returns a byte buffer representing the literal value of the\n  // current token.\n  // Note that this method returns a byte buffer that is potentially referenced\n  // internally and which value might change next time s.scan is called. If you\n  // plan to keep referencing the byte buffer, use s.takeByteValue instead.\n  //\n  byteValue() :Uint8Array {\n    const s = this\n    const end = s.endoffs == -1 ? s.offset : s.endoffs\n    return s.byteval || s.sdata.subarray(s.startoffs, end)\n  }\n\n  // takeByteValue returns a new byte buffer that is not referenced by\n  // the scanner. The buffer is still immutable.\n  //\n  takeByteValue() :Uint8Array {\n    const s = this\n    const b = s.byteValue()\n    s.byteval = null\n    return (this.mode & Mode.CopySource) ? b.slice() : b\n  }\n\n  // Increment errorCount and call any error handler\n  //\n  error(msg :string, pos :Pos = this.pos, code? :ErrorCode) {\n    const s = this\n    s.errorAt(msg, s.sfile.position(pos), code)\n  }\n\n  errorAtOffs(msg :string, offs :int, code? :ErrorCode) {\n    const s = this\n    s.errorAt(msg, s.sfile.position(s.sfile.pos(offs)), code)\n  }\n\n  // Scan the next token\n  //\n  next() {\n  while (true) {\n    const s = this\n\n    if (s.istrOne == istrOne.OFF) {\n      // skip whitespace\n      while (\n        s.ch == 0x20 ||\n        s.ch == 0x9 ||\n        (s.ch == 0xA && !s.insertSemi) ||\n        s.ch == 0xD\n      ) {\n        s.readchar()\n      }\n    }\n\n    // current token start\n    s.pos = s.sfile.pos(s.offset)\n    s.startoffs = s.offset\n    s.endoffs = -1\n    s.byteval = null\n\n    if (s.istrOne == istrOne.CONT) {\n      // continue interpolated string\n      s.istrOne = istrOne.OFF\n      s.startoffs-- // b/c scanString increments it, assuming it's skipping `\"`\n      s.tok = s.scanString()\n      s.insertSemi = s.tok != token.STRING_PIECE\n      return\n    } else if (s.istrOne == istrOne.WAIT) {\n      // we are about to scan a single token following $ in a string template\n      s.istrOne = istrOne.CONT\n    }\n\n    // make progress\n    let ch = s.ch\n    s.readchar()\n\n    let insertSemi = false\n\n    switch (ch) {\n\n      case -1: {\n        s.tok = s.insertSemi ? token.SEMICOLON : token.EOF\n        break\n      }\n\n      case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:\n      case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:\n        // 0..9\n        s.scanNumber(ch, /*modch=*/0)\n        insertSemi = true\n        break\n\n      case 0xA: { // \\n\n        // we only reach here if s.insertSemi was set in the first place\n        // and exited early from skipping whitespace.\n        // newline consumed\n        s.tok = token.SEMICOLON\n        break\n      }\n\n      case 0x22: // \"\n        s.tok = s.scanString()\n        insertSemi = s.tok != token.STRING_PIECE\n        break\n\n      case 0x27: // '\n        s.scanChar()\n        insertSemi = true\n        break\n\n      case 0x3a: // :\n        if (s.gotchar(0x3D)) {\n          s.tok = token.SET_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.COLON\n        }\n        break\n\n      case 0x2e: { // .\n        if (\n          isDigit(s.ch) &&\n          s.tok != token.NAME &&\n          s.tok != token.RPAREN &&\n          s.tok != token.RBRACKET\n        ) {\n          // Note: We check for NAME so that:\n          //   x.1 => (selector (name x) (int 1))\n          //   ).1 => (selector (name x) (int 1))\n          //   ].1 => (selector (name x) (int 1))\n          //   .1  => (float 0.1)\n          s.scanFloatNumber(/*seenDecimal*/true, /*modc*/0)\n          insertSemi = true\n        } else {\n          if (s.gotchar(0x2e)) { // ..\n            if (s.gotchar(0x2e)) { // ...\n              s.tok = token.ELLIPSIS\n            } else {\n              s.tok = token.PERIODS\n            }\n          } else {\n            s.tok = token.DOT\n          }\n        }\n        break\n      }\n\n      case 0x40: { // @\n        s.startoffs++ // skip @\n        let c = s.ch\n        if (c < utf8.UniSelf && (asciiFeats[c] & langIdentStart)) {\n          s.readchar()\n          s.scanIdentifier(c)\n        } else if (c >= utf8.UniSelf && isUniIdentStart(c)) {\n          s.readchar()\n          s.scanIdentifierU(c, this.startoffs)\n        }\n        s.tok = token.NAMEAT\n        insertSemi = true\n        break\n      }\n\n      case 0x2c: // ,\n        s.tok = token.COMMA\n        break\n      case 0x3b: // ;\n        s.tok = token.SEMICOLON\n        break\n\n      case 0x28: // (\n        if (s.interpStrL) {\n          s.parenL++\n        }\n        s.tok = token.LPAREN\n        break\n      case 0x29: // )\n        s.tok = token.RPAREN\n        insertSemi = true\n        if (s.interpStrL) {\n          if (s.parenL == 0) {\n            // continue interpolated string\n            s.interpStrL--\n            s.tok = s.scanString()\n            insertSemi = s.tok != token.STRING_PIECE\n          } else {\n            s.parenL--\n          }\n        }\n        break\n\n      case 0x5b: // [\n        s.tok = token.LBRACKET\n        break\n      case 0x5d: // ]\n        s.tok = token.RBRACKET\n        insertSemi = true\n        break\n\n      case 0x7b: // {\n        s.tok = token.LBRACE\n        break\n      case 0x7d: // }\n        s.tok = token.RBRACE\n        insertSemi = true\n        break\n\n      case 0x2B: { // +\n        s.prec = prec.LOWEST\n        if (s.gotchar(0x3D)) { // +=\n          s.tok = token.ADD_ASSIGN\n        } else if (s.gotchar(ch)) { // ++\n          s.tok = token.INC\n          insertSemi = true\n        } else if (s.ch >= 0x30 && s.ch <= 0x39) { // 0..9\n          ch = s.ch\n          s.readchar()\n          s.scanNumber(ch, /*modch=*/0x2B)\n          insertSemi = true\n        } else if (s.gotchar(0x2e)) { // .\n          s.scanFloatNumber(/*seenDecimal*/true, /*modc=*/0x2B)\n          insertSemi = true\n        } else {\n          s.tok = token.ADD\n          s.prec = prec.ADD\n        }\n        break\n      }\n\n      case 0x2D: { // -\n        s.prec = prec.LOWEST\n        if (s.gotchar(0x3e)) { // ->\n          s.tok = token.ARROWR\n        } else if (s.gotchar(0x3D)) { // -=\n          s.tok = token.SUB_ASSIGN\n        } else if (s.gotchar(ch)) { // --\n          s.tok = token.DEC\n          insertSemi = true\n        } else if (s.ch >= 0x30 && s.ch <= 0x39) { // 0..9\n          ch = s.ch\n          s.readchar()\n          s.scanNumber(ch, /*modc=*/0x2D)\n          insertSemi = true\n        } else if (s.gotchar(0x2e)) { // .\n          s.scanFloatNumber(/*seenDecimal*/true, /*modc=*/0x2D)\n          insertSemi = true\n        } else {\n          s.tok = token.SUB\n          s.prec = prec.ADD\n        }\n        break\n      }\n\n      case 0x2a: // *\n        if (s.gotchar(0x3D)) { // *=\n          s.tok = token.MUL_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.MUL\n          s.prec = prec.MUL\n        }\n        break\n\n      case 0x2f: { // /\n        if (s.ch == 0x2f) { // //\n          s.scanLineComment()\n          if (!(s.mode & Mode.ScanComments)) {\n            continue\n          }\n          insertSemi = s.insertSemi // persist s.insertSemi\n        } else if (s.ch == 0x2a) { // /*\n          const CRcount = s.scanGeneralComment()\n          if (s.mode & Mode.ScanComments) {\n            s.tok = token.COMMENT\n            if (CRcount) {\n              // strip CR characters from comment\n              const v = s.sdata.subarray(\n                s.startoffs,\n                s.endoffs == -1 ? s.offset : s.endoffs\n              )\n              s.byteval = stripByte(v, 0xD, CRcount) // copy; no mutation\n            }\n          } else {\n            continue\n          }\n          insertSemi = s.insertSemi // persist s.insertSemi\n        } else {\n          if (s.gotchar(0x3D)) { // /=\n            s.tok = token.QUO_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.QUO\n            s.prec = prec.MUL\n          }\n        }\n        break\n      }\n\n      case 0x25: // %\n        if (s.gotchar(0x3D)) { // %=\n          s.tok = token.REM_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.REM\n          s.prec = prec.MUL\n        }\n        break\n\n      case 0x5e: // ^\n        if (s.gotchar(0x3D)) { // ^=\n          s.tok = token.XOR_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.XOR\n          s.prec = prec.ADD\n        }\n        break\n\n      case 0x3c: { // <\n        if (s.gotchar(0x2D)) { // <-\n          s.tok = token.ARROWL\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(0x3D)) { // <=\n          s.tok = token.LEQ\n          s.prec = prec.CMP\n        } else if (s.gotchar(ch)) { // <<\n          if (s.gotchar(0x3D)) { // <<=\n            s.tok = token.SHL_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.SHL\n            s.prec = prec.MUL\n          }\n        } else {\n          s.tok = token.LSS\n          s.prec = prec.CMP\n        }\n        break\n      }\n\n      case 0x3E: // >\n        if (s.gotchar(0x3D)) { // >=\n          s.tok = token.GEQ\n          s.prec = prec.CMP\n        } else if (s.gotchar(ch)) { // >>\n          if (s.gotchar(0x3D)) { // >>=\n            s.tok = token.SHR_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.SHR\n            s.prec = prec.MUL\n          }\n        } else {\n          s.tok = token.GTR\n          s.prec = prec.CMP\n        }\n        break\n      \n      case 0x3D: // =\n        if (s.gotchar(0x3D)) { // ==\n          s.tok = token.EQL\n          s.prec = prec.CMP\n        } else {\n          s.tok = token.ASSIGN\n          s.prec = prec.LOWEST\n        }\n        break\n\n      case 0x21: // !\n        if (s.gotchar(0x3D)) { // !=\n          s.tok = token.NEQ\n          s.prec = prec.CMP\n        } else {\n          s.tok = token.NOT\n          s.prec = prec.LOWEST\n        }\n        break\n\n      case 0x26: { // &\n        if (s.gotchar(0x5E)) { // &^\n          if (s.gotchar(0x3D)) { // &^=\n            s.tok = token.AND_NOT_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.AND_NOT\n            s.prec = prec.MUL\n          }\n        } else if (s.gotchar(0x3D)) { // &=\n          s.tok = token.AND_ASSIGN\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(ch)) { // &&\n          s.tok = token.ANDAND\n          s.prec = prec.ANDAND\n        } else {\n          s.tok = token.AND\n          s.prec = prec.MUL\n        }\n        break\n      }\n\n      case 0x7c: // |\n        if (s.gotchar(0x3D)) { // |=\n          s.tok = token.OR_ASSIGN\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(ch)) { // ||\n          s.tok = token.OROR\n          s.prec = prec.OROR\n        } else {\n          s.tok = token.OR\n          s.prec = prec.ADD\n        }\n        break\n\n      default: {\n        if (\n          (ch < utf8.UniSelf && (asciiFeats[ch] & langIdentStart)) ||\n          (ch >= utf8.UniSelf && isUniIdentStart(ch))\n        ) {\n          if (ch < utf8.UniSelf) {\n            s.scanIdentifier(ch)\n          } else {\n            s.scanIdentifierU(ch, this.startoffs)\n          }\n\n          if (s.offset - s.startoffs > 1) {\n            // shortest keyword is 2\n            switch (s.tok = lookupKeyword(s.byteValue())) {\n              case token.NAME:\n              case token.BREAK:\n              case token.CONTINUE:\n              case token.FALLTHROUGH:\n              case token.RETURN:\n                insertSemi = true\n                break\n            }\n          } else {\n            s.tok = token.NAME\n            insertSemi = true\n          }\n        } else {\n          s.error(`unexpected character ${unicode.repr(ch)} in input`)\n          s.tok = token.ILLEGAL\n        }\n        break\n      }\n\n    } // switch (ch)\n\n    if (s.endoffs == -1) {\n      s.endoffs = s.offset\n    }\n\n    s.insertSemi = insertSemi\n\n    // dlog(\n    //   `-> ${tokstr(s.tok)} \"${utf8.decodeToString(s.byteValue())}\"`)\n    return\n\n    } // while(true)\n  }\n\n\n  scanIdentifierU(c :int, hashOffs :int, hash :int = 0x811c9dc5) {\n    // Scan identifier with non-ASCII characters.\n    // c is already verified to be a valid indentifier character.\n    // Hash is calculated as a second pass at the end.\n    const s = this\n    const ZeroWidthJoiner = 0x200D\n    let lastCp = c\n    c = s.ch\n\n    while (\n      isUniIdentCont(c) ||\n      unicode.isEmojiModifier(c) ||\n      unicode.isEmojiModifierBase(c) ||\n      c == ZeroWidthJoiner\n    ) {\n      if (lastCp == 0x2D && c == 0x2D) { // --\n        s.undobyte() // \"put back\" the \"-\" byte\n        break\n      }\n      lastCp = c\n      s.readchar()\n      c = s.ch\n    }\n\n    if (lastCp == ZeroWidthJoiner) {\n      s.error(`illegal zero width-joiner character at end of identifer`)\n      s.tok = token.ILLEGAL\n      return\n    }\n\n    // computing rest of hash\n    for (let i = hashOffs; i < s.offset; ++i) {\n      hash = (hash ^ s.sdata[i]) * 0x1000193 // fnv1a\n    }\n    s.hash = hash >>> 0\n  }\n\n  scanIdentifier(c :int) {\n    // enters past first char; c = 1st char, s.ch = 2nd char\n    // c is already verified to be a valid indentifier character.\n    // The hash function used here must exactly match what's in bytestr.\n    const s = this\n    let hash = (0x811c9dc5 ^ c) * 0x1000193 // fnv1a\n\n    c = s.ch\n    while (\n      isLetter(c) ||\n      isDigit(c) ||\n      c == 0x2D || // -\n      c == 0x5F || // _\n      c == 0x24    // $\n    ) {\n      s.readchar()\n      if (c == 0x2D && s.ch == 0x2D) { // --\n        s.undobyte() // \"put back\" the \"-\" byte\n        break\n      }\n      hash = (hash ^ c) * 0x1000193 // fnv1a\n      c = s.ch\n    }\n\n    if (c >= utf8.UniSelf && isUniIdentCont(c)) {\n      return s.scanIdentifierU(c, s.offset, hash)\n    }\n\n    s.hash = hash >>> 0\n  }\n\n  scanChar() {\n    const s = this\n    let cp = -1\n    s.tok = token.CHAR\n    s.int32val = NaN\n\n    switch (s.ch) {\n    \n    case -1: // EOF\n      s.error(\"unterminated character literal\")\n      s.tok = token.ILLEGAL\n      return\n\n    case 0x27: // '\n      s.error(\"empty character literal or unescaped ' in character literal\")\n      s.readchar()\n      s.tok = token.ILLEGAL\n      return\n\n    case 0x5c: // \\\n      s.readchar()\n      cp = s.scanEscape(0x27) // '\n      // note: cp is -1 for illegal escape sequences\n      break\n\n    default:\n      cp = s.ch\n      if (cp < 0x20) {\n        s.error(\"invalid character literal\")\n        s.tok = token.ILLEGAL\n        cp = -1\n      }\n      s.readchar()\n      break\n    }\n\n    if (s.ch == 0x27) { // '\n      s.readchar()\n      if (cp == -1) {\n        s.tok = token.ILLEGAL\n      } else {\n        s.int32val = cp\n      }\n    } else {\n      // failed -- read until EOF or '\n      s.tok = token.ILLEGAL\n      while (true) {\n        if (s.ch == -1) {\n          break\n        }\n        if (s.ch == 0x27) { // '\n          s.readchar() // consume '\n          break\n        }\n        s.readchar()\n      }\n      s.error(\"invalid character literal\")\n    }\n  }\n\n  resetAppendBuf() :AppendBuffer {\n    const s = this\n    if (s.appendbuf) {\n      s.appendbuf.reset()\n    } else {\n      // we need to buffer the value since it's not a 1:1 literal\n      s.appendbuf = new AppendBuffer(64)\n    }\n    return s.appendbuf\n  }\n\n  scanString() :token {\n    // opening char already consumed\n    const s = this\n    let buf :AppendBuffer|null = null\n    s.startoffs++ // skip initial \"\n    let chunkStart = s.startoffs\n    let tok = token.STRING\n\n    loop1:\n    while (true) {\n      switch (s.ch) {\n        case -1:\n          s.error(\"string literal not terminated\")\n          if (buf) {\n            buf = null\n          }\n          break loop1\n\n        case 0x22: // \"\n          if (buf) {\n            buf.appendRange(s.sdata, chunkStart, s.offset)\n          }\n          s.readchar()\n          break loop1\n\n        case 0x5c: { // \\\n          // we need to buffer the value since it's not a 1:1 literal\n          if (!buf) {\n            buf = s.resetAppendBuf()\n          }\n\n          if (chunkStart != s.offset) {\n            buf.appendRange(s.sdata, chunkStart, s.offset)\n          }\n\n          s.readchar()\n          const ch = s.ch as int // e.g. \"u\", \"x\", etc\n          const n = s.scanEscape(0x22) // \"\n\n          // we continue even if there was an error\n          if (n >= 0) {\n            if (n >= utf8.UniSelf && (ch == 0x75 || ch == 0x55)) { // u | U\n              // Write unicode code point as UTF8 to value buffer\n              if (0xD800 <= n && n <= 0xE000) {\n                s.error(\"illegal: surrogate half in string literal\")\n              } else if (n > unicode.MaxRune) {\n                s.error(\"escape sequence is invalid Unicode code point\")\n              }\n              buf.reserve(utf8.UTFMax)\n              buf.length += utf8.encode(buf.buffer, buf.length, n)\n            } else {\n              buf.append(n)\n            }\n          }\n\n          chunkStart = s.offset\n          break\n        }\n\n        case 0x24: { // $\n          s.readchar()\n          // start interpolated string\n\n          if (buf) {\n            s.byteval = buf.subarray()\n          }\n\n          if (s.gotchar(0x28)) { // (\n            // don't close until we see a balanced closing ')'\n            s.interpStrL++\n            s.endoffs = s.offset - 2 // exclude `$(`\n          } else if (s.ch as int == 0x22) { // \"\n            // \"foo $\"bar\"\" is invalid -- hard to read, hard to parse.\n            // (\"foo $(\"bar\")\" _is_ valid however.)\n            s.error(\n              \"invalid \\\" in string template â€” string literals inside string \" +\n              \"templates need to be enclosed in parenthesis\"\n            )\n            break // consume\n          } else {\n            // expect a single token to follow\n            s.endoffs = s.offset - 1 // exclude `$`\n            s.istrOne = istrOne.WAIT\n          }\n          return token.STRING_PIECE\n        }\n\n        case 0xA: // \\n\n          tok = token.STRING_MULTI\n          s.readchar()\n          break\n\n        default:\n          s.readchar()\n      }\n    }\n\n    if (buf) {\n      s.byteval = buf.subarray()\n    } else {\n      s.endoffs = s.offset - 1\n    }\n\n    return tok\n  }\n\n  // scanEscape parses an escape sequence where `quote` is the accepted\n  // escaped character. In case of a syntax error, it stops at the offending\n  // character (without consuming it) and returns -1.\n  // Otherwise it returns the unicode codepoint for \\u and \\U, and returns a\n  // byte value for all other escape sequences.\n  //\n  scanEscape(quote :int) :int {\n    const s = this\n\n    let n :int = 0\n    let base :int = 0\n    let isuc = false\n\n    switch (s.ch) {\n      case quote: s.readchar(); return quote\n      case 0x30:  s.readchar(); return 0    // 0 - null\n      case 0x61:  s.readchar(); return 0x7  // a - alert or bell\n      case 0x62:  s.readchar(); return 0x8  // b - backspace\n      case 0x66:  s.readchar(); return 0xC  // f - form feed\n      case 0x6e:  s.readchar(); return 0xA  // n - line feed or newline\n      case 0x72:  s.readchar(); return 0xD  // r - carriage return\n      case 0x74:  s.readchar(); return 0x9  // t - horizontal tab\n      case 0x76:  s.readchar(); return 0xb  // v - vertical tab\n      case 0x5c:  s.readchar(); return 0x5c // \\\n      case 0x24:  s.readchar(); return 0x24 // $\n      case 0x78:  s.readchar(); n = 2; base = 16; break // x\n      case 0x75:  s.readchar(); n = 4; base = 16; isuc = true; break // u\n      case 0x55:  s.readchar(); n = 8; base = 16; isuc = true; break // U\n      default: {\n        let msg = \"unknown escape sequence\"\n        if (s.ch < 0) {\n          msg = \"escape sequence not terminated\"\n        }\n        s.error(msg)\n        return -1\n      }\n    }\n\n    let cp :int = 0\n    while (n > 0) {\n      let d = digitVal(s.ch) // returns a large value for non-digit chars\n      if (d >= base) {\n        let msg = (\n          (s.ch == quote) ? \"escape sequence incomplete\" :\n          (s.ch < 0) ? \"escape sequence not terminated\" :\n            `illegal character ${unicode.repr(s.ch)} in escape sequence`\n        )\n        s.errorAtOffs(msg, s.offset)\n        return -1\n      }\n      cp = cp * base + d\n      s.readchar()\n      n--\n    }\n\n    // validate unicode codepoints\n    if (isuc && !unicode.isValid(cp)) {\n      s.errorAtOffs(\n        \"escape sequence is invalid Unicode code point\",\n        s.offset\n      )\n      return -1\n    }\n\n    return cp\n  }\n\n  scanNumber(c :int, modc :int) {\n    let s = this\n\n    if (c == 0x30) { // 0\n      switch (s.ch) {\n\n        case 0x78: case 0x58: // x, X\n          return s.scanHexInt(modc)\n\n        case 0x6F: case 0x4F: // o, O\n          s.tok = token.INT_OCT\n          return s.scanRadixInt8(8, modc)\n\n        case 0x62: case 0x42: // b, B\n          s.tok = token.INT_BIN\n          return s.scanRadixInt8(2, modc)\n\n        case 0x2e: case 0x65: case 0x45:  // . e E\n          return s.scanFloatNumber(/*seenDecimal*/false, modc)\n\n        // case 0x2f:  // /\n        //   // this is invalid, but we will still parse any number after \"/\"\n        //   // scanRatioNumber returns true if it actually parsed a number.\n        //   if (s.scanRatioNumber()) {\n        //     // i.e. 0/N\n        //     s.error(\"invalid zero ratio\")\n        //     return\n        //   }\n        //   break\n      }\n    }\n\n    // if we get here, the number is in base 10 and is either an int, float\n    // or ratio.\n\n    s.intParser.init(10, /*signed*/modc > 0, /*negative*/modc == 0x2D)\n    s.intParser.parseval(c - 0x30) // entry char\n\n    while (s.ch >= 0x30 && s.ch <= 0x39) {  // 0..9\n      s.intParser.parseval(s.ch - 0x30)\n      s.readchar()\n    }\n    s.tok = token.INT\n\n    switch (s.ch) {\n    case 0x2e: case 0x65: case 0x45:  // . e E\n      // scanning a floating-point number\n      return s.scanFloatNumber(/*seenDecimal*/false, modc)\n    }\n\n    // scanned an integer\n    let valid = s.intParser.finalize()\n    s.int32val = s.intParser.int32val\n    s.int64val = s.intParser.int64val\n    if (!valid) {\n      s.error(\"integer constant too large\")\n    }\n\n    // if (s.ch == 0x2f) {\n    //   return s.scanRatioNumber()\n    // }\n  }\n\n  scanHexInt(modc :int) {\n    const s = this\n    s.tok = token.INT_HEX\n    s.readchar()\n    s.intParser.init(16, /*signed*/modc > 0, /*negative*/modc == 0x2D)\n    let n = 0\n    while ((n = hexDigit(s.ch)) != -1) {\n      s.intParser.parseval(n)\n      s.readchar()\n    }\n    if (s.offset - s.startoffs <= 2 || unicode.isLetter(s.ch)) {\n      // only scanned \"0x\" or \"0X\" OR e.g. 0xfg\n      while (unicode.isLetter(s.ch) || unicode.isDigit(s.ch)) {\n        s.readchar() // consume invalid letters & digits\n      }\n      s.error(\"invalid hex number\")\n    }\n    let valid = s.intParser.finalize()\n    s.int32val = s.intParser.int32val\n    s.int64val = s.intParser.int64val\n    if (!valid) {\n      s.error(\"integer constant too large\")\n    }\n  }\n\n  scanRadixInt8(radix :int, modc :int) {\n    const s = this\n    s.readchar()\n    let isInvalid = false\n\n    s.intParser.init(radix, /*signed*/modc > 0, /*negative*/modc == 0x2D)\n\n    while (unicode.isDigit(s.ch)) {\n      if (s.ch - 0x30 >= radix) {\n        // e.g. 0o678\n        isInvalid = true\n      } else {\n        s.intParser.parseval(s.ch - 0x30)\n      }\n      s.readchar()\n    }\n\n    if (isInvalid || s.offset - s.startoffs <= 2 || !s.intParser.finalize()) {\n      // isInvalid OR only scanned \"0x\"\n      s.error(`invalid ${radix == 8 ? \"octal\" : \"binary\"} number`)\n      s.int32val = NaN\n      s.int64val = null\n    } else {\n      s.int32val = s.intParser.int32val\n      s.int64val = s.intParser.int64val\n    }\n  }\n\n  // scanRatioNumber() :bool {\n  //   // ratio_lit = decimals \"/\" decimals\n  //   const s = this\n  //   const startoffs = s.offset\n  //   s.readchar() // consume /\n  //   while (unicode.isDigit(s.ch)) {\n  //     s.readchar()\n  //   }\n  //   if (startoffs+1 == s.offset) {\n  //     // e.g. 43/* 43/= etc -- restore state\n  //     s.ch = 0x2f // /\n  //     s.offset = startoffs\n  //     s.rdOffset = s.offset + 1\n  //     return false\n  //   }\n  //   if (s.ch == 0x2e) { // .\n  //     s.error(\"invalid ratio\")\n  //   }\n  //   s.tok = token.RATIO\n  //   return true\n  // }\n\n  scanFloatNumber(seenDecimal :bool, _modc :int) {\n    // float_lit = decimals \".\" [ decimals ] [ exponent ] |\n    //             decimals exponent |\n    //             \".\" decimals [ exponent ] .\n    // decimals  = decimal_digit { decimal_digit } .\n    // exponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals .\n    const s = this\n    s.tok = token.FLOAT\n\n    // Note: We are ignoring modc since we use parseFloat to parse the entire\n    // range of source text.\n\n    if (seenDecimal || s.ch == 0x2e) { // .\n      s.readchar()\n      while (unicode.isDigit(s.ch)) {\n        s.readchar()\n      }\n    }\n\n    if (s.ch == 0x65 || s.ch == 0x45) { // e E\n      s.readchar()\n      if ((s.ch as int) == 0x2D || (s.ch as int) == 0x2B) { // - +\n        s.readchar()\n      }\n      let valid = false\n      if (unicode.isDigit(s.ch)) {\n        valid = true\n        s.readchar()\n        while (unicode.isDigit(s.ch)) {\n          s.readchar()\n        }\n      }\n      if (!valid) {\n        s.error(\"invalid floating-point exponent\")\n        s.floatval = NaN\n        return\n      }\n    }\n\n    let str :string\n    if (s.byteval) {\n      str = asciistr(s.byteval)\n    } else {\n      str = asciistrn(s.sdata, s.startoffs, s.offset)\n    }\n\n    s.floatval = parseFloat(str)\n\n    assert(!isNaN(s.floatval), 'we failed to catch invalid float lit')\n  }\n\n  scanLineComment() {\n    const s = this\n    // initial '/' already consumed; s.ch == '/'\n    do { s.readchar() } while (s.ch != 0xA && s.ch >= 0)\n\n    if (s.sdata[s.offset-1] == 0xD) { // \\r\n      // don't include \\r in comment\n      s.endoffs = s.offset - 1\n    }\n\n    if (s.startoffs == s.lineOffset && s.sdata[s.startoffs + 2] == 0x21) { // !\n      // comment pragma, e.g. //!foo\n      s.interpretCommentPragma()\n    }\n\n    s.startoffs += 2 // skip //\n    s.tok = token.COMMENT\n  }\n\n  scanGeneralComment() :int /* CR count */ {\n    // initial '/' already consumed; s.ch == '*'\n    const s = this\n    let CR_count = 0\n\n    while (true) {\n      s.readchar()\n      switch (s.ch) {\n        case -1: // EOF\n          s.error(\"comment not terminated\")\n          return CR_count\n        case 0x2f: // /\n          if (s.sdata[s.offset-1] == 0x2a) { // *\n            s.readchar()\n            s.startoffs += 2\n            s.endoffs = s.offset - 2\n            return CR_count\n          }\n          break\n        case 0xD: // \\r\n          ++CR_count\n          break\n        default:\n          break\n      }\n    }\n  }\n\n  findCommentLineEnd() :bool {\n    // initial '/' already consumed; s.ch == '*'\n    const s = this\n    \n    // save state\n    const enterOffset = s.offset\n\n    while (true) {\n      const ch = s.ch\n      s.readchar()\n      switch (ch) {\n        case -1: // EOF\n        case 0xA: // \\n\n          return true\n        case 0x2a: // *\n          if (s.ch == 0x2f) { // /\n            // restore state\n            s.ch = 0x2a\n            s.offset = enterOffset\n            s.rdOffset = s.offset + 1\n            return false\n          }\n          break\n        default:\n          break\n      }\n    }\n  }\n  \n  interpretCommentPragma() {\n    const s = this\n    const offs = s.startoffs\n    if ( s.offset - offs > linePrefix.length &&\n         bufcmp(s.sdata, linePrefix, offs, offs + linePrefix.length) == 0\n    ) {\n      // get filename and line number, if any\n      // e.g. \"//!line file name:line\"\n      let text = utf8.decodeToString(\n        s.sdata.subarray(offs + linePrefix.length, s.offset)\n      )\n      /// --- here--- the above doesnt work on uintarray.\n      // we need to decode sdata to a js string\n      let i = text.lastIndexOf(':')\n      if (i > 0) {\n        let line = parseInt(text.substr(i+1))\n        if (!isNaN(line) && line > 0) {\n          // valid //!line filename:line comment\n          let filename = text.substr(0, i).trim()\n          if (filename) {\n            filename = path.clean(filename)\n            if (!path.isAbs(filename)) {\n              // make filename relative to current directory\n              filename = path.join(s.dir, filename)\n            }\n          }\n          // update scanner position\n          s.sfile.addLineInfo(s.offset + 1, filename, line)\n            // +1 since comment applies to next line\n        }\n      }\n    }\n  }\n\n  findLineEnd() :bool {\n    // initial '/' already consumed; enters with s.ch == '*'\n    const s = this\n  \n    // read ahead until a newline, EOF, or non-comment token is found\n    while (s.ch == 0x2f || s.ch == 0x2a) { // / *\n      if (s.ch == 0x2f) { // /\n        //-style comment always contains a newline\n        return true\n      }\n\n      /*-style comment: look for newline */\n      s.readchar()\n      while (s.ch >= 0) {\n        const ch = s.ch as int\n        if (ch == 0xA) { // \\n\n          return true\n        }\n        s.readchar()\n        if (ch == 0x2a && s.ch as int == 0x2f) { // */\n          s.readchar()\n          break\n        }\n      }\n\n      // skip whitespace\n      while (\n        s.ch as int == 0x20 || // ' '\n        s.ch as int == 0x9 || // \\t\n        (s.ch as int == 0xA && !s.insertSemi) || // \\n\n        s.ch as int == 0xD) // \\r\n      {\n        s.readchar()\n      }\n\n      if (s.ch < 0 || s.ch as int == 0xA) { // \\n\n        return true\n      }\n\n      if (s.ch as int != 0x2f) { // /\n        // non-comment token\n        return false\n      }\n\n      s.readchar() // consume '/'\n    }\n  \n    return false\n  }\n\n}\n\n\nfunction digitVal(ch :int) :int {\n  return (\n    0x30 <= ch && ch <= 0x39 ? ch - 0x30 :      // 0..9\n    0x61 <= ch && ch <= 0x66 ? ch - 0x61 + 10 : // a..f\n    0x41 <= ch && ch <= 0x46 ? ch - 0x41 + 10 : // A..F\n    16 // larger than any legal digit val\n  )\n}\n\n\nfunction stripByte(v :Uint8Array, b :byte, countHint :int = 0) :Uint8Array {\n  const c = new Uint8Array(v.length - countHint)\n  let i = 0\n  for (let x = 0, L = v.length; x < L; ++x) {\n    const _b = v[x]\n    if (_b != b) { // \\r\n      c[i++] = _b\n    }\n  }\n  return i < c.length ? c.subarray(0, i) : c\n}\n\nfunction isLetter(c :int) :bool {\n  return (\n    (0x41 <= c && c <= 0x5A) || // A..Z\n    (0x61 <= c && c <= 0x7A)  // a..z\n  )\n}\n\nfunction isDigit(c :int) :bool {\n  return 0x30 <= c && c <= 0x39 // 0..9\n}\n\nfunction hexDigit(c :int) :int {\n  if (c >= 0x30 && c <= 0x39) { // 0..9\n    return c - 0x30\n  } else if (c >= 0x41 && c <= 0x46) { // A..F\n    return c - (0x41 - 10)\n  } else if (c >= 0x61 && c <= 0x66) { // a..f\n    return c - (0x61 - 10)\n  }\n  return -1\n}\n\nfunction isUniIdentStart(c :int) :bool {\n  return (\n    unicode.isLetter(c) ||\n    c == 0x5F || // _\n    c == 0x24 || // $\n    unicode.isEmojiPresentation(c) ||\n    unicode.isEmojiModifierBase(c)\n  )\n}\n\nfunction isUniIdentCont(c :int) :bool {\n  return (\n    unicode.isLetter(c) ||\n    unicode.isDigit(c) ||\n    c == 0x2D || // -\n    c == 0x5F || // _\n    c == 0x24 || // $\n    unicode.isEmojiPresentation(c) ||\n    unicode.isEmojiModifierBase(c)\n  )\n}\n\nconst\n  langIdent = 1<< 1 -1,\n  langIdentStart = 1<< 2 -1\n\n// must smaller than utf8.UniSelf\nconst asciiFeats = new Uint8Array([\n  /* 0    0  NUL */ 0,\n  /* 1    1  SOH */ 0,\n  /* 2    2  STX */ 0,\n  /* 3    3  ETX */ 0,\n  /* 4    4  EOT */ 0,\n  /* 5    5  ENQ */ 0,\n  /* 6    6  ACK */ 0,\n  /* 7    7  BEL */ 0,\n  /* 8    8  BS  */ 0,\n  /* 9    9  TAB */ 0,\n  /* 10   A  LF  */ 0,\n  /* 11   B  VT  */ 0,\n  /* 12   C  FF  */ 0,\n  /* 13   D  CR  */ 0,\n  /* 14   E  SO  */ 0,\n  /* 15   F  SI  */ 0,\n  /* 16  10  DLE */ 0,\n  /* 17  11  DC1 */ 0,\n  /* 18  12  DC2 */ 0,\n  /* 19  13  DC3 */ 0,\n  /* 20  14  DC4 */ 0,\n  /* 21  15  NAK */ 0,\n  /* 22  16  SYN */ 0,\n  /* 23  17  ETB */ 0,\n  /* 24  18  CAN */ 0,\n  /* 25  19  EM  */ 0,\n  /* 26  1A  SUB */ 0,\n  /* 27  1B  ESC */ 0,\n  /* 28  1C  FS  */ 0,\n  /* 29  1D  GS  */ 0,\n  /* 30  1E  RS  */ 0,\n  /* 31  1F  US  */ 0,\n  /* 32  20  SP  */ 0,\n  /* 33  21  !   */ 0,\n  /* 34  22  \"   */ 0,\n  /* 35  23  #   */ 0,\n  /* 36  24  $   */ langIdent | langIdentStart,\n  /* 37  25  %   */ 0,\n  /* 38  26  &   */ 0,\n  /* 39  27  '   */ 0,\n  /* 40  28  (   */ 0,\n  /* 41  29  )   */ 0,\n  /* 42  2A  *   */ 0,\n  /* 43  2B  +   */ 0,\n  /* 44  2C  ,   */ 0,\n  /* 45  2D  -   */ 0,\n  /* 46  2E  .   */ 0,\n  /* 47  2F  /   */ 0,\n  /* 48  30  0   */ langIdent,\n  /* 49  31  1   */ langIdent,\n  /* 50  32  2   */ langIdent,\n  /* 51  33  3   */ langIdent,\n  /* 52  34  4   */ langIdent,\n  /* 53  35  5   */ langIdent,\n  /* 54  36  6   */ langIdent,\n  /* 55  37  7   */ langIdent,\n  /* 56  38  8   */ langIdent,\n  /* 57  39  9   */ langIdent,\n  /* 58  3A  :   */ 0,\n  /* 59  3B  ;   */ 0,\n  /* 60  3C  <   */ 0,\n  /* 61  3D  =   */ 0,\n  /* 62  3E  >   */ 0,\n  /* 63  3F  ?   */ 0,\n  /* 64  40  @   */ 0,\n  /* 65  41  A   */ langIdent | langIdentStart,\n  /* 66  42  B   */ langIdent | langIdentStart,\n  /* 67  43  C   */ langIdent | langIdentStart,\n  /* 68  44  D   */ langIdent | langIdentStart,\n  /* 69  45  E   */ langIdent | langIdentStart,\n  /* 70  46  F   */ langIdent | langIdentStart,\n  /* 71  47  G   */ langIdent | langIdentStart,\n  /* 72  48  H   */ langIdent | langIdentStart,\n  /* 73  49  I   */ langIdent | langIdentStart,\n  /* 74  4A  J   */ langIdent | langIdentStart,\n  /* 75  4B  K   */ langIdent | langIdentStart,\n  /* 76  4C  L   */ langIdent | langIdentStart,\n  /* 77  4D  M   */ langIdent | langIdentStart,\n  /* 78  4E  N   */ langIdent | langIdentStart,\n  /* 79  4F  O   */ langIdent | langIdentStart,\n  /* 80  50  P   */ langIdent | langIdentStart,\n  /* 81  51  Q   */ langIdent | langIdentStart,\n  /* 82  52  R   */ langIdent | langIdentStart,\n  /* 83  53  S   */ langIdent | langIdentStart,\n  /* 84  54  T   */ langIdent | langIdentStart,\n  /* 85  55  U   */ langIdent | langIdentStart,\n  /* 86  56  V   */ langIdent | langIdentStart,\n  /* 87  57  W   */ langIdent | langIdentStart,\n  /* 88  58  X   */ langIdent | langIdentStart,\n  /* 89  59  Y   */ langIdent | langIdentStart,\n  /* 90  5A  Z   */ langIdent | langIdentStart,\n  /* 91  5B  [   */ 0,\n  /* 92  5C  \\   */ 0,\n  /* 93  5D  ]   */ 0,\n  /* 94  5E  ^   */ 0,\n  /* 95  5F  _   */ langIdent | langIdentStart,\n  /* 96  60  `   */ 0,\n  /* 97  61  a   */ langIdent | langIdentStart,\n  /* 98  62  b   */ langIdent | langIdentStart,\n  /* 99  63  c   */ langIdent | langIdentStart,\n  /* 100 64  d   */ langIdent | langIdentStart,\n  /* 101 65  e   */ langIdent | langIdentStart,\n  /* 102 66  f   */ langIdent | langIdentStart,\n  /* 103 67  g   */ langIdent | langIdentStart,\n  /* 104 68  h   */ langIdent | langIdentStart,\n  /* 105 69  i   */ langIdent | langIdentStart,\n  /* 106 6A  j   */ langIdent | langIdentStart,\n  /* 107 6B  k   */ langIdent | langIdentStart,\n  /* 108 6C  l   */ langIdent | langIdentStart,\n  /* 109 6D  m   */ langIdent | langIdentStart,\n  /* 110 6E  n   */ langIdent | langIdentStart,\n  /* 111 6F  o   */ langIdent | langIdentStart,\n  /* 112 70  p   */ langIdent | langIdentStart,\n  /* 113 71  q   */ langIdent | langIdentStart,\n  /* 114 72  r   */ langIdent | langIdentStart,\n  /* 115 73  s   */ langIdent | langIdentStart,\n  /* 116 74  t   */ langIdent | langIdentStart,\n  /* 117 75  u   */ langIdent | langIdentStart,\n  /* 118 76  v   */ langIdent | langIdentStart,\n  /* 119 77  w   */ langIdent | langIdentStart,\n  /* 120 78  x   */ langIdent | langIdentStart,\n  /* 121 79  y   */ langIdent | langIdentStart,\n  /* 122 7A  z   */ langIdent | langIdentStart,\n  /* 123 7B  {   */ 0,\n  /* 124 7C  |   */ 0,\n  /* 125 7D  }   */ 0,\n  /* 126 7E  ~   */ 0,\n  /* 127 7F  DEL */ 0,\n])\n\n","\n// Mem denotes the storage type needed for a basic type\n//\nexport enum Mem {\n  None = -1,  // zero-width; not a concrete type\n  Ptr  =  0,  // pointer (actual size defined by IR)\n  i8   =  1,  // 8-bit integer\n  i16  =  2,  // 16-bit integer\n  i32  =  4,  // 32-bit integer\n  i64  =  8,  // 64-bit integer\n  f32  =  5,  // 32-bit floating-point\n  f64  =  9,  // 64-bit floating-point\n}\n\n\nexport class Type {\n\n  // descriptor properties\n  mem :Mem               // memory type\n  size :int              // size in bytes\n  isFloat = false        // true for floating-point numbers\n  isInt = false          // true for bool and integers\n  isSignedInt = false    // true for signed integers\n  isUnsignedInt = false  // true for unsigned integers\n  //isUnresolved = false  // true for unresolved types\n\n  constructor(mem :Mem = Mem.None) {\n    this.mem = mem\n    this.size = this.mem as int\n  }\n\n  // accepts returns true if the other type is compatible with this type.\n  // essentially: \"this >= other\"\n  // For instance, if the receiver is the same as `other`\n  // or a superset of `other`, true is returned.\n  //\n  accepts(other :Type) :bool {\n    return this.equals(other)\n  }\n\n  // equals returns true if the receiver is equivalent to `other`\n  //\n  equals(other :Type) :bool {\n    return this === other\n  }\n\n  isTuple() : this is TupleType {\n    return this instanceof TupleType\n  }\n}\n\n\n// UnresolvedType represents a type that is not yet known, but may be\n// known later (i.e. during bind/resolve.)\n//\n// Whenever something refers to this type, you must call addRef(x) where\n// x is the thing that uses/refers to this type. This makes it possible\n// for the TypeResolver to--when resolving this type--go in an edit all\n// the uses of this type, updating them with the concrete, resolved type.\n//\nexport class UnresolvedType extends Type {\n  isUnresolved = true\n  refs :Set<Object>|null = null  // things that references this type\n  def  :Object  // really ast.Expr\n\n  // def is some optional information of where this type was seen.\n  // def is only used by toString().\n  //\n  constructor(def :Object) {\n    super()\n    this.def = def\n  }\n\n  addRef(x :Object) {\n    assert(x !== this.def, 'register ref to definition')\n    if (!this.refs) {\n      this.refs = new Set<Object>([x])\n    } else {\n      this.refs.add(x)\n    }\n  }\n\n  toString() {\n    return '~' + String(this.def || \"T\")\n  }\n}\n\n\n// NativeType represents all built-in types, like i32, str, bool, etc.\n//\nexport class NativeType extends Type {\n}\n\n\n// BasicType is a built-in basic type like i32, bool.\n//\nexport class BasicType extends NativeType {\n  name :string\n\n  constructor(mem :Mem, name :string) {\n    super(mem)\n    this.name = name\n  }\n\n  toString() :string {\n    return this.name\n  }\n}\n\nexport class NumType extends BasicType {\n}\n\nexport class FloatType extends NumType {\n  isFloat = true\n  size = this.mem - 1\n}\n\nexport class IntType extends NumType {\n  isInt = true\n}\n\nexport class SIntType extends IntType {\n  isSignedInt = true\n}\n\nexport class UIntType extends IntType {\n  isUnsignedInt = true\n}\n\n// basic type constants\n//\nexport const\n  // special types\n  t_nil   = new BasicType(Mem.Ptr,  'nil')\n  // integer types\n, t_bool  = new UIntType(Mem.i8,    'bool')\n, t_u8    = new UIntType(Mem.i8,    'u8')\n, t_i8    = new SIntType(Mem.i8,    'i8')\n, t_u16   = new UIntType(Mem.i16,   'u16')\n, t_i16   = new SIntType(Mem.i16,   'i16')\n, t_u32   = new UIntType(Mem.i32,   'u32')\n, t_i32   = new SIntType(Mem.i32,   'i32')\n, t_u64   = new UIntType(Mem.i64,   'u64')\n, t_i64   = new SIntType(Mem.i64,   'i64')\n, t_uint  = new UIntType(Mem.Ptr,   'uint')\n, t_int   = new SIntType(Mem.Ptr,   'int')\n, t_usize = new UIntType(Mem.Ptr,   'usize')\n, t_isize = new SIntType(Mem.Ptr,   'isize')\n  // floating-point types\n, t_f32   = new FloatType(Mem.f32,  'f32')\n, t_f64   = new FloatType(Mem.f64,  'f64')\n  // aliases\n, t_byte = t_u8\n, t_char = t_u32\n\n\n// intTypes returns a pair of [signed, unsigned] integer types\n// that are bytesize wide.\n//\nexport function intTypes(bytesize :int) :[IntType,IntType] {\n  switch (bytesize) {\n    case 1: return [t_i8,  t_u8]\n    case 2: return [t_i16, t_u16]\n    case 4: return [t_i32, t_u32]\n    case 8: return [t_i64, t_u64]\n  }\n  panic(`invalid integer size ${bytesize}`)\n  return [t_i32, t_u32]\n}\n\n\n// StrType = \"str\" (\"<\" length \">\")?\n//\nexport class StrType extends NativeType {\n  length :int // -1 means length only known at runtime\n\n  constructor(length :int) {\n    super()\n    this.length = length\n  }\n\n  toString() :string {\n    return this.length > -1 ? `str<${this.length}>` : 'str'\n  }\n\n  equals(other :Type) :bool {\n    // TODO: break this up, partly into accepts(), so its truly \"equals\",\n    // e.g. \"str<4> != str\"\n    return (\n      this === other ||\n      ( other instanceof StrType &&\n        this.length == other.length\n      )\n    )\n  }\n}\n\n\n// RestType = \"...\" Type\n//\nexport class RestType extends Type {\n  type :Type\n\n  constructor(type :Type) {\n    super()\n    this.type = type\n  }\n\n  toString() :string {\n    return `...${this.type}`\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof RestType &&\n        this.type.equals(other.type)\n      )\n    )\n  }\n}\n\n\n// TupleType = \"(\" Type (\",\" Type)+ \")\"\n//\nexport class TupleType extends Type {\n  types :Type[]\n\n  constructor(types :Type[]) {\n    super()\n    this.types = types\n  }\n\n  toString() :string {\n    return '(' + this.types.map(t => t.toString()).join(', ') + ')'\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof TupleType &&\n        this.types.length == other.types.length &&\n        this.types.every((t, i) => t.equals(other.types[i]))\n      )\n    )\n  }\n\n  isTuple() : this is TupleType {\n    return true\n  }\n}\n\n// FunType = ( Type | TupleType ) \"->\" Type\n//\nexport class FunType extends Type {\n  args   :Type[]\n  result :Type\n\n  constructor(args :Type[], result :Type) {\n    super()\n    this.args = args\n    this.result = result\n  }\n\n  toString() :string {\n    return `(${this.args.join(', ')}) -> ${this.result}`\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof FunType &&\n        this.args.length == other.args.length &&\n        this.result.equals(other.result) &&\n        this.args.every((t, i) => t.equals(other.args[i]))\n      )\n    )\n  }\n}\n\n\n// UnionType = Type (\"|\" Type)+\n//\nexport class UnionType extends Type {\n  types :Set<Type>\n\n  constructor(types :Set<Type>) {\n    super()\n    this.types = types\n  }\n\n  add(t :Type) {\n    assert(!(t instanceof UnionType), 'adding union type to union type')\n    this.types.add(t)\n  }\n\n  toString() :string {\n    let s = '(', first = true\n    for (let t of this.types) {\n      if (first) {\n        first = false\n      } else {\n        s += '|'\n      }\n      s += t.toString()\n    }\n    return s + ')'\n  }\n\n  equals(other :Type) :bool {\n    if (this === other) {\n      return true\n    }\n    if (!(other instanceof UnionType) || other.types.size != this.types.size) {\n      return false\n    }\n    // Note: This relies on type instances being singletons (being interned)\n    for (let t of this.types) {\n      if (!other.types.has(t)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  accepts(other :Type) :bool {\n    if (this === other) {\n      return true\n    }\n    if (!(other instanceof UnionType)) {\n      return false\n    }\n    // Note: This relies on type instances being singletons (being interned)\n    // make sure that we have at least the types of `other`.\n    // e.g.\n    //   (int|f32|bool) accepts (int|f32) => true\n    //   (int|f32) accepts (int|f32|bool) => false\n    for (let t of other.types) {\n      if (!this.types.has(t)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n\n// OptionalType = Type \"?\"\n//\nexport class OptionalType extends Type {\n  type :Type\n\n  constructor(type :Type) {\n    super()\n    assert(!(type instanceof OptionalType), \"optional already optional\")\n    assert(!(type instanceof UnionType), \"union type can't be nil\")\n    assert(!(type instanceof BasicType), \"basic types can't be nil\")\n  }\n\n  toString() :string {\n    return `${this.type}?`\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof OptionalType &&\n        this.type.equals(other.type)\n      )\n    )\n  }\n\n  accepts(other :Type) :bool {\n    return (\n      this.equals(other) ||       // e.g. \"x str?; y str?; x = y\"\n      this.type.equals(other) ||  // e.g. \"x str?; y str; x = y\"\n      other === t_nil           // e.g. \"x str?; x = nil\"\n    )\n  }\n}\n\n\n// t_str0 is a preallocated singleton representing the type of\n// the empty string\n// i.e. \"str<0>\"\n//\nexport const t_str0 = new StrType(0)\n\n\n// t_str is a preallocated singleton representing a heap-allocated\n// string which size is only known at runtime.\n// i.e. \"str\"\n//\nexport const t_str = new StrType(-1)\n\n\n// t_stropt is a preallocated singleton representing an optional\n// heap-allocated string which size is only known at runtime.\n// i.e. \"str?\"\n//\nexport const t_stropt = new OptionalType(t_str)\n\n","import { Int64, SInt64, UInt64 } from './int64'\nimport { token } from './token'\nimport { debuglog as dlog } from './util'\nimport {\n  Ent,\n  Expr,\n  NumLit,\n  Ident,\n  Operation,\n} from './ast'\nimport {\n  Mem,\n  IntType,\n  NumType,\n\n  t_u8, t_i8, t_u16, t_i16, t_u32, t_i32, t_u64, t_i64,\n  t_uint, t_int,\n  //t_usize, t_isize,\n  t_f32, t_f64,\n} from './types'\n\nexport type Num = number | Int64\n\nconst _Int64_UINT32_MAX = UInt64.fromInt32(0xffffffff)\nconst _Int64_SINT32_MAX = SInt64.fromInt32(0x7fffffff)\nconst _Int64_SINT32_MIN = SInt64.fromInt32(-0x80000000)\n\nconst _Int32_UINT16_MAX = 0xffff >>> 0\nconst _Int32_SINT16_MAX = 0x7fff | 0\nconst _Int32_SINT16_MIN = -0x8000 | 0\nconst _Int64_UINT16_MAX = UInt64.fromInt32(_Int32_UINT16_MAX)\nconst _Int64_SINT16_MAX = SInt64.fromInt32(_Int32_SINT16_MAX)\nconst _Int64_SINT16_MIN = SInt64.fromInt32(_Int32_SINT16_MIN)\n\nconst _Int32_UINT8_MAX = 0xff >>> 0\nconst _Int32_SINT8_MAX = 0x7f | 0\nconst _Int32_SINT8_MIN = -0x80 | 0\nconst _Int64_UINT8_MAX = UInt64.fromInt32(_Int32_UINT8_MAX)\nconst _Int64_SINT8_MAX = SInt64.fromInt32(_Int32_SINT8_MAX)\nconst _Int64_SINT8_MIN = SInt64.fromInt32(_Int32_SINT8_MIN)\n\n\n// numIsZero return true if the number is zero\n//\nexport function numIsZero(v :Num) :bool {\n  return (typeof v == 'number') ? v == 0 : v.isZero()\n}\n\n// numIsZero return true if the number is zero\n//\nexport function isNum(v :any) :v is Num {\n  return (\n    typeof v == 'number' ||\n    v instanceof SInt64 ||\n    v instanceof UInt64\n  )\n}\n\n// numconv coverts a number to a type.\n//\n// Conversion always succeeds but might be lossy;\n// returns [Num,true] when lossless, [Num,false] when conversion was lossy.\n//\nexport function numconv(v :Num, t :NumType) :[Num,bool] {  // -> v2, lossless\n  let lossless :bool = false\n\n  // TODO FIXME if the type is arch dependent, assume 32-bit\n  if (t === t_int) {\n    t = t_i32\n  } else if (t === t_uint) {\n    t = t_u32\n  }\n\n  if (t === t_i64) {\n    // ? -> i64\n    if (typeof v == 'number') {\n      if (v === (v | 0) || v === v >>> 0) {\n        // i32|u32 -> i64\n        lossless = true\n        v = SInt64.fromFloat64(v)\n      } else {\n        // f32|f64 -> i64\n        let n :SInt64|null\n        if (Math.ceil(v) == v && (n = SInt64.maybeFromFloat64(v))) {\n          lossless = true\n          v = n\n        } else {\n          v = SInt64.fromFloat64(v)\n        }\n      }\n    } else {\n      // u64|i64 -> i64\n      lossless = v.lte(SInt64.MAX)\n      v = v.toSigned()\n    }\n\n  } else if (t === t_u64) {\n    // ? -> u64\n    if (typeof v == 'number') {\n      if (v === v >>> 0) {\n        // +i32|u32 -> u64\n        lossless = true\n        v = SInt64.fromInt32(v)\n      } else {\n        // -i32|f32|f64 -> u64\n        let n :UInt64|null\n        if (Math.ceil(v) == v && (n = UInt64.maybeFromFloat64(v))) {\n          lossless = true\n          v = n\n        } else {\n          v = UInt64.fromFloat64(v)\n        }\n      }\n    } else {\n      // u64|i64 -> i64\n      lossless = v.isPos()\n      v = v.toUnsigned()\n    }\n\n  } else if (t === t_i32) {\n    // ? -> i32\n    if (typeof v == 'number') {\n      let v2 = v | 0\n      lossless = v === v2\n      v = v2\n    } else {\n      // u64|i64 -> i32\n      lossless = v.gte(_Int64_SINT32_MIN) && v.lte(_Int64_SINT32_MAX)\n      v = v.toInt32()\n    }\n\n  } else if (t === t_u32) {\n    // ? -> u32\n    if (typeof v == 'number') {\n      let v2 = v >>> 0\n      lossless = v === v2\n      v = v2\n    } else {\n      // u64|i64 -> u32\n      lossless = v.gte(UInt64.ZERO) && v.lte(_Int64_UINT32_MAX)\n      v = v.toUInt32()\n    }\n\n  } else if (t === t_i16) {\n    // ? -> i16\n    if (typeof v == 'number') {\n      let v2 = v | 0\n      lossless = v === v2 && v >= _Int32_SINT16_MIN && v <= _Int32_SINT16_MAX\n      v = v2\n    } else {\n      // u64|i64 -> i16\n      lossless = v.gte(_Int64_SINT16_MIN) && v.lte(_Int64_SINT16_MAX)\n      v = v.toInt32()\n      assert(v >= _Int32_SINT16_MIN && v <= _Int32_SINT16_MAX)\n    }\n\n  } else if (t === t_u16) {\n    // ? -> u16\n    if (typeof v == 'number') {\n      let v2 = v >>> 0\n      lossless = v === v2 && v >= 0 && v <= _Int32_UINT16_MAX\n      v = v2\n    } else {\n      // u64|i64 -> u16\n      lossless = v.gte(UInt64.ZERO) && v.lte(_Int64_UINT16_MAX)\n      v = v.toInt32()\n      assert(v >= 0 && v <= _Int32_UINT16_MAX)\n    }\n\n  } else if (t === t_i8) {\n    // ? -> i8\n    if (typeof v == 'number') {\n      let v2 = v | 0\n      lossless = v === v2 && v >= _Int32_SINT8_MIN && v <= _Int32_SINT8_MAX\n      v = v2\n    } else {\n      // u64|i64 -> i8\n      lossless = v.gte(_Int64_SINT8_MIN) && v.lte(_Int64_SINT8_MAX)\n      v = v.toInt32()\n      assert(v >= _Int32_SINT8_MIN && v <= _Int32_SINT8_MAX)\n    }\n\n  } else if (t === t_u8) {\n    // ? -> u8\n    if (typeof v == 'number') {\n      let v2 = v >>> 0\n      lossless = v === v2 && v >= 0 && v <= _Int32_UINT8_MAX\n      v = v2\n    } else {\n      // u64|i64 -> u8\n      lossless = v.gte(UInt64.ZERO) && v.lte(_Int64_UINT8_MAX)\n      v = v.toInt32()\n      assert(v >= 0 && v <= _Int32_UINT8_MAX)\n    }\n\n  } else if (t === t_f64) {\n    // ? -> f64\n    lossless = true\n    if (typeof v != 'number') {\n      v = v.toFloat64()\n    }\n\n  } else if (t === t_f32) {\n    // ? -> f32\n    lossless = true\n    if (typeof v != 'number') {\n      v = v.toFloat64()\n    }\n\n  } else {\n    assert(false, `unexpected destination type ${t}`)\n  }\n\n  return [v, lossless]\n}\n\n\n// evalConstU32 evaluates a constant expression yielding a u32\n// returns\n//  >= 0 on success\n//    -1 on lossy conversion\n//    -2 if x is not a number\n//\nexport function numEvalU32(x :Expr) :int {\n  let n = numEval(x)\n  if (n === null) {\n    return -2\n  }\n\n  let [i, lossless] = numconv(n, t_u32)\n  assert(typeof i == 'number')\n  assert(i >= 0, 'negative value of u32')\n\n  return lossless ? i as int : -1\n}\n\n\n// numEval evaulates a constant expression yielding a number.\n// returns null if the expression either yields a non-number or some\n// components are unresolved or not constant.\n//\nexport function numEval(x :Expr) :Num|null {\n  if (x instanceof NumLit) {\n    return x.value\n  }\n\n  if (x instanceof Ident) {\n    let ent = x.ent as Ent\n    assert(ent, 'unresolved identifier')\n    assert(ent.value, 'unresolved identifier value')\n    if (ent.value && (ent.isConstant() || ent.nreads == 1)) {\n      // Note: ent is either constant (never written to)\n      // or we are the only ones reading it.\n      return numEval(ent.value)\n    }\n\n  } else if (x instanceof Operation) {\n    return numEvalOp(x)\n\n  } else {\n    dlog(`TODO handle ${x.constructor.name} ${x}`)\n  }\n\n  return null\n}\n\n\n// numEvalOp evaluates a constant operation.\n// returns null on failure.\n//\nexport function numEvalOp(x :Operation) :Num|null {\n  let t = x.type as NumType\n  assert(t, 'unresolved type')\n  \n  if (!(t instanceof NumType)) {\n    // not a numeric operation\n    return null\n  }\n\n  let xn = numEval(x.x)\n  if (xn === null) {\n    return null\n  }\n\n  if (!x.y) {\n    // unary operation\n    assert(x.x.type === t, 'unexpected operand type')\n    return numEvalOpUnary(t, xn, x.op)\n  }\n\n  // else: binary operation\n\n  let yn = numEval(x.y)\n  if (yn === null) {\n    return null\n  }\n\n  let lossless :bool = false\n\n  if (x.x.type !== t) {\n    // cast x to typeof x\n    ;[xn, lossless] = numconv(xn, t)\n    if (!lossless) {\n      return null\n    }\n  }\n\n  if (x.op == token.SHL || x.op == token.SHR) {\n    // special case for bit shifts which takes an unsigned in as 2nd operand\n    // y must be unsigned int\n    let yt = x.y.type as IntType\n    if (!(yt instanceof IntType) || !(t instanceof IntType)) {\n      // floating point operand for bit shift is invalid\n      return null\n    }\n    return numEvalOpBitSh(t, xn, yn, x.op)\n\n  } else if (x.y.type !== t) {\n    // cast y to typeof x\n    ;[yn, lossless] = numconv(yn, t)\n    if (!lossless) {\n      return null\n    }\n  }\n\n  return numEvalOpBin(t, xn, yn, x.op)\n}\n\n\nexport function numEvalOpBitSh(\n  t :IntType,\n  a :Num,\n  b :Num,\n  op :token.SHL|token.SHR\n) :Num|null {\n  let nbits = 0\n  if (typeof b == 'number' && b >= 0) {\n    nbits = b >>> 0\n  } else {\n    // convert b to u32\n    let lossless :bool = false\n    ;[nbits, lossless] = numconv(b, t_u32) as [int,bool]\n    if (!lossless) {\n      return null\n    }\n  }\n\n  if (typeof a == 'number') {\n    assert(t.mem == Mem.i32 || t.mem == Mem.i16 || t.mem == Mem.i8)\n    if (op == token.SHL) {\n      return a << nbits\n    }\n    assert(op == token.SHR)\n    return (\n      t.isSignedInt ? a >> nbits :  // sign-extending\n      a >>> nbits  // zero-replicating\n    )\n  }\n\n  assert(t.mem == Mem.i64)\n  assert(a instanceof SInt64 || a instanceof UInt64)\n  if (op == token.SHL) {\n    return (a as Int64).shl(nbits) // <<\n  }\n  assert(op == token.SHR)\n  return (a as Int64).shr(nbits) // >>\n}\n\n\nexport function numEvalOpBin(\n  t :NumType,\n  a :Num,\n  b :Num,\n  op :token\n) :Num|null {\n  if (t.mem == Mem.i32) {\n    assert(t instanceof IntType)\n    assert(typeof a == 'number')\n    assert(typeof b == 'number')\n    if (t.isSignedInt) {\n      return numEvalOpBinS32(a as int, b as int, op)\n    }\n    assert(a >= 0)\n    assert(b >= 0)\n    return numEvalOpBinU32(a as int, b as int, op)\n  }\n\n  if (t.mem == Mem.i64) {\n    assert(t instanceof IntType)\n    if (t.isSignedInt) {\n      assert(a instanceof SInt64)\n      assert(b instanceof SInt64)\n    } else {\n      assert(a instanceof UInt64)\n      assert(b instanceof UInt64)\n    }\n    return numEvalOpBinI64(a as Int64, b as Int64, op)\n  }\n\n  assert(typeof a == 'number')\n  assert(typeof b == 'number')\n  return numEvalOpBinFloat(a as number, b as number, op)\n}\n\n\n// Binary numeric operators\n//\n// Op       Avail.  Src  Note\n//\n// ADD      i, f    +\n// SUB      i, f    -\n// MUL      i, f    *\n// QUO      i, f    /\n// REM      i       %\n// OR       i       |\n// XOR      i       ^\n// AND      i       &\n// AND_NOT  i       &^   equiv to `x & (^y)` (note: unary ^ = \"NOT\")\n// SHL      i       <<\n// SHR      i       >>   arithmetic when signed, logical when unsigned\n//\n\nexport function numEvalOpBinS32(a :int, b :int, op :token) :Num|null {\n  switch (op) {\n  case token.ADD:     return a + b | 0 // +\n  case token.SUB:     return a - b | 0 // -\n  case token.MUL:     return Math.imul(a, b) // *\n  case token.QUO:     return a / b | 0 // /\n  case token.REM:     return a % b | 0 // %\n  case token.OR:      return a | b  // |\n  case token.XOR:     return a ^ b // ^\n  case token.AND:     return a & b // &\n  case token.AND_NOT: return a & ~b // &^\n  case token.SHL:     return a << b // <<\n  case token.SHR:     return a >> b // >> sign-extending\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\nexport function numEvalOpBinU32(a :int, b :int, op :token) :Num|null {\n  switch (op) {\n  case token.ADD:     return a + b >>> 0 // +\n  case token.SUB:     return a - b >>> 0 // -\n  case token.MUL:     return Math.imul(a, b) >>> 0 // *\n  case token.QUO:     return a / b >>> 0 // /\n  case token.REM:     return a % b >>> 0 // %\n  case token.OR:      return a | b  // |\n  case token.XOR:     return a ^ b // ^\n  case token.AND:     return a & b // &\n  case token.AND_NOT: return a & ~b // &^\n  case token.SHL:     return a << b // <<\n  case token.SHR:     return a >>> b // >> zero-replicating\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\nexport function numEvalOpBinI64(a :Int64, b :Int64, op :token) :Num|null {\n  switch (op) {\n  case token.ADD:     return a.add(b) // +\n  case token.SUB:     return a.sub(b) // -\n  case token.MUL:     return a.mul(b) // *\n  case token.QUO:     return a.div(b) // /\n  case token.REM:     return a.mod(b) // %\n  case token.OR:      return a.or(b)  // |\n  case token.XOR:     return a.xor(b) // ^\n  case token.AND:     return a.and(b) // &\n  case token.AND_NOT: return a.and(b.not()) // &^\n  case token.SHL:     return a.shl(b.toUInt32()) // <<\n  case token.SHR:     return a.shr(b.toUInt32()) // >>\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\nexport function numEvalOpBinFloat(a :number, b :number, op :token) :Num|null {\n  switch (op) {\n  case token.ADD:     return a + b // +\n  case token.SUB:     return a - b // -\n  case token.MUL:     return a * b // *\n  case token.QUO:     return a / b // /\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\n\nexport function numEvalOpUnary(t :NumType, n :Num, op :token) :Num|null {\n  if (t.mem == Mem.i32) {\n    assert(typeof n == 'number')\n    assert(t instanceof IntType)\n    if (t.isSignedInt) {\n      return numEvalOpUnaryS32(n as int, op)\n    }\n    return numEvalOpUnaryU32(n as int, op)\n  }\n\n  if (t.mem == Mem.i64) {\n    assert(typeof n == 'object')\n    assert(n instanceof UInt64 || n instanceof SInt64)\n    assert(t instanceof IntType)\n    return numEvalOpUnaryI64(n as Int64, op)\n  }\n\n  assert(typeof n == 'number')\n  return numEvalOpUnaryFloat(n as number, op)\n}\n\n// Unary operator definitions:\n// Op   Example   Definition  Notes\n// ADD  +x        0 + x\n// SUB  -x        0 - x\n// XOR  ^x        m ^ x       aka NOT, C equiv: `~x`\n//                  where m = \"all bits set to 1\" for unsigned x\n//                  and   m = -1 for signed x\n//\n\nexport function numEvalOpUnaryS32(n :int, op :token) :Num|null {\n  switch (op) {\n  case token.ADD: return n\n  case token.SUB: return 0 - n | 0\n  case token.XOR: return ~n  // \"NOT\" (alt impl: `-1 ^ n | 0`)\n  case token.NOT: return null // logical, not numeric\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\nexport function numEvalOpUnaryU32(n :int, op :token) :Num|null {\n  switch (op) {\n  case token.ADD: return n\n  case token.SUB: return 0 - n >>> 0\n  case token.XOR: return ~n  // \"NOT\" (alt impl: `0xffffffff ^ n >>> 0`)\n  case token.NOT: return null // logical, not numeric\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\nexport function numEvalOpUnaryI64(n :Int64, op :token) :Num|null {\n  switch (op) {\n  case token.ADD: return n\n  case token.SUB: return n.neg()\n  case token.XOR: return n.not()\n  case token.NOT: return null // logical, not numeric\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n\nexport function numEvalOpUnaryFloat(n :number, op :token) :Num|null {\n  switch (op) {\n  case token.ADD: return n\n  case token.SUB: return 0 - n\n  default:\n    assert(false, `unexpected ${token[op]}`)\n    return null\n  }\n}\n","import { Pos, SrcFile } from './pos'\nimport { ByteStr } from './bytestr'\nimport { token, tokstr } from './token'\nimport * as utf8 from './utf8'\nimport { Num, numconv } from './num'\nimport { Int64 } from './int64'\nimport {\n  Type,\n  NativeType,\n  NumType,\n  IntType,\n  FloatType,\n  RestType,\n  StrType,\n} from './types'\nimport * as types from './types'\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// AST type hierarchy\n//\n//  Group\n//  Comment\n//  Node\n//    Field\n//    Stmt\n//      NoOpStmt\n//      Decl\n//        MultiDecl\n//        ImportDecl\n//        VarDecl\n//        TypeDecl\n//      ReturnStmt\n//      Expr\n//        Block\n//        Ident\n//        IfExpr\n//        LiteralExpr\n//        FunExpr\n//        Assignment\n//        ...\n//\n\nlet nextgid = 0\nexport class Group { id = nextgid++ } // nextgid only for DEBUG\n\nexport class Comment {\n  constructor(\n    public pos   :Pos,\n    public value :Uint8Array,\n  ) {}\n}\n\nexport class Node {\n  constructor(\n    public pos   :Pos,\n    public scope :Scope,\n    // public comments? :Comment[],\n  ) {}\n\n  toString() :string {\n    return this.constructor.name\n  }\n}\n\n// Ident Type\n//       Type\nexport class Field extends Node {\n  constructor(pos :Pos, scope :Scope,\n  public type :TypeExpr,\n  public name :Ident|null,\n    // nil means anonymous field/parameter (structs/parameters),\n    // or embedded interface (interfaces)\n  ) {\n    super(pos, scope)\n  }\n}\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Scope\n\n// An Ent describes a named language entity such as a package,\n// constant, type, variable, function (incl. methods), or label.\n//\n// VARIABLES\n//\n//   decl\n//    | value\n//    â†“   â†“\n//    x = 0 ; xÂ¹ = 3 ; print(xÂ²)\n//            â†‘              â†‘\n//         writes++       reads.add(xÂ²)\n//\n//\n// FUNCTIONS\n//\n//    fun a() { ... };  aÂ¹()\n//    ~~~~~~~~~~~~~~~   â†‘\n//           â†‘       reads.add(aÂ¹)\n//      decl==value\n//\n//\nexport class Ent {\n  name  :ByteStr\n  decl  :Node\n  value :Expr|null\n  data  :any\n  type  :Type|null\n\n  writes :int = 0  // Tracks stores\n  nreads :int = 0  // Tracks loads\n    // writes and reads does NOT include the definition/declaration itself.\n\n  constructor(\n    name  :ByteStr,\n    decl  :Node,\n    value :Expr|null,\n    type  :Type|null = null,\n    data  :any = null,\n  ) {\n    if (!type) {\n      // assign by best effort\n      type = (\n\n        ( decl &&\n          ( decl instanceof Field || decl instanceof VarDecl ) &&\n          decl.type &&\n          decl.type.type ) ||\n\n        ( value &&\n          value.type &&\n          value.type ) ||\n\n        null\n      )\n    }\n    this.name = name\n    this.decl = decl\n    this.value = value\n    this.data = data\n    this.type = type\n  }\n\n  // getTypeExpr returns the Expr which type should represent this\n  // Ent's type.\n  //\n  // This is used by the parser and type resolver only when .type=null\n  //\n  getTypeExpr() :Expr | null {\n    return (\n      ( this.decl && (\n        this.decl instanceof Field ||\n        this.decl instanceof VarDecl\n      ) && this.decl.type) ||\n\n      this.value\n    )\n  }\n\n  isConstant() :bool {\n    return this.writes == 0\n  }\n\n  get scope() :Scope {\n    return this.decl.scope\n  }\n}\n\n\nexport class Scope {\n  fun :FunExpr | null = null // when set, scope if function scope\n\n  constructor(\n  public outer :Scope | null,\n  public decls :Map<ByteStr,Ent> | null = null,\n  public isFunScope :bool = false, // if the scope is that of a function\n  ) {}\n\n  // lookup a declaration in this scope and any outer scopes\n  //\n  lookup(s :ByteStr) :Ent | null {\n    const d = this.decls && this.decls.get(s)\n    return d ? d : this.outer ? this.outer.lookup(s) : null\n  }\n\n  // lookupImm looks up a declaration only in this scope\n  //\n  lookupImm(s :ByteStr) :Ent | null {\n    const d = this.decls && this.decls.get(s)\n    return d || null\n  }\n\n  // declare registers a name in this scope.\n  // If the name is already registered, null is returned.\n  //\n  declare(name: ByteStr, decl :Node, x: Expr|null) :Ent|null {\n    const ent = new Ent(name, decl, x)\n    return this.declareEnt(ent) ? ent : null\n  }\n\n  // declareEnt returns true if ent was declared, and false it's already\n  // declared.\n  //\n  declareEnt(ent :Ent) :bool {\n    // Note: name is interned by value in the same space as all other names in\n    // this scope, meaning we can safely use the object identity of name.\n    if (!this.decls) {\n      this.decls = new Map<ByteStr,Ent>([[ent.name, ent]])\n      return true\n    }\n    if (this.decls.has(ent.name)) {\n      return false\n    }\n    this.decls.set(ent.name, ent)\n    return true\n  }\n\n  // redeclareEnt returns the previously declared entity, if any.\n  //\n  redeclareEnt(ent :Ent) :Ent|null {\n    // Note: name is interned by value in the same space as all other names in\n    // this scope, meaning we can safely use the entity identity of name.\n    if (!this.decls) {\n      this.decls = new Map<ByteStr,Ent>([[ent.name, ent]])\n      return null\n    }\n    const prevent = this.decls.get(ent.name)\n    if (prevent === ent) {\n      return null\n    }\n    this.decls.set(ent.name, ent)\n    return prevent || null\n  }\n\n  // get closest function scope (could be this scope)\n  funScope() :Scope|null {\n    let s :Scope|null = this\n    while (s) {\n      if (s.fun) {\n        return s\n      }\n      s = s.outer\n    }\n    return null\n  }\n\n  level() {\n    let level = 0, s :Scope|null = this\n    while ((s = s.outer)) {\n      level++\n    }\n    return level\n  }\n\n  toString() {\n    const names = this.decls ? Array.from(this.decls.keys()) : []\n    return `Scope(level: ${this.level()}, names: (${names.join(', ')}))`\n  }\n}\n\n// used by intrinsics\nconst nilScope = new Scope(null)\n\n\n// File corresponds to a source file\n//\nexport class File {\n  constructor(\n    public sfile      :SrcFile,\n    public scope      :Scope,\n    public imports    :ImportDecl[] | null,  // imports in this file\n    public decls      :(Decl|FunExpr)[],     // top-level declarations\n    public unresolved :Set<Ident> | null,    // unresolved references\n  ) {}\n\n  toString() :string {\n    return (\n      `File(\"${this.sfile.name}\"; ${this.decls.length} decls` +\n      ( this.imports ? `; ${this.imports.length} imports)` : '' )\n    )\n  }\n}\n\nexport class Package {\n  files :File[] = []\n\n  constructor(\n    public name :string,\n    public scope :Scope,\n    // public imports\n    // public exports\n  ) {}\n\n  toString() {\n    return `Package(${this.name})`\n  }\n}\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Statements\n//\n// There are two kinds of statements:\n// - declaration statements and\n// - expression statements.\n//\nexport class Stmt extends Node {}\n\n// no operation / blank / filler\nexport class NoOpStmt extends Stmt {}\n\n\nexport class ReturnStmt extends Stmt {\n  constructor(pos :Pos, scope :Scope,\n  public result :Expr, // t_nil means no explicit return values\n  public type :Type | null,  // effective type. null until resolved.\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class WhileStmt extends Stmt {\n  constructor(pos :Pos, scope :Scope,\n  public cond :Expr, // condition for executing the body\n  public body :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Declarations\n\nexport class Decl extends Stmt {}\n\nexport class MultiDecl extends Decl {\n  // MultiDecl represents a collection of declarations that were parsed from\n  // a multi-declaration site. E.g. \"type (a int; b f32)\"\n  constructor(pos :Pos, scope :Scope,\n  public decls :Decl[],\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class ImportDecl extends Decl {\n  constructor(pos :Pos, scope :Scope,\n  public path       :StringLit,\n  public localIdent :Ident|null,\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class VarDecl extends Decl {\n  constructor(pos :Pos, scope :Scope,\n  public idents  :Ident[],\n  public group   :Group|null,           // null means not part of a group\n  public type    :TypeExpr|null = null, // null means no type\n  public values  :Expr[]|null = null,   // null means no values\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class TypeDecl extends Decl {\n  // Ident Type\n  constructor(pos :Pos, scope :Scope,\n  public ident  :Ident,\n  public alias  :bool,\n  public type   :TypeExpr,\n  public group  :Group|null, // nil = not part of a group\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Expressions\n\nexport class Expr extends Stmt {\n  type :Type|null = null  // effective type of expression. null until resolved.\n\n  isIdent() :this is Ident {\n    return this instanceof Ident\n  }\n}\n\n// BadExpr is a placeholder for an expression that failed to parse correctly\n// and where we can't provide a better node.\n//\nexport class BadExpr extends Expr {}\n\n\n// TypeExpr simply represents a type\n//\nexport class TypeExpr extends Expr {\n  type :Type\n\n  constructor(pos :Pos, scope :Scope, type :Type) {\n    super(pos, scope)\n    this.type = type\n  }\n}\n\n\n// BadTypeExpr is a placeholder for a type expression that failed to parse\n// correctly and where we can't provide a better node.\n//\nexport class BadTypeExpr extends TypeExpr {\n  constructor(pos :Pos, scope :Scope) {\n    super(pos, scope, types.t_nil)\n  }\n}\n\n\n// \"...\" TypeExpr\n//\nexport class RestTypeExpr extends TypeExpr {\n  type :RestType\n  expr :TypeExpr\n\n  constructor(pos :Pos, scope :Scope, expr :TypeExpr, type :RestType) {\n    super(pos, scope, type)\n    this.expr = expr\n  }\n}\n\n\nexport class Ident extends Expr {\n  ent :Ent|null = null // what this name references\n\n  constructor(pos :Pos, scope :Scope,\n    public value :ByteStr, // interned in ByteStrSet\n    public ver :int = 0,   // SSA-like version\n  ) {\n    super(pos, scope)\n  }\n\n  toString() { return String(this.value) }\n\n  incrWrite() {\n    assert(this.ent != null)\n    let ent = this.ent as Ent\n    ent.writes++\n    this.ver = ent.writes\n  }\n\n  // ref registers a reference to this ent from an identifier\n  //\n  refEnt(ent :Ent) {\n    assert(this !== ent.decl, \"ref declaration\")\n    ent.nreads++\n    this.ent = ent\n    this.ver = ent.writes\n  }\n\n  // ref unregisters a reference to this ent from an identifier\n  //\n  unrefEnt() {\n    assert(this.ent, \"null ent\")\n    const ent = this.ent as Ent\n    ent.nreads--\n    this.ent = null\n    this.ver = 0\n  }\n}\n\n\nexport class Block extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public list :Stmt[],\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class IfExpr extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public cond :Expr,\n  public then :Expr,\n  public els_ :Expr|null,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class TupleExpr extends Expr {\n  // TupleExpr = \"(\" Expr (\",\" Expr)+ \")\"\n  constructor(pos :Pos, scope :Scope,\n  public exprs :Expr[],\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `(${this.exprs.map(x => x.toString()).join(', ')})`\n  }\n}\n\nexport class SelectorExpr extends Expr {\n  // Selector = Expr \".\" ( Ident | Selector )\n  constructor(pos :Pos, scope :Scope,\n    public lhs :Expr,\n    public rhs :Expr, // Ident or SelectorExpr\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `${this.lhs}.${this.rhs}`\n  }\n}\n\n\nexport class IndexExpr extends Expr {\n  // IndexExpr = Expr \"[\" Expr \"]\"\n\n  indexv :int = -1  // >=0 = resolved, -1 = invalid/unresolved\n    // TODO: remove when we remove resolve.resolveTupleIndex\n\n  indexnum :Num = -1\n    // index value\n    // >=0 : resolved\n    //  -1 : invalid or unresolved\n\n  constructor(pos :Pos, scope :Scope,\n    public operand :Expr,\n    index   :Expr,\n    // public index   :Expr,\n  ) {\n    super(pos, scope)\n    this._index = index\n  }\n\n  private _index :Expr\n\n  get index() :Expr { return this._index }\n  set index(x :Expr) {\n    let e = new Error()\n    console.log(\n      '>>>> set index\\n' +\n      (e.stack as string).split('\\n').slice(2).join('\\n'))\n    this._index = x\n  }\n\n  toString() :string {\n    return `${this.operand}[${this.index}]`\n  }\n}\n\n\nexport class SliceExpr extends Expr {\n  // SliceExpr = Expr \"[\" Expr? \":\" Expr? \"]\"\n\n  startnum :Num = -1\n  endnum   :Num = -1\n    // >=0 : resolved\n    //  -1 : invalid or unresolved\n\n  constructor(pos :Pos, scope :Scope,\n    public operand :Expr,\n    public start   :Expr|null,\n    public end     :Expr|null,\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return `${this.operand}[${this.start || ''}:${this.end || ''}]`\n  }\n}\n\n\nexport class LiteralExpr extends Expr {}\n\n\nexport class NumLit extends LiteralExpr {\n  value :Int64 | number\n  type  :NumType\n\n  constructor(pos :Pos, scope :Scope, value: Int64 | number, type :NumType) {\n    super(pos, scope)\n    this.value = value\n    this.type = type\n  }\n\n  // convertToType coverts the value of the literal to the provided basic type.\n  // Returns true if the conversion was lossless.\n  //\n  convertToType(t :NumType) :bool {\n    let [v, lossless] = numconv(this.value, t)\n    this.type = t\n    this.value = v\n    return lossless\n  }\n}\n\n\nexport class IntLit extends NumLit {\n  kind  :token.INT | token.INT_BIN | token.INT_OCT | token.INT_HEX\n  type  :IntType  // type is always known\n\n  constructor(pos :Pos, scope :Scope,\n    value :Int64 | number,\n    type  :IntType,\n    kind  :token.INT | token.INT_BIN | token.INT_OCT | token.INT_HEX,\n  ) {\n    super(pos, scope, value, type)\n    this.kind = kind\n  }\n\n  toString() :string {\n    switch (this.kind) {\n      case token.INT_HEX: return '0x' + this.value.toString(16)\n      case token.INT_OCT: return '0o' + this.value.toString(8)\n      case token.INT_BIN: return '0b' + this.value.toString(2)\n      default:            return this.value.toString(10)\n    }\n  }\n}\n\n\nexport class CharLit extends NumLit {\n  value :int\n  type  :typeof types.t_char\n\n  constructor(pos :Pos, scope :Scope, value :number) {\n    super(pos, scope, value, types.t_char)\n  }\n\n  toString() :string {\n    // TODO: clever printing of safe chars, \\u and \\U sequences, etc.\n    return '0x' + this.value.toString(16)\n  }\n}\n\n\nexport class FloatLit extends NumLit {\n  value :number\n  type  :FloatType\n\n  constructor(pos :Pos, scope :Scope, value :number, type :FloatType) {\n    super(pos, scope, value, type)\n  }\n\n  toString() :string {\n    return this.value.toString()\n  }\n}\n\n\n// export const ImplicitOne = new IntLit(\n//   0,\n//   nilScope,\n//   token.INT,\n//   null as any as Uint8Array,\n// )\n\n\nexport class StringLit extends LiteralExpr {\n  type  :StrType\n  value :Uint8Array\n\n  constructor(pos :Pos, scope :Scope, value :Uint8Array, type :StrType) {\n    super(pos, scope)\n    this.type = type\n  }\n\n  toString() :string {\n    return JSON.stringify(utf8.decodeToString(this.value))\n  }\n}\n\nexport class Assignment extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public op  :token, // ILLEGAL means no operation\n  public lhs :Expr[],\n  public rhs :Expr[], // empty == lhs++ or lhs--\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return `${this.lhs.join(', ')} ${tokstr(this.op)} ${this.rhs.join(', ')}`\n  }\n}\n\nexport class Operation extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public op :token, // [token.operator_beg .. token.operator_end]\n  public x  :Expr,\n  public y  :Expr|null = null, // nil means unary expression\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `(${token[this.op]} ${this.x}${this.y ? ' ' + this.y : ''})`\n  }\n}\n\nexport class CallExpr extends Expr {\n  // Fun(ArgList[0], ArgList[1], ...)\n  constructor(pos :Pos, scope :Scope,\n  public fun     :Expr,\n  public args    :Expr[],\n  public hasDots :bool,  // last argument is followed by ...\n  ) {\n    super(pos, scope)\n  }\n}\n\n// export class ParenExpr extends Expr {\n//   // (X)\n//   constructor(pos :Pos, scope :Scope,\n//   public x :Expr,\n//   ) {\n//     super(pos, scope)\n//   }\n// }\n\nexport class FunExpr extends Expr {\n  body :Expr|null = null // nil = forward declaration\n  // nlocali32 :int = 0\n  // nlocali64 :int = 0\n  // nlocalf32 :int = 0\n  // nlocalf64 :int = 0\n\n  constructor(pos :Pos, scope :Scope,\n    public name   :Ident|null, // nil = anonymous func expression\n    public sig    :FunSig,\n    public isInit :bool = false, // true for special \"init\" funs at file level\n  ) {\n    super(pos, scope)\n    scope.fun = this  // Mark the scope as being a \"function scope\"\n  }\n}\n\nexport class FunSig extends Node {\n  constructor(pos :Pos, scope :Scope,\n  public params :Field[],\n  public result :TypeExpr | null,  // null = auto\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class TypeConvExpr extends Expr {\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n    public type :Type,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// NativeTypeExpr represents basic/bottom types\n//\nexport class NativeTypeExpr extends TypeExpr {\n  type :NativeType\n  constructor(type :NativeType) {\n    super(0, nilScope, type)\n  }\n}\n\n\n// Atom is a value that identifies itself\n//\n// i.e. true, false, nil\n//\nexport class Atom extends Expr {\n  name :string\n  type :Type\n\n  constructor(name :string, type :Type) {\n    super(0, nilScope)\n    this.name = name\n    this.type = type\n  }\n\n  toString() {\n    return this.name\n  }\n}\n\n\n// built-in, predefined types\nexport const builtInTypes : {[name :string] :TypeExpr} = {\n  \"nil\":   new NativeTypeExpr(types.t_nil),\n  \"bool\":  new NativeTypeExpr(types.t_bool),\n  \"u8\":    new NativeTypeExpr(types.t_u8),\n  \"i8\":    new NativeTypeExpr(types.t_i8),\n  \"u16\":   new NativeTypeExpr(types.t_u16),\n  \"i16\":   new NativeTypeExpr(types.t_i16),\n  \"u32\":   new NativeTypeExpr(types.t_u32),\n  \"i32\":   new NativeTypeExpr(types.t_i32),\n  \"u64\":   new NativeTypeExpr(types.t_u64),\n  \"i64\":   new NativeTypeExpr(types.t_i64),\n  \"uint\":  new NativeTypeExpr(types.t_uint),\n  \"int\":   new NativeTypeExpr(types.t_int),\n  \"usize\": new NativeTypeExpr(types.t_usize),\n  \"isize\": new NativeTypeExpr(types.t_isize),\n  \"f32\":   new NativeTypeExpr(types.t_f32),\n  \"f64\":   new NativeTypeExpr(types.t_f64),\n\n  \"byte\":  new NativeTypeExpr(types.t_byte),\n  \"char\":  new NativeTypeExpr(types.t_char),\n\n  \"str\":   new NativeTypeExpr(types.t_str),\n}\n\n\nconst typeToBuiltInTypes = new Map<Type,TypeExpr>()\nfor (let k in builtInTypes) {\n  let x = (builtInTypes)[k]\n  typeToBuiltInTypes.set(x.type, x)\n}\n\n// getTypeExpr returns an interned TypeExpr for t if one exists,\n// or creates a new TypeExpr that references t.\n//\nexport function GetTypeExpr(t :Type) :TypeExpr {\n  let x = typeToBuiltInTypes.get(t)\n  return x || new TypeExpr(0, nilScope, t)\n}\n\n\n// built-in, predefined values\nexport const builtInValues : {[name :string] :Expr} = {\n  \"true\":  new Atom(\"true\",  types.t_bool),\n  \"false\": new Atom(\"false\", types.t_bool),\n  \"nil\":   new Atom(\"nil\",   types.t_nil),\n}\n","import { SrcFile, Pos } from './pos'\nimport { token, tokstr, prec } from './token'\nimport * as scanner from './scanner'\nimport { ErrorHandler, ErrorCode } from './error'\nimport { TypeResolver } from './resolve'\nimport { ByteStr, ByteStrSet } from './bytestr'\nimport { Universe } from './universe'\nimport { debuglog as dlog } from './util'\nimport { DiagHandler, DiagKind } from './diag'\nimport { SInt64, UInt64 } from './int64'\nimport {\n  File,\n  Scope,\n  Ent,\n  Group,\n  Comment,\n\n  Node,\n\n  Field,\n  Stmt,\n  ReturnStmt,\n  WhileStmt,\n  \n  Decl,\n  ImportDecl,\n  VarDecl,\n  TypeDecl,\n  MultiDecl,\n\n  Expr,\n  Ident,\n  RestTypeExpr,\n  FunExpr,\n  FunSig,\n  NumLit,\n  IntLit,\n  CharLit,\n  FloatLit,\n  StringLit,\n  Block,\n  IfExpr,\n  Assignment,\n  Operation,\n  CallExpr,\n  TupleExpr,\n  BadExpr,\n  TypeExpr,\n  BadTypeExpr,\n  SelectorExpr,\n  IndexExpr,\n  SliceExpr,\n\n  builtInTypes as bitypes,\n  GetTypeExpr,\n} from './ast'\n\nimport {\n  Type,\n  IntType,\n  NumType,\n  FunType,\n  UnresolvedType,\n  UnionType,\n  TupleType,\n  RestType,\n\n  t_nil,\n  // t_u8, t_i8, t_u16, t_i16,\n  t_u32, t_i32, t_u64, t_i64,\n  // t_uint, t_int, t_usize, t_isize,\n  // t_f32,\n  t_f64,\n  t_str0,\n} from './types'\n\nconst kEmptyByteArray = new Uint8Array(0)\nconst kBytes__ = new Uint8Array([0x5f]) // '_'\nconst kBytes_dot = new Uint8Array([0x2e]) // '.'\nconst kBytes_init = new Uint8Array([0x69, 0x6e, 0x69, 0x74]) // 'init'\n\nconst emptyExprList :Expr[] = []\n\ntype exprCtx = Assignment|VarDecl|null\n\n\n// funInfo contains information about the current function, used for data\n// that is really only needed during parsing.\nclass funInfo {\n  inferredReturnType :UnionType|null = null // inferred result types\n\n  constructor(\n  public f :FunExpr, // the respective function node\n  ){}\n\n  addInferredReturnType(t :Type) {\n    if (this.inferredReturnType == null) {\n      this.inferredReturnType = new UnionType(new Set<Type>([t]))\n    } else {\n      this.inferredReturnType.add(t)\n    }\n  }\n}\n\n\n// Parser scans source code and produces AST.\n// It must be initialized via init before use or resue.\n//\nexport class Parser extends scanner.Scanner {\n  fnest      :int = 0   // function nesting level (for error handling)\n  universe   :Universe\n  strSet     :ByteStrSet\n  comments   :Comment[]|null\n  scope      :Scope\n  filescope  :Scope\n  pkgscope   :Scope\n  diagh      :DiagHandler|null = null\n  initfnest  :int = 0  // tracks if we're inside an init function\n  unresolved :Set<Ident>|null   // unresolved identifiers\n  funstack   :funInfo[]  // function stack\n  types      :TypeResolver\n\n  _id__      :ByteStr\n  _id_dot    :ByteStr\n  _id_init   :ByteStr\n\n  initParser(\n    sfile      :SrcFile,\n    sdata      :Uint8Array,\n    universe   :Universe,\n    pkgscope   :Scope|null,\n    typeres    :TypeResolver,\n    errh       :ErrorHandler|null = null,\n    diagh      :DiagHandler|null = null,\n    smode      :scanner.Mode = scanner.Mode.None,\n  ) {\n    const p = this\n    super.init(sfile, sdata, errh, smode)\n    p.scope = new Scope(pkgscope)\n    p.filescope = p.scope\n    p.pkgscope = pkgscope || p.filescope\n    \n    p.fnest = 0\n    p.universe = universe\n    p.strSet = universe.strSet\n    p.comments = null\n    p.diagh = diagh\n    p.initfnest = 0\n    p.unresolved = null\n    p.funstack = []\n    p.types = typeres\n\n    p._id__ = p.strSet.emplace(kBytes__)\n    p._id_dot = p.strSet.emplace(kBytes_dot)\n    p._id_init = p.strSet.emplace(kBytes_init)\n\n    if (smode & scanner.Mode.ScanComments) {\n      p.next = p.next_comments\n    }\n\n    p.next()\n  }\n\n  next_comments() {\n    const p = this\n    super.next()\n    while (p.tok == token.COMMENT) {\n      if (!p.comments) {\n        p.comments = []\n      }\n      p.comments.push(new Comment(p.pos, p.takeByteValue()))\n      super.next()\n    }\n    // TODO: Figure out a way to attach comments to nodes\n  }\n\n  got(tok :token) :bool {\n    const p = this\n    if (p.tok == tok) {\n      p.next()\n      return true\n    }\n    return false\n  }\n  \n  want(tok :token) {\n    const p = this\n    if (!p.got(tok)) {\n      p.syntaxError(`expecting ${tokstr(tok)}`)\n      p.next()\n    }\n  }\n\n  // inFun() :FunExpr|null {\n  //   return this.funstack[0] || null\n  // }\n\n  currFun() :funInfo {\n    assert(this.funstack.length > 0, 'access current function at file level')\n    return this.funstack[0]\n  }\n\n  pushFun(f :FunExpr) {\n    this.funstack.push(new funInfo(f))\n  }\n\n  popFun() {\n    assert(this.funstack.length > 0, 'popFun with empty funstack')\n    this.funstack.pop()\n  }\n\n\n  pushScope(scope :Scope | null = null) {\n    const p = this\n    if (scope) {\n      assert(scope.outer != null, 'pushing scope without outer scope')\n    }\n    p.scope = scope || new Scope(p.scope)\n    // dlog(`${(p as any).scope.outer.level()} -> ${p.scope.level()}`)\n  }\n\n  popScope() :Scope { // returns old (\"popped\") scope\n    const p = this\n    const s = p.scope\n    \n    assert(s !== p.filescope, \"pop file scope\")\n    assert(s !== p.pkgscope, \"pop file scope\")\n    assert(p.scope.outer != null, 'pop scope at base scope')\n\n    // dlog(` ${(p as any).scope.outer.level()} <- ${p.scope.level()}`)\n\n    p.scope = p.scope.outer as Scope\n\n    // check for unused declarations\n    if (s.decls) for (let [name, ent] of s.decls) {\n      if (ent.nreads == 0) {\n        if (ent.decl instanceof Field) {\n          p.diag(\"warn\", `${name} not used`, ent.decl.pos, (\n            ent.decl.scope.isFunScope ? 'E_UNUSED_PARAM' :\n            'E_UNUSED_FIELD'\n          ))\n        } else {\n          p.diag(\n            \"warn\",\n            `${name} declared and not used`,\n            ent.decl.pos,\n            'E_UNUSED_VAR'\n          )\n        }\n      }\n    }\n\n    return s\n  }\n\n  // declare registers decl and x in scope identified by name\n  //\n  declare(scope :Scope, ident: Ident, decl :Node, x: Expr|null) {\n    const p = this\n\n    if (ident.value === p._id__) {\n      // \"_\" is never declared\n      return\n    }\n\n    assert(ident.ent == null, `redeclaration of ${ident}`)\n\n    const ent = new Ent(ident.value, decl, x)\n    if (!scope.declareEnt(ent)) {\n      p.syntaxError(`${ident} redeclared`, ident.pos)\n    }\n\n    ident.ent = ent\n    // TODO: in the else branch, we could count locals/registers needed here.\n    // For instance, \"currFun().local_i32s_needed++\"\n  }\n\n  // declarev performs multiple declarations at once\n  //\n  declarev(scope :Scope, idents: Ident[], decl :Node, xs: Expr[]|null) {\n    const p = this\n    for (let i = 0; i < idents.length; ++i) {\n      p.declare(scope, idents[i], decl, xs && xs[i] || null)\n    }\n  }\n\n  // Resolve resolves ent of an Expr\n  //\n  // If x is an identifier, resolve attempts to resolve x by looking up\n  // the entity it denotes. If no entity is found and collectUnresolved is\n  // set, x is marked as unresolved and collected in the list of unresolved\n  // identifiers.\n  //\n  // Returns x\n  //\n  resolve<N extends Expr>(x :N, collectUnresolved :bool = true) :N {\n    const p = this\n\n    // nothing to do if x is not an identifier or the blank identifier\n    if (!(x instanceof Ident) || x.value === p._id__) {\n      return x\n    }\n\n    assert(x.ent == null, \"already resolved\")\n\n    // try to resolve the identifier\n    let s :Scope|null = x.scope\n    while (s) {\n      const ent = s.lookupImm(x.value)\n      if (ent) {\n        // dlog(`${x} found in scope#${s.level()}`)\n        x.refEnt(ent) // reference ent\n\n        if (!x.type) {\n          x.type = ent.type || p.types.markUnresolved(x)\n          if (x.type instanceof UnresolvedType) {\n            // references something that itself is undefined\n            x.type.addRef(x)\n          }\n        }\n\n        return x\n      }\n      s = s.outer\n    }\n\n    // dlog(`${x} not found`)\n    if (collectUnresolved) {\n      // all local scopes are known, so any unresolved identifier\n      // must be found either in the file scope, package scope\n      // (perhaps in another file), or universe scope --- collect\n      // them so that they can be resolved later\n      if (!p.unresolved) {\n        p.unresolved = new Set<Ident>([x])\n      } else {\n        p.unresolved.add(x)\n      }\n    }\n\n    return x\n  }\n\n  // ctxType returns the type of the context, or null if the type is not known\n  // or if the type can't be reliably inferred, in which case it should be\n  // resolved later on.\n  //\n  ctxType(ctx :exprCtx) :Type|null {\n    const p = this\n    if (ctx) {\n      if (ctx instanceof VarDecl) {\n        return ctx.type && p.types.maybeResolve(ctx.type) || null\n      }\n      if (ctx instanceof Assignment) {\n        // common case: single assignment\n        // we handle multi assignments later, in p.assignment()\n        return (\n          ctx.lhs && ctx.lhs.length == 1 ? p.types.maybeResolve(ctx.lhs[0]) :\n          null\n        )\n      }\n    }\n    return null\n  }\n\n  parseFile() :File {\n    const p = this\n    const imports = p.parseImports()\n    const decls = p.parseFileBody()\n\n    return new File(\n      p.sfile,\n      p.scope,\n      imports,\n      decls,\n      p.unresolved,\n    )\n  }\n\n  parseImports() :ImportDecl[] {\n    const p = this\n    //\n    // Imports     = ImportDecl? | ImportDecl (\";\" ImportDecl)*\n    // ImportDecl  = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" )\n    // ImportSpec  = [ \".\" | PackageName ] ImportPath\n    // ImportPath  = string_lit\n    //\n    let imports = [] as ImportDecl[]\n    while (p.got(token.IMPORT)) {\n      p.appendGroup(imports, p.importDecl)\n      p.want(token.SEMICOLON)\n    }\n    return imports\n  }\n\n  importDecl = (_ :Group|null) :ImportDecl => {\n    const p = this\n    let localIdent :Ident|null = null\n    let hasLocalIdent = false\n  \n    switch (p.tok) {\n      case token.NAME:\n        localIdent = p.ident()\n        hasLocalIdent = true\n        break\n\n      case token.DOT:\n        const s = p._id_dot\n        localIdent = new Ident(p.pos, p.scope, s)\n        p.next()\n        break\n    }\n\n    let path :StringLit\n    if (p.tok == token.STRING) {\n      path = p.strlit()\n    } else {\n      p.syntaxError(\"missing import path; expecting quoted string\")\n      path = new StringLit(p.pos, p.scope, kEmptyByteArray, t_str0)\n      p.advanceUntil(token.SEMICOLON, token.RPAREN)\n    }\n\n    const d = new ImportDecl(p.pos, p.scope, path, localIdent)\n\n    if (hasLocalIdent && localIdent) {\n      p.declare(p.filescope, localIdent, d, null)\n    }\n    \n    return d\n  }\n\n  parseFileBody() :Decl[] {\n    const p = this\n    const decls = [] as Decl[]\n\n    // { TopLevelDecl \";\" }\n    while (p.tok != token.EOF) {\n      switch (p.tok) {\n\n        case token.TYPE:\n          p.next() // consume \"type\"\n          p.appendGroup(decls, p.typeDecl)\n          break\n\n        case token.NAME:\n          const pos = p.pos\n          const idents = p.identList(p.ident())\n          decls.push(p.varDecl(pos, idents))\n          break\n\n        case token.FUN:\n          decls.push(p.funExpr(null))\n          break\n\n        // TODO: token.TYPE\n\n        default: {\n          if (\n            p.tok == token.LBRACE &&\n            decls.length > 0 &&\n            isEmptyFunExpr(decls[decls.length-1])\n          ) {\n            // opening { of function declaration on next line\n            p.syntaxError(\"unexpected semicolon or newline before {\")\n          } else {\n            p.syntaxError(\"non-declaration statement outside function body\")\n          }\n\n          p.error(`TODO file-level token \\`${tokstr(p.tok)}\\``); p.next()\n\n          p.advanceUntil(/*token.CONST, */token.TYPE, token.FUN)\n          continue\n        }\n      }\n\n      if ((p.tok as token) != token.EOF && !p.got(token.SEMICOLON)) {\n        p.syntaxError(\"after top level declaration\")\n        p.advanceUntil(/*token.CONST, */token.TYPE, token.FUN)\n      }\n    }\n\n    return decls\n  }\n\n  // checkDeclLen verifies that idents.length == nvalues, and if not,\n  // reports a syntax error.\n  // Returns true if lengths matches.\n  //\n  checkDeclLen(idents :Ident[], nvalues: number, kind :string) :bool {\n    const p = this\n    if (nvalues != idents.length) {\n      p.syntaxError(\n        `cannot assign ${nvalues} values to ${idents.length} ${kind}`,\n        idents[0].pos\n      )\n      return false\n    }\n    return true\n  }\n\n  typeDecl = (group :Group|null, _ :int) :TypeDecl => {\n    // TypeSpec = \"type\" identifier [ \"=\" ] Type\n    const p = this\n    const pos = p.pos\n    const ident = p.ident()\n    const alias = p.got(token.ASSIGN)\n\n    let t = p.maybeType()\n    if (!t) {\n      t = p.badTypeExpr()\n      p.syntaxError(\"in type declaration\")\n      p.advanceUntil(token.SEMICOLON, token.RPAREN)\n    }\n\n    const d = new TypeDecl(pos, p.scope, ident, alias, t as TypeExpr, group)\n    // TODO: declare in scope\n    return d\n  }\n\n  varDecl(pos :Pos, idents :Ident[]) :VarDecl|Assignment {\n    // VarDecl = IdentifierList\n    //           ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList )\n    const p = this\n    const typ = p.maybeType()\n    let isError = false\n\n    // vars at the file level are declared in the package scope\n    const scope = p.scope === p.filescope ? p.pkgscope : p.scope\n\n    // if (p.scope !== p.filescope && p.tok == token.ASSIGN) {\n    //   // produce Assignment instead\n    //   return p.assignment(idents, typ ? p.types.resolve(typ) : null)\n    // }\n\n    const d = new VarDecl(pos, scope, idents, null, typ, null)\n\n    if (p.got(token.ASSIGN)) {\n      // e.g. x, y = 1, 2\n      d.values = p.exprList(/*ctx=*/d)\n      isError = !p.checkDeclLen(idents, d.values.length, 'constants')\n    } else if (!typ) {\n      // e.g. `x` -- missing type or values\n      p.syntaxError(\"unexpected identifier\", pos)\n      isError = true\n      d.values = [p.bad()]\n      p.advanceUntil(token.SEMICOLON)\n    }\n\n    if (isError) {\n      return d\n    }\n\n    const reqt = d.type ? p.types.resolve(d.type) : null\n    p.processAssign(d.idents, d.values, d, reqt, /*onlyDef=*/true)\n\n    return d\n  }\n\n  funExpr(ctx :exprCtx) :FunExpr {\n    //\n    // FunExpr  = \"fun\" FunName? Signature? FunBody?\n    // FunName  = identifier\n    // FunBody  = ( Block | \"->\" Stmt )\n    //\n    // Note: FunName is required at file level in \"fun\" declarations\n    //\n    const p = this\n    const pos = p.pos\n    p.want(token.FUN)\n\n    const isTopLevel = p.scope === p.filescope\n\n    let name :Ident|null\n    let isInitFun = false\n\n    if (isTopLevel && !ctx) {\n      // case: statement(!ctx) at top-level\n      name = p.ident()\n      // functions called \"init\" at the file level are special\n      isInitFun = p.scope === p.filescope && name.value.equals(p._id_init)\n    } else {\n      name = p.maybeIdent()\n    }\n\n    // scope in which we will declare the function's name.\n    // declarations at the top-level are declared in the package scope.\n    const scope = isTopLevel ? p.pkgscope : p.scope\n\n    // new scope for parameters, signature and body\n    p.pushScope(new Scope(p.scope, null, /*isFunScope*/true))\n\n    // parse signature.\n    //\n    // Note: we use the default and special type constant \"auto\" for all\n    // functions but initi functions. This allows us to track multiple return\n    // sites and do type checking as we go.\n    //\n    // Additionally, p.funSig may find an explicit return type in which case\n    // it will use that instead. Whenever we encounter a return statement, we\n    // will check the expected return type with the actual return type.\n    //\n    const sig = p.funSig(isInitFun ? bitypes.nil : null)\n\n    const f = new FunExpr(pos, p.scope, name, sig, isInitFun)\n\n    if (isInitFun) {\n      // check initfun signature (should be empty)\n      if (sig.params.length > 0) {\n        p.syntaxError(`init function with parameters`, sig.pos)\n      }\n      if (sig.result !== bitypes.nil) {\n        p.syntaxError(`init function with result ${sig.result}`, sig.pos)\n      }\n    } else {\n      if (sig.result) {\n        // an explicit result type was provided -- resolve its type\n        p.types.resolve(sig.result)\n      }\n\n      if (name && !ctx) {\n        // The function itself is declared in its outer scope, so that its body\n        // can refer to the function, but also so that \"funname = x\" declares a\n        // new variable rather than replacing the function.\n        //\n        // The check for !ctx is to make sure that decorative names in\n        // expressions are not declared in the scope.\n        // E.g. the statement \"x = fun y(){}\" should only declare x in the scope,\n        // but not y.\n        p.declare(scope, name, f, f)\n      }\n    }\n\n    // parse body\n    if (!isTopLevel || isInitFun || ctx || p.tok != token.SEMICOLON) {\n\n      // Note: the following code can be enabled to disallow type-only param\n      // signatures for functions with bodies.\n      // e.g. \"fun foo(int, f32) {}\"\n      // if (sig.params.length > 0 && !sig.params[0].name) {\n      //   p.syntaxError(\n      //     `type-only parameters for function with body`,\n      //     sig.pos\n      //   )\n      // }\n\n      if (isInitFun) { p.initfnest++ }\n      p.pushFun(f)\n\n      f.body = p.funBody(name)\n      const fi = p.currFun()\n\n      p.popFun()\n      if (isInitFun) { p.initfnest-- }\n\n      // pop function body scope before resolving types.\n      // otherwise we would run the risk of resolving a type to something\n      // that's defined in the function body itself which may shadow outer\n      // definitions.\n      p.popScope()\n\n      if (f.body instanceof Block) {\n        if (!sig.result) {\n          // auto result of block = nil\n          //\n          // e.g.  fun foo() { ... }\n          //   =>  fun foo() nil { ... }\n          //\n          sig.result = bitypes.nil\n        } else if (!isInitFun && sig.result !== bitypes.nil) {\n          // convert implicit return to explicit return\n          //\n          // e.g.  fun foo() i32 { 3 }\n          //   =>  fun foo() i32 { return 3 }\n          //\n          let lastindex = f.body.list.length - 1\n          let result = f.body.list[lastindex]\n          if (result instanceof Expr) {\n            let rettype = p.types.resolve(result)\n            let ret = new ReturnStmt(result.pos, result.scope, result, rettype)\n            f.body.list[lastindex] = ret\n          }\n        }\n      } else if (!sig.result) {\n        // expression body with auto result type\n        //\n        // e.g.  fun foo() -> 3\n        //   =>  fun foo() i32 -> 3\n        //\n        // inferred result type\n        if (!fi.inferredReturnType) {\n          // no return statements encountered.\n          // set result type to same as the body\n          sig.result = GetTypeExpr(p.types.resolve(f.body))\n        } else if (fi.inferredReturnType.types.size == 1) {\n          // single return type (note: may be void if found `return;`)\n          sig.result = GetTypeExpr(fi.inferredReturnType.types.values().next().value)\n        } else {\n          // union type\n          sig.result = GetTypeExpr(fi.inferredReturnType)\n        }\n      }\n    } else {\n      if (sig.result === null) {\n        // auto\n        // for functions without a body and that is missing an explicit\n        // result type, nil/void is assumed.\n        sig.result = bitypes.nil\n      }\n      p.popScope()\n    }\n\n    if (sig.result instanceof UnresolvedType) {\n      sig.result.addRef(sig)\n    }\n\n    const funtype = p.types.resolve(f) as FunType\n    assert(funtype.constructor === FunType) // funtype always resolves\n\n    if (name && name.value !== p._id__ && !isInitFun) {\n      // since we declared the name of the function, the name now represents\n      // the function and thus its type.\n      name.type = funtype\n    }\n\n    return f\n  }\n\n  // TODO: maybeFunExpr() :Expr -- FunExpr or some other expr\n  // FunExpr = \"fun\" FunName? Signature FunBody\n  // FunName = identifier\n  // FunBody  = ( Block | \"->\" Stmt )\n\n  // funSig parses a function signature\n  //\n  // Signature = ( Parameters Result? | Type )?\n  //\n  funSig(defaultType :TypeExpr | null): FunSig {\n    const p = this\n    const pos = p.pos\n    const params = p.tok == token.LPAREN ? p.parameters() : []\n    const result = p.maybeType() || defaultType\n    return new FunSig(pos, p.scope, params, result)\n  }\n\n  // parameters parses a parameter list\n  //\n  // This is a pretty complicated function since parameter lists\n  // has complex semantics.\n  // Three syntax modes are supported:\n  //   type, type\n  //   OR\n  //   ( name type, name type\n  //     AND\n  //     name, name type )\n  //\n  // Parameters    = \"(\" [ ParameterList [ \",\" ] ] \")\"\n  // ParameterList = ParameterDecl (\",\" ParameterDecl)*\n  // ParameterDecl = [ NameList ] [ \"...\" ] Type\n  //\n  parameters() :Field[] {\n    // examples:\n    //\n    // (T)\n    // (x T)\n    // (x, y, z T)\n    // (... T)\n    // (x  ... T)\n    // (x, y, z  ... T)\n    // (T1, T2, T3)\n    // (T1, T2, ... T3)\n    //\n    const p = this\n    p.want(token.LPAREN)\n\n    let named = 0   // parameters that have an explicit name and type\n    let seenRestTypeExpr = false\n    const paramsPos = p.pos\n    const fields = [] as Field[]\n    const scope = p.scope\n\n    while (p.tok != token.RPAREN) {\n      let pos = p.pos\n      // let f = new Field(p.pos, scope, t_nil, p.ident())\n      \n      let typ :Expr|null = null\n      let name :Ident|null = null\n\n      // parse type or name\n      if (p.tok == token.NAME) {\n        typ = p.dotident(null, p.ident())\n      } else {\n        // Note: No need to check for \";\" or \")\" since the \"while\" condition\n        // checks for \")\" and an empty parameter set with linebreaks never\n        // produces a semicolon implicitly. I.e. \"foo(<LF><LF>)\" == \"foo()\"\n        // However, it's a syntax error to write \"foo(;)\"\n        const x = p.maybeType()\n        if (x) {\n          typ = x\n        } else {\n          typ = p.badTypeExpr()\n          p.syntaxError(\"expecting name or type\")\n          // p.next()\n        }\n      }\n\n      if (p.tok != token.COMMA &&\n          p.tok != token.SEMICOLON &&\n          p.tok as token != token.RPAREN)\n      {\n        // e.g. func(T), func(... T)\n\n        // move typ -> name as we are about to parse the actual type\n        if (typ) {\n          // e.g. func(name T)\n          if (typ instanceof Ident) {\n            name = typ\n            named++\n          } else {\n            // e.g. func(a.b.c T)\n            p.syntaxError(\"illegal parameter name\", pos)\n          }\n        }\n\n        // parse type\n        if (p.got(token.ELLIPSIS)) {\n          const x = p.maybeType()\n          if (x) {\n            let t = new RestType(p.types.resolve(x))\n            typ = new RestTypeExpr(pos, scope, x, t)\n          } else {\n            typ = p.badTypeExpr()\n            p.syntaxError(\"expecting type after ...\")\n          }\n          if (seenRestTypeExpr) {\n            p.syntaxError(\"can only use ... with final parameter\")\n            continue  // skip this field\n          } else {\n            seenRestTypeExpr = true\n          }\n        } else {\n          typ = p.type()\n        }\n      } // else if (typ instanceof Ident) {}\n\n      // restType() :RestTypeExpr {\n      //   // RestType = \"...\" Expr?\n      //   const p = this\n      //   const pos = p.pos\n      //   p.want(token.ELLIPSIS)\n      //   const rt = new RestTypeExpr(pos, p.scope, p.type())\n      //   p.types.resolve(rt)\n      //   return rt\n      // }\n\n      // parse optional comma, or break on error\n      if (!p.ocomma(token.RPAREN)) {\n        // error: unexpected SOMETHING, expecting comma, or )\n        // e.g. \"fun foo(a, b<LF>)\" fix -> \"fun foo(a, b,<LF>)\"\n        //                                              ^\n        break\n      }\n\n      // Note: OK that typ is an Ident here. We may edit this later\n      // TODO: cleaner way of doing this\n      fields.push(new Field(pos, scope, typ as TypeExpr, name))\n    }\n\n    p.want(token.RPAREN)\n\n    // distribute parameter types\n    if (named == 0) {\n      // none named -- types only\n      for (let f of fields) {\n        p.resolve(f.type)\n      }\n    } else {\n\n      if (named < fields.length) {\n        // All named, some has types, e.g. func(a, b B, c ...C)\n        // some named => all must be named\n        let ok = true\n        let typ :TypeExpr|null = null\n        let t :Type = t_nil\n\n        for (let i = fields.length - 1; i >= 0; --i) {\n          const f = fields[i]\n\n          if (!f.name) {\n            // is a single-name param (name is actually on .type)\n            if (f.type instanceof Ident) {\n              f.name = f.type\n              if (typ) {\n                f.type = typ\n                f.name.type = t\n              } else {\n                // f.type == nil && typ == null => we only have a f.name\n                ok = false\n                f.type = p.badTypeExpr(f.type.pos)\n              }\n            } else {\n              p.syntaxError(\"illegal parameter name\", f.type.pos)\n            }\n          } else if (f.type) {\n            p.resolve(f.type)\n            t = p.types.resolve(f.type)\n            typ = f.type\n            if (typ instanceof RestTypeExpr) {\n              // unbox rest type, e.g. \"...typ\" -> \"typ\"\n              const tx = typ.expr\n              assert(tx.type, 'unresolved type')\n              typ = new TypeExpr(tx.pos, tx.scope, tx.type as Type)\n            }\n            if (f.name) {\n              f.name.type = t\n            } else {\n              ok = false\n              f.name = p.fallbackIdent(typ.pos)\n            }\n          }\n\n          if (!ok) {\n            p.syntaxError(\n              \"mixed named and unnamed function parameters\",\n              paramsPos\n            )\n            break\n          }\n\n          // declare name in function scope\n          assert(f.name != null)\n          p.declare(scope, f.name as Ident, f, null)\n        }\n      } else {\n        // All named, all have types\n        // declare names in function scope\n        for (let f of fields) {\n          assert(f.name != null)\n          p.resolve(f.type)\n          ;(f.name as Ident).type = p.types.resolve(f.type)\n          p.declare(scope, f.name as Ident, f, null)\n        }\n      }\n    }\n\n    return fields\n  }\n\n  funBody(funcname :Ident|null) :Expr {\n    // FunBody = ( Block | \"->\" Expr )\n    const p = this\n\n    if (p.tok == token.LBRACE) {\n      // Block\n      return p.block()\n      // let b = p.block()\n      // if (b.list.length > 0) {\n      //   let laststmt = b.list[b.list.length-1]\n      //   if (laststmt instanceof ReturnExpr) {\n      //     // unwrap \"return\" when it is the last statement in a function, since\n      //     // last statement is implicit.\n      //     b.list[b.list.length-1] = laststmt.result\n      //   }\n      // }\n      // return b\n    }\n\n    if (p.got(token.ARROWR)) {\n      // \"->\" Expr\n      return p.expr(/*ctx=*/null)\n      // let x = p.expr(/*ctx=*/null)\n      // if (x instanceof ReturnExpr) {\n      //   // unwrap \"return\" when it is the last statement in a function, since\n      //   // last statement is implicit.\n      //   return x.result\n      // }\n      // return x\n    }\n\n    // error\n    const pos = p.pos\n    if (funcname) {\n      p.syntaxError(`${funcname} is missing function body`, pos)\n    } else {\n      p.syntaxError(\"missing function body\", pos)\n    }\n    return p.bad(pos)\n  }\n\n  // block parses a block expression.\n  // The caller manages scope (push/pop if required)\n  //\n  block() :Block {\n    // Block = \"{\" StatementList \"}\" | Stmt\n    const p = this\n    const pos = p.pos\n    p.want(token.LBRACE)\n    const list = p.stmtList()\n    p.want(token.RBRACE)\n    return new Block(pos, p.scope, list)\n  }\n\n  multiDecl<D extends Decl>(f :(g:Group|null, i:int)=>D) :MultiDecl {\n    const p = this\n    const pos = p.pos\n    p.next() // e.g. TYPE\n    const decls :Decl[] = []\n    p.appendGroup(decls, f)\n    return new MultiDecl(pos, p.scope, decls)\n  }\n\n  stmtList() :Stmt[] {\n    // StatementList = { Statement \";\" }\n    const p = this\n    const list = [] as Stmt[]\n\n    while (p.tok != token.EOF &&\n           p.tok != token.RBRACE &&\n           // p.tok != token.CASE &&\n           p.tok != token.DEFAULT)\n    {\n      const s = p.maybeStmt()\n      if (!s) {\n        break\n      }\n      list.push(s)\n      // customized version of osemi:\n      // ';' is optional before a closing ')' or '}'\n      if (p.tok == token.RPAREN || p.tok as token == token.RBRACE) {\n        continue\n      }\n      if (!p.got(token.SEMICOLON)) {\n        p.syntaxError(\"at end of statement\")\n        p.advanceUntil(token.SEMICOLON, token.RBRACE)\n      }\n    }\n\n    return list\n  }\n\n  // shouldStoreToEnt returns true if ent is within atScope in such a way\n  // that \"ent = value\" means \"store value to ent\".\n  //\n  shouldStoreToEnt(ent :Ent, atScope :Scope) :bool {\n    const p = this\n    return (\n      ent.scope === atScope  // same scope\n      ||\n      ( ent.scope !== p.filescope &&\n        ( ( ent.scope === p.pkgscope &&\n            atScope.fun && atScope.fun.isInit )\n          ||\n          ent.scope.funScope() === atScope.funScope()\n        )\n      )\n    )\n  }\n\n\n  processAssign(\n    lhs :Expr[],\n    rhs :Expr[]|null,\n    decl :Node,\n    reqt :Type|null,\n    onlyDef :bool,\n  ) {\n    const p = this\n\n    // TODO refactor this and move this function (that has a closure)\n    function maybeConvRVal(typ :Type, rval :Expr, index :int) {\n      if (\n        !(rval.type instanceof UnresolvedType) &&\n        !(typ instanceof UnresolvedType)\n      ) {\n        const convx = p.types.convert(typ, rval)\n        if (!convx) {\n          if (rval.type instanceof UnresolvedType) {\n            // unresolved\n            return \n          }\n          p.error(\n            (rval.type instanceof UnresolvedType ?\n              `cannot convert \"${rval}\" to type ${typ}` :\n              `cannot convert \"${rval}\" (type ${rval.type}) to type ${typ}`\n            ),\n            rval.pos\n          )\n        } else if (convx !== rval) {\n          // no error and conversion is needed.\n          // replace original expression with conversion expression\n          assert(rhs != null)\n          ;(rhs as any)[index] = convx\n        }\n      }\n    }\n\n    // Check each left-hand identifier against scope and unresolved.\n    // Note that exprList already has called p.resolve on all ids.\n    //\n    // If an id has an ent (i.e. was resolved to something), then we simply\n    // register the assignment with it so that we can later bind.\n    //\n    // If an id is unresolved (doesn't have an ent), the semantics are:\n    // - assume it's a constant definition and declare it as such\n    // - register the assignment so that if we later find a var in the outer\n    //   scope, we can convert the declaration to an assignment.\n    //\n    for (let i = 0; i < lhs.length; ++i) {\n      const id = lhs[i]\n\n      if (!(id instanceof Ident)) {\n        dlog(`TODO LHS is not an id (type is ${id.constructor.name})`)\n        continue\n      }\n\n      // Decide to store to an existing ent, or declare a new one\n      if (!onlyDef && rhs && id.ent && p.shouldStoreToEnt(id.ent, id.scope)) {\n        const rval = rhs[i]\n\n        id.incrWrite()\n\n        let typ = id.ent.type\n        if (!typ) {\n          const typexpr = id.ent.getTypeExpr()\n          assert(typexpr != null, 'null ent (internal parser error)')\n          typ = p.types.resolve(typexpr as Expr)\n        }\n\n        // const typexpr = id.ent.getTypeExpr()\n        // assert(typexpr != null)\n        // const typ = p.types.resolve(typexpr as Expr)\n\n        // check & resolve type, converting rval if needed\n        id.type = typ\n        maybeConvRVal(typ, rval, i)\n\n        continue\n      }\n\n      id.ent = null\n      \n      // new declaration\n      //\n      // since we are about to redeclare, clear any \"unresolved\" mark for\n      // this identifier expression.\n      const rval = rhs ? rhs[i] : null\n\n      if (reqt) {\n        id.type = reqt\n        if (rval) {\n          // see if we need to convert the rval to fit the destination type\n          maybeConvRVal(reqt, rval, i)\n        }\n      } else {\n        assert(rval, \"processAssign called with no reqt and no rvals\")\n        id.type = p.types.resolve(rval as Expr)\n      }\n      \n      if (p.unresolved) { p.unresolved.delete(id) } // may be noop\n      p.declare(id.scope, id, decl, rval)\n\n      if (id.type instanceof UnresolvedType) {\n        id.type.addRef(id)\n      }\n\n    } // end for loop\n  }\n\n\n  assignment(lhs :Expr[], reqt :Type|null = null) :Assignment {\n    // Assignment = ExprList \"=\" ExprList\n    const p = this\n    p.want(token.ASSIGN) // \"=\"\n\n    const s = new Assignment(lhs[0].pos, p.scope, token.ASSIGN, lhs, [])\n\n    // parse right-hand side in context of the function\n    s.rhs = p.exprList(/*ctx=*/s)\n\n    p.processAssign(s.lhs, s.rhs, s, /*reqt=*/reqt, /*onlyDef=*/false)\n\n    p.types.resolve(s)\n\n    return s\n  }\n\n  // simpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt\n  //            | Assignment | VarDecl\n  simpleStmt(lhs :Expr[]) :Stmt {\n    const p = this\n\n    // Note: token.SET_ASSIGN \":=\" is currently unused\n    // we could use it to allow shadowing in same scope, e.g.\n    //   \"b = 4; b := true\" where \"b :=\" redeclares b.\n\n    if (p.tok == token.ASSIGN) {\n      // e.g.  \"a = 1\"  \"a, b = 1, 2\"  \"a[1], b.f = 1, 2\"  etc\n      return p.assignment(lhs)\n    }\n\n    if (p.tok == token.NAME && lhs.every(x => x instanceof Ident)) {\n      // var definition\n      // e.g. \"a T\", \"a, b, c T\" -- declare var with type T\n\n      // first, revert either bindings or unresolved mark of LHS idents\n      for (let i = 0; i < lhs.length; i++) {\n        let x = lhs[i] as Ident\n        if (x.ent) {\n          x.unrefEnt()\n        } else {\n          assert(p.unresolved != null)\n          ;(p.unresolved as Set<Ident>).delete(x)\n        }\n      }\n\n      // now, form a var declaration (next up may be assignment and values)\n      return p.varDecl(lhs[0].pos, lhs as Ident[])\n    }\n\n    const pos = lhs[0].pos\n\n    if (lhs.length != 1) {\n      p.syntaxError('expecting \"=\" or \",\"')\n      p.advanceUntil(token.SEMICOLON, token.RBRACE)\n      return lhs[0]\n    }\n\n    // single expression\n\n    let t = p.types.resolve(lhs[0])\n\n    if (token.assignop_beg < p.tok && p.tok < token.assignop_end) {\n      // lhs op= rhs;  e.g. \"x += 2\"\n      let op = p.tok\n      p.next() // consume operator\n\n      // map assign ops to regular ops.\n      // e.g. \"(assign += x 2)\" => \"(assign + x 2)\"\n      switch (op) {\n        case token.ADD_ASSIGN:     op = token.ADD; break  // +\n        case token.SUB_ASSIGN:     op = token.SUB; break  // -\n        case token.MUL_ASSIGN:     op = token.MUL; break  // *\n        case token.QUO_ASSIGN:     op = token.QUO; break  // /\n        case token.REM_ASSIGN:     op = token.REM; break  // %\n        case token.AND_ASSIGN:     op = token.AND; break  // &\n        case token.OR_ASSIGN:      op = token.OR;  break  // |\n        case token.XOR_ASSIGN:     op = token.XOR; break  // ^\n        case token.SHL_ASSIGN:     op = token.SHL; break  // <<\n        case token.SHR_ASSIGN:     op = token.SHR; break  // >>\n        case token.AND_NOT_ASSIGN: op = token.AND_NOT; break // &^\n        default:\n          assert(false, `unexpected operator token ${token[op]}`)\n      }\n\n      const s = new Assignment(pos, p.scope, op, lhs, [])\n      s.rhs = p.exprList(/*ctx=*/s)\n      p.types.resolve(s)\n      return s\n    }\n\n    if (p.tok == token.INC || p.tok == token.DEC) {\n      // lhs++ or lhs--\n      const op = p.tok\n      p.next() // consume operator\n\n      if (!(t instanceof IntType) && !(t instanceof UnresolvedType)) {\n        // lhs is not a mutable type. For instance, it might be str.\n        this.syntaxError(`cannot mutate ${lhs[0]}`, lhs[0].pos)\n      }\n\n      let s = new Assignment(pos, p.scope, op, lhs, emptyExprList)\n      p.types.resolve(s)\n      return s\n    }\n\n    if (p.tok == token.ARROWL) {\n      // lhs <- rhs\n      p.syntaxError(\"TODO simpleStmt ARROWL\")\n    }\n\n    if (p.tok == token.ARROWR) {\n      // params -> result\n      p.syntaxError(\"TODO simpleStmt ARROWR\")\n    }\n\n    // else: expr\n    return lhs[0]\n  }\n\n\n  maybeStmt() :Stmt|null {\n    // Statement =\n    //   Declaration | LabeledStmt | simpleStmt |\n    //   GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n    //   FallthroughStmt | Block | IfExpr | SwitchStmt | SelectStmt | ForStmt |\n    //   DeferStmt .\n    const p = this\n\n    switch (p.tok) {\n      // Most statements (assignments) start with an identifier;\n      // look for it first before doing anything more expensive.\n      case token.NAME:\n      case token.NAMEAT:\n        return p.simpleStmt(p.exprList(/*ctx=*/null))\n\n      case token.LBRACE:\n        p.pushScope()\n        const s = p.block()\n        p.popScope()\n        return s\n\n      case token.TYPE:\n        return p.multiDecl(p.typeDecl)\n\n      case token.ADD:\n      case token.SUB:\n      case token.MUL:\n      case token.AND:\n      case token.NOT:\n      case token.XOR: // unary operators\n      case token.FUN:\n      case token.LPAREN: // operands\n      case token.LBRACKET:\n      // case token.STRUCT:\n      // case token.CHAN:\n      case token.INTERFACE: // composite types\n      // case token.ARROW: // receive operator\n        return p.simpleStmt(p.exprList(/*ctx=*/null))\n\n      // case token.FOR:\n      //   return p.forStmt()\n\n      // case token.SWITCH:\n      //   return p.switchStmt()\n\n      // case token.SELECT:\n      //   return p.selectStmt()\n\n      case token.WHILE:\n        return p.whileStmt()\n\n      case token.IF:\n        return p.ifExpr(/*ctx=*/null)\n\n      // case token.FALLTHROUGH:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   p.next()\n      //   s.Tok = _Fallthrough\n      //   return s\n\n      // case token.BREAK, token.CONTINUE:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   s.Tok = p.tok\n      //   p.next()\n      //   if p.tok == _Name {\n      //     s.Label = p.name()\n      //   }\n      //   return s\n\n      // case token.GO, token.DEFER:\n      //   return p.callStmt()\n\n      // case token.GOTO:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   s.Tok = _Goto\n      //   p.next()\n      //   s.Label = p.name()\n      //   return s\n\n      case token.RETURN:\n        return p.returnStmt()\n\n      // case token.SEMI:\n      //   s := new(EmptyStmt)\n      //   s.pos = p.pos()\n      //   return s\n\n      default:\n        if (token.literal_beg < p.tok && p.tok < token.literal_end) {\n          return p.simpleStmt(p.exprList(/*ctx=*/null))\n        }\n    }\n\n    return null\n  }\n\n  whileStmt() :WhileStmt {\n    //\n    // WhileStmt = \"while\" Expression Block\n    //\n    const p = this\n    const pos = p.pos\n    const scope = p.scope\n\n    p.want(token.WHILE)\n\n    const cond = p.expr(/*ctx=*/null)\n    p.types.resolve(cond)\n\n    const body = p.expr(/*ctx=*/null)\n\n    return new WhileStmt(pos, scope, cond, body)\n  }\n\n  ifExpr(ctx :exprCtx) :IfExpr {\n    //\n    // IfExpr = \"if\" Expression Block\n    //          [ \"else\" ( IfExpr | Block ) ]\n    //\n    // e.g. `if x > 1 \"large\" else \"small\"`\n    // e.g. `if x = size() > 1 print(\"large number: $x\")`\n    //\n    const p = this\n\n    // push a scope for conditions to support e.g. capture of x in\n    //   if x = a() > 0 print(\"$x > 0\") else print(\"$x < 0\")\n    //\n    p.pushScope()\n    const s = p.ifExpr2(ctx)\n    p.popScope()\n\n    return s\n  }\n\n  ifExpr2(ctx :exprCtx) :IfExpr {\n    // used by ifExpr\n    const p = this\n    const pos = p.pos\n    const scope = p.scope\n\n    p.want(token.IF)\n\n    const cond = p.expr(ctx)\n    p.types.resolve(cond)\n\n    const then = p.expr(ctx)\n\n    const s = new IfExpr(pos, scope, cond, then, null)\n\n    if (p.got(token.ELSE)) {\n      if (p.tok == token.IF) {\n        s.els_ = p.ifExpr2(ctx)\n      } else {\n        p.pushScope()\n        s.els_ = p.expr(ctx)\n        p.popScope()\n      }\n    }\n\n    return s\n  }\n\n  returnStmt() :ReturnStmt {\n    const p = this\n    const pos = p.pos\n\n    p.want(token.RETURN)\n\n    // expected return type (may be null (auto); bitypes.nil for init)\n    const fi = p.currFun()\n    const frtype = fi.f.sig.result\n\n    assert(\n      !frtype || frtype.type instanceof Type,\n      \"currFun sig.result type not resolved\"\n    )\n\n    const n = new ReturnStmt(pos, p.scope, bitypes.nil, t_nil)\n\n    if (p.tok == token.SEMICOLON || p.tok == token.RBRACE) {\n      // no result; just \"return\"\n      if (frtype !== bitypes.nil) {\n        if (frtype === null && fi.inferredReturnType == null) {\n          // patch current function's signature: nil result type\n          fi.f.sig.result = bitypes.nil\n        } else {\n          // if `fi.inferredReturnType != null` that means the block returns\n          // both some type and nothing, which is invalid.\n          p.syntaxError(\n            `missing return value; expecting ${fi.inferredReturnType || frtype}`\n          )\n        }\n      }\n      return n\n    }\n\n    // expecting one or more results to follow \"return\"\n\n    const xs = p.exprList(/*ctx=*/null) // ?: maybe pass TupleExpr as ctx?\n\n    let rval = (\n      xs.length == 1 ? xs[0] :\n        // e.g. \"return 1\", \"return (1, 2)\"\n\n      new TupleExpr(xs[0].pos, xs[0].scope, xs)\n        // Support paren-less tuple return\n        // e.g. \"return 1, 2\" == \"return (1, 2)\"\n    )\n\n    if (frtype === bitypes.nil) {\n      p.syntaxError(\"function does not return a value\", rval.pos)\n      return n\n    }\n\n    const rtype = p.types.resolve(rval)\n    n.result = rval\n    n.type = rtype\n\n    if (frtype === null) {\n      // return type is auto -- register inferred result type\n      fi.addInferredReturnType(rtype)\n\n    } else {\n      assert(frtype.type)\n      const funResType = frtype.type as Type\n      if (\n        !(rtype instanceof UnresolvedType) && // type is known, and\n        !rtype.equals(funResType) // type is different than function's ret type\n      ) {\n        // attempt type conversion; rtype -> frtype.type\n        const convexpr = p.types.convert(funResType, rval)\n        if (convexpr) {\n          n.result = convexpr\n          n.type = funResType\n        } else {\n          // error: type mismatch\n          p.syntaxError(\n            (rval.type instanceof UnresolvedType ?\n              `cannot use \"${rval}\" as return type ${frtype}` :\n              `cannot use \"${rval}\" (type ${rval.type}) as return type ${frtype}`\n            ),\n            rval.pos\n          )\n        }\n      }\n    }\n\n    return n\n  }\n\n  exprList(ctx :exprCtx) :Expr[] {\n    // ExpressionList = Expression ( \",\" Expression )*\n    const p = this\n    const list = [p.expr(ctx)]\n    while (p.got(token.COMMA)) {\n      list.push(p.expr(ctx))\n    }\n    return list\n  }\n\n  expr(ctx :exprCtx) :Expr {\n    const p = this\n    return p.binaryExpr(prec.LOWEST, ctx)\n  }\n\n  binaryExpr(pr :prec, ctx :exprCtx) :Expr {\n    // Expression = UnaryExpr | Expression binary_op Expression\n    const p = this\n    let x = p.unaryExpr(ctx)\n\n    while (\n      (token.operator_beg < p.tok && p.tok < token.operator_end) &&\n      p.prec > pr)\n    {\n      const pos = p.pos\n      const tprec = p.prec\n      const op = p.tok\n      p.next()\n      x = new Operation(pos, p.scope, op, x, p.binaryExpr(tprec, ctx))\n\n      p.types.resolve(x)\n      // Note: We need to resolve types here rather than outside this\n      // loop since x may be an identifier in the left-hand-side of an\n      // assignment operation, which would cause type resolution to fail,\n      // which is slow.\n    }\n\n    return x\n  }\n\n  unaryExpr(ctx :exprCtx) :Expr {\n    // UnaryExpr = PrimaryExpr | unary_op UnaryExpr\n    const p = this\n    const t = p.tok\n    const pos = p.pos\n\n    switch (t) {\n      case token.ADD:\n      case token.SUB:\n      case token.NOT:\n      case token.XOR: {\n        p.next()\n        // unaryExpr may have returned a parenthesized composite literal\n        // (see comment in operand)\n        let x = new Operation(pos, p.scope, t, p.unaryExpr(ctx))\n        p.types.resolve(x)\n\n        let isint = x.type instanceof IntType\n        if (!isint && t != token.ADD && t != token.SUB) {\n          p.syntaxError(\n            `invalid operation ${tokstr(t)} ${p.types.resolve(x.x)}`\n          )\n        }\n\n        return x\n        // legacy: unparen(p.unaryExpr(ctx)) to unwrap ParenExpr.\n      }\n\n      // TODO: case token.ARROWL; `<-x`, `<-chan E`\n    }\n\n    return p.primExpr(ctx)\n  }\n\n\n  primExpr(ctx :exprCtx) :Expr {\n    // PrimaryExpr =\n    //   Operand |\n    //   Conversion |\n    //   PrimaryExpr Selector |\n    //   PrimaryExpr Index |\n    //   PrimaryExpr Slice |\n    //   PrimaryExpr TypeAssertion |\n    //   PrimaryExpr Arguments .\n    //\n    // Selector       = \".\" identifier .\n    // Index          = \"[\" Expression \"]\" .\n    // Slice          = \"[\" ( [ Expression ] \":\" [ Expression ] ) |\n    //                      ( [ Expression ] \":\" Expression \":\" Expression )\n    //                  \"]\" .\n    // TypeAssertion  = \".\" \"(\" Type \")\" .\n    // Arguments      = \"(\"\n    //   [ (  ExpressionList | Type [ \",\" ExpressionList ] ) [ \"...\" ] [ \",\" ]]\n    //   \")\" .\n    const p = this\n    let x = p.operand(ctx)\n\n    loop:\n    while (true) switch (p.tok) {\n\n      case token.LPAREN:\n        x = p.call(x, ctx)\n        break  // may be more calls, e.g. foo()()()\n\n      case token.LBRACKET:\n        x = p.bracketExpr(x, ctx)\n        break\n\n      case token.DOT:\n        x = p.selectorExpr(x, ctx)\n        break\n\n      default:\n        break loop\n    }\n\n    return x\n  }\n\n\n  call(fun :Expr, ctx :exprCtx) :CallExpr {\n    // Arguments = \"(\" [\n    //     ( ExpressionList | Type [ \",\" ExpressionList ] )\n    //     [ \"...\" ] [ \",\" ]\n    //   ] \")\"\n    const p = this\n\n    // call or conversion\n    // convtype '(' expr ocomma ')'\n    const pos = p.pos\n    const args = [] as Expr[]\n    let hasDots = false\n\n    p.want(token.LPAREN)\n    // p.xnest++\n\n    while (p.tok != token.EOF && p.tok != token.RPAREN) {\n      args.push(p.expr(ctx))\n      hasDots = p.got(token.ELLIPSIS)\n      if (!p.ocomma(token.RPAREN) || hasDots) {\n        break\n      }\n    }\n\n    // p.xnest--\n    p.want(token.RPAREN)\n\n    return new CallExpr(pos, p.scope, fun, args, hasDots)\n  }\n\n\n  operand(ctx :exprCtx) :Expr {\n    // Operand   = Literal | OperandName | MethodExpr | \"(\" Expression \")\" .\n    // Literal   = NumLit | string_lit | CompositeLit | FunctionLit .\n    // NumLit    = int_lit | float_lit\n    // OperandName = identifier | QualifiedIdent.\n    const p = this\n\n    switch (p.tok) {\n      case token.NAME:\n      case token.NAMEAT:\n        return p.dotident(ctx, p.resolve(p.ident()))\n\n      case token.LPAREN:\n        return p.parenExpr(ctx)\n\n      case token.FUN:\n        return p.funExpr(ctx)\n\n      case token.LBRACE:\n        p.pushScope()\n        const b = p.block()\n        p.popScope()\n        return b\n\n      case token.IF:\n        return p.ifExpr(ctx)\n\n      // case _Lbrack, _Chan, _Map, _Struct, _Interface:\n      //   return p.type_() // othertype\n\n      case token.STRING:\n        return p.strlit()\n\n      case token.INT:\n      case token.INT_BIN:\n      case token.INT_OCT:\n      case token.INT_HEX:\n        return p.intLit(ctx, p.tok)\n\n      case token.CHAR:\n        return p.charLit(ctx)\n\n      case token.FLOAT:\n        return p.floatLit(ctx)\n\n      default: {\n        const x = p.bad()\n        p.syntaxError(\"expecting expression\")\n        // p.next()\n        return x\n      }\n    }\n  }\n\n\n  charLit(ctx :exprCtx) :NumLit {\n    const p = this\n    assert(p.int32val >= 0, 'negative character value')\n    const x = new CharLit(p.pos, p.scope, p.int32val)\n    p.next() // consume literal token\n    return p.numLitConv(x, p.ctxType(ctx))\n  }\n\n\n  floatLit(ctx :exprCtx) :NumLit {\n    const p = this\n    assert(!isNaN(p.floatval), 'scanner produced invalid number')\n    const x = new FloatLit(p.pos, p.scope, p.floatval, t_f64)\n    p.next() // consume literal token\n    return p.numLitConv(x, p.ctxType(ctx))\n  }\n\n\n  intLit(\n    ctx :exprCtx,\n    tok :token.INT | token.INT_BIN | token.INT_OCT | token.INT_HEX,\n  ) :NumLit {\n    const p = this\n    let x :IntLit\n\n    // prefer signed integer types when the value fits\n    if (p.int64val) {\n      if (p.int64val.isSigned || p.int64val.lte(SInt64.MAX)) {\n        x = new IntLit(p.pos, p.scope, p.int64val.toSigned(), t_i64, tok)\n      } else {\n        assert(p.int64val instanceof UInt64)\n        x = new IntLit(p.pos, p.scope, p.int64val, t_u64, tok)\n      }\n    } else {\n      const t = p.int32val <= 0x7fffffff ? t_i32 : t_u32\n      x = new IntLit(p.pos, p.scope, p.int32val, t, tok)\n    }\n\n    p.next() // consume literal token\n    return p.numLitConv(x, p.ctxType(ctx))\n  }\n\n\n  // numLitConv may convert x (in-place) to a different type as requested\n  // by reqt.\n  //\n  numLitConv(x :NumLit, reqt :Type | null) :NumLit {\n    if (reqt) {\n      const p = this\n      // a certain type was requested\n      if (reqt instanceof NumType) {\n        // capture refs to current type and value before converting, as\n        // convertToType may change these properties.\n        if (!x.convertToType(reqt)) {\n          let xt = x.type\n          let xv = x.value\n          if ((xt instanceof IntType) == (reqt instanceof IntType)) {\n            p.syntaxError(`constant ${xv} overflows ${reqt.name}`, x.pos)\n          } else {\n            p.syntaxError(`constant ${xv} truncated to ${reqt.name}`, x.pos)\n          }\n        }\n      } else {\n        // reqt is not a number type\n        p.syntaxError(`invalid value ${x.value} for type ${reqt}`, x.pos)\n      }\n    }\n    return x\n  }\n\n\n  numLitErrH = (msg :string, pos :Pos) => {\n    this.syntaxError(msg, pos)\n  }\n\n\n  strlit() :StringLit {\n    const p = this\n    assert(p.tok == token.STRING)\n    const bytes = p.takeByteValue()\n    const t = p.types.getStrType(bytes.length)\n    const n = new StringLit(p.pos, p.scope, bytes, t)\n    p.next()\n    return n\n  }\n\n\n  // SelectorExpr = Expr \".\" ( Ident | IntLit )\n  //\n  selectorExpr(operand :Expr, ctx :exprCtx) :SelectorExpr|IndexExpr {\n    const p = this\n    p.want(token.DOT)\n    const pos = p.pos  // pos is after \".\"\n\n    let rhs :Expr\n\n    switch (p.tok) {\n\n    case token.NAME:\n      // e.g. \"a.b\"\n      rhs = p.dotident(ctx, p.ident())\n      break\n\n    case token.INT:\n    case token.INT_BIN:\n    case token.INT_OCT:\n    case token.INT_HEX:\n      // e.g. \"t.3\"\n      let x = new IndexExpr(pos, p.scope, operand, p.intLit(ctx, p.tok))\n      if (operand.type instanceof TupleType) {\n        if (!p.types.maybeResolveTupleAccess(x)) {\n          x.type = p.types.markUnresolved(x)\n        }\n      } else {\n        // numeric access on something that's not a tuple\n        x.type = p.types.markUnresolved(x)\n        p.syntaxError(\n          `numeric field access on non-tuple type ${operand.type}`,\n          pos\n        )\n      }\n      return x\n\n    default:\n      p.syntaxError('expecting name or integer after \".\"')\n      rhs = p.bad(pos)\n      break\n    }\n\n    return new SelectorExpr(pos, p.scope, operand, rhs)\n  }\n\n\n  // dotident = Ident | SelectorExpr\n  //\n  dotident(ctx :exprCtx, ident :Ident) :Ident|SelectorExpr|IndexExpr {\n    const p = this\n    return p.tok == token.DOT ? p.selectorExpr(ident, ctx) : ident\n  }\n\n\n  // bracketExpr = IndexExpr | SliceExpr\n  // IndexExpr   = Expr \"[\" Expr \"]\"\n  // SliceExpr   = Expr \"[\" Expr? \":\" Expr? \"]\"\n  //\n  bracketExpr(operand :Expr, ctx :exprCtx) :IndexExpr|SliceExpr {\n    const p = this\n    const pos = p.pos\n    p.want(token.LBRACKET)\n\n    let x1 :Expr|null = null\n    if (p.tok != token.COLON) {\n      x1 = p.expr(ctx)\n    }\n\n    if (p.got(token.COLON)) {\n      // slice, e.g. \"x[1:3]\", \"x[:3]\", \"x[1:]\", \"x[:]\"\n      let endx :Expr|null = null\n      \n      if (!p.got(token.RBRACKET)) {\n        // explicit end, e.g. \"x[1:3]\", \"x[:3]\n        endx = p.expr(ctx)\n        p.want(token.RBRACKET)\n      } // else: implicit end, e.g. \"x[1:]\", \"x[:]\"\n\n      let x = new SliceExpr(pos, p.scope, operand, x1, endx)\n\n      if (operand.type instanceof TupleType) {\n        // non-uniform operand type\n        // we need to resolve indexes to find type\n        if (!p.types.tupleSlice(x)) {\n          x.type = p.types.markUnresolved(x)\n        }\n      } else dlog(`TODO handle uniform slice operand ${operand.type}`)\n\n      return x\n    }\n\n    // index\n    p.want(token.RBRACKET)\n    \n    assert(x1 != null)\n    assert(x1 instanceof Expr)\n\n    let x = new IndexExpr(pos, p.scope, operand, x1 as Expr)\n\n    if (operand.type instanceof TupleType) {\n      // non-uniform operand type\n      // we need to resolve index to find type\n      if (!p.types.maybeResolveTupleAccess(x)) {\n        x.type = p.types.markUnresolved(x)\n      }\n      return x\n    }\n\n    // else: operand is unitype or unknown\n    dlog(`TODO resolve item type for uniform operand of type ${operand.type}`)\n    x.type = p.types.markUnresolved(x)\n    return x\n    // return p.types.resolveIndex(x)\n  }\n\n\n  // ParenExpr = \"(\" Expr \",\"? \")\" | TupleExpr | Assignment\n  // TupleExpr = \"(\" Expr (\",\" Expr)+ \",\"? \")\"\n  //\n  parenExpr(ctx :exprCtx) :Expr {\n    const p = this\n    const pos = p.pos\n    p.want(token.LPAREN)\n\n    const l = []\n    while (true) {\n      l.push(p.expr(ctx))\n      if (p.tok == token.ASSIGN) {\n        // e.g. \"(a, b = 1, 2)\"\n        const x = p.assignment(l)\n        p.want(token.RPAREN)\n        return x\n      }\n      if (!p.ocomma(token.RPAREN)) {\n        break  // error: unexpected ;, expecting comma, or )\n      }\n      if (p.tok == token.RPAREN) {\n        break\n      }\n    }\n    p.want(token.RPAREN)\n\n    return (\n      // l.length == 1 ? (\n      //   p.keepParens ? new ParenExpr(pos, p.scope, l[0]) :\n      //   l[0]\n      // ) :\n      l.length == 1 ? l[0] :\n      new TupleExpr(pos, p.scope, l)\n    )\n  }\n\n\n  bad(pos? :Pos) :BadExpr {\n    const p = this\n    return new BadExpr(pos === undefined ? p.pos : pos, p.scope)\n  }\n\n\n  badTypeExpr(pos? :Pos) :BadTypeExpr {\n    const p = this\n    return new BadTypeExpr(pos === undefined ? p.pos : pos, p.scope)\n  }\n\n\n  // maybeType parses a type.\n  // Returns null if there was no type.\n  //\n  // If you expect a type, use type() instead which repors an error if no\n  // type is found.\n  //\n  // Type     = TypeName | TypeLit | \"(\" Type \")\" .\n  // TypeName = identifier | QualifiedIdent .\n  // TypeLit  = ArrayType | StructType | PointerType | FunctionType\n  //          | InterfaceType | SliceType | MapType | Channel_Type\n  //\n  maybeType() :TypeExpr|null {\n    const p = this\n\n    switch (p.tok) {\n\n      case token.NAME:\n        const x = p.dotident(null, p.resolve(p.ident()))\n        return new TypeExpr(x.pos, x.scope, p.types.resolve(x))\n\n      case token.LPAREN:\n        return p.tupleType()\n\n      case token.LBRACE:\n        dlog(`TODO: parse struct type def`)\n        return null\n\n      // TODO: all other types\n\n      default:\n        return null\n    }\n  }\n\n\n  // type parses a type\n  //\n  type() :TypeExpr {\n    const p = this\n    let t = p.maybeType()\n    if (t) {\n      return t\n    }\n    t = p.badTypeExpr()\n    p.syntaxError(\"expecting type\")\n    p.next()\n    return t\n  }\n\n\n  // TupleType = \"(\" Type (\",\" Type)+ \",\"? \")\"\n  // Returns null for empty tuples, i.e. \"()\"\n  // Returns the inner type for single-type tuples, i.e. \"(Type)\"\n  //\n  tupleType() :TypeExpr|null {\n    const p = this\n    p.want(token.LPAREN)\n    const pos = p.pos\n    let tx :TypeExpr | null = null\n    const types = [] as Type[]\n\n    while (p.tok != token.RPAREN) {\n      tx = p.type()\n      assert(tx.type, 'unresolved type')\n      types.push(tx.type as Type)\n      if (!p.ocomma(token.RPAREN)) {\n        // error: unexpected ;, expecting comma, or )\n        break\n      }\n    }\n    p.want(token.RPAREN)\n\n    if (!tx) {\n      return null  // \"()\"  => null\n    }\n\n    if (types.length == 1) {\n      return tx as TypeExpr  // \"(a)\" => \"a\"\n    }\n\n    const tupleType = p.types.getTupleType(types)\n    return new TypeExpr(pos, p.scope, tupleType)\n  }\n\n\n  // IdentifierList = identifier { \",\" identifier } .\n  // The first identifier must be provided.\n  identList(first :Ident) :Ident[] {\n    const p = this\n    const l = [first]\n    while (p.got(token.COMMA)) {\n      l.push(p.ident())\n    }\n    return l\n  }\n\n  ident() :Ident {\n    const p = this\n    const pos = p.pos\n    if (p.tok == token.NAME) {\n      const s = p.strSet.emplace(p.takeByteValue(), p.hash)\n      p.next()\n      return new Ident(pos, p.scope, s)\n    }\n    p.syntaxError(\"expecting identifier\", pos)\n    p.advanceUntil()\n    return new Ident(pos, p.scope, p._id__)\n  }\n\n  maybeIdent() :Ident|null {\n    const p = this\n    return (p.tok == token.NAME) ? p.ident() : null\n  }\n\n  fallbackIdent(pos? :Pos) :Ident {\n    const p = this\n    return new Ident(pos === undefined ? p.pos : pos, p.scope, p._id__)\n  }\n\n  // osemi parses an optional semicolon.\n  osemi(follow :token) :bool {\n    const p = this\n\n    switch (p.tok) {\n      case token.SEMICOLON:\n        p.next()\n        return true\n    \n      case token.RPAREN:\n      case token.RBRACE:\n        // semicolon is optional before ) or }\n        return true\n    }\n  \n    p.syntaxError(\"expecting semicolon, newline, or \" + tokstr(follow))\n    p.advanceUntil(follow)\n    return false\n  }\n\n  // ocomma parses an optional comma.\n  ocomma(follow :token) :bool {\n    const p = this\n\n    switch (p.tok) {\n      case token.COMMA:\n        p.next()\n        return true\n\n      case token.RPAREN:\n      case token.RBRACE:\n        // comma is optional before ) or }\n        return true\n    }\n\n    p.syntaxError(\"expecting comma, or \" + tokstr(follow))\n    p.advanceUntil(follow)\n    return false\n  }\n\n  // appendGroup(f) = f | \"(\" { f \";\" } \")\" .\n  appendGroup<D extends Decl>(list :D[], f :(g:Group|null, i:int)=>D) {\n    const p = this\n    let i = 0\n    if (p.got(token.LPAREN)) {\n      const g = new Group()\n      while (p.tok != token.EOF && p.tok != token.RPAREN) {\n        list.push(f(g, i++))\n        if (!p.osemi(token.RPAREN)) {\n          break\n        }\n      }\n      p.want(token.RPAREN)\n    } else {\n      list.push(f(null, i))\n    }\n  }\n\n  // advanceUntil consumes tokens until it finds a token of the followlist.\n  // The stopset is only considered if we are inside a function (p.fnest > 0).\n  // The followlist is the list of valid tokens that can follow a production;\n  // if it is empty, exactly one token is consumed to ensure progress.\n  //\n  // Not speed critical, advance is only called in error situations.\n  //\n  advanceUntil(...followlist :token[]) {\n    const p = this\n\n    if (followlist.length == 0) {\n      p.next()\n      return\n    }\n\n    // TODO: improve performance of this, especially followlist.includes\n\n    if (p.fnest > 0) {\n      // The stopset contains keywords that start a statement.\n      // They are good synchronization points in case of syntax\n      // errors and (usually) shouldn't be skipped over.\n      loop1:\n      while (!followlist.includes(p.tok)) {\n        switch (p.tok) {\n          case token.EOF:\n          case token.BREAK:\n          // case token.CONST:\n          case token.CONTINUE:\n          case token.DEFER:\n          case token.FALLTHROUGH:\n          case token.FOR:\n          case token.FUN:\n          case token.GO:\n          // case token.GOTO:\n          case token.IF:\n          case token.RETURN:\n          case token.SELECT:\n          case token.SWITCH:\n          case token.TYPE:\n            break loop1\n        }\n        p.next()\n      }\n    } else {\n      while (!(p.tok == token.EOF || followlist.includes(p.tok))) {\n        p.next()\n      }\n    }\n  }\n\n  // syntaxError reports a syntax error\n  //\n  syntaxError(msg :string, pos :Pos = this.pos) {\n    const p = this\n    const position = p.sfile.position(pos)\n\n    // if (p.tok == token.EOF) {\n    //   return // avoid meaningless follow-up errors\n    // }\n\n    // add punctuation etc. as needed to msg\n    if (msg == \"\") {\n      // nothing to do\n    } else if (\n      msg.startsWith(\"in \") ||\n      msg.startsWith(\"at \") ||\n      msg.startsWith(\"after \"))\n    {\n      msg = \" \" + msg\n    } else if (msg.startsWith(\"expecting \")) {\n      msg = \", \" + msg\n    } else {\n      // plain error - we don't care about current token\n      p.errorAt(msg, position)\n      return\n    }\n\n    let cond = (\n      p.tok == token.EOF ? 'unexpected end of input' :\n      `unexpected ${tokstr(p.tok)}`\n    )\n    p.errorAt(cond + msg, position)\n    if (DEBUG) {\n      // print token state when compiled in debug mode\n      console.error(`  p.tok = ${token[p.tok]} ${tokstr(p.tok)}`)\n    }\n  }\n\n  // diag reports a diagnostic message, or an error if k is ERROR\n  //\n  diag(k :DiagKind, msg :string, pos :Pos = this.pos, code? :ErrorCode) {\n    const p = this\n    // if (code !== undefined) {\n    //   // level overridden?\n    //   k = p.diagConfig[code] || k\n    // }\n    if (k == \"error\") {\n      p.error(msg, pos, code)\n    } else if (p.diagh) {\n      p.diagh(p.sfile.position(pos), msg, k)\n    }\n  }\n\n}\n\n// unparen removes all parentheses around an expression.\n// function unparen(x :Expr) :Expr {\n//   while (x instanceof ParenExpr) {\n//     x = x.x\n//   }\n//   return x\n// }\n\nfunction isEmptyFunExpr(d :Decl) :bool {\n  return d instanceof FunExpr && !d.body\n}\n","// import { token } from './token'\nimport { SrcFileSet, Pos } from './pos'\nimport { ErrorCode, ErrorHandler, ErrorReporter } from './error'\nimport * as utf8 from './utf8'\nimport { TypeResolver } from './resolve'\nimport { debuglog as dlog } from './util'\nimport {\n  File,\n  Package,\n  Ent,\n  Ident,\n  FunSig,\n  ImportDecl,\n  Expr,\n} from './ast'\nimport { FunType, UnresolvedType } from './types'\n\n\n// An Importer resolves import paths to package entities.\n// The imports map records the packages already imported,\n// indexed by package id (canonical import path).\n// An Importer must determine the canonical import path and\n// check the map to see if it is already present in the imports map.\n// If so, the Importer can return the map entry. Otherwise, the\n// Importer should load the package data for the given path into\n// a new Ent (pkg), record pkg in the imports map, and then\n// return pkg.\n//\nexport type Importer =\n  (imports :Map<string,Ent>, path :string) => Promise<Ent>\n\n\n// pkgBinder resolves a ast.Package and its ast.File s\n//\nclass pkgBinder extends ErrorReporter {\n  errorCount = 0\n  // package-global mapping of imported package ids to package entities\n  imports = new Map<string,Ent>()\n  undef :Set<Ident>|null = null // track undefined so we don't report twice\n\n  constructor(\n    public pkg      :Package,\n    public fset     :SrcFileSet,\n    public importer :Importer|null,\n    public types    :TypeResolver,\n    errh            :ErrorHandler|null,\n  ) {\n    super('E_RESOLVE', errh)\n  }\n\n  bind() :Promise<void> {\n    const b = this\n    //\n    // binding happens in three steps:\n    //\n    // 1. imports are resolved\n    // 2. identifiers are resolved in all files (and across the package)\n    // 3. types are resolved across the package\n    //\n\n    // step 1: complete file scopes with imports\n    return Promise.all(\n      b.pkg.files.map(f => this._resolveImports(f))\n    ).then(() => {\n      if (b.errorCount > 0) {\n        return  // stop when imports failed\n      }\n\n      // step 2: resolve identifiers\n      for (let f of b.pkg.files) {\n        b._resolveIdents(f)\n      }\n\n      // step 3: resolve types\n      b._resolveTypes()\n    })\n  }\n\n  _resolveImports(f :File) :Promise<void> {\n    // step 1: complete file scopes with imports\n    const b = this\n\n    if (!f.imports || f.imports.length == 0) {\n      return Promise.resolve()\n    }\n\n    const pv :Promise<void>[] = []\n\n    for (let decl of f.imports) {\n      if (!b.importer) {\n        b.error(`unresolvable import ${decl.path}`, decl.path.pos)\n        break\n      }\n      const path = utf8.decodeToString(decl.path.value)\n      pv.push(b.importer(b.imports, path)\n        .then((pkg :Ent) => { b.integrateImport(f, decl, pkg) })\n        .catch(err => {\n          b.error(\n            `could not import ${path} (${err.message || err})`,\n            decl.path.pos\n          )\n        })\n      )\n    }\n    return Promise.all(pv).then(() => {})\n  }\n\n  integrateImport(f :File, imp :ImportDecl, pkg :Ent) {\n    // local name overrides imported package name\n    let name = imp.localIdent ? imp.localIdent.value : pkg.name\n\n    if (name.toString() == \".\") { // TODO: fix efficiency\n      // TODO: merge imported scope with file scope\n      // for _, obj := range pkg.Data.(*Scope).Objects {\n      //   p.declare(fileScope, pkgScope, obj)\n      // }\n    } else if (name.toString() != \"_\") { // TODO: fix efficiency\n      // declare imported package entities in file scope\n      // (do not re-use pkg in the file scope but create\n      // a new ent instead; the Decl field is different\n      // for different files)\n      f.scope.declareEnt(new Ent(name, imp, null, null, pkg.data))\n    }\n  }\n\n  _resolveIdents(f :File) {\n    // step 2: resolve identifiers\n    const b = this\n\n    if (f.unresolved) for (let id of f.unresolved) {\n      // see if the name was declared after it was referenced in the file, or\n      // declared in another file in the same package\n      let ent = f.scope.lookup(id.value)\n\n      if (!ent) { // truly undefined\n        b.error(`${id} undefined`, id.pos)\n        if (!b.undef) {\n          b.undef = new Set<Ident>()\n        }\n        b.undef.add(id)\n        continue\n      }\n\n      dlog(\n        `${id} (${ent.value && ent.value.constructor.name})`+\n        ` at ${b.fset.position(id.pos)}`\n      )\n\n      id.refEnt(ent) // reference ent\n\n      let t = id.type\n      if (t instanceof UnresolvedType) {\n        assert(ent.value != null)\n        id.type = b.types.resolve(ent.value as Expr)\n        assert(!(id.type instanceof UnresolvedType), 'still unresolved')\n        \n        // delegate type to any expressions that reference this type\n        dlog('len(t.refs):', t.refs ? t.refs.size : 0)\n        if (t.refs) for (let ref of t.refs) {\n          if (ref instanceof FunSig || ref instanceof FunType) {\n            ref.result = id.type\n          } else {\n            assert(ref instanceof Expr)\n            ;(ref as Expr).type = id.type\n          }\n        }\n      }\n    }\n  }\n\n  _resolveTypes() {\n    // step 3: resolve types\n    const b = this\n\n    for (let ut of b.types.unresolved) {\n      // console.log('types.unresolved.size = ', b.types.unresolved.size)\n      const expr = ut.def as Expr ; assert(expr instanceof Expr)\n      const t = expr.type\n\n      if (!(t instanceof UnresolvedType)) {\n        // was probably resolved during step 2\n        continue\n      }\n\n      if (b.undef && expr instanceof Ident && b.undef.has(expr)) {\n        continue\n      }\n  \n      // attempt to resolve the type now that we can see the entire package\n      expr.type = null // clear so resolve can progress\n      const restyp = b.types.maybeResolve(expr)\n\n      if (!restyp) {\n        expr.type = t // restore original which might have refs\n        // Note: This normally happens when the expression contains something\n        // that itself failed to resolve, like an undefined variable.\n        dlog(\n          `cannot resolve type of ${expr} ${b.fset.position(expr.pos)}`\n        )\n        continue\n      }\n\n      // succeeded in resolving the type.\n      // delegate type to any expressions that reference this type.\n      if (t.refs) for (let ref of t.refs) {\n        if (ref instanceof FunSig || ref instanceof FunType) {\n          ref.result = restyp\n        } else {\n          assert(ref instanceof Expr)\n          ;(ref as Expr).type = restyp\n        }\n      }\n    }\n  }\n\n  error(msg :string, pos :Pos, c? :ErrorCode) {\n    const b = this\n    b.errorAt(msg, b.fset.position(pos), c)\n  }\n}\n\n\n// bindpkg resolves any undefined names (usually across source files) and,\n// unless there are errors, all identifiers in the package will have Ident.ent\n// set, pointing to whatever entity a name references.\n//\n// Returns false if there were errors\n//\nexport function bindpkg(\n  pkg      :Package,\n  fset     :SrcFileSet,\n  importer :Importer|null,\n  typeres  :TypeResolver,\n  errh     :ErrorHandler,\n) :Promise<bool> {\n  const b = new pkgBinder(pkg, fset, importer, typeres, errh)\n  return b.bind().then(() => b.errorCount != 0)\n}\n","import * as util from './util'\n\n// Pos is a compact encoding of a source position within a file set.\n// It can be converted into a Position for a more convenient, but much\n// larger, representation.\n//\n// The Pos value for a given file is a number in the range [base, base+size],\n// where base and size are specified when adding the file to the file set via\n// addFile.\n//\n// To create the Pos value for a specific source offset (measured in bytes),\n// first add the respective file to the current file set using\n// SrcFileSet.addFile and then call File.Pos(offset) for that file.\n// Given a Pos value p for a specific file set fset, the corresponding Position\n// value is obtained by calling fset.Position(p).\n//\n// Pos values can be compared directly with the usual comparison operators:\n// If two Pos values p and q are in the same file, comparing p and q is\n// equivalent to comparing the respective source file offsets. If p and q\n// are in different files, p < q is true if the file implied by p was added\n// to the respective file set before the file implied by q.\n//\nexport type Pos = int\n\n// The zero value for Pos is NoPos; there is no file and line information\n// associated with it, and NoPos().IsValid() is false. NoPos is always\n// smaller than any other Pos value. The corresponding Position value\n// for NoPos is the zero value for Position.\n//\nexport const NoPos :Pos = 0\n\n// IsValid reports whether the position is valid.\nexport function PosIsValid(p :Pos) :bool {\n  return p != NoPos\n}\n\n// Position describes an arbitrary source position\n// including the file, line, and column location.\n// A Position is valid if the line number is > 0.\nexport class Position { constructor(\n  public readonly filename :string = '', // filename, if any\n  public readonly offset   :int = 0,    // offset, starting at 0\n  public readonly line     :int = 0,    // line number, starting at 1\n  public readonly column   :int = 0,    // column number, starting at 1 (byte count)\n  ) {}\n\n  // IsValid reports whether the position is valid.\n  isValid() :bool {\n    return this.line > 0\n  }\n\n  // toString returns a string in one of several forms:\n  //\n  //  file:line:column    valid position with file name\n  //  line:column         valid position without file name\n  //  file                invalid position with file name\n  //  -                   invalid position without file name\n  //\n  toString() :string {\n    let p = this\n    let s = p.filename\n    if (p.isValid()) {\n      if (s) {\n        s += \":\"\n      }\n      s += `${p.line}:${p.column}`\n    }\n    return s || \"-\"\n  }\n}\n\nconst invalidPosition = new Position()\n\n// -----------------------------------------------------------------\n\n// A lineInfo object describes alternative file and line number\n// information (such as provided via a //line comment in a .go\n// file) for a given file offset.\ninterface lineInfo {\n  offset   :int\n  filename :string\n  line     :int\n}\n\n// A SrcFile is a handle for a file belonging to a FileSet.\n// A SrcFile has a name, size, and line offset table.\nexport class SrcFile {\n  private infos :lineInfo[] = []\n\n  constructor(\n  public name  :string,  // file name as provided to addFile\n  public base  :int,     // Pos value range for this file is [base...base+size]\n  public size  :int,     // file size as provided to addFile\n  public lines :int[],\n  ) {}\n\n  // Number of lines in file\n  get lineCount() :int {\n    return this.lines.length\n  }\n\n  // addLine adds the line offset for a new line.\n  // The line offset must be larger than the offset for the previous line\n  // and smaller than the file size; otherwise the line offset is ignored.\n  //\n  addLine(offset :int) {\n    const f = this\n    const i = f.lines.length\n    if ((i === 0 || f.lines[i-1] < offset) && offset < f.size) {\n      f.lines.push(offset)\n    }\n  }\n\n  // AddLineInfo adds alternative file and line number information for\n  // a given file offset. The offset must be larger than the offset for\n  // the previously added alternative line info and smaller than the\n  // file size; otherwise the information is ignored.\n  //\n  // AddLineInfo is typically used to register alternative position\n  // information for //line filename:line comments in source files.\n  //\n  addLineInfo(offset :int, filename :string, line :int) {\n    const f = this\n    const i = f.infos.length\n    if (i == 0 || f.infos[i-1].offset < offset && offset < f.size) {\n      f.infos.push({offset, filename, line})\n    }\n  }\n\n  // Pos returns the Pos value for the given file offset;\n  // the offset must be <= f.size.\n  // f.pos(f.offset(p)) == p.\n  //\n  pos(offset :int) :Pos {\n    const f = this\n    if (offset > f.size) {\n      panic(\"illegal file offset\")\n    }\n    return f.base + offset\n  }\n\n  // Offset returns the offset for the given file position p;\n  // p must be a valid Pos value in that file.\n  // f.offset(f.pos(offset)) == offset.\n  //\n  offset(p :Pos) :int {\n    const f = this\n    if (p < f.base || p > f.base + f.size) {\n      panic(\"illegal Pos value\")\n    }\n    return p - f.base\n  }\n\n  // position returns the Position value for the given file position p.\n  // If adjusted is set, the position may be adjusted by position-altering\n  // //!line comments; otherwise those comments are ignored.\n  // p must be a Pos value in f or NoPos.\n  //\n  position(p :Pos, adjusted :bool = true) :Position {\n    const f = this\n    if (p == NoPos) {\n      return invalidPosition\n    }\n    if (p < f.base || p > f.base + f.size) {\n      panic(\"illegal Pos value\")\n    }\n    return f._position(p, adjusted)\n  }\n\n  // If adjusted is set, will return the filename and line information possibly\n  // adjusted by //line comments; otherwise those comments are ignored.\n  //\n  private _position(p :Pos, adjusted :bool) :Position {\n    const f = this\n    const offset = p - f.base\n\n    let filename = f.name\n    let line = 0, column = 0\n    \n    let i = searchInts(f.lines, offset)\n\n    if (i >= 0) {\n      line = i + 1\n      column = offset - f.lines[i] + 1\n    }\n\n    if (adjusted && f.infos.length > 0) {\n      // file has extra line infos\n      let i = searchLineInfos(f.infos, offset)\n      if (i >= 0) {\n        const alt = f.infos[i]\n        filename = alt.filename\n        i = searchInts(f.lines, alt.offset)\n        if (i >= 0) {\n          line += alt.line - i - 1\n        }\n      }\n    }\n\n    return new Position(filename, offset, line, column)\n  }\n\n}\n\nfunction searchLineInfos(a :lineInfo[], x :int) :int {\n  return util.search(a.length, (i :int) => a[i].offset > x) - 1\n}\n\n// -----------------------------------------------------------------\n\n// A SrcFileSet represents a set of source files\nexport class SrcFileSet { constructor(\n  public base:  int = 1,      // base offset for the next file. 0 == NoPos\n    // Base is the minimum base offset that must be provided to\n    // addFile when adding the next file.\n\n  public files: SrcFile[] = [],  // list of files in the order added to the set\n  public last:  SrcFile|null = null,  // cache of last file looked up\n  ) {}\n\n  // addFile adds a new file with a given filename, base offset, and file size\n  // to the file set s and returns the file. Multiple files may have the same\n  // name. The base offset must not be smaller than the SrcFileSet's Base(), and\n  // size must not be negative. As a special case, if a negative base is\n  // provided, the current value of the SrcFileSet's base() is used instead.\n  //\n  // Adding the file will set the file set's Base() value to base + size + 1\n  // as the minimum base value for the next file. The following relationship\n  // exists between a Pos value p for a given file offset offs:\n  //\n  //  int(p) = base + offs\n  //\n  // with offs in the range [0, size] and thus p in the range [base, base+size].\n  // For convenience, SrcFile.pos may be used to create file-specific position\n  // values from a file offset.\n  //\n  addFile(filename :string, size :int, base :int = -1) :SrcFile {\n    const s = this\n    if (base < 0) {\n      base = s.base\n    }\n    if (base < s.base || size < 0) {\n      panic(\"illegal base or size\")\n    }\n    // base >= s.base && size >= 0\n    const f = new SrcFile(filename, base, size, [0])\n    base += size + 1 // +1 because EOF also has a position\n    if (base < 0) {\n      panic(\"Pos offset overflow (too much source code in file set)\")\n    }\n    // add the file to the file set\n    s.base = base\n    s.files.push(f)\n    s.last = f\n    return f\n  }\n\n  // findFile returns the file that contains the position p.\n  // If no such file is found (for instance for p == NoPos),\n  // the result is null.\n  //\n  findFile(p :Pos) :SrcFile|null {\n    if (p == NoPos) {\n      return null\n    }\n    const s = this\n    // common case: p is in last file\n    let f = s.last\n    if (f && f.base <= p && p <= f.base + f.size) {\n      return f\n    }\n    // p is not in last file - search all files\n    let i = searchFiles(s.files, p)\n    if (i >= 0) {\n      f = s.files[i]\n      // f.base <= p  by definition of searchFiles\n      if (p <= f.base + f.size) {\n        s.last = f\n        return f\n      }\n    }\n    return null\n  }\n\n  // position converts a Pos p in the fileset into a Position value.\n  // If adjusted is set, the position may be adjusted by position-altering\n  // //line comments; otherwise those comments are ignored.\n  // p must be a Pos value in s or NoPos.\n  //\n  position(p :Pos, adjusted :bool = true) :Position {\n    const f = this.findFile(p)\n    return f ? f.position(p, adjusted) : invalidPosition\n  }\n}\n\n\nfunction searchFiles(a :SrcFile[], x :int) :int {\n  return util.search(a.length, (i :int) => a[i].base > x ) - 1\n}\n\n\nfunction searchInts(a :ArrayLike<int>, x :int) :int {\n  // Inlined version of\n  //  return util.search(a.length, i => a[i] > x) - 1\n  //\n  let i = 0, j = a.length\n  while (i < j) {\n    const h = i + (((j-i)/2) >> 0) // avoid overflow when computing h\n    // i â‰¤ h < j\n    if (a[h] <= x) {\n      i = h + 1\n    } else {\n      j = h\n    }\n  }\n  return i - 1\n}\n","import { bufcmp, asciibuf } from './util'\nimport * as utf8 from './utf8'\n//\n// Interned byte strings\n//\n\nlet _nextId = 0\n\nexport class ByteStr {\n  readonly _id :int = _nextId++ // only for debugging\n  constructor(\n  readonly hash  :int,\n  readonly bytes :Uint8Array,\n  ){}\n\n  isUnderscore() {\n    // Note: Hash constant needs to be updated if hash function changes.\n    return this.hash == 0xda0c1970 && this.bytes[0] == 0x5f\n  }\n\n  toString() :string {\n    return utf8.decodeToString(this.bytes)\n  }\n\n  equals(other :ByteStr) :bool {\n    return (\n      this.hash == other.hash &&\n      this.bytes.length == other.bytes.length &&\n      bufcmp(this.bytes, other.bytes) == 0\n    )\n  }\n}\n\nexport class ByteStrSet {\n  _m = new Map<int,ByteStr[]>() // naive implementation\n  // TODO: use a rb-tree or something like that\n\n  emplace(value :Uint8Array, hash :int = 0) :ByteStr {\n    if (!hash) {\n      hash = hashBytes(value, 0, value.length)\n    }\n    let v = this._m.get(hash)\n    if (v) {\n      for (let bs of v) {\n        if (bs.bytes.length == value.length && bufcmp(bs.bytes, value) == 0) {\n          return bs\n        }\n      }\n      const bs = new ByteStr(hash, value)\n      v.push(bs)\n      return bs\n    } else {\n      const bs = new ByteStr(hash, value)\n      this._m.set(hash, [bs])\n      return bs\n    }\n  }\n}\n\n// hashBytes returns an unsigned 31 bit integer hash of an array of bytes.\n// It's using the FNV1a algorithm which is very fast and has good distribution\n// for common short names (based on tests on a large corpus of go source code.)\n//\nexport function hashBytes(buf :ArrayLike<byte>, offs :int, length :int) {\n  // This function must exactly match what's in scanner.\n  var h = 0x811c9dc5, i = offs, e = offs + length\n  while (i < e) {\n    h = (h ^ buf[i++]) * 0x1000193\n  }\n  return h >>> 0\n}\n\n\nexport function asciiByteStr(s :string) :ByteStr {\n  let b = asciibuf(s)\n  return new ByteStr(hashBytes(b, 0, b.length), b)\n}\n","import { Type } from './types'\n\n// TypeSet provides interning of types based on equality on a per-constructor\n// basis.\n//\nexport class TypeSet {\n  types = new Map<Object,Set<Type>>() // type constructor => type instance\n\n  intern<T extends Type>(t :T) :T {\n    let s = this.types.get(t.constructor)\n    if (s) {\n      for (let i of s) {\n        if (i.equals(t)) {\n          assert(i instanceof t.constructor)\n          return i as T\n        }\n      }\n      s.add(t)\n    } else {\n      this.types.set(t.constructor, new Set<Type>([t]))\n    }\n    return t\n  }\n}\n","//\n// Produces a human-readable format of an AST, meant for debugging.\n//\nimport * as utf8 from './utf8'\nimport { tokstr, token } from './token'\nimport { termColorSupport, style, noStyle } from './termstyle'\nimport {\n  Package,\n  File,\n  Group,\n  Node,\n\n  Field,\n  ReturnStmt,\n  WhileStmt,\n\n  ImportDecl,\n  VarDecl,\n  TypeDecl,\n  MultiDecl,\n\n  Expr,\n  Atom,\n  Ident,\n  NumLit,\n  StringLit,\n  FunExpr,\n  FunSig,\n  NoOpStmt,\n  Block,\n  IfExpr,\n  Assignment,\n  Operation,\n  CallExpr,\n  TupleExpr,\n  BadExpr,\n  TypeExpr,\n  BadTypeExpr,\n  RestTypeExpr,\n  SelectorExpr,\n  IndexExpr,\n  SliceExpr,\n  TypeConvExpr,\n} from './ast'\n\nimport {\n  Type,\n  t_nil,\n  // BasicType,\n  // FloatType,\n  // IntType,\n  // NumType,\n  // SIntType,\n  // UIntType,\n  // FunType,\n  // StrType,\n  // UnresolvedType,\n  // UnionType,\n  // TupleType,\n  // RestType,\n} from './types'\n\n\nclass ReprCtx {\n  // This is a hack for creating printable group identifiers\n  groupIds = new Map<Group,int>()\n  nextGroupId = 0\n  ind :string = '  '\n  typedepth = 0\n  style = termColorSupport ? style : noStyle\n\n  groupId(g :Group) :string {\n    let gid = (g as any).id || this.groupIds.get(g)\n    if (gid === undefined) {\n      gid = this.nextGroupId++\n      this.groupIds.set(g, gid)\n    }\n    return gid.toString(36)\n  }\n}\n\n\nconst defaultCtx = new ReprCtx()\n\n\nexport interface ReprOptions {\n  colors?: bool\n}\n\n\nexport function astRepr(n :Package|File|Node, options? :ReprOptions) :string {\n  let ctx = defaultCtx\n  if (options) {\n    ctx = new ReprCtx()\n    if (options.colors !== undefined) {\n      ctx.style = options.colors ? style : noStyle\n    }\n  }\n  if (n instanceof Package) {\n    return reprpkg(n, ctx)\n  } if (n instanceof File) {\n    return reprfile(n, '\\n', ctx)\n  } else {\n    return repr1(n, '\\n', ctx).trim()\n  }\n}\n\n\nfunction reprpkg(n :Package, c :ReprCtx) :string {\n  let s = `(pkg \"${n.name.replace(/\"/g,'\\\\\"')}\"`\n  if (n.files.length) {\n    let nl = '\\n  '\n    for (let f of n.files) {\n      s += nl + reprfile(f, nl, c)\n    }\n    s = s.trimRight() + '\\n'\n  }\n  return s + ')'\n}\n\n\nfunction reprfile(n :File, nl :string, c :ReprCtx) :string {\n  let s = `(file \"${n.sfile.name.replace(/\"/g,'\\\\\"')}\"`\n  if (n.decls.length) {\n    let nl2 = nl + '  '\n    for (let d of n.decls) {\n      s += nl2 + repr1(d, nl2, c)\n    }\n    s = s.trimRight() + nl\n  }\n  return s + ')'\n}\n\n\n// reprt formats a type\n//\nfunction reprt(t :Type|null, _newline :string, c :ReprCtx) :string {\n  return c.style.blue(`<${t || 'nil'}>`)\n}\n\n\nfunction reprv(nv :Node[], newline :string, c :ReprCtx, delims :string='()') :string {\n  return (\n    (delims[0] || '') +\n    nv.map(n => repr1(n, newline, c)).join(' ') +\n    (delims[1] || '')\n  )\n}\n\n\n// function subscriptnum(n :int) :string {\n//   // ASCII 0-9 Unicode range: [U+0030 .. U+0039]\n//   // superscript 0-9 Unicode range: [U+2070 .. U+2079]\n//   // subscript 0-9 Unicode range: [U+2080 .. U+2089]\n//   let s = n.toString(10)\n//   let r = ''\n//   let ss0 = 0x2080 - 0x30\n//   for (let i = 0; i < s.length; ++i) {\n//     let c = s.charCodeAt(i) + ss0\n//     r += String.fromCharCode(c)\n//   }\n//   return r\n// }\n\n\nfunction reprid(id :Ident, c :ReprCtx) :string {\n  return (\n    utf8.decodeToString(id.value.bytes)\n    // + c.style.pink(subscriptnum(id.ver))\n  )\n}\n\n\nfunction reprcons(n :Node, c :ReprCtx) :string {\n  return c.style.grey(n.constructor.name)\n}\n\n\nfunction repr1(n :Node, newline :string, c :ReprCtx, flag :int = 0) :string {\n  assert(n)\n\n  if (n instanceof Atom) {\n    return c.style.purple(c.style.bold(n.name))\n  }\n\n  if (n instanceof NumLit) {\n    return reprt(n.type, newline, c) + c.style.green(n.value.toString())\n  }\n\n  if (n instanceof StringLit) {\n    let s = JSON.stringify(utf8.decodeToString(n.value))\n    return reprt(n.type, newline, c) + c.style.green(s)\n  }\n\n  if (n instanceof Ident) {\n    return (c.typedepth ? '' : reprt(n.type, newline, c)) + reprid(n, c)\n  }\n\n  if (n instanceof RestTypeExpr) {\n    return '...' + repr1(n.expr, newline, c)\n  }\n\n  if (n instanceof TypeExpr) {\n    return reprt(n.type, newline, c)\n  }\n\n  if (n instanceof BadExpr) {\n    return 'BAD'\n  }\n\n  if (n instanceof BadTypeExpr) {\n    return 'BAD_TYPE'\n  }\n\n  if (n instanceof Type) {\n    return c.style.blue(n.toString())\n  }\n\n  const nl2 = newline + c.ind\n\n  if (n instanceof Field) {\n    let s = repr1(n.type, nl2, c)\n    if (n.name) {\n      s = '(' + repr1(n.name, nl2, c) + ' ' + s + ')'\n    }\n    return s\n  }\n\n  if (n instanceof Block) {\n    return (\n      n.list.length ?\n        newline + '(' + reprt(n.type, newline, c) + 'block ' +\n        n.list.map(n => nl2 + repr1(n, nl2, c).trim()).join('') +\n        newline + ')' :\n        '(block)'\n    )\n  }\n\n  if (n instanceof WhileStmt) {\n    return (\n      '(while ' + repr1(n.cond, nl2, c) + ' ' +\n      repr1(n.body, nl2, c) + newline + ')'\n    )\n  }\n\n  if (n instanceof ReturnStmt) {\n    if (n.result) {\n      return newline + `(return ${repr1(n.result, nl2, c)})`\n    }\n    return newline + reprcons(n, c)\n  }\n\n  if (n instanceof IfExpr) {\n    // flag=1 means \"else if\" branch\n    let s = (\n      ( flag ? '' :\n        newline + '(' + reprt(n.type, newline, c)\n      ) +\n      'if ' + repr1(n.cond, nl2, c) +\n      repr1(n.then, newline, c)\n    )\n    if (n.els_) {\n      s += newline + 'else ' + repr1(n.els_, newline, c, /*flag*/1)\n    }\n    return flag ? s : s + ')'\n  }\n\n  // if (n instanceof ExprStmt) {\n  //   return newline + `(${reprcons(n, c)} ${repr1(n.expr, nl2, c)})`\n  // }\n\n  if (n instanceof FunSig) {\n    const restype = n.result ? n.result.type : t_nil\n    return reprv(n.params, nl2, c) + ' -> ' + reprt(restype, nl2, c)\n  }\n\n  if (n instanceof Assignment) {\n    let s = newline + `(${c.style.grey('assign')} `\n    s += reprv(n.lhs, nl2, c)\n    if (n.op == token.ILLEGAL) {\n      s += ' = '\n    } else {\n      s += ' ' + tokstr(n.op) + ' '\n    }\n    s += reprv(n.rhs, nl2, c)\n    return s + ')'\n  }\n\n  if (n instanceof MultiDecl) {\n    return newline + `(${reprcons(n, c)}` + ' ' + reprv(n.decls, nl2, c, '') + ')'\n  }\n\n  if (n instanceof SelectorExpr) {\n    return (\n      '(SEL ' +\n      repr1(n.lhs, newline, c) + '.' +\n      repr1(n.rhs, newline, c) + ')'\n    )\n  }\n\n  if (n instanceof IndexExpr) {\n    return (\n      `(${reprt(n.type, newline, c)}index ` +\n      repr1(n.operand, newline, c) + ' ' +\n      repr1(n.index, newline, c) +\n      ')'\n    )\n  }\n\n  if (n instanceof SliceExpr) {\n    return (\n      `(${reprt(n.type, newline, c)}slice ` +\n      repr1(n.operand, newline, c) + ' ' +\n      (n.start ? repr1(n.start, newline, c) : 'nil') + ' ' +\n      (n.end ? repr1(n.end, newline, c) : 'nil') +\n      ')'\n    )\n  }\n\n  if (n instanceof Operation) {\n    let ts = c.typedepth ? '' : reprt(n.type, newline, c)\n    let s = '(' + ts + c.style.orange(token[n.op]) + ' ' + repr1(n.x, nl2, c)\n    if (n.y) {\n      s += ' ' + repr1(n.y, nl2, c)\n    }\n    return s + ')'\n  }\n\n\n  // --------\n\n  let s = '('\n  if (n instanceof Expr && !c.typedepth) {\n    s += reprt(n.type, newline, c)\n  }\n\n\n  if (n instanceof FunExpr) {\n    s += 'fun '\n    if (n.isInit) {\n      s += 'init '\n    } else if (n.name) {\n      s += reprid(n.name, c) + ' '\n    }\n    s += repr1(n.sig, newline, c)\n    if (n.body) {\n      s += ' ' + repr1(n.body, nl2, c)\n    }\n    return s + ')'\n  }\n\n\n  // --------\n\n  s += reprcons(n, c)\n\n  if (n instanceof ImportDecl) {\n    s += ' path: ' + repr1(n.path, nl2, c)\n    if (n.localIdent) {\n      s += newline +\n        c.ind + 'localIdent: ' + repr1(n.localIdent, nl2, c)\n    }\n    return s + ' )'\n  }\n\n  if (n instanceof VarDecl) {\n    if (n.group) {\n      s += ' [#' + c.groupId(n.group) + ']'\n    }\n    if (n.type) {\n      s += reprt(n.type.type, newline, c) + ' ' + reprv(n.idents, nl2, c)\n    } else {\n      s += ' (' + n.idents.map(id =>\n        reprt(id.type, newline, c) + reprid(id, c)\n      ).join(' ') + ')'\n    }\n    if (n.values) {\n      s += ' ' + reprv(n.values, nl2, c)\n    }\n    return s + ')'\n  }\n\n  if (n instanceof TypeDecl) {\n    if (n.group) {\n      s += ' [#' + c.groupId(n.group) + ']'\n    }\n    s += ' ' + repr1(n.ident, nl2, c)\n    if (n.alias) {\n      s += ' ='\n    }\n    return s + ' ' + repr1(n.type, nl2, c) + ')'\n  }\n\n  if (n instanceof CallExpr) {\n    s += ' ' + repr1(n.fun, newline, c) + ' ('\n    s += reprv(n.args, nl2, c, '')\n    if (n.hasDots) {\n      s += '...'\n    }\n    return s + '))'\n  }\n\n  // if (n instanceof ParenExpr) {\n  //   return s + ' ' + repr1(n.x, newline, c) + ')'\n  // }\n\n  if (n instanceof TypeConvExpr) {\n    return s + ' ' + repr1(n.expr, newline, c) + ')'\n  }\n\n  if (n instanceof TupleExpr) {\n    return s + ' ' + reprv(n.exprs, nl2, c, '') + ')'\n  }\n\n  if (n.constructor === NoOpStmt) {\n    return 'noop'\n  }\n\n  return '(???'+ reprcons(n, c) + ' ' + repr(n) + ')'\n}\n","import { ByteStr, ByteStrSet } from './bytestr'\nimport { asciibuf } from './util'\nimport { TypeSet } from './typeset'\nimport { Scope, Ent, builtInTypes, builtInValues } from './ast'\nimport { Type } from './types'\n\n// inspired by go/src/cmd/compile/internal/gc/universe.go\n\nexport class Universe {\n  readonly strSet  :ByteStrSet\n  readonly typeSet :TypeSet\n  readonly scope   :Scope\n\n  constructor(strSet :ByteStrSet, typeSet :TypeSet) {\n    this.strSet = strSet\n    this.typeSet = typeSet\n\n    // build scope\n    const decls = new Map<ByteStr,Ent>()\n\n    // export all built-in types\n    for (let name of Object.keys(builtInTypes)) {\n      const t = builtInTypes[name]  // a TypeExpr\n      const namebuf = strSet.emplace(asciibuf(name))\n      // declare t as namebuf of type t.type\n      decls.set(namebuf, new Ent(namebuf, t, null, t.type))\n    }\n\n    // export all built-in values (true, false, nil, etc)\n    for (let name of Object.keys(builtInValues)) {\n      const v = builtInValues[name]  // a Expr\n      const namebuf = strSet.emplace(asciibuf(name))\n      // define v as namebuf with value v of type v.type\n      decls.set(namebuf, new Ent(namebuf, v, v, v.type))\n    }\n\n    this.scope = new Scope(null, decls)\n  }\n\n  // internType potentially returns an equivalent type (t1.equals(t2) == true)\n  // if previously seen. Otherwise it registers t for future calls to this\n  // function and returns t as-is. Populates typeSet.\n  //\n  // The trade-offs are as follows:\n  //\n  //  [-] slower to parse files with many different types because of\n  //      intern-miss overhead.\n  //\n  //  [+] faster to parse files with few types that are used many times\n  //      (common case), since type equality testing is cheap for correct code.\n  //\n  //  [+] uses less memory (fewer resident Type instances).\n  //\n  internType<T extends Type>(t :T) :T {\n    return this.typeSet.intern(t)\n  }\n\n}\n","//\n// Exposes the function\n//   basicTypeCompat(dst :BasicType, src :BasicType) :TypeCompat\n// which can be used to understand how conversion from one type to another\n// affects its value.\n//\n// The result can be\n//\nimport {\n  BasicType,\n  t_uint,\n  t_int,\n  t_i8,\n  t_i16,\n  t_i32,\n  t_i64,\n  t_u8,\n  t_u16,\n  t_u32,\n  t_u64,\n  t_f32,\n  t_f64,\n} from './types'\n\n// type compatibility\nexport enum TypeCompat {\n  NO = 0,   // not compatible\n  LOSSY,    // can be converted at a loss\n  LOSSLESS, // can be converted safely without loss\n}\n\nconst uintz :number = 32 // TODO FIXME: target-dependant\n\n// maps destination type to receiver types and their compatbility type\n// TODO: separate into a \"type\" source file.\nconst typeCompatMap = new Map<BasicType,Map<BasicType,TypeCompat>>([\n\n  [t_u64, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSLESS],\n    [t_int,  TypeCompat.LOSSLESS],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSLESS],\n    [t_i64, TypeCompat.LOSSLESS],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, TypeCompat.LOSSLESS],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_i64, new Map<BasicType,TypeCompat>([\n    [t_uint, uintz <= 63 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [t_int,  TypeCompat.LOSSLESS],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSLESS],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, TypeCompat.LOSSLESS],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_u32, new Map<BasicType,TypeCompat>([\n    [t_uint, uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSLESS],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_i32, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n    [t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_uint, new Map<BasicType,TypeCompat>([\n    [t_int, TypeCompat.LOSSLESS],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSLESS],\n    [t_i64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, uintz >= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [t_u64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_int, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSLESS],\n    [t_i64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, uintz >= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_u16, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n    [t_int,  TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSY],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u32, TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_i16, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n    [t_int,  TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSY],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSY],\n    [t_u32, TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_u8, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n    [t_int,  TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSY],\n    [t_i32, TypeCompat.LOSSY],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u16, TypeCompat.LOSSY],\n    [t_u32, TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_i8, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n    [t_int,  TypeCompat.LOSSY],\n\n    [t_i16, TypeCompat.LOSSY],\n    [t_i32, TypeCompat.LOSSY],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSY],\n    [t_u16, TypeCompat.LOSSY],\n    [t_u32, TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSY],\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_f32, new Map<BasicType,TypeCompat>([\n    [t_uint, TypeCompat.LOSSY],\n    [t_int,  TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSY],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, TypeCompat.LOSSY],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [t_f64, new Map<BasicType,TypeCompat>([\n    [t_uint, uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [t_i8,  TypeCompat.LOSSLESS],\n    [t_i16, TypeCompat.LOSSLESS],\n    [t_i32, TypeCompat.LOSSLESS],\n    [t_i64, TypeCompat.LOSSY],\n\n    [t_u8,  TypeCompat.LOSSLESS],\n    [t_u16, TypeCompat.LOSSLESS],\n    [t_u32, TypeCompat.LOSSLESS],\n    [t_u64, TypeCompat.LOSSY],\n\n    [t_f32, TypeCompat.LOSSLESS],\n  ])],\n])\n\nexport function basicTypeCompat(dst :BasicType, src :BasicType) :TypeCompat {\n  assert(dst !== src, \"same type is always compatible\")\n  let s = typeCompatMap.get(dst)\n  return s && s.get(src) || TypeCompat.NO\n}\n\nTEST(\"basicTypeCompat\", () => {\n  function assertTypeCompat(\n    dst :BasicType,\n    src :BasicType,\n    expect :TypeCompat,\n    cons :Function,\n  ) {\n    const r = basicTypeCompat(dst, src)\n    assert(\n      r === expect,\n      `${dst}(${src}) == ${TypeCompat[r]} (expected ${TypeCompat[expect]})`,\n      cons\n    )\n  }\n\n  function assert_LOSSLESS(dst :BasicType, src :BasicType) {\n    assertTypeCompat(dst, src, TypeCompat.LOSSLESS, assert_LOSSLESS)\n  }\n\n  function assert_LOSSY(dst :BasicType, src :BasicType) {\n    assertTypeCompat(dst, src, TypeCompat.LOSSY, assert_LOSSY)\n  }\n\n  // u64\n  assert_LOSSLESS(t_u64, t_uint)\n  assert_LOSSLESS(t_u64, t_int)\n  assert_LOSSLESS(t_u64, t_i64)\n  assert_LOSSLESS(t_u64, t_u32)\n  assert_LOSSLESS(t_u64, t_i32)\n  assert_LOSSLESS(t_u64, t_u16)\n  assert_LOSSLESS(t_u64, t_i16)\n  assert_LOSSLESS(t_u64, t_u8)\n  assert_LOSSLESS(t_u64, t_i8)\n  assert_LOSSY   (t_u64, t_f32)\n  assert_LOSSY   (t_u64, t_f64)\n\n  // i64\n  assert_LOSSLESS(t_i64, t_uint)\n  if (uintz == 64) {\n    assert_LOSSY(t_i64, t_int)\n  } else {\n    assert_LOSSLESS(t_i64, t_int)\n  }\n  assert_LOSSY   (t_i64, t_u64)\n  assert_LOSSLESS(t_i64, t_u32)\n  assert_LOSSLESS(t_i64, t_i32)\n  assert_LOSSLESS(t_i64, t_u16)\n  assert_LOSSLESS(t_i64, t_i16)\n  assert_LOSSLESS(t_i64, t_u8)\n  assert_LOSSLESS(t_i64, t_i8)\n  assert_LOSSY   (t_i64, t_f32)\n  assert_LOSSY   (t_i64, t_f64)\n\n  // u32\n  if (uintz == 64) {\n    assert_LOSSY(t_u32, t_uint)\n    assert_LOSSY(t_u32, t_int)\n  } else {\n    assert_LOSSLESS(t_u32, t_uint)\n    assert_LOSSLESS(t_u32, t_int)\n  }\n  assert_LOSSY   (t_u32, t_u64)\n  assert_LOSSY   (t_u32, t_i64)\n  assert_LOSSLESS(t_u32, t_i32)\n  assert_LOSSLESS(t_u32, t_u16)\n  assert_LOSSLESS(t_u32, t_i16)\n  assert_LOSSLESS(t_u32, t_u8)\n  assert_LOSSLESS(t_u32, t_i8)\n  assert_LOSSY   (t_u32, t_f32)\n  assert_LOSSY   (t_u32, t_f64)\n\n  // i32\n  assert_LOSSY   (t_i32, t_uint)\n  if (uintz == 64) {\n    assert_LOSSY(t_i32, t_int)\n  } else {\n    assert_LOSSLESS(t_i32, t_int)\n  }\n  assert_LOSSY   (t_i32, t_u64)\n  assert_LOSSY   (t_i32, t_i64)\n  assert_LOSSY   (t_i32, t_u32)\n  assert_LOSSLESS(t_i32, t_u16)\n  assert_LOSSLESS(t_i32, t_i16)\n  assert_LOSSLESS(t_i32, t_u8)\n  assert_LOSSLESS(t_i32, t_i8)\n  assert_LOSSY   (t_i32, t_f32)\n  assert_LOSSY   (t_i32, t_f64)\n\n  // u16\n  assert_LOSSY   (t_u16, t_uint)\n  assert_LOSSY   (t_u16, t_int)\n  assert_LOSSY   (t_u16, t_u64)\n  assert_LOSSY   (t_u16, t_i64)\n  assert_LOSSY   (t_u16, t_u32)\n  assert_LOSSY   (t_u16, t_i32)\n  assert_LOSSLESS(t_u16, t_i16)\n  assert_LOSSLESS(t_u16, t_u8)\n  assert_LOSSLESS(t_u16, t_i8)\n  assert_LOSSY   (t_u16, t_f32)\n  assert_LOSSY   (t_u16, t_f64)\n\n  // i16\n  assert_LOSSY   (t_i16, t_uint)\n  assert_LOSSY   (t_i16, t_int)\n  assert_LOSSY   (t_i16, t_u64)\n  assert_LOSSY   (t_i16, t_i64)\n  assert_LOSSY   (t_i16, t_u32)\n  assert_LOSSY   (t_i16, t_i32)\n  assert_LOSSY   (t_i16, t_u16)\n  assert_LOSSLESS(t_i16, t_u8)\n  assert_LOSSLESS(t_i16, t_i8)\n  assert_LOSSY   (t_i16, t_f32)\n  assert_LOSSY   (t_i16, t_f64)\n\n  // u8\n  assert_LOSSY   (t_u8, t_uint)\n  assert_LOSSY   (t_u8, t_int)\n  assert_LOSSY   (t_u8, t_u64)\n  assert_LOSSY   (t_u8, t_i64)\n  assert_LOSSY   (t_u8, t_u32)\n  assert_LOSSY   (t_u8, t_i32)\n  assert_LOSSY   (t_u8, t_u16)\n  assert_LOSSY   (t_u8, t_i16)\n  assert_LOSSLESS(t_u8, t_i8)\n  assert_LOSSY   (t_u8, t_f32)\n  assert_LOSSY   (t_u8, t_f64)\n\n  // i8\n  assert_LOSSY   (t_i8, t_uint)\n  assert_LOSSY   (t_i8, t_int)\n  assert_LOSSY   (t_i8, t_u64)\n  assert_LOSSY   (t_i8, t_i64)\n  assert_LOSSY   (t_i8, t_u32)\n  assert_LOSSY   (t_i8, t_i32)\n  assert_LOSSY   (t_i8, t_u16)\n  assert_LOSSY   (t_i8, t_i16)\n  assert_LOSSY   (t_i8, t_u8)\n  assert_LOSSY   (t_i8, t_f32)\n  assert_LOSSY   (t_i8, t_f64)\n\n  // f64\n  if (uintz <= 32) {\n    assert_LOSSLESS(t_f64, t_uint)\n    assert_LOSSLESS(t_f64, t_int)\n  } else {\n    assert_LOSSY   (t_f64, t_uint)\n    assert_LOSSY   (t_f64, t_int)\n  }\n  assert_LOSSY   (t_f64, t_u64)\n  assert_LOSSY   (t_f64, t_i64)\n  assert_LOSSLESS(t_f64, t_u32)\n  assert_LOSSLESS(t_f64, t_i32)\n  assert_LOSSLESS(t_f64, t_u16)\n  assert_LOSSLESS(t_f64, t_i16)\n  assert_LOSSLESS(t_f64, t_u8)\n  assert_LOSSLESS(t_f64, t_i8)\n  assert_LOSSLESS(t_f64, t_f32)\n\n  // f32\n  assert_LOSSY   (t_f32, t_uint)\n  assert_LOSSY   (t_f32, t_int)\n  assert_LOSSY   (t_f32, t_u64)\n  assert_LOSSY   (t_f32, t_i64)\n  assert_LOSSY   (t_f32, t_u32)\n  assert_LOSSY   (t_f32, t_i32)\n  assert_LOSSLESS(t_f32, t_u16)\n  assert_LOSSLESS(t_f32, t_i16)\n  assert_LOSSLESS(t_f32, t_u8)\n  assert_LOSSLESS(t_f32, t_i8)\n  assert_LOSSY   (t_f32, t_f64)\n})\n","import { SrcFileSet, Pos, NoPos } from './pos'\nimport { Universe } from './universe'\nimport { TypeCompat, basicTypeCompat } from './typecompat'\nimport { ErrorCode, ErrorReporter, ErrorHandler } from './error'\nimport { debuglog as dlog } from './util'\nimport { token } from './token'\nimport { Num, numEvalU32 } from './num'\nimport * as ast from './ast'\nimport {\n  ReturnStmt,\n  Expr,\n  Ident,\n  LiteralExpr,\n  SelectorExpr,\n  TypeConvExpr,\n  IndexExpr,\n  SliceExpr,\n} from './ast'\n\nimport {\n  Type,\n\n  UnresolvedType,\n  BasicType,\n  StrType,\n  RestType,\n  TupleType,\n  FunType,\n  OptionalType,\n  UnionType,\n\n  t_nil, t_bool,\n  // t_u8, t_i8, t_u16, t_i16, t_u32, t_i32, t_u64, t_i64,\n  // t_uint, t_int, t_usize, t_isize,\n  t_str0, t_str, t_stropt\n} from './types'\n\n\nfunction isResolvedType(t :Type|null) :t is Type {\n  return t ? t.constructor !== UnresolvedType : false\n}\n\n\nexport class TypeResolver extends ErrorReporter {\n  fset       :SrcFileSet\n  universe   :Universe\n  unresolved :Set<UnresolvedType>\n\n  constructor() {\n    super('E_RESOLVE')\n    this.setupResolvers()\n  }\n\n  init(fset :SrcFileSet, universe :Universe, errh :ErrorHandler|null) {\n    // note: normally initialized per package (not per file)\n    const r = this\n    r.errh = errh\n    r.fset = fset\n    r.universe = universe\n    r.unresolved = new Set<UnresolvedType>()\n  }\n\n  // error resports an error\n  //\n  error(msg :string, pos :Pos = NoPos, typ? :ErrorCode) {\n    const r = this\n    r.errorAt(msg, r.fset.position(pos), typ)\n  }\n\n  // syntaxError reports a syntax error.\n  // Interface is compatible with that of Parser.syntaxError\n  //\n  syntaxError(msg :string, pos :Pos = NoPos) {\n    this.error(msg, pos, 'E_SYNTAX')\n  }\n\n\n  getTupleType(types :Type[]) :TupleType {\n    return this.universe.internType(new TupleType(types))\n  }\n\n  getRestType(t :Type) :RestType {\n    return this.universe.internType(new RestType(t))\n  }\n\n  getOptionalUnionType2(l :OptionalType, r :OptionalType) :UnionType {\n    return this.universe.internType(\n      new UnionType(new Set<Type>([\n        l.type instanceof StrType && l.type.length != -1 ? t_stropt : l,\n        r.type instanceof StrType && r.type.length != -1 ? t_stropt : r,\n      ]))\n    )\n  }\n\n  getUnionType2(l :Type, r :Type) :UnionType {\n    return this.universe.internType(\n      new UnionType(new Set<Type>([\n        l instanceof StrType && l.length != -1 ? t_str : l,\n        r instanceof StrType && r.length != -1 ? t_str : r,\n      ]))\n    )\n  }\n\n  getFunType(args :Type[], result :Type) :FunType {\n    return this.universe.internType(new FunType(args, result))\n  }\n\n  getOptionalType(t :Type) {\n    return (\n      t instanceof OptionalType ? t :\n      t instanceof StrType ? t_stropt :\n      this.universe.internType(new OptionalType(t))\n    )\n  }\n\n  getStrType(length :int) :StrType {\n    return (\n      length < 0 ? t_str :\n      length == 0 ? t_str0 :\n      this.universe.internType(new StrType(length))\n    )\n  }\n\n  // resolve attempts to resolve or infer the type of n.\n  // Returns UnresolvedType if the type refers to an undefined identifier.\n  //\n  // This function may mutate n.type, and may call ErrorHandler for undefined\n  // fields.\n  //\n  resolve(n :Expr) :Type {\n    if (n.type instanceof Type /*&& (n.type.constructor !== UnresolvedType)*/) {\n      if (n.type instanceof UnresolvedType) {\n        n.type.addRef(n)\n      }\n      return n.type\n    }\n\n    const r = this\n    let t = r.maybeResolve(n)\n\n    if (!t) {\n      t = r.markUnresolved(n)\n\n      // error failing to resolve field of known type\n      if (\n        n instanceof SelectorExpr &&\n        n.lhs instanceof Ident &&\n        n.lhs.ent\n      ) {\n        // Partially resolved selector, e.g.\n        // \"a.B undefined (type <typeof(a)> has no field or method B)\"\n        r.error(`${n} undefined`, n.pos)\n      }\n    }\n\n    n.type = t\n\n    return t\n  }\n\n  resolvers = new Map<Function,(n:any)=>Type|null>()\n\n  // setupResolvers defines all resolvers.\n  // Called by constructor\n  //\n  setupResolvers() {\n    const r = this\n\n    // nodes which has a TypeExpr \"type\" field\n    r.resolvers.set(ast.Field,    r.maybeResolveNodeWithTypeExpr)\n    r.resolvers.set(ast.VarDecl,  r.maybeResolveNodeWithTypeExpr)\n    r.resolvers.set(ast.TypeDecl, r.maybeResolveNodeWithTypeExpr)\n\n    r.resolvers.set(ast.Ident, r.maybeResolveIdent)\n    r.resolvers.set(ast.Block, r.maybeResolveBlock)\n    r.resolvers.set(ast.FunExpr, r.maybeResolveFunExpr)\n    r.resolvers.set(ast.TupleExpr, r.maybeResolveTupleExpr)\n    r.resolvers.set(ast.RestTypeExpr, r.maybeResolveRestTypeExpr)\n    r.resolvers.set(ast.CallExpr, r.maybeResolveCallExpr)\n    r.resolvers.set(ast.Assignment, r.maybeResolveAssignment)\n    r.resolvers.set(ast.Operation, r.maybeResolveOperation)\n    r.resolvers.set(ast.IndexExpr, r.maybeResolveIndexExpr)\n    r.resolvers.set(ast.IfExpr, r.maybeResolveIfExpr)\n\n    // r.resolvers.set(ast.ReturnStmt, r.maybeResolveReturnStmt)\n  }\n\n\n  // maybeResolve attempts to resolve or infer the type of n.\n  // Returns null if the type can't be resolved or inferred.\n  // May mutate n.type and may call ErrorHandler.\n  //\n  maybeResolve(n :Expr|ReturnStmt) :Type|null {\n    const r = this\n\n    if (isResolvedType(n.type)) {\n      // already resolved\n      return n.type\n    }\n\n    // map node type to resolver function\n    const resolver = r.resolvers.get(n.constructor)\n    if (resolver) {\n      return n.type = resolver(n)\n    }\n\n    dlog(`TODO handle ${n.constructor.name}`)\n    return null  // unknown type\n  }\n\n\n  // maybeResolveReturnStmt = (n :ast.ReturnStmt) => {\n  //   // return expressions always represents type of its results, if any\n  //   const r = this\n  //   return n.result ? r.resolve(n.result) : t_nil\n  // }\n\n\n  maybeResolveNodeWithTypeExpr = (n :ast.Field|ast.VarDecl|ast.TypeDecl) => {\n    // nodes which has a TypeExpr \"type\" field\n    return n.type ? n.type.type : null\n  }\n\n\n  maybeResolveIdent = (n :ast.Ident) => {\n    const r = this\n    if (n.ent) {\n      if (isResolvedType(n.ent.type)) {\n        return n.ent.type\n      }\n      const tx = n.ent.getTypeExpr()\n      if (tx) {\n        return r.maybeResolve(tx)\n      }\n    }\n    return null\n  }\n\n\n  maybeResolveBlock = (n :ast.Block) => {\n    const r = this\n    // type of block is the type of the last statement, or in the case\n    // of return, the type of the returned value.\n    if (n.list.length == 0) {\n      // empty block\n      return t_nil\n    }\n    let s = n.list[n.list.length-1]\n    if (s instanceof Expr) {\n      return r.resolve(s)\n    }\n    // last statement is a declaration\n    // dlog(`TODO handle Block with declaration at end`)\n    return t_nil\n  }\n\n\n  maybeResolveFunExpr = (n :ast.FunExpr) => {\n    const r = this\n\n    const s = n.sig\n    let restype :Type = t_nil\n    if (s.result) {\n      restype = r.resolve(s.result)\n    } else {\n      // automatic result type\n      if (n.body) {\n        restype = r.resolve(n.body)\n      } // else: leave restype as t_nil\n    }\n\n    let argtypes = s.params.map(field => r.resolve(field.type))\n    let t = r.getFunType(argtypes, restype)\n\n    if (t.result instanceof UnresolvedType) {\n      t.result.addRef(t)\n    }\n    return t\n  }\n\n\n  maybeResolveTupleExpr = (n :ast.TupleExpr) => {\n    return this.maybeResolveTupleType(n.exprs)\n  }\n\n  maybeResolveTupleType(exprs :Expr[]) {\n    const r = this\n    let types :Type[] = []\n    for (const x of exprs) {\n      // Note: We don't check for unresolved types\n      //\n      // TODO: when x is unresolved, register the tuple _type_ as a dependency\n      // for that unresolved type, so that laste-bind can wire it up.\n      //\n      types.push(r.resolve(x))\n    }\n    return r.getTupleType(types)\n  }\n\n\n  maybeResolveRestTypeExpr = (n :ast.RestTypeExpr) => {\n    const r = this\n    let t = r.maybeResolve(n.expr)\n    return isResolvedType(t) ? r.getRestType(t) : t\n  }\n\n\n  maybeResolveCallExpr = (n :ast.CallExpr) => {\n    const r = this\n    const funtype = r.resolve(n.fun)\n    // resolve argument types\n    for (let arg of n.args) {\n      // r.resolve(arg)\n      r.maybeResolve(arg)\n    }\n    if (funtype instanceof FunType) {\n      return funtype.result\n    }\n    return null\n  }\n\n\n  maybeResolveAssignment = (n :ast.Assignment) => {\n    const r = this\n    if (n.lhs.length == 1) {\n      // single assignment (common case)\n      return r.resolve(n.lhs[0])\n    }\n    // multi-assignment yields tuple\n    // E.g.\n    //   a i32\n    //   b f64\n    //   t = a, b = 1, 2.3\n    //   typeof(t)  // => (i32, f64)\n    //\n    return r.maybeResolveTupleType(n.lhs)\n  }\n\n\n  maybeResolveOperation = (n :ast.Operation) => {\n    const r = this\n    const xt = r.resolve(n.x)\n    if (!n.y) {\n      // unary\n      return xt\n    } else {\n      const yt = r.resolve(n.y)\n\n      if (n.op > token.cmpop_beg && n.op < token.cmpop_end) {\n        // comparison operations always yield boolean values\n        return t_bool\n      }\n\n      if (xt instanceof UnresolvedType || yt instanceof UnresolvedType) {\n        // operation's effective type not yet know\n        return null\n      }\n\n      if (xt === yt || xt.equals(yt)) {\n        // both operands types are equivalent\n        return xt\n      }\n\n      let x = r.convert(xt, n.y)\n      if (x) {\n        return x === n.y ? yt : r.resolve(x)\n      }\n\n      r.error(`invalid operation (mismatched types ${xt} and ${yt})`, n.pos)\n    }\n    return null\n  }\n\n\n  // resolveIndex attempts to resolve the type of an index expression.\n  //\n  maybeResolveIndexExpr = (n :ast.IndexExpr) => {\n    const r = this\n\n    // resolve operand type\n    let opt = r.resolve(n.operand)\n\n    if (opt instanceof UnresolvedType) {\n      // defer to bind stage\n      dlog(`[index type] deferred to bind stage`)\n    } else if (opt instanceof TupleType) {\n      r.maybeResolveTupleAccess(n)\n    } else {\n      dlog(`[index type] operand is not a tuple; opt = ${opt}`)\n    }\n\n    return n.type\n  }\n\n\n  maybeResolveIfExpr = (n :ast.IfExpr) => {\n    const r = this\n\n    // resolve \"then\" branch type\n    let thentyp = r.resolve(n.then)\n\n    if (!n.els_) {\n      // e.g. `if x A => A`\n\n      // with only a single then branch, the result type is that branch.\n      // if the branch is not taken, the result is a zero-initialized T.\n\n      // special case: if thentyp is a string constant, we must resolve to\n      // just \"str\" (length only known at runtime) since if the branch is\n      // not taken, a zero-initialized string is returned, which is zero.\n      if (thentyp instanceof StrType && thentyp.length != 0) {\n        return t_str\n      }\n\n      return thentyp\n    }\n\n    // resolve \"else\" branch type\n    let eltyp = r.resolve(n.els_)\n    \n    if (eltyp.equals(thentyp)) {\n      // e.g. `if x A else A => A`\n      // e.g. `if x A? else A? => A?`\n      return thentyp\n    }\n\n    if (eltyp === t_nil) {\n      if (thentyp === t_nil) {\n        // both branches are nil/void\n        // e.g. `if x nil else nil => nil`\n        return t_nil\n      }\n      // e.g. `if x A else nil => A?`\n      if (thentyp instanceof BasicType) {\n        // e.g. `if x int else nil`\n        r.error(`mixing ${thentyp} and optional type`, n.pos, 'E_CONV')\n      }\n      // makes the type optional\n      return r.getOptionalType(thentyp)\n    }\n\n    if (thentyp === t_nil) {\n      // e.g. `if x nil else A => A?`\n      if (eltyp instanceof BasicType) {\n        // e.g. `if x nil else int`\n        r.error(`mixing optional and ${eltyp} type`, n.pos, 'E_CONV')\n      }\n      return r.getOptionalType(eltyp)\n    }\n\n    if (eltyp instanceof OptionalType) {\n      if (thentyp instanceof OptionalType) {\n        // e.g. `if x A? else B? => A?|B?`\n        //\n        // Invariant: NOT eltyp.type.equals(thentyp.type)\n        //   since we checked that already above with eltyp.equals(thentyp)\n        //\n\n        if (eltyp.type instanceof StrType &&\n            thentyp.type instanceof StrType\n        ) {\n          // e.g. `a str?; b str?; if x a else b => str`\n          assert(eltyp.type.length != thentyp.type.length,\n            \"str type matches but StrType.equals failed\")\n          return t_stropt\n        }\n\n        return r.getOptionalUnionType2(thentyp, eltyp)\n      }\n      // e.g. `if x A else B? => A?|B?`\n      // e.g. `if x A else A? => A?`\n      // e.g. `if x A|B else A? => A?|B?`\n      return r.joinOptional(n.pos, eltyp, thentyp)\n    }\n\n    if (thentyp instanceof OptionalType) {\n      // e.g. `if x A? else B => A?|B?`\n      // e.g. `if x A? else B|C => A?|B?|C?`\n      return r.joinOptional(n.pos, thentyp, eltyp)\n    }\n\n    if (eltyp instanceof StrType && thentyp instanceof StrType) {\n      // e.g. `if x \"foo\" else \"x\" => str`\n      return t_str\n    }\n\n    if (eltyp instanceof UnionType) {\n      if (thentyp instanceof OptionalType) {\n        // e.g. `if x A? else B|C => A?|B?|C?`\n        return r.joinOptional(n.pos, thentyp, eltyp)\n      }\n      if (thentyp instanceof UnionType) {\n        // e.g. `if x A|B else A|C => A|B|C`\n        // e.g. `if x A|B? else A|C => A?|B?|C?`\n        return r.mergeUnions(thentyp, eltyp)\n      }\n      // else: e.g. `if x A else B|C => B|C|A`\n      eltyp.add(thentyp)\n      return eltyp\n    }\n\n    if (thentyp instanceof UnionType) {\n      // e.g. `if x A|B else C => A|B|C`\n      thentyp.add(eltyp)\n      return thentyp\n    }\n\n    // e.g. `if x A else B => A|B`\n    return r.getUnionType2(thentyp, eltyp)\n  }\n\n\n\n  // joinOptional takes two types, one of them optional and the other not,\n  // and considers them as two branches that are merging into one type, thus\n  // this function returns an optional for t. The returned optional may be\n  // incompatible with `opt`, or it might be t in the case of a union type.\n  //\n  joinOptional(pos :Pos, opt :OptionalType, t :Type) :Type {\n    const r = this\n\n    if (opt.type.equals(t)) {\n      // return optional type since underlying type == t\n      return opt\n    }\n\n    if (opt.type instanceof StrType && t instanceof StrType) {\n      assert(opt.type.length != t.length,\n        \"str type matches but StrType.equals failed\")\n      // if the optional type is a string and the compile-time length\n      // differs, return an optional string type with unknown length.\n      return t_stropt\n    }\n\n    if (t instanceof UnionType) {\n      let ut = new UnionType(new Set<Type>([opt]))\n      for (let t1 of t.types) {\n        if (!(t1 instanceof OptionalType)) {\n          if (t1 instanceof BasicType) {\n            this.error(`mixing optional and ${t1} type`, pos, 'E_CONV')\n          } else {\n            t1 = r.getOptionalType(t1)\n          }\n        }\n        ut.add(t1)\n      }\n      return ut\n    }\n\n    if (t instanceof BasicType) {\n      this.error(`mixing optional and ${t} type`, pos, 'E_CONV')\n      return t\n    }\n\n    // t is different than opt -- return optional of t\n    return r.getOptionalType(t)\n  }\n\n\n  mergeOptionalUnions(a :UnionType, b :UnionType) :UnionType {\n    const r = this\n    let ut = new UnionType(new Set<Type>())\n    for (let t of a.types) {\n      if (!(t instanceof OptionalType)) {\n        t = r.getOptionalType(t)\n      }\n      ut.add(t)\n    }\n    for (let t of b.types) {\n      if (!(t instanceof OptionalType)) {\n        t = r.getOptionalType(t)\n      }\n      ut.add(t)\n    }\n    return r.universe.internType(ut)\n  }\n\n\n  mergeUnions(a :UnionType, b :UnionType) :UnionType {\n    const r = this\n    let ut = new UnionType(new Set<Type>())\n    for (let t of a.types) {\n      if (t instanceof OptionalType) {\n        return r.mergeOptionalUnions(a, b)\n      }\n      ut.add(t)\n    }\n    for (let t of b.types) {\n      if (t instanceof OptionalType) {\n        return r.mergeOptionalUnions(a, b)\n      }\n      ut.add(t)\n    }\n    return r.universe.internType(ut)\n  }\n\n  // resolveIndex attempts to resolve the type of an index expression.\n  // returns x as a convenience.\n  //\n  resolveIndex(x :IndexExpr) :IndexExpr {\n    const r = this\n\n    // resolve operand type\n    let opt = r.resolve(x.operand)\n\n    if (opt instanceof UnresolvedType) {\n      // defer to bind stage\n      dlog(`[index type] deferred to bind stage`)\n    } else if (opt instanceof TupleType) {\n      r.maybeResolveTupleAccess(x)\n    } else {\n      dlog(`TODO [index type] operand is not a tuple; opt = ${opt}`)\n    }\n\n    return x\n  }\n\n\n  tupleSlice(x :SliceExpr) :bool {\n    const p = this\n\n    let tupletype = x.operand.type as TupleType\n    assert(tupletype, 'unresolved operand type')\n    assert(tupletype instanceof TupleType)\n    assert(tupletype.types.length > 0, 'empty tuple')\n\n    let tuplelen = tupletype.types.length\n    let starti = 0\n    let endi = tuplelen\n\n    if (x.start) {\n      starti = numEvalU32(x.start)\n      if (starti < 0) {\n        p.syntaxError(`invalid index into type ${tupletype}`, x.start.pos)\n        return false\n      }\n      if (starti >= tuplelen) {\n        p.outOfBoundsAccess(starti, tupletype, x.start.pos)\n        return false\n      }\n    }\n\n    if (x.end) {\n      endi = numEvalU32(x.end)\n      if (endi < 0) {\n        p.syntaxError(`invalid index into type ${tupletype}`, x.end.pos)\n        return false\n      }\n      if (endi >= tuplelen) {\n        p.outOfBoundsAccess(endi, tupletype, x.end.pos)\n        return false\n      }\n    }\n\n    if (starti >= endi) {\n      if (starti == endi) {\n        p.syntaxError(`invalid empty slice: ${starti} == ${endi}`, x.pos)\n      } else {\n        p.syntaxError(`invalid slice index: ${starti} > ${endi}`, x.pos)\n      }\n      return false\n    }\n\n    let len = endi - starti\n\n    if (len == 1) {\n      p.syntaxError(\n        `invalid single-element slice into type ${tupletype}`,\n        x.pos,\n        // `Instead of slicing a single element from a tuple, ` +\n        // `access it directly with a subscript operation: ` +\n        // `${x.operand}[${x.start || x.end}]`,\n      )\n      return false\n    }\n\n    x.startnum = starti\n    x.endnum = endi\n\n    if (len == tuplelen) {\n      // e.g. `(1,2,3)[:] => (1,2,3)`\n      x.type = tupletype\n    } else {\n      x.type = p.getTupleType(tupletype.types.slice(starti, endi))\n    }\n\n    return true\n  }\n\n  // maybeResolveTupleAccess attempts to evaluate a tuple access.\n  // x.index must be constant.\n  // Return true if resolution succeeded.\n  //\n  maybeResolveTupleAccess(x :IndexExpr) :bool {\n    const p = this\n\n    let tupletype = x.operand.type as TupleType\n    assert(tupletype, 'unresolved operand type')\n    assert(tupletype instanceof TupleType)\n    assert(tupletype.types.length > 0, 'empty tuple')\n\n    let i = numEvalU32(x.index)\n\n    if (i < 0) {\n      if (i == -1) {\n        p.outOfBoundsAccess(i, tupletype, x.index.pos)\n      } else {\n        p.syntaxError(`invalid index into type ${tupletype}`, x.index.pos)\n      }\n      return false\n    }\n\n    let memberTypes = tupletype.types\n    if (i as int >= memberTypes.length) {\n      p.outOfBoundsAccess(i, tupletype, x.index.pos)\n      return false\n    }\n\n    x.indexnum = i\n    x.type = memberTypes[i as int]\n\n    return true\n  }\n\n  // outOfBoundsAccess reports an error for out-of-bounds access\n  //\n  outOfBoundsAccess(i :Num, t :Type, pos :Pos) {\n    this.syntaxError(`out-of-bounds index ${i} on type ${t}`, pos)\n  }\n\n\n  // registerUnresolved registers expr as having an unresolved type.\n  // Does NOT set expr.type but instead returns an UnresolvedType object.\n  //\n  markUnresolved(expr :Expr) :UnresolvedType {\n    const t = new UnresolvedType(expr)\n    dlog(`expr ${expr} at ${this.fset.position(expr.pos)}`)\n    this.unresolved.add(t)\n    return t\n  }\n\n  // isConstant returns true if the expression is a compile-time constant\n  //\n  isConstant(x :Expr) :bool {\n    return (\n      x instanceof LiteralExpr ||\n      (x instanceof Ident && x.ent != null && x.ent.isConstant())\n    )\n    // TODO: expand\n  }\n\n  // convertType attempts to convert expression x to type t.\n  // If x is already of type t, x is returned unchanged.\n  // If conversion is needed, a TypeConvExpr is returned,\n  // encapsulating x.\n  // If conversion is impossible, null is returned to indicate error.\n  //\n  convert(t :Type, x :Expr) :Expr|null {\n    const r = this\n    const xt = r.resolve(x)\n\n    if (xt === t || xt.equals(t)) {\n      return x\n    }\n\n    if (\n      r.isConstant(x) &&\n      t instanceof BasicType &&\n      xt instanceof BasicType\n    ) {\n      // expression with basic types\n      switch (basicTypeCompat(t, xt)) { // TypeCompat\n        case TypeCompat.NO: {\n          // Note: caller should report error\n          return null\n        }\n        case TypeCompat.LOSSY: {\n          r.error(`constant ${x} truncated to ${t}`, x.pos, 'E_CONV')\n          // TODO: ^ use diag instead with DiagKind.ERROR as the default, so\n          // that user code can override this error into a warning instead, as\n          // it's still valid to perform a lossy conversion.\n          return new TypeConvExpr(x.pos, x.scope, x, t)\n        }\n        case TypeCompat.LOSSLESS: {\n          return new TypeConvExpr(x.pos, x.scope, x, t)\n        }\n      }\n    }\n\n    dlog(`TODO conversion of ${x} into type ${t}`)\n\n    // TODO: figure out a scalable type conversion system\n    // TODO: conversion of other types\n\n    return null\n  }\n}\n","import { UInt64 } from '../int64'\n\n// A Register is a machine register, like AX.\n// They are numbered densely from 0 (for each architecture).\nexport interface Register {\n  num    :int // dense numbering\n  name   :string\n  // objNum :int // arch-specific register number\n}\n\n\nexport type Reg = int // uint8\nexport type RegSet = UInt64  // each bit corresponds to a register\n\nexport const emptyRegSet = UInt64.ZERO\nexport const noReg :Reg = 255\n\n\nexport function fmtRegSet(m :RegSet) :string {\n  let s = '{'\n  for (let r :Reg = 0 >>> 0; !m.isZero(); r++) {\n    if (m.shr(r & 1).isZero()) { // m >> r&1 == 0\n      continue\n    }\n    // m &^= RegSet(1) << r\n    // m = m &^ (RegSet(1) << r)\n    // m = m & ~(RegSet(1) << r)\n    m = m.and(UInt64.ONE.shl(r).not())\n    s += ` r${r}`\n  }\n  return s == '{' ? '{}' : s + ' }'\n}\n\n\n// regBuilder returns a function that can build RegSet from a string\n// of whitespace-separated register names.\n//\nexport function regBuilder(names :string[]) :(s:string)=>RegSet {\n  const num = new Map<string,int>(\n    names.map((k, i) => [k, i]) as [string,int][]\n  )\n  return function(s :string): RegSet {\n    let m = emptyRegSet\n    for (let r of s.trim().split(/\\s+/)) {\n      let n = num.get(r)\n      if (n !== undefined) {\n        // m |= regMask(1) << uint(n)\n        m = m.or(UInt64.ONE.shl(n))\n        continue\n      }\n      panic(\"register \" + r + \" not found\")\n    }\n    return m\n  }\n}\n","import {\n  NativeType,\n  BasicType,\n\n  t_bool,\n  t_u8,\n  // t_i8,\n  t_u16,\n  t_i16,\n  t_u32,\n  t_i32,\n  t_u64,\n  t_i64,\n  // t_uint,\n  // t_int,\n  t_usize,\n  // t_isize,\n  \n  t_f32,\n  t_f64,\n\n  // t_str,\n} from '../types'\nimport { RegSet, emptyRegSet } from './reg'\n\n\n// Strategy borrowed from\n//   go/src/cmd/compile/internal/ssa/op.go\n//\n// Instruction set inspired by\n//   go/src/cmd/compile/internal/ssa/gen/genericOps.go\n//\n\n\ninterface RegInfoEntry {\n  idx  :int    // index in Args array\n  regs :RegSet // allowed input registers\n}\n\nexport class RegInfo {\n  inputs   :RegInfoEntry[]  // allowed input registers\n  outputs  :RegInfoEntry[]  // allowed output registers\n  clobbers :RegSet\n\n  constructor(\n    inputs   :RegSet[] = [],\n    outputs  :RegSet[] = [],\n    clobbers :RegSet = emptyRegSet\n  ) {\n    this.inputs = inputs.map((regs, idx) => ({ idx, regs }))\n    this.outputs = outputs.map((regs, idx) => ({ idx, regs }))\n    this.clobbers = clobbers\n  }\n\n  // inputs and outputs are ordered in register allocation order\n}\n\n\n// A SymEffect describes the effect that an SSA Value has on the variable\n// identified by the symbol in its aux field.\nexport enum SymEffect {\n  None = 0,\n\n  Read = 1,\n  Write = 2,\n  Addr = 4,\n\n  ReadWrite = 1 | 2,  // Read | Write\n}\n\n\nexport class Op {\n  name: string // printed name\n  argLen: int\n  type = null as BasicType|null // default result type\n  aux = null as NativeType|null // type of aux field\n    // number of arguments, if -1, then this operation has a variable number\n    // of arguments\n  constant = false as bool // true if the value is a constant. Value in aux\n  commutative = false as bool\n    // this operation is commutative on its first 2 arguments (e.g. addition)\n  resultInArg0 = false as bool\n    // (first, if a tuple) output of v and v.Args[0] must be allocated to the\n    // same register\n  resultNotInArgs = false as bool\n    // outputs must not be allocated to the same registers as inputs\n  rematerializeable = false as bool\n    // whether a register allocator can recompute a value instead of\n    // spilling/restoring it.\n  clobberFlags = false as bool // this op clobbers flags register\n  call = false as bool         // is a function call\n  nilCheck = false as bool     // this op is a nil check on arg0\n  faultOnNilArg0 = false as bool\n    // this op will fault if arg0 is nil (and aux encodes a small offset)\n  faultOnNilArg1 = false as bool\n    // this op will fault if arg1 is nil (and aux encodes a small offset)\n  usesScratch = false as bool  // this op requires scratch memory space\n  hasSideEffects = false as bool\n    // for \"reasons\", not to be eliminated.  E.g., atomic store.\n  zeroWidth = false as bool\n    // op never translates into any machine code. example: copy, which may\n    // sometimes translate to machine code, is not zero-width.\n  symEffect = SymEffect.None as SymEffect\n    // effect this op has on symbol in aux\n  // asm = \"\" // ObjAs\n  reg = new RegInfo()\n\n  constructor(name :string, argLen :int, props? :Partial<Op>) {\n    if (props) for (let k in props) {\n      ;(this as any)[k] = (props as any)[k]\n    }\n    this.name = name\n    this.argLen = argLen || 0\n  }\n\n  toString() :string {\n    return this.name\n  }\n}\n\n\nconst t_addr = t_usize\n\nfunction op(name :string, argLen :int, props? :Partial<Op>) :Op {\n  return new Op(name, argLen, props)\n}\n\n\n// operations\nexport const ops = {\n\n  // special\n  Invalid:  op(\"Invalid\", 0),\n  Unknown:  op(\"Unknown\", 0),\n    // Unknown value.\n    // Used for Values whose values don't matter because they are dead code.\n  Phi:      op(\"Phi\", -1, {zeroWidth: true}),\n    // select an argument based on which predecessor block we came from\n  Copy:     op(\"Copy\", 1),  // output = arg0\n  Arg:      op(\"Arg\", 0, {zeroWidth: true}), // argument to current function\n  CallArg:  op(\"CallArg\", 1, {zeroWidth: true}), // argument for function call\n  NilCheck: op(\"NilCheck\", 2,\n    {nilCheck: true, faultOnNilArg0: true}), // panic if arg0 is nil. arg1=mem.\n\n  // function calls\n  //\n  // Arguments to the call have already been written to the stack.\n  // Return values appear on the stack.\n  Call:     op(\"Call\", 1, {aux: t_usize, call: true}), // call function\n  TailCall: op(\"TailCall\", 1, {aux: t_usize, call: true}), // call function\n  // ClosureCall: op(\"ClosureCall\", 3, {aux: t_usize, call: true})\n    // arg0=code pointer, arg1=context ptr, arg2=memory.  aux=arg size.\n  // ICall: op(\"ICall\", 2, {aux: t_usize, call: true})\n    // interface call.  arg0=code pointer, arg1=memory, aux=arg size.\n\n\n  // constants\n  // Constant values are stored in the aux field.\n  ConstBool:   op(\"ConstBool\", 0, {aux: t_bool, constant: true}),\n    // aux is 0=false, 1=true\n  ConstI8:     op(\"ConstI8\",   0, {aux: t_u8, constant: true}),\n    // aux is sign-extended 8 bits\n  ConstI16:    op(\"ConstI16\",  0, {aux: t_u16, constant: true}),\n    // aux is sign-extended 16 bits\n  ConstI32:    op(\"ConstI32\",  0, {aux: t_u32, constant: true}),\n    // aux is sign-extended 32 bits\n  ConstI64:    op(\"ConstI64\", 0, {aux: t_u64, constant: true}),\n    // aux is Int64\n  ConstF32:    op(\"ConstF32\", 0, {aux: t_u32, constant: true}),\n    // value is math.Float64frombits(uint64(aux))\n    // and is exactly prepresentable as float 32\n  ConstF64:    op(\"ConstF64\", 0, {aux: t_u64, constant: true}),\n    // value is math.Float64frombits(uint64(aux))\n  // ConstString: op(\"ConstString\", 0, {aux: t_str}),\n  //   // value is aux (string)\n\n\n  // stack\n  SP: op(\"SP\", 0, {zeroWidth: true}), // stack pointer\n    // The SP pseudo-register is a virtual stack pointer used to refer\n    // to frame-local variables and the arguments being prepared for\n    // function calls. It points to the top of the local stack frame,\n    // so references should use negative offsets in the range\n    // [âˆ’framesize, 0): x-8(SP), y-4(SP), and so on.\n  SB: op(\"SB\", 0, {type: t_usize, zeroWidth: true}),\n    // static base pointer (a.k.a. globals pointer)\n    // SB is a pseudo-register that holds the \"static base\" pointer,\n    // i.e. the address of the beginning of the program address space.\n\n\n  // memory\n  Load:  op(\"Load\", 2),\n    // Load from arg0. arg1=addr\n  Store: op(\"Store\", 3, {type: t_addr}),\n    // Store arg1 to arg0.  arg2=addr, aux=type\n  Move:  op(\"Move\", 3, {type: t_addr}),\n    // arg0=destptr, arg1=srcptr, arg2=addr, aux=type\n  Zero:  op(\"Zero\", 2, {type: t_addr}),\n    // arg0=destptr, arg1=addr, auxint=size, aux=type\n\n\n  // 2-input arithmetic\n  // Types must be consistent with typing.\n  // Add, for example, must take two values of the same type and produces that\n  // same type\n  //\n  // arg0 + arg1 ; sign-agnostic addition\n  AddI8:  op(\"AddI8\",  2, {commutative: true, resultInArg0: true}),\n  AddI16: op(\"AddI16\", 2, {commutative: true, resultInArg0: true}),\n  AddI32: op(\"AddI32\", 2, {commutative: true, resultInArg0: true}),\n  AddI64: op(\"AddI64\", 2, {commutative: true, resultInArg0: true}),\n  AddF32: op(\"AddF32\", 2, {commutative: true, resultInArg0: true}),\n  AddF64: op(\"AddF64\", 2, {commutative: true, resultInArg0: true}),\n  //\n  // arg0 - arg1 ; sign-agnostic subtraction\n  SubI8:  op(\"SubI8\",  2, {resultInArg0: true}),\n  SubI16: op(\"SubI16\", 2, {resultInArg0: true}),\n  SubI32: op(\"SubI32\", 2, {resultInArg0: true}),\n  SubI64: op(\"SubI64\", 2, {resultInArg0: true}),\n  SubF32: op(\"SubF32\", 2, {resultInArg0: true}),\n  SubF64: op(\"SubF64\", 2, {resultInArg0: true}),\n  //\n  // arg0 * arg1 ; sign-agnostic multiplication\n  MulI8:  op(\"MulI8\",  2, {commutative: true, resultInArg0: true}),\n  MulI16: op(\"MulI16\", 2, {commutative: true, resultInArg0: true}),\n  MulI32: op(\"MulI32\", 2, {commutative: true, resultInArg0: true}),\n  MulI64: op(\"MulI64\", 2, {commutative: true, resultInArg0: true}),\n  MulF32: op(\"MulF32\", 2, {commutative: true, resultInArg0: true}),\n  MulF64: op(\"MulF64\", 2, {commutative: true, resultInArg0: true}),\n  //\n  // arg0 / arg1 ; division\n  DivS8:  op(\"DivS8\",  2, {resultInArg0: true}), // signed (result is truncated toward zero)\n  DivU8:  op(\"DivU8\",  2, {resultInArg0: true}), // unsigned (result is floored)\n  DivS16: op(\"DivS16\", 2, {resultInArg0: true}),\n  DivU16: op(\"DivU16\", 2, {resultInArg0: true}),\n  DivS32: op(\"DivS32\", 2, {resultInArg0: true}),\n  DivU32: op(\"DivU32\", 2, {resultInArg0: true}),\n  DivS64: op(\"DivS64\", 2, {resultInArg0: true}),\n  DivU64: op(\"DivU64\", 2, {resultInArg0: true}),\n  DivF32: op(\"DivF32\", 2, {resultInArg0: true}),\n  DivF64: op(\"DivF64\", 2, {resultInArg0: true}),\n  //\n  // arg0 % arg1 ; remainder\n  RemS8:  op(\"RemS8\",  2, {resultInArg0: true}), // signed (result has the sign of the dividend)\n  RemU8:  op(\"RemU8\",  2, {resultInArg0: true}), // unsigned\n  RemS16: op(\"RemS16\", 2, {resultInArg0: true}),\n  RemU16: op(\"RemU16\", 2, {resultInArg0: true}),\n  RemS32: op(\"RemS32\", 2, {resultInArg0: true}),\n  RemU32: op(\"RemU32\", 2, {resultInArg0: true}),\n  RemI64: op(\"RemI64\", 2, {resultInArg0: true}),\n  RemU64: op(\"RemU64\", 2, {resultInArg0: true}),\n  //\n  // arg0 & arg1 ; sign-agnostic bitwise and\n  AndI8:  op(\"AndI8\",  2, {commutative: true, resultInArg0: true}),\n  AndI16: op(\"AndI16\", 2, {commutative: true, resultInArg0: true}),\n  AndI32: op(\"AndI32\", 2, {commutative: true, resultInArg0: true}),\n  AndI64: op(\"AndI64\", 2, {commutative: true, resultInArg0: true}),\n  //\n  // arg0 | arg1 ; sign-agnostic bitwise inclusive or\n  OrI8:  op(\"OrI8\",  2, {commutative: true, resultInArg0: true}),\n  OrI16: op(\"OrI16\", 2, {commutative: true, resultInArg0: true}),\n  OrI32: op(\"OrI32\", 2, {commutative: true, resultInArg0: true}),\n  OrI64: op(\"OrI64\", 2, {commutative: true, resultInArg0: true}),\n  //\n  // arg0 ^ arg1 ; sign-agnostic bitwise exclusive or\n  XorI8:  op(\"XorI8\",  2, {commutative: true, resultInArg0: true}),\n  XorI16: op(\"XorI16\", 2, {commutative: true, resultInArg0: true}),\n  XorI32: op(\"XorI32\", 2, {commutative: true, resultInArg0: true}),\n  XorI64: op(\"XorI64\", 2, {commutative: true, resultInArg0: true}),\n  //\n  // For shifts, AxB means the shifted value has A bits and the shift amount\n  // has B bits.\n  // Shift amounts are considered unsigned.\n  // If arg1 is known to be less than the number of bits in arg0,\n  // then aux may be set to 1.\n  // According to the Go assembler, this enables better code generation\n  // on some platforms.\n  //\n  // arg0 << arg1 ; sign-agnostic shift left\n  ShLI8x8:   op(\"ShLI8x8\",   2, {aux: t_bool}),\n  ShLI8x16:  op(\"ShLI8x16\",  2, {aux: t_bool}),\n  ShLI8x32:  op(\"ShLI8x32\",  2, {aux: t_bool}),\n  ShLI8x64:  op(\"ShLI8x64\",  2, {aux: t_bool}),\n  ShLI16x8:  op(\"ShLI16x8\",  2, {aux: t_bool}),\n  ShLI16x16: op(\"ShLI16x16\", 2, {aux: t_bool}),\n  ShLI16x32: op(\"ShLI16x32\", 2, {aux: t_bool}),\n  ShLI16x64: op(\"ShLI16x64\", 2, {aux: t_bool}),\n  ShLI32x8:  op(\"ShLI32x8\",  2, {aux: t_bool}),\n  ShLI32x16: op(\"ShLI32x16\", 2, {aux: t_bool}),\n  ShLI32x32: op(\"ShLI32x32\", 2, {aux: t_bool}),\n  ShLI32x64: op(\"ShLI32x64\", 2, {aux: t_bool}),\n  ShLI64x8:  op(\"ShLI64x8\",  2, {aux: t_bool}),\n  ShLI64x16: op(\"ShLI64x16\", 2, {aux: t_bool}),\n  ShLI64x32: op(\"ShLI64x32\", 2, {aux: t_bool}),\n  ShLI64x64: op(\"ShLI64x64\", 2, {aux: t_bool}),\n  //\n  // arg0 >> arg1 ; sign-replicating (arithmetic) shift right\n  ShRS8x8:   op(\"ShRS8x8\",   2, {aux: t_bool}),\n  ShRS8x16:  op(\"ShRS8x16\",  2, {aux: t_bool}),\n  ShRS8x32:  op(\"ShRS8x32\",  2, {aux: t_bool}),\n  ShRS8x64:  op(\"ShRS8x64\",  2, {aux: t_bool}),\n  ShRS16x8:  op(\"ShRS16x8\",  2, {aux: t_bool}),\n  ShRS16x16: op(\"ShRS16x16\", 2, {aux: t_bool}),\n  ShRS16x32: op(\"ShRS16x32\", 2, {aux: t_bool}),\n  ShRS16x64: op(\"ShRS16x64\", 2, {aux: t_bool}),\n  ShRS32x8:  op(\"ShRS32x8\",  2, {aux: t_bool}),\n  ShRS32x16: op(\"ShRS32x16\", 2, {aux: t_bool}),\n  ShRS32x32: op(\"ShRS32x32\", 2, {aux: t_bool}),\n  ShRS32x64: op(\"ShRS32x64\", 2, {aux: t_bool}),\n  ShRS64x8:  op(\"ShRS64x8\",  2, {aux: t_bool}),\n  ShRS64x16: op(\"ShRS64x16\", 2, {aux: t_bool}),\n  ShRS64x32: op(\"ShRS64x32\", 2, {aux: t_bool}),\n  ShRS64x64: op(\"ShRS64x64\", 2, {aux: t_bool}),\n  //\n  // arg0 >> arg1 (aka >>>) ; zero-replicating (logical) shift right\n  ShRU8x8:   op(\"ShRU8x8\",   2, {aux: t_bool}),\n  ShRU8x16:  op(\"ShRU8x16\",  2, {aux: t_bool}),\n  ShRU8x32:  op(\"ShRU8x32\",  2, {aux: t_bool}),\n  ShRU8x64:  op(\"ShRU8x64\",  2, {aux: t_bool}),\n  ShRU16x8:  op(\"ShRU16x8\",  2, {aux: t_bool}),\n  ShRU16x16: op(\"ShRU16x16\", 2, {aux: t_bool}),\n  ShRU16x32: op(\"ShRU16x32\", 2, {aux: t_bool}),\n  ShRU16x64: op(\"ShRU16x64\", 2, {aux: t_bool}),\n  ShRU32x8:  op(\"ShRU32x8\",  2, {aux: t_bool}),\n  ShRU32x16: op(\"ShRU32x16\", 2, {aux: t_bool}),\n  ShRU32x32: op(\"ShRU32x32\", 2, {aux: t_bool}),\n  ShRU32x64: op(\"ShRU32x64\", 2, {aux: t_bool}),\n  ShRU64x8:  op(\"ShRU64x8\",  2, {aux: t_bool}),\n  ShRU64x16: op(\"ShRU64x16\", 2, {aux: t_bool}),\n  ShRU64x32: op(\"ShRU64x32\", 2, {aux: t_bool}),\n  ShRU64x64: op(\"ShRU64x64\", 2, {aux: t_bool}),\n\n\n  // 2-input comparisons\n  //\n  // arg0 == arg1 ; sign-agnostic compare equal\n  EqI8:  op(\"EqI8\",  2, {commutative: true, type: t_bool}),\n  EqI16: op(\"EqI16\", 2, {commutative: true, type: t_bool}),\n  EqI32: op(\"EqI32\", 2, {commutative: true, type: t_bool}),\n  EqI64: op(\"EqI64\", 2, {commutative: true, type: t_bool}),\n  EqF32: op(\"EqF32\", 2, {commutative: true, type: t_bool}),\n  EqF64: op(\"EqF64\", 2, {commutative: true, type: t_bool}),\n  //\n  // arg0 != arg1 ; sign-agnostic compare unequal\n  NeqI8:  op(\"NeqI8\",  2, {commutative: true, type: t_bool}),\n  NeqI16: op(\"NeqI16\", 2, {commutative: true, type: t_bool}),\n  NeqI32: op(\"NeqI32\", 2, {commutative: true, type: t_bool}),\n  NeqI64: op(\"NeqI64\", 2, {commutative: true, type: t_bool}),\n  NeqF32: op(\"NeqF32\", 2, {commutative: true, type: t_bool}),\n  NeqF64: op(\"NeqF64\", 2, {commutative: true, type: t_bool}),\n  //\n  // arg0 < arg1 ; less than\n  LessS8:  op(\"LessS8\",  2, {type: t_bool}), // signed\n  LessU8:  op(\"LessU8\",  2, {type: t_bool}), // unsigned\n  LessS16: op(\"LessS16\", 2, {type: t_bool}),\n  LessU16: op(\"LessU16\", 2, {type: t_bool}),\n  LessS32: op(\"LessS32\", 2, {type: t_bool}),\n  LessU32: op(\"LessU32\", 2, {type: t_bool}),\n  LessS64: op(\"LessS64\", 2, {type: t_bool}),\n  LessU64: op(\"LessU64\", 2, {type: t_bool}),\n  LessF32: op(\"LessF32\", 2, {type: t_bool}),\n  LessF64: op(\"LessF64\", 2, {type: t_bool}),\n  //\n  // arg0 <= arg1 ; less than or equal\n  LeqS8:  op(\"LeqS8\",  2, {type: t_bool}), // signed\n  LeqU8:  op(\"LeqU8\",  2, {type: t_bool}), // unsigned\n  LeqS16: op(\"LeqS16\", 2, {type: t_bool}),\n  LeqU16: op(\"LeqU16\", 2, {type: t_bool}),\n  LeqS32: op(\"LeqS32\", 2, {type: t_bool}),\n  LeqU32: op(\"LeqU32\", 2, {type: t_bool}),\n  LeqS64: op(\"LeqS64\", 2, {type: t_bool}),\n  LeqU64: op(\"LeqU64\", 2, {type: t_bool}),\n  LeqF32: op(\"LeqF32\", 2, {type: t_bool}),\n  LeqF64: op(\"LeqF64\", 2, {type: t_bool}),\n  //\n  // arg0 > arg1 ; greater than\n  GreaterS8:  op(\"GreaterS8\",  2, {type: t_bool}), // signed\n  GreaterU8:  op(\"GreaterU8\",  2, {type: t_bool}), // unsigned\n  GreaterS16: op(\"GreaterS16\", 2, {type: t_bool}),\n  GreaterU16: op(\"GreaterU16\", 2, {type: t_bool}),\n  GreaterS32: op(\"GreaterS32\", 2, {type: t_bool}),\n  GreaterU32: op(\"GreaterU32\", 2, {type: t_bool}),\n  GreaterS64: op(\"GreaterS64\", 2, {type: t_bool}),\n  GreaterU64: op(\"GreaterU64\", 2, {type: t_bool}),\n  GreaterF32: op(\"GreaterF32\", 2, {type: t_bool}),\n  GreaterF64: op(\"GreaterF64\", 2, {type: t_bool}),\n  //\n  // arg0 <= arg1 ; greater than or equal\n  GeqS8:  op(\"GeqS8\",  2, {type: t_bool}), // signed\n  GeqU8:  op(\"GeqU8\",  2, {type: t_bool}), // unsigned\n  GeqS16: op(\"GeqS16\", 2, {type: t_bool}),\n  GeqU16: op(\"GeqU16\", 2, {type: t_bool}),\n  GeqS32: op(\"GeqS32\", 2, {type: t_bool}),\n  GeqU32: op(\"GeqU32\", 2, {type: t_bool}),\n  GeqS64: op(\"GeqS64\", 2, {type: t_bool}),\n  GeqU64: op(\"GeqU64\", 2, {type: t_bool}),\n  GeqF32: op(\"GeqF32\", 2, {type: t_bool}),\n  GeqF64: op(\"GeqF64\", 2, {type: t_bool}),\n  //\n  // boolean ops (AndB and OrB are not shortcircuited)\n  // AndB: op(\"AndB\", 2, {commutative: true, type: t_bool}), // arg0 && arg1\n  // OrB:  op(\"OrB\",  2, {commutative: true, type: t_bool}), // arg0 || arg1\n  // EqB:  op(\"EqB\",  2, {commutative: true, type: t_bool}), // arg0 == arg1\n  // NeqB: op(\"NeqB\", 2, {commutative: true, type: t_bool}), // arg0 != arg1\n  Not:  op(\"Not\",  1, {type: t_bool}),                    // !arg0, boolean\n\n\n  // min(arg0, arg1) ; max(arg0, arg1)\n  MinF32: op(\"MinF32\", 2),\n  MinF64: op(\"MinF64\", 2),\n  MaxF32: op(\"MaxF32\", 2),\n  MaxF64: op(\"MaxF64\", 2),\n\n  // CondSelect is a conditional MOVE (register to register.)\n  //\n  // The type of a CondSelect is the same as the type of its first\n  // two arguments, which should be register-width scalars; the third\n  // argument should be a boolean.\n  //\n  // Placed during optimization by branchelim\n  //\n  // arg2 ? arg0 : arg1\n  // CondSelect: op(\"CondSelect\", 3),\n\n\n  // 1-input ops\n  //\n  // -arg0 ; negation\n  NegI8:  op(\"NegI8\",  1),\n  NegI16: op(\"NegI16\", 1),\n  NegI32: op(\"NegI32\", 1),\n  NegI64: op(\"NegI64\", 1),\n  NegF32: op(\"NegF32\", 1),\n  NegF64: op(\"NegF64\", 1),\n  //\n  // Count trailing (low order) zeroes\n  CtzI8:  op(\"CtzI8\",  1), // returns 0-8\n  CtzI16: op(\"CtzI16\", 1), // returns 0-16\n  CtzI32: op(\"CtzI32\", 1), // returns 0-32\n  CtzI64: op(\"CtzI64\", 1), // returns 0-64\n  //\n  // same as above, but arg0 known to be non-zero\n  CtzI8NonZero:  op(\"CtzI8NonZero\",  1), // returns 0-7\n  CtzI16NonZero: op(\"CtzI16NonZero\", 1), // returns 0-15\n  CtzI32NonZero: op(\"CtzI32NonZero\", 1), // returns 0-31\n  CtzI64NonZero: op(\"CtzI64NonZero\", 1), // returns 0-63\n  //\n  // Number of bits in arg0\n  BitLen8:  op(\"BitLen8\",  1), // returns 0-8\n  BitLen16: op(\"BitLen16\", 1), // returns 0-16\n  BitLen32: op(\"BitLen32\", 1), // returns 0-32\n  BitLen64: op(\"BitLen64\", 1), // returns 0-64\n  //\n  // Swap bytes\n  // op(\"Bswap32\", 1)\n  // op(\"Bswap64\", 1) // Swap bytes\n  //\n  // Reverse the bits in arg0\n  // op(\"BitRev8\", 1)  \n  // op(\"BitRev16\", 1) // Reverse the bits in arg0\n  // op(\"BitRev32\", 1) // Reverse the bits in arg0\n  // op(\"BitRev64\", 1) // Reverse the bits in arg0\n  //\n  // sign-agnostic count number of one bits in arg0\n  PopCountI8:  op(\"PopCountI8\",  1),\n  PopCountI16: op(\"PopCountI16\", 1),\n  PopCountI32: op(\"PopCountI32\", 1),\n  PopCountI64: op(\"PopCountI64\", 1),\n  //\n  // Square root\n  // Special cases:\n  //   +âˆž  â†’ +âˆž\n  //   Â±0  â†’ Â±0 (sign preserved)\n  //   x<0 â†’ NaN\n  //   NaN â†’ NaN\n  SqrtF32: op(\"SqrtF32\", 1), // âˆšarg0\n  SqrtF64: op(\"SqrtF64\", 1), // âˆšarg0\n  //\n  // Round to integer\n  // Special cases:\n  //   Â±âˆž  â†’ Â±âˆž (sign preserved)\n  //   Â±0  â†’ Â±0 (sign preserved)\n  //   NaN â†’ NaN\n  FloorF32: op(\"FloorF32\", 1), // round arg0 toward -âˆž\n  FloorF64: op(\"FloorF64\", 1),\n  CeilF32:  op(\"CeilF32\", 1),   // round arg0 toward +âˆž\n  CeilF64:  op(\"CeilF64\", 1),\n  TruncF32: op(\"TruncF32\", 1), // round arg0 toward 0\n  TruncF64: op(\"TruncF64\", 1),\n  RoundF32: op(\"RoundF32\", 1), // round arg0 to nearest, ties away from 0\n  RoundF64: op(\"RoundF64\", 1),\n  //\n  // round arg0 to nearest, ties to even\n  RoundToEvenF32: op(\"RoundToEvenF32\", 1),\n  RoundToEvenF64: op(\"RoundToEvenF64\", 1),\n  //\n  // Modify the sign bit\n  AbsF32: op(\"AbsF32\", 1), // absolute value arg0\n  AbsF64: op(\"AbsF64\", 1),\n  CopysignF32: op(\"CopysignF32\", 2), // copy sign from arg0 to arg1\n  CopysignF64: op(\"CopysignF64\", 2),\n\n\n  // Conversions\n  //\n  // signed extensions\n  SignExtI8to16:  op(\"SignExtS8to16\",  1, {type: t_i16}), // i8  -> i16\n  SignExtI8to32:  op(\"SignExtS8to32\",  1, {type: t_i32}), // i8  -> i32\n  SignExtI8to64:  op(\"SignExtS8to64\",  1, {type: t_i64}), // i8  -> i64\n  SignExtI16to32: op(\"SignExtS16to32\", 1, {type: t_i32}), // i16 -> i32\n  SignExtI16to64: op(\"SignExtS16to64\", 1, {type: t_i64}), // i16 -> i64\n  SignExtI32to64: op(\"SignExtS32to64\", 1, {type: t_i64}), // i32 -> i64\n  //\n  // zero (unsigned) extensions\n  ZeroExtI8to16:  op(\"ZeroExtU8to16\",  1, {type: t_u16}), // u8  -> u16\n  ZeroExtI8to32:  op(\"ZeroExtU8to32\",  1, {type: t_u32}), // u8  -> u32\n  ZeroExtI8to64:  op(\"ZeroExtU8to64\",  1, {type: t_u64}), // u8  -> u64\n  ZeroExtI16to32: op(\"ZeroExtU16to32\", 1, {type: t_u32}), // u16 -> u32\n  ZeroExtI16to64: op(\"ZeroExtU16to64\", 1, {type: t_u64}), // u16 -> u64\n  ZeroExtI32to64: op(\"ZeroExtU32to64\", 1, {type: t_u64}), // u32 -> u64\n  //\n  // truncations\n  TruncI16to8:  op(\"TruncI16to8\",  1), // i16 -> i8  ; u16 -> u8\n  TruncI32to8:  op(\"TruncI32to8\",  1), // i32 -> i8  ; u32 -> u8\n  TruncI32to16: op(\"TruncI32to16\", 1), // i32 -> i16 ; u32 -> u16\n  TruncI64to8:  op(\"TruncI64to8\",  1), // i64 -> i8  ; u64 -> u8\n  TruncI64to16: op(\"TruncI64to16\", 1), // i64 -> i16 ; u64 -> u16\n  TruncI64to32: op(\"TruncI64to32\", 1), // i64 -> i32 ; u64 -> u32\n  //\n  // conversions\n  ConvI32toF32: op(\"ConvI32toF32\", 1, {type: t_f32}), // i32 -> f32\n  ConvI32toF64: op(\"ConvI32toF64\", 1, {type: t_f64}), // i32 -> f64\n  ConvI64toF32: op(\"ConvI64toF32\", 1, {type: t_f32}), // i64 -> f32\n  ConvI64toF64: op(\"ConvI64toF64\", 1, {type: t_f64}), // i64 -> f64\n  ConvF32toI32: op(\"ConvF32toI32\", 1, {type: t_i32}), // f32 -> i32\n  ConvF32toI64: op(\"ConvF32toI64\", 1, {type: t_i64}), // f32 -> i64\n  ConvF64toI32: op(\"ConvF64toI32\", 1, {type: t_i32}), // f64 -> i32\n  ConvF64toI64: op(\"ConvF64toI64\", 1, {type: t_i64}), // f64 -> i64\n  ConvF32toF64: op(\"ConvF32toF64\", 1, {type: t_f64}), // f32 -> f64\n  ConvF64toF32: op(\"ConvF64toF32\", 1, {type: t_f32}), // f64 -> f32\n  //\n  // conversions only used on 32-bit arch\n  ConvU32toF32: op(\"ConvU32toF32\", 1, {type: t_f32}), // u32 -> f32\n  ConvU32toF64: op(\"ConvU32toF64\", 1, {type: t_f64}), // u32 -> f64\n  ConvF32toU32: op(\"ConvF32toU32\", 1, {type: t_u32}), // f32 -> u32\n  ConvF64toU32: op(\"ConvF64toU32\", 1, {type: t_u32}), // f64 -> u32\n  //\n  // conversions only used on archs that has the instruction\n  ConvU64toF32: op(\"ConvU64toF32\", 1, {type: t_f32}), // u64 -> f32\n  ConvU64toF64: op(\"ConvU64toF64\", 1, {type: t_f64}), // u64 -> f64\n  ConvF32toU64: op(\"ConvF32toU64\", 1, {type: t_u64}), // f32 -> u64\n  ConvF64toU64: op(\"ConvF64toU64\", 1, {type: t_u64}), // f64 -> u64\n\n\n  // Atomic operations used for semantically inlining runtime/internal/atomic.\n  // Atomic loads return a new memory so that the loads are properly ordered\n  // with respect to other loads and stores.\n  //\n  AtomicLoad32: op(\"AtomicLoad32\", 2, {/*type: \"(UInt32,Mem)\"*/}),\n    // Load from arg0.  arg1=memory.  Returns loaded value and new memory.\n  AtomicLoad64: op(\"AtomicLoad64\", 2, {/*type: \"(UInt64,Mem)\"*/}),\n    // Load from arg0.  arg1=memory.  Returns loaded value and new memory.\n  AtomicLoadPtr: op(\"AtomicLoadPtr\", 2, {/*type: \"(BytePtr,Mem)\"*/}),\n    // Load from arg0.  arg1=memory.  Returns loaded value and new memory.\n  AtomicStore32: op(\"AtomicStore32\", 3, {/*type: \"Mem\",*/hasSideEffects: true}),\n    // Store arg1 to *arg0.  arg2=memory.  Returns memory.\n  AtomicStore64: op(\"AtomicStore64\", 3, {/*type: \"Mem\",*/hasSideEffects: true}),\n    // Store arg1 to *arg0.  arg2=memory.  Returns memory.\n  AtomicStorePtrNoWB: op(\"AtomicStorePtrNoWB\", 3,\n    {type: t_addr, hasSideEffects: true}),\n    // Store arg1 to *arg0.  arg2=memory.  Returns memory.\n  AtomicExchange32: op(\"AtomicExchange32\", 3,\n    {/*type: \"(UInt32,Mem)\",*/hasSideEffects: true}),\n    // Store arg1 to *arg0.  arg2=memory.\n    // Returns old contents of *arg0 and new memory.\n  AtomicExchange64: op(\"AtomicExchange64\", 3,\n    {/*type: \"(UInt64,Mem)\",*/hasSideEffects: true}),\n    // Store arg1 to *arg0.  arg2=memory.\n    // Returns old contents of *arg0 and new memory.\n  AtomicAdd32: op(\"AtomicAdd32\", 3,\n    {/*type: \"(UInt32,Mem)\",*/hasSideEffects: true}),\n    // Do *arg0 += arg1.  arg2=memory.  Returns sum and new memory.\n  AtomicAdd64: op(\"AtomicAdd64\", 3,\n    {/*type: \"(UInt64,Mem)\",*/hasSideEffects: true}),\n    // Do *arg0 += arg1.  arg2=memory.  Returns sum and new memory.\n  AtomicCompareAndSwap32: op(\"AtomicCompareAndSwap32\", 4,\n    {/*type: \"(Bool,Mem)\",*/hasSideEffects: true}),\n    // if *arg0==arg1, then set *arg0=arg2.\n    // Returns true iff store happens and new memory.\n  AtomicCompareAndSwap64: op(\"AtomicCompareAndSwap64\", 4,\n    {/*type: \"(Bool,Mem)\",*/hasSideEffects: true}),\n    // if *arg0==arg1, then set *arg0=arg2.\n    // Returns true if store happens and new memory.\n  AtomicAnd8: op(\"AtomicAnd8\", 3, {type: t_addr, hasSideEffects: true}),\n    // *arg0 &= arg1.  arg2=memory.  Returns memory.\n  AtomicOr8: op(\"AtomicOr8\", 3, {type: t_addr, hasSideEffects: true}),\n  // *arg0 |= arg1.  arg2=memory.  Returns memory.\n\n} // end `const op`\n\n\n\n","import { Num } from '../num'\nimport { Int64 } from '../int64'\nimport { BasicType } from '../types'\nimport { ops, Op } from './op'\n\n\n// consteval2 evaluates the operation op with x and y of result type t\n//\nexport function consteval2(op :Op, t :BasicType, x :Num, y :Num) :Num|null {\n  // work around typescript\n  const xn = x as number\n  const yn = y as number\n  const xo = x as Int64\n  const yo = y as Int64\n\n  switch (op) {\n\n  // x + y\n  case ops.AddI8:\n  case ops.AddI16:\n  case ops.AddI32:\n    return t.isSignedInt ? (xn + yn | 0) : (xn + yn >>> 0)\n   case ops.AddI64:\n    return xo.add(yo)\n  case ops.AddF32:\n  case ops.AddF64:\n    return (xn as int) + (yn as int)\n\n  // x - y\n  case ops.SubI8:\n  case ops.SubI16:\n  case ops.SubI32:\n    return t.isSignedInt ? (xn - yn | 0) : (xn - yn >>> 0)\n  case ops.SubI64:\n    return xo.sub(yo)\n  case ops.SubF32:\n  case ops.SubF64:\n    return xn - yn\n\n  // x * y\n  case ops.MulI8:\n  case ops.MulI16:\n  case ops.MulI32:\n    return t.isSignedInt ? Math.imul(xn, yn) : (Math.imul(xn, yn) >>> 0)\n  case ops.MulI64:\n    return xo.mul(yo)\n  case ops.MulF32:\n  case ops.MulF64:\n    return xn * yn\n\n  // x / y\n  case ops.DivS8:\n  case ops.DivS16:\n  case ops.DivS32:\n    return xn / yn | 0\n  case ops.DivU8:\n  case ops.DivU16:\n  case ops.DivU32:\n    return xn / yn >>> 0\n  case ops.DivS64:\n  case ops.DivU64:\n    return xo.div(yo)\n  case ops.DivF32:\n  case ops.DivF64:\n    return xn / yn\n\n  // x % y\n  case ops.RemS8:\n  case ops.RemS16:\n  case ops.RemS32:\n    return xn % yn | 0\n  case ops.RemU8:\n  case ops.RemU16:\n  case ops.RemU32:\n    return xn % yn >>> 0\n  case ops.RemI64:\n  case ops.RemU64:\n    return xo.mod(yo)\n\n  // x & y\n  case ops.AndI8:\n  case ops.AndI16:\n  case ops.AndI32:\n    return xn & yn\n  case ops.AndI64:\n    return xo.and(yo)\n\n  // x | y\n  case ops.OrI8:\n  case ops.OrI16:\n  case ops.OrI32:\n    return xn | yn\n  case ops.OrI64:\n    return xo.or(yo)\n\n  // x ^ y\n  case ops.XorI8:\n  case ops.XorI16:\n  case ops.XorI32:\n    return xn ^ yn\n  case ops.XorI64:\n    return xo.xor(yo)\n\n  // x << y\n  case ops.ShLI8x8:\n  case ops.ShLI8x16:\n  case ops.ShLI8x32:\n  case ops.ShLI16x8:\n  case ops.ShLI16x16:\n  case ops.ShLI16x32:\n  case ops.ShLI32x8:\n  case ops.ShLI32x16:\n  case ops.ShLI32x32:\n    return xn << yn\n  case ops.ShLI8x64:\n  case ops.ShLI16x64:\n  case ops.ShLI32x64:\n    return xn << yo.toUInt32()\n  case ops.ShLI64x8:\n  case ops.ShLI64x16:\n  case ops.ShLI64x32:\n  case ops.ShLI64x64:\n    return xo.shl(yo.toUInt32())\n\n  // x >> y ; sign-replicating (arithmetic) shift right\n  case ops.ShRS8x8:\n  case ops.ShRS8x16:\n  case ops.ShRS8x32:\n  case ops.ShRS16x8:\n  case ops.ShRS16x16:\n  case ops.ShRS16x32:\n  case ops.ShRS32x8:\n  case ops.ShRS32x16:\n  case ops.ShRS32x32:\n    return xn >> yn\n  case ops.ShRS8x64:\n  case ops.ShRS16x64:\n  case ops.ShRS32x64:\n    return xn >> yo.toUInt32()\n  case ops.ShRS64x8:\n  case ops.ShRS64x16:\n  case ops.ShRS64x32:\n  case ops.ShRS64x64:\n    return xo.shr(yo.toUInt32())\n\n  // x >> y (aka >>>) ; zero-replicating (logical) shift right\n  case ops.ShRU8x8:\n  case ops.ShRU8x16:\n  case ops.ShRU8x32:\n  case ops.ShRU16x8:\n  case ops.ShRU16x16:\n  case ops.ShRU16x32:\n  case ops.ShRU32x8:\n  case ops.ShRU32x16:\n  case ops.ShRU32x32:\n    return xn >>> yn\n  case ops.ShRU8x64:\n  case ops.ShRU16x64:\n  case ops.ShRU32x64:\n    return xn >>> yo.toUInt32()\n  case ops.ShRU64x8:\n  case ops.ShRU64x16:\n  case ops.ShRU64x32:\n  case ops.ShRU64x64:\n    return xo.shr(yo.toUInt32())\n\n  // x == y\n  case ops.EqI8:\n  case ops.EqI16:\n  case ops.EqI32:\n  case ops.EqF32:\n  case ops.EqF64:\n    return xn === yn ? 1 : 0\n  case ops.EqI64:\n    return xo.eq(yo) ? 1 : 0\n\n  // x != y\n  case ops.NeqI8:\n  case ops.NeqI16:\n  case ops.NeqI32:\n  case ops.NeqF32:\n  case ops.NeqF64:\n    return xn !== yn ? 1 : 0\n  case ops.NeqI64:\n    return xo.neq(yo) ? 1 : 0\n\n  // x < y\n  case ops.LessS8:\n  case ops.LessU8:\n  case ops.LessS16:\n  case ops.LessU16:\n  case ops.LessS32:\n  case ops.LessU32:\n  case ops.LessF32:\n  case ops.LessF64:\n    return xn < yn ? 1 : 0\n  case ops.LessS64:\n  case ops.LessU64:\n    return xo.lt(yo) ? 1 : 0\n\n  // x <= y\n  case ops.LeqS8:\n  case ops.LeqU8:\n  case ops.LeqS16:\n  case ops.LeqU16:\n  case ops.LeqS32:\n  case ops.LeqU32:\n  case ops.LeqF32:\n  case ops.LeqF64:\n    return xn <= yn ? 1 : 0\n  case ops.LeqS64:\n  case ops.LeqU64:\n    return xo.lte(yo) ? 1 : 0\n\n  // x > y\n  case ops.GreaterS8:\n  case ops.GreaterU8:\n  case ops.GreaterS16:\n  case ops.GreaterU16:\n  case ops.GreaterS32:\n  case ops.GreaterU32:\n  case ops.GreaterF32:\n  case ops.GreaterF64:\n    return xn > yn ? 1 : 0\n  case ops.GreaterS64:\n  case ops.GreaterU64:\n    return xo.gt(yo) ? 1 : 0\n\n  // x >= y\n  case ops.GeqS8:\n  case ops.GeqU8:\n  case ops.GeqS16:\n  case ops.GeqU16:\n  case ops.GeqS32:\n  case ops.GeqU32:\n  case ops.GeqF32:\n  case ops.GeqF64:\n    return xn >= yn ? 1 : 0\n  case ops.GeqS64:\n  case ops.GeqU64:\n    return xo.gte(yo) ? 1 : 0\n\n  // min(x, y)\n  case ops.MinF32:\n  case ops.MinF64:\n    return Math.min(xn, yn)\n\n  // min(x, y)\n  case ops.MaxF32:\n  case ops.MaxF64:\n    return Math.max(xn, yn)\n\n  } // switch\n\n  // Note:\n  //  AND_NOT \"x &^ y\"\n  //   x & ~y\n  //   xo.and(yo.not())\n  //\n  assert(false, `unexpected ${op}`)\n  return null\n}\n\n\n// consteval2 evaluates the operation op with x of result type t\n//\nexport function consteval1(op :Op, t :BasicType, x :Num) :Num|null {\n  return null\n}\n\n\n// function f_to_i32(n :number) {\n//   return n < 0 ? Math.ceil(n) : Math.floor(n)\n// }\n\n// function f_to_u32(n :number) {\n//   n = toi32(n)\n//   return n - Math.floor(n / 0x100000000) * 0x100000000\n// }\n\n// function eval_op1(op :Op, t :BasicType, x :number) :number {\n//   switch (op) {\n//   case Op.i32Clz: return Math.clz32(x)\n//   }\n//   return NaN\n// }\n\n// // popcnt32 returns the number of set bits in n\n// //\n// function popcnt32(n :int) :int {\n//   n = n - ((n >> 1) & 0x55555555)\n//   n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n//   return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n// }\n//\n// function popcnt32(n) {\n//   let c = 0\n//   for (; n; c++) {\n//     n &= n - 1  // clear the least significant bit set\n//   }\n//   return c\n// }\n","//\n// constant-folding optimizations\n//\nimport { Num, numconv, isNum } from '../num'\nimport { Op } from './op'\nimport { Value, Block } from './ssa'\nimport { consteval1, consteval2 } from './consteval'\n\n\nexport function optcf_op1(b :Block, op :Op, x :Value) :Value|null {\n  if (x.op.constant) {\n    assert(isNum(x.aux))\n    let val = consteval1(op, x.type, x.aux as Num)\n    if (val !== null) {\n      return b.f.constVal(x.type, val)\n    }\n  }\n  return null\n}\n\n\nexport function optcf_op2(b :Block, op :Op, x :Value, y :Value) :Value|null {\n  if (!x.op.constant || !y.op.constant) {\n    // one or both operands not constant\n    return null\n  }\n\n  assert(isNum(x.aux))\n  assert(isNum(y.aux))\n\n  let xval = x.aux as Num\n  let yval = y.aux as Num\n\n  if (x.type !== y.type) {\n    // different types\n    let lossless :bool\n    ;[yval, lossless] = numconv(yval, x.type)\n    if (!lossless) {\n      // lossy conversion\n      return null\n    }\n  }\n\n  // attempt to evaluate the operation\n  let val = consteval2(op, x.type, xval, yval)\n\n  if (val !== null) {\n    return b.f.constVal(x.type, val)\n  }\n\n  // unsupported operation\n  return null\n}\n\n\n\n","import { Fun, Block } from './ssa'\n\ninterface blockAndIndex {\n  b     :Block\n  index :int\n    // index is the number of successor edges of b that have already\n    // been explored.\n}\n\n// postorder provides a DFS postordering of blocks in f\n//\nexport function postorder(f :Fun) :Block[] {\n  // let postnums = new Array<int>(f.numBlocks())\n  let explored = new Array<bool>(f.numBlocks())\n\n  // result ordering\n  let order :Block[] = []\n\n  // stack of blocks and next child to visit\n  let s :blockAndIndex[] = [ { b: f.entry, index: 0 } ]\n  explored[f.entry.id] = true\n\n  while (s.length > 0) {\n    let tos = s.length - 1\n\n    let x :blockAndIndex = s[tos]\n    let b = x.b\n    let i = x.index\n\n    if (i < b.succs.length) {\n      s[tos].index++\n      let bb = b.succs[i]\n      if (!explored[bb.id]) {\n        explored[bb.id] = true\n        s.push({ b: bb, index: 0 })\n      }\n    } else {\n      s = s.slice(0, tos)\n      //postnums[b.id] = order.length\n      order.push(b)\n    }\n  }\n\n  //dlog(`postnums: ${postnums.map((n, bi) => `b${bi} = #${n}`).join(', ')}`)\n\n  return order\n}\n","import { ByteStr, asciiByteStr } from '../bytestr'\nimport { Num, numIsZero, isNum } from '../num'\nimport { Pos, NoPos } from '../pos'\n// import { debuglog as dlog } from '../util'\nimport { Op, ops } from './op'\nimport {\n  BasicType,\n  NumType,\n  FunType,\n\n  t_nil,\n  t_bool,\n  t_u8,\n  t_i8,\n  t_u16,\n  t_i16,\n  t_u32,\n  t_i32,\n  t_u64,\n  t_i64,\n  t_f32,\n  t_f64,\n} from '../types'\nimport { postorder } from './postorder'\nimport { Register } from './reg'\nimport { LocalSlot } from './localslot'\n// import { LoopNest, loopnestFun } from './loopnest'\n\n\nconst byteStr_main = asciiByteStr(\"main\")\nconst byteStr_anonfun = asciiByteStr(\"anonfun\")\n\n\nexport type ID = int\n\n// Location is the storage location of a value. Either a register or stack\n// slot.\nexport type Location = Register | LocalSlot\n\n\n// Aux is an auxiliary value of Value\n//\nexport type Aux = ByteStr | Uint8Array | Num\n\n\n// Value is a three-address-code operation\n//\nexport class Value {\n  id      :ID    // unique identifier\n  pos     :Pos = NoPos  // source position\n  op      :Op    // operation that computes this value\n  type    :BasicType\n  b       :Block // containing block\n  aux     :Aux|null // auxiliary info for this value. Type depends on op & type\n  args    :Value[] = [] // arguments of this value\n  comment :string = '' // human readable short comment for IR formatting\n  prevv   :Value|null = null // previous value (list link)\n  nextv   :Value|null = null // next value (list link)\n  reg     :Register|null = null  // allocated register\n\n  uses  :int = 0 // use count. Each appearance in args or b.control counts once\n  // users = new Set<Value|Block>()\n\n\n  constructor(id :ID, b :Block, op :Op, type :BasicType, aux :Aux|null) {\n    this.id = id\n    this.op = op\n    this.type = type\n    this.b = b\n    this.aux = aux\n    assert(type instanceof BasicType)\n    assert(type.mem > 0, `ir.Value assigned abstract type ${type}`)\n  }\n\n  toString() {\n    return 'v' + this.id\n  }\n\n  auxIsZero() :bool {\n    assert(isNum(this.aux), `aux is not a number`)\n    return numIsZero(this.aux as Num)\n  }\n\n  reset(op :Op) {\n    assert(op, `null op`)\n    const v = this\n    v.op = op\n    // if (op != ops.Copy && notStmtBoundary(op)) {\n    //   // Special case for OpCopy because of how it is used in rewrite\n    //   v.pos = posWithNotStmt(v.pos)\n    // }\n    v.resetArgs()\n    v.aux = null\n  }\n\n  setArgs1(a :Value) {\n    this.resetArgs()\n    this.addArg(a)\n  }\n\n  setArg(i :int, v :Value) {\n    assert(this.args[i], `setArg on null slot ${i}`)\n    this.args[i].uses--\n    this.args[i] = v\n    v.uses++\n  }\n\n  resetArgs() {\n    for (let a of this.args) {\n      a.uses--\n    }\n    this.args.length = 0\n  }\n\n  addArg(v :Value) {\n    assert(v !== this, `using self as arg to self`)\n    v.uses++\n    // v.users.add(this)\n    this.args.push(v)\n  }\n\n  removeArg(i :int) {\n    let v = this.args[i]\n    // v.users.delete(this)\n    v.uses--\n    this.args.splice(i, 1)\n  }\n\n  // rematerializeable reports whether a register allocator should recompute\n  // a value instead of spilling/restoring it.\n  rematerializeable() :bool {\n    if (!this.op.rematerializeable) {\n      return false\n    }\n    for (let a of this.args) {\n      // SP and SB (generated by ops.SP and ops.SB) are always available.\n      if (a.op !== ops.SP && a.op !== ops.SB) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n\n// BlockKind denotes what specific kind a block is\n//\n//     kind       control (x)    successors     notes\n//     ---------- -------------- -------------- --------\n//     Plain      (nil)          [next]         e.g. \"goto\"\n//     If         boolean        [then, else]\n//     Ret        memory         []\n//\n//     First      boolean        [always, never]\n//\n//       BlockKind.First is used by optimizer to mark otherwise conditional\n//       branches as always taking a certain path.\n//\n//       For instance, say we have this:\n//\n//       foo ()->int\n//         b0:\n//           v0 = ConstI32 <i32> [0]\n//           v1 = ConstI32 <i32> [1]\n//           v2 = ConstI32 <i32> [2]\n//         if v0 -> b1, b2\n//         b1:\n//           v3 = Copy <i32> v1\n//         cont -> b3\n//         b2:\n//           v4 = Copy <i32> v2\n//         cont -> b3\n//         b1:\n//           v5 = Phi v3 v4\n//         ret\n//\n//       Now, b0's control will always route us to b1 and never b2,\n//       since v0 is constant \"1\".\n//       The optimizer may rewrite b0 as kind==First; information that\n//       a later \"deadcode\" pass will use to eliminate b1 and its values:\n//\n//       foo ()->int\n//         b0:\n//           v0 = ConstI32 <i32> [0]\n//           v1 = ConstI32 <i32> [1]\n//           v2 = ConstI32 <i32> [2]\n//         first v0 -> b1, b2\n//         b1:\n//           v3 = Copy <i32> v1\n//         cont -> b3\n//         b2:\n//           v4 = Copy <i32> v2\n//         cont -> b3\n//         b1:\n//           v5 = Phi v3 v4\n//         ret\n//\n//       After the optimizer pipeline is done, the code will have been\n//       reduced to simply:\n//\n//       foo ()->int\n//         b0:\n//           v1 = ConstI32 <i32> [1]\n//         ret\n//\n//\nexport enum BlockKind {\n  Invalid = 0,\n  Plain,\n  If,\n  Ret,\n  First,\n}\n\nexport enum BranchPrediction {\n  Unlikely = -1,\n  Unknown  = 0,\n  Likely   = 1,\n}\n\n// Block represents a basic block\n//\nexport class Block {\n  id       :ID\n  pos      :Pos = NoPos  // source position\n  kind     :BlockKind = BlockKind.Invalid // The kind of block\n  succs    :Block[] = []  // Successor/subsequent blocks (CFG)\n  preds    :Block[] = []  // Predecessors (CFG)\n  control  :Value|null = null\n    // A value that determines how the block is exited. Its value depends\n    // on the kind of the block. For instance, a BlockKind.If has a boolean\n    // control value and BlockKind.Exit has a memory control value.\n\n  f :Fun // containing function\n\n  values  :Value[] = [] // three-address code values\n  sealed  :bool = false // true if no further predecessors will be added\n  comment :string = '' // human readable short comment for IR formatting\n\n  // Likely direction for branches.\n  // If BranchLikely, succs[0] is the most likely branch taken.\n  // If BranchUnlikely, succs[1] is the most likely branch taken.\n  // Ignored if succs.length < 2.\n  // Fatal if not BranchUnknown and succs.length > 2.\n  likely :BranchPrediction = BranchPrediction.Unknown\n\n  constructor(kind :BlockKind, id :ID, f :Fun) {\n    this.kind = kind\n    this.id = id\n    this.f = f\n  }\n\n  // pushValueFront adds v to the top of the block\n  //\n  pushValueFront(v :Value) {\n    this.values.unshift(v)\n  }\n\n  // replaceValue replaces all uses of existingv value with newv\n  //\n  replaceValue(existingv :Value, newv :Value) {\n    assert(existingv !== newv, 'trying to replace V with V')\n\n    // TODO: there must be a better way to replace values and retain their\n    // edges with users.\n\n    // for (let user of existingv.users) {\n    //   assert(user !== newv,\n    //     `TODO user==newv (newv=${newv} existingv=${existingv}) -- CYCLIC USE!`)\n\n    //   for (let i = 0; i < user.args.length; i++) {\n    //     if (user.args[i] === existingv) {\n    //       dlog(`replace ${existingv} in user ${user} with ${newv}`)\n    //       user.args[i] = newv\n    //       newv.users.add(user)\n    //       newv.uses++\n    //       existingv.uses--\n    //     }\n    //   }\n    // }\n    // existingv.users.clear()\n\n    // Remove self.\n    // Note that we don't decrement this.uses since the definition\n    // site doesn't count toward \"uses\".\n    this.f.freeValue(existingv)\n\n    // clear block pointer.\n    // Note: \"uses\" does not count for the value's ref to its block, so\n    // we don't decrement this.uses here.\n    ;(existingv as any).b = null\n  }\n\n  setControl(v :Value|null) {\n    let existing = this.control\n    if (existing) {\n      existing.uses--\n      // existing.users.delete(this)\n    }\n    this.control = v\n    if (v) {\n      v.uses++\n      // v.users.add(this)\n    }\n  }\n\n  // removeNthPred removes the ith input edge e from b.\n  // It is the responsibility of the caller to remove the corresponding\n  // successor edge.\n  //\n  removeNthPred(i :int) {\n    this.preds.splice(i, 1)\n    this.f.invalidateCFG()\n  }\n\n  // Like removeNthPred but takes a block reference and returns the index\n  // of that block as it was in this.preds\n  //\n  removePred(e :Block) :int {\n    let i = this.preds.indexOf(e)\n    assert(i > -1, `${e} not a predecessor of ${this}`)\n    this.removeNthPred(i)\n    return i\n  }\n\n  // removeNthSucc removes the ith output edge from b.\n  // It is the responsibility of the caller to remove\n  // the corresponding predecessor edge.\n  removeNthSucc(i :int) {\n    this.succs.splice(i, 1)\n    this.f.invalidateCFG()\n  }\n\n  // Like removeNthSucc but takes a block reference and returns the index\n  // of that block as it was in this.succs\n  //\n  removeSucc(s :Block) :int {\n    let i = this.succs.indexOf(s)\n    assert(i > -1, `${s} not a successor of ${this}`)\n    this.removeNthSucc(i)\n    return i\n  }\n\n  newPhi(t :BasicType) :Value {\n    let v = this.f.newValue(this, ops.Phi, t, null)\n    this.values.push(v)\n    return v\n  }\n\n  // newValue0 return a value with no args\n  newValue0(op :Op, t :BasicType|null = null, aux :Aux|null = null) :Value {\n    let v = this.f.newValue(this, op, t, aux)\n    this.values.push(v)\n    return v\n  }\n\n  // newValue1 returns a new value in the block with one argument\n  newValue1(op :Op, t :BasicType, arg0 :Value, aux :Aux|null = null) :Value {\n    let v = this.f.newValue(this, op, t, aux)\n    v.args = [arg0]\n    arg0.uses++ //; arg0.users.add(v)\n    this.values.push(v)\n    return v\n  }\n\n  // newValue2 returns a new value in the block with two arguments and zero\n  // aux values.\n  newValue2(\n    op :Op,\n    t :BasicType,\n    arg0 :Value,\n    arg1 :Value,\n    aux :Aux|null = null,\n  ) :Value {\n    let v = this.f.newValue(this, op, t, aux)\n    v.args = [arg0, arg1]\n    arg0.uses++ //; arg0.users.add(v)\n    arg1.uses++ //; arg1.users.add(v)\n    this.values.push(v)\n    return v\n  }\n\n  toString() :string {\n    return 'b' + this.id\n  }\n}\n\n\nexport interface NamedValueEnt {\n  local  :LocalSlot\n  values :Value[]\n}\n\n\nexport class Fun {\n  entry  :Block\n  blocks :Block[]\n  type   :FunType\n  name   :ByteStr\n  nargs  :int      // number of arguments\n\n  bid    :ID = 0  // block ID allocator\n  vid    :ID = 0  // value ID allocator\n\n  consts :Map<Op,Map<Num,Value>> | null = null  // constants cache\n\n  // map from LocalSlot to set of Values that we want to store in that slot.\n  namedValues = new Map<string,NamedValueEnt>()\n\n  // when register allocation is done, maps value ids to locations\n  regAlloc :Location[]|null = null\n\n  // Cached CFG data\n  _cachedPostorder :Block[] | null = null\n  // _cachedLoopnest  :LoopNest | null = null\n\n\n  constructor(type :FunType, name :ByteStr|null, nargs :int) {\n    this.entry = new Block(BlockKind.Plain, this.bid++, this)\n    this.blocks = [this.entry]\n    this.type = type\n    this.name = name || byteStr_anonfun\n    this.nargs = nargs\n  }\n\n  newBlock(k :BlockKind) :Block {\n    assert(this.bid < 0xFFFFFFFF, \"too many block IDs generated\")\n    let b = new Block(k, this.bid++, this)\n    this.blocks.push(b)\n    return b\n  }\n\n  freeBlock(b :Block) {\n    assert(b.f != null, `trying to free an already freed block ${b}`)\n    b.f = null as any as Fun\n    // TODO: put into free list\n  }\n\n  newValue(b :Block, op :Op, t :BasicType|null, aux :Aux|null) :Value {\n    assert(this.vid < 0xFFFFFFFF, \"too many value IDs generated\")\n    // TODO we could use a free list and return values when they die\n\n    assert(!t || !op.type || op.type.mem == 0 || t === op.type,\n      `op ${op} with different concrete type (op.type=${op.type}, t=${t})`)\n\n    return new Value(this.vid++, b, op, t || op.type || t_nil, aux)\n  }\n\n  freeValue(v :Value) {\n    assert(v.b, `trying to free an already freed value ${v}`)\n    assert(v.uses == 0, `value ${v} still has ${v.uses} uses`)\n    assert(v.args.length == 0, `value ${v} still has ${v.args.length} args`)\n    // TODO: put into free list\n  }\n\n  // constVal returns a constant Value representing c for type t\n  //\n  constVal(t :NumType, c :Num) :Value {\n    let f = this\n\n    // Select operation based on type\n    let op :Op = ops.Invalid\n    switch (t) {\n      case t_bool:            op = ops.ConstBool; break\n      case t_u8:  case t_i8:  op = ops.ConstI8; break\n      case t_u16: case t_i16: op = ops.ConstI16; break\n      case t_u32: case t_i32: op = ops.ConstI32; break\n      case t_u64: case t_i64: op = ops.ConstI64; break\n      case t_f32:             op = ops.ConstF32; break\n      case t_f64:             op = ops.ConstF64; break\n      default:\n        assert(false, `invalid constant type ${t}`)\n        break\n    }\n\n    if (!f.consts) {\n      f.consts = new Map<Op,Map<Num,Value>>()\n    }\n\n    let nvmap = f.consts.get(op)\n    if (!nvmap) {\n      nvmap = new Map<Num,Value>()\n      f.consts.set(op, nvmap)\n    }\n\n    let v = nvmap.get(c)\n    if (!v) {\n      // create new const value in function's entry block\n      v = f.blocks[0].newValue0(op, t, c)\n      nvmap.set(c, v) // put into cache\n    }\n\n    return v as Value\n  }\n\n  removeBlock(b :Block) {\n    let i = this.blocks.indexOf(b)\n    assert(i != -1, `block ${b} not part of function`)\n    this.blocks.splice(i, 1)\n    this.invalidateCFG()\n  }\n\n  // numBlocks returns an integer larger than the id of any Block in the Fun.\n  //\n  numBlocks() :int {\n    return this.bid\n  }\n\n  // numValues returns an integer larger than the id of any Value of any Block\n  // in the Fun.\n  //\n  numValues() :int {\n    return this.vid\n  }\n\n  postorder() :Block[] {\n    if (!this._cachedPostorder) {\n      this._cachedPostorder = postorder(this)\n    }\n    return this._cachedPostorder\n  }\n\n  // loopnest() :LoopNest {\n  //   if (!this._cachedLoopnest) {\n  //     this._cachedLoopnest = loopnestFun(this)\n  //   }\n  //   return this._cachedLoopnest\n  // }\n\n  // invalidateCFG tells the function that its CFG has changed\n  //\n  invalidateCFG() {\n    this._cachedPostorder = null\n    // this._cachedLoopnest = null\n  }\n\n  toString() {\n    return this.name.toString()\n  }\n}\n\n\n// Pkg represents a package with functions and data\n//\nexport class Pkg {\n  // data :Uint8Array   // data  TODO wrap into some simple linear allocator\n  funs = new Map<ByteStr,Fun>()   // functions mapped by name\n  init :Fun|null = null // init functions (merged into one)\n\n  // mainFun returns the main function of the package, if any\n  //\n  mainFun() :Fun|null {\n    for (let fn of this.funs.values()) {\n      if (byteStr_main.equals(fn.name)) {\n        return fn\n      }\n    }\n    return null\n  }\n}\n","import { token } from '../token'\nimport {\n  Mem,\n  BasicType,\n  t_u8,\n  t_i8,\n  t_u16,\n  t_i16,\n  t_u32,\n  t_i32,\n  t_u64,\n  t_i64,\n  t_f32,\n  t_f64,\n} from '../types'\nimport { ops, Op } from './op'\n\n\n// opselect1 returns the IR operation for the corresponding token operator\n// and operand type.\n//\nexport function opselect1(tok :token, x :BasicType) :Op {\n  switch (tok) {\n\n  case token.NOT: return ops.Not\n\n  case token.ADD: switch (x.mem) { // -arg\n    case Mem.i8:  return ops.NegI8\n    case Mem.i16: return ops.NegI16\n    case Mem.i32: return ops.NegI32\n    case Mem.i64: return ops.NegI64\n    case Mem.i32: return ops.NegF32\n    case Mem.i64: return ops.NegF64\n  }; break\n\n  } // switch\n\n  // unhandled operator token\n  assert(false, `invalid token.${token[tok]} with type ${x}`)\n  return ops.Invalid\n}\n\n\n// opselect2 returns the IR operator for the corresponding token operator\n// and operand types.\n//\nexport function opselect2(tok :token, x :BasicType, y :BasicType) :Op {\n  switch (tok) {\n\n  //\n  // arithmetic\n  //\n  case token.ADD: switch (x.mem) { // +\n    case Mem.i8:   return ops.AddI8\n    case Mem.i16:  return ops.AddI16\n    case Mem.i32:  return ops.AddI32\n    case Mem.i64:  return ops.AddI64\n    case Mem.f32:  return ops.AddF32\n    case Mem.f64:  return ops.AddF64\n  }; break\n\n  case token.SUB: switch (x.mem) { // -\n    case Mem.i8:   return ops.SubI8\n    case Mem.i16:  return ops.SubI16\n    case Mem.i32:  return ops.SubI32\n    case Mem.i64:  return ops.SubI64\n    case Mem.f32:  return ops.SubF32\n    case Mem.f64:  return ops.SubF64\n  }; break\n\n  case token.MUL: switch (x.mem) { // *\n    case Mem.i8:   return ops.MulI8\n    case Mem.i16:  return ops.MulI16\n    case Mem.i32:  return ops.MulI32\n    case Mem.i64:  return ops.MulI64\n    case Mem.f32:  return ops.MulF32\n    case Mem.f64:  return ops.MulF64\n  }; break\n\n  case token.QUO: switch (x) { // /\n    case t_i8:  return ops.DivS8\n    case t_u8:  return ops.DivU8\n    case t_i16: return ops.DivS16\n    case t_u16: return ops.DivU16\n    case t_i32: return ops.DivS32\n    case t_u32: return ops.DivU32\n    case t_i64: return ops.DivS64\n    case t_u64: return ops.DivU64\n    case t_f32: return ops.DivF32\n    case t_f64: return ops.DivF64\n  }; break\n\n  case token.REM: switch (x) { // %\n    case t_i8:  return ops.RemS8\n    case t_u8:  return ops.RemU8\n    case t_i16: return ops.RemS16\n    case t_u16: return ops.RemU16\n    case t_i32: return ops.RemS32\n    case t_u32: return ops.RemU32\n    case t_i64: return ops.RemI64\n    case t_u64: return ops.RemU64\n  }; break\n\n  case token.AND: switch (x.mem) { // &\n    case Mem.i8:   return ops.AndI8\n    case Mem.i16:  return ops.AndI16\n    case Mem.i32:  return ops.AndI32\n    case Mem.i64:  return ops.AndI64\n  }; break\n\n  case token.OR: switch (x.mem) { // |\n    case Mem.i8:   return ops.OrI8\n    case Mem.i16:  return ops.OrI16\n    case Mem.i32:  return ops.OrI32\n    case Mem.i64:  return ops.OrI64\n  }; break\n\n  case token.XOR: switch (x.mem) { // ^\n    case Mem.i8:   return ops.XorI8\n    case Mem.i16:  return ops.XorI16\n    case Mem.i32:  return ops.XorI32\n    case Mem.i64:  return ops.XorI64\n  }; break\n\n  case token.AND_NOT: // &^  TODO implement. Emulated by: x & ~y\n    assert(false, 'AND_NOT \"&^\" not yet supported')\n    break\n\n  //\n  // comparisons\n  //\n  case token.EQL: switch (x.mem) { // ==\n    case Mem.i8:   return ops.EqI8\n    case Mem.i16:  return ops.EqI16\n    case Mem.i32:  return ops.EqI32\n    case Mem.i64:  return ops.EqI64\n    case Mem.f32:  return ops.EqF32\n    case Mem.f64:  return ops.EqF64\n  }; break\n\n  case token.NEQ: switch (x.mem) { // !=\n    case Mem.i8:   return ops.NeqI8\n    case Mem.i16:  return ops.NeqI16\n    case Mem.i32:  return ops.NeqI32\n    case Mem.i64:  return ops.NeqI64\n    case Mem.f32:  return ops.NeqF32\n    case Mem.f64:  return ops.NeqF64\n  }; break\n\n  case token.LSS: switch (x) { // <\n    case t_i8:  return ops.LessS8\n    case t_u8:  return ops.LessU8\n    case t_i16: return ops.LessS16\n    case t_u16: return ops.LessU16\n    case t_i32: return ops.LessS32\n    case t_u32: return ops.LessU32\n    case t_i64: return ops.LessS64\n    case t_u64: return ops.LessU64\n    case t_f32: return ops.LessF32\n    case t_f64: return ops.LessF64\n  }; break\n\n  case token.LEQ: switch (x) { // <=\n    case t_i8:  return ops.LeqS8\n    case t_u8:  return ops.LeqU8\n    case t_i16: return ops.LeqS16\n    case t_u16: return ops.LeqU16\n    case t_i32: return ops.LeqS32\n    case t_u32: return ops.LeqU32\n    case t_i64: return ops.LeqS64\n    case t_u64: return ops.LeqU64\n    case t_f32: return ops.LeqF32\n    case t_f64: return ops.LeqF64\n  }; break\n\n  case token.GTR: switch (x) { // >\n    case t_i8:  return ops.GreaterS8\n    case t_u8:  return ops.GreaterU8\n    case t_i16: return ops.GreaterS16\n    case t_u16: return ops.GreaterU16\n    case t_i32: return ops.GreaterS32\n    case t_u32: return ops.GreaterU32\n    case t_i64: return ops.GreaterS64\n    case t_u64: return ops.GreaterU64\n    case t_f32: return ops.GreaterF32\n    case t_f64: return ops.GreaterF64\n  }; break\n\n  case token.GEQ: switch (x) { // >=\n    case t_i8:  return ops.GeqS8\n    case t_u8:  return ops.GeqU8\n    case t_i16: return ops.GeqS16\n    case t_u16: return ops.GeqU16\n    case t_i32: return ops.GeqS32\n    case t_u32: return ops.GeqU32\n    case t_i64: return ops.GeqS64\n    case t_u64: return ops.GeqU64\n    case t_f32: return ops.GeqF32\n    case t_f64: return ops.GeqF64\n  }; break\n\n  //\n  // shifts\n  //\n  case token.SHL: switch (x.mem) { // <<\n    case Mem.i8: switch (y) {\n      case t_u8:   return ops.ShLI8x8\n      case t_u16:  return ops.ShLI8x16\n      case t_u32:  return ops.ShLI8x32\n      case t_u64:  return ops.ShLI8x64\n    } break\n    case Mem.i16: switch (y) {\n      case t_u8:   return ops.ShLI16x8\n      case t_u16:  return ops.ShLI16x16\n      case t_u32:  return ops.ShLI16x32\n      case t_u64:  return ops.ShLI16x64\n    } break\n    case Mem.i32: switch (y) {\n      case t_u8:   return ops.ShLI32x8\n      case t_u16:  return ops.ShLI32x16\n      case t_u32:  return ops.ShLI32x32\n      case t_u64:  return ops.ShLI32x64\n    } break\n    case Mem.i64: switch (y) {\n      case t_u8:   return ops.ShLI64x8\n      case t_u16:  return ops.ShLI64x16\n      case t_u32:  return ops.ShLI64x32\n      case t_u64:  return ops.ShLI64x64\n    } break\n  }; break\n\n  case token.SHR: assert(y.isUnsignedInt); switch (x) { // >>\n    case t_i8: switch (y) {\n      case t_u8:   return ops.ShRS8x8\n      case t_u16:  return ops.ShRS8x16\n      case t_u32:  return ops.ShRS8x32\n      case t_u64:  return ops.ShRS8x64\n    } break\n    case t_u8: switch (y) {\n      case t_u8:   return ops.ShRU8x8\n      case t_u16:  return ops.ShRU8x16\n      case t_u32:  return ops.ShRU8x32\n      case t_u64:  return ops.ShRU8x64\n    } break\n    case t_i16: switch (y) {\n      case t_u8:   return ops.ShRS16x8\n      case t_u16:  return ops.ShRS16x16\n      case t_u32:  return ops.ShRS16x32\n      case t_u64:  return ops.ShRS16x64\n    } break\n    case t_u16: switch (y) {\n      case t_u8:   return ops.ShRU16x8\n      case t_u16:  return ops.ShRU16x16\n      case t_u32:  return ops.ShRU16x32\n      case t_u64:  return ops.ShRU16x64\n    } break\n    case t_i32: switch (y) {\n      case t_u8:   return ops.ShRS32x8\n      case t_u16:  return ops.ShRS32x16\n      case t_u32:  return ops.ShRS32x32\n      case t_u64:  return ops.ShRS32x64\n    } break\n    case t_u32: switch (y) {\n      case t_u8:   return ops.ShRU32x8\n      case t_u16:  return ops.ShRU32x16\n      case t_u32:  return ops.ShRU32x32\n      case t_u64:  return ops.ShRU32x64\n    } break\n    case t_i64: switch (y) {\n      case t_u8:   return ops.ShRS64x8\n      case t_u16:  return ops.ShRS64x16\n      case t_u32:  return ops.ShRS64x32\n      case t_u64:  return ops.ShRS64x64\n    } break\n    case t_u64: switch (y) {\n      case t_u8:   return ops.ShRU64x8\n      case t_u16:  return ops.ShRU64x16\n      case t_u32:  return ops.ShRU64x32\n      case t_u64:  return ops.ShRU64x64\n    } break\n  }; break\n\n  } // switch\n\n  // unhandled operator token\n  assert(false, `invalid token.${token[tok]} with types ${x}, ${y}`)\n  return ops.Invalid\n}\n\n\n// opselectConv returns the IR operation for converting x to y.\n//\nexport function opselectConv(x :BasicType, y :BasicType) :Op {\n  switch (x) {\n\n  case t_i8: switch (y) {\n    case t_i16: return ops.SignExtI8to16\n    case t_i32: return ops.SignExtI8to32\n    case t_i64: return ops.SignExtI8to64\n  }; break\n\n  case t_u8: switch (y) {\n    case t_u16: return ops.ZeroExtI8to16\n    case t_u32: return ops.ZeroExtI8to32\n    case t_u64: return ops.ZeroExtI8to64\n  }; break\n\n  case t_i16: switch (y) {\n    case t_i8:  return ops.TruncI16to8\n    case t_i32: return ops.SignExtI16to32\n    case t_i64: return ops.SignExtI16to64\n  }; break\n\n  case t_u16: switch (y) {\n    case t_u8:  return ops.TruncI16to8\n    case t_u32: return ops.ZeroExtI16to32\n    case t_u64: return ops.ZeroExtI16to64\n  }; break\n\n  case t_i32: switch (y) {\n    case t_i8:  return ops.TruncI32to8\n    case t_i16: return ops.TruncI32to16\n    case t_i64: return ops.SignExtI32to64\n    case t_f32: return ops.ConvI32toF32\n    case t_f64: return ops.ConvI32toF64\n  }; break\n\n  case t_u32: switch (y) {\n    case t_u8:  return ops.TruncI32to8\n    case t_u16: return ops.TruncI32to16\n    case t_u64: return ops.ZeroExtI32to64\n    case t_f32: return ops.ConvU32toF32\n    case t_f64: return ops.ConvU32toF64\n  }; break\n\n  case t_i64: switch (y) {\n    case t_i8:  return ops.TruncI64to8\n    case t_i16: return ops.TruncI64to16\n    case t_i32: return ops.TruncI64to32\n    case t_f32: return ops.ConvI64toF32\n    case t_f64: return ops.ConvI64toF64\n  }; break\n\n  case t_u64: switch (y) {\n    case t_u8:  return ops.TruncI64to8\n    case t_u16: return ops.TruncI64to16\n    case t_u32: return ops.TruncI64to32\n    case t_f32: return ops.ConvU64toF32\n    case t_f64: return ops.ConvU64toF64\n  }; break\n\n  case t_f32: switch (y) {\n    case t_i32: return ops.ConvF32toI32\n    case t_u32: return ops.ConvF32toU32\n    case t_i64: return ops.ConvF32toI64\n    case t_u64: return ops.ConvF32toU64\n    case t_f64: return ops.ConvF32toF64\n  }; break\n\n  case t_f64: switch (y) {\n    case t_i32: return ops.ConvF64toI32\n    case t_u32: return ops.ConvF64toU32\n    case t_i64: return ops.ConvF64toI64\n    case t_u64: return ops.ConvF64toU64\n    case t_f32: return ops.ConvF64toF32\n  }; break\n\n  } // switch\n\n  // unhandled operator token\n  assert(false, `invalid conversion ${x} -> ${y}`)\n  return ops.Invalid\n}\n","import { Style, stdoutStyle, style, noStyle } from '../termstyle'\nimport { Pkg, Fun, Block, BlockKind, Value, BranchPrediction } from './ssa'\n\nexport type LineWriter = (s :string) => any\n\nclass IRFmt {\n  rarr :string  // \" -> \"\n  larr :string  // \" <- \"\n\n  constructor(\n  public types :bool,\n  public style :Style,\n  public println :LineWriter,\n  ){\n    this.rarr = style.grey(' â€”> ')\n    this.larr = style.grey(' <â€” ')\n  }\n}\n\nfunction fmtval(f :IRFmt, v :Value) :string {\n  assert(v.op, `value ${v} without .op`)\n  let s = `v${v.id} = `\n  s += v.op.name\n  if (f.types) {\n    s += ' ' + f.style.grey(`<${v.type}>`)\n  }\n  for (let arg of v.args) {\n    s += ' ' + arg\n  }\n  if (v.aux !== null) {\n    s += ` [${v.aux}]`\n  }\n  // if (v.reg != noReg) {\n  //   s += ` {${style.orange(v.reg.toString())}}`\n  // }\n  if (v.reg) {\n    s += ` {${style.orange(v.reg.name)}}`\n  }\n  // s += ` : ${style.pink(v.uses.toString())}`\n  if (v.comment) {\n    s += f.style.grey('  // ' + v.comment)\n  }\n  return s\n}\n\n\nfunction printval(f :IRFmt, v :Value, indent :string) {\n  f.println(indent + fmtval(f, v))\n}\n\n\nfunction printblock(f :IRFmt, b :Block, indent :string) {\n  let label = b.toString()\n  let preds = ''\n  let meta = ''\n\n  if (b.preds.length) {\n    preds = f.larr + b.preds.map(b => \n      f.style.lightyellow(b.toString())\n    ).join(', ')\n\n    f.println('')\n  } // else: entry block\n\n  let comment = b.comment ? f.style.grey('  // ' + b.comment) : ''\n  f.println(indent + f.style.lightyellow(label + ':') + preds + meta + comment)\n\n  let valindent = indent + '  '\n  for (let v of b.values) {\n    printval(f, v, valindent)\n  }\n\n  const fmtsucc = (b :Block) => {\n    let s = f.style.lightyellow(b.toString())\n    switch (b.likely) {\n      case BranchPrediction.Likely:\n        s += f.style.grey(' (likely)')\n        break\n      case BranchPrediction.Unlikely:\n        s += f.style.grey(' (unlikely)')\n        break\n    }\n    return s\n  }\n\n  switch (b.kind) {\n\n    case BlockKind.Plain: {\n      // check & print successors\n      // assert(b.succs.length == 1,\n      //   `b.succs.length = ${b.succs && b.succs.length || 0}; expected 1`)\n      let contb = b.succs[0]\n      if (contb) {\n        f.println(\n          indent +\n          f.style.cyan('cont') + f.rarr +\n          fmtsucc(contb)\n        )\n      }\n      break\n    }\n\n    case BlockKind.First:\n    case BlockKind.If: {\n      // check & print successors\n      // assert(b.succs.length == 2,\n      //   `b.succs.length = ${b.succs && b.succs.length || 0}; expected 2`)\n      let thenb = b.succs[0]\n      let elseb = b.succs[1]\n      if (thenb && elseb) {\n        assert(b.control, \"missing control (condition) value\")\n        f.println(\n          indent +\n          f.style.cyan(b.kind == BlockKind.If ? 'if' : 'first') +\n          ` ${b.control}${f.rarr}` +\n          fmtsucc(thenb) + ', ' + fmtsucc(elseb)\n        )\n      }\n      break\n    }\n\n    case BlockKind.Ret: {\n      // check successors\n      assert(b.succs.length == 0, \"can't have successor to return block\")\n      f.println(\n        indent +\n        f.style.cyan('ret') + (b.control ? ' ' + b.control : '')\n      )\n      break\n    }\n\n    default:\n      assert(false, `unexpected block kind ${BlockKind[b.kind]}`)\n  }\n}\n\n\nfunction printfun(f :IRFmt, fn :Fun) {\n  f.println(\n    f.style.white(fn.toString()) +\n    ' (' + fn.type.args.join(' ') + ')->' + fn.type.result\n  )\n  for (let b of fn.blocks) {\n    printblock(f, b, /*indent*/'  ')\n  }\n}\n\n\nfunction printpkg(f :IRFmt, pkg :Pkg) {\n  // data :Uint8Array      // data  TODO wrap into some simple linear allocator\n  // funs :Fun[] = []      // functions\n  // init :Fun|null = null // init functions (merged into one)\n  let isFirst = true\n  for (let fn of pkg.funs.values()) {\n    printfun(f, fn)\n    if (isFirst) {\n      isFirst = false\n    } else {\n      f.println('')\n    }\n  }\n}\n\n\nexport interface Options {\n  noTypes?  :bool  // include type annotations\n  colors? :bool\n    // true: always generate ANSI-styled output\n    // false: never generate ANSI-styled output\n    // undefined: generate ANSI-styled output if stdout is a TTY\n}\n\nexport function printir(v :Fun|Block|Value, w? :LineWriter, o? :Options) {\n  let f = new IRFmt(\n    /*types*/ !(o && o.noTypes),\n    /*style*/ (\n      o && o.colors ? style :\n      o && o.colors === false ? noStyle :\n      stdoutStyle\n    ),\n    /*println*/ w || console.log.bind(console) as LineWriter,\n  )\n  if      (v instanceof Pkg) {   printpkg(f, v) }\n  else if (v instanceof Fun) {   printfun(f, v) }\n  else if (v instanceof Block) { printblock(f, v, /*indent=*/'') }\n  else if (v instanceof Value) { printval(f, v, /*indent=*/'') }\n  else {\n    let o = v as any\n    assert(false,\n      `unexpected value ${o && typeof o == 'object' ? o.constructor.name : o}`\n    )\n  }\n}\n\nexport function fmtir(v :Fun|Block|Value, options? :Options) :string {\n  let str = ''\n  let w = (s :string) => { str += s + '\\n' }\n  printir(v, w, options)\n  return str.replace(/\\r?\\n$/, '')\n}\n","import { Type } from '../types'\n\n// A LocalSlot is a location in the stack frame, which identifies and stores\n// part or all of a PPARAM, PPARAMOUT, or PAUTO ONAME node.\n// It can represent a whole variable, part of a larger stack slot, or part of a\n// variable that has been decomposed into multiple stack slots.\n// As an example, a string could have the following configurations:\n//\n//           stack layout              LocalSlots\n//\n// Optimizations are disabled. s is on the stack and represented in its entirety.\n// [ ------- s string ---- ] { N: s, type: string, Off: 0 }\n//\n// s was not decomposed, but the SSA operates on its parts individually, so\n// there is a LocalSlot for each of its fields that points into the single\n// stack slot.\n// [ ------- s string ---- ] { N: s, type: *uint8, Off: 0 }, {N: s, type: int, Off: 8}\n//\n// s was decomposed. Each of its fields is in its own stack slot and has its own LocalSLot.\n// [ ptr *uint8 ] [ len int] { N: ptr, type: *uint8, Off: 0, splitOf: parent, splitOffset: 0},\n//                           { N: len, type: int, Off: 0, splitOf: parent, splitOffset: 8}\n//                           parent = &{N: s, type: string}\n//\nexport class LocalSlot {\n  n    :any   // an ONAME *gc.Node representing a stack location.\n  type :Type  // type of slot\n  offs :int   // offset of slot in N\n\n  // splitOf     :LocalSlot  // slot is a decomposition of splitOf\n  // splitOffset :int64      // .. at this offset.\n\n  constructor(n :any, type :Type, offs :int) {\n    this.n = n\n    this.type = type\n    this.offs = offs\n  }\n\n  _key :string\n\n  key() :string {\n    // HACK to derive a unique key of the state of this object\n    if (!this._key) {\n      this._key = `${this.n} ${this.type} ${this.offs}`\n    }\n    return this._key\n  }\n\n  toString() :string {\n    if (this.offs == 0) {\n      return `${this.n}[${this.type}]`\n    }\n    return `${this.n}+${this.offs}[${this.type}]`\n  }\n}\n","import { ByteStr, asciiByteStr } from '../bytestr'\nimport { Pos, SrcFile } from '../pos'\nimport { token } from '../token'\nimport { DiagKind, DiagHandler } from '../diag'\nimport * as ast from '../ast'\nimport * as types from '../types'\nimport {\n  Type,\n  BasicType,\n  FunType,\n  t_nil,\n  t_bool,\n} from '../types'\nimport { optcf_op1, optcf_op2 } from './opt_cf'\nimport { ops } from './op'\nimport { Value, Block, BlockKind, Fun, Pkg } from './ssa'\nimport { opselect1, opselect2 } from './opselect'\nimport { Config } from './config'\nimport { printir } from './repr'\nimport { LocalSlot } from './localslot'\n\n// import { debuglog as dlog } from '../util'\nconst dlog = function(..._ :any[]){} // silence dlog\n\n\nconst bitypes = ast.builtInTypes\n\n\nexport enum IRBuilderFlags {\n  Default  = 0,\n  Comments = 1 << 1,  // include comments in some values, for formatting\n}\n\n\nclass TmpName extends ByteStr {\n}\n\n\n// IRBuilder produces SSA IR for functions, taking AST as the input.\n//\n// The \"inline\"/\"single-pass\" Phi placement heuristic is based on the paper\n// \"Simple and Efficient Construction of Static Single Assignment Form\"\n// https://pp.info.uni-karlsruhe.de/uploads/publikationen/braun13cc.pdf\n//\nexport class IRBuilder {\n  config   :Config\n\n  pkg      :Pkg\n  sfile    :SrcFile|null = null\n  diagh    :DiagHandler|null = null\n  b        :Block       // current block\n  f        :Fun         // current function\n  flags    :IRBuilderFlags = IRBuilderFlags.Default\n  \n  vars :Map<ByteStr,Value>\n    // variable assignments in the current block (map from variable symbol\n    // to ssa value)\n\n  defvars :(Map<ByteStr,Value>|null)[]\n    // all defined variables at the end of each block. Indexed by block id.\n    // null indicates there are no variables in that block.\n\n  incompletePhis :Map<Block,Map<ByteStr,Value>>|null\n    // tracks pending, incomplete phis that are completed by sealBlock for\n    // blocks that are sealed after they have started. This happens when preds\n    // are not known at the time a block starts, but is known and registered\n    // before the block ends.\n\n  init(config :Config,\n       diagh :DiagHandler|null = null,\n       flags :IRBuilderFlags = IRBuilderFlags.Default\n  ) {\n    const r = this\n    r.config = config\n    r.pkg = new Pkg()\n    r.sfile = null\n    r.diagh = diagh\n    r.vars = new Map<ByteStr,Value>()\n    r.defvars = []\n    r.incompletePhis = null\n    r.flags = flags\n\n    // select integer types\n    const [intt_s, intt_u] = types.intTypes(config.intSize)\n    const [sizet_s, sizet_u] = types.intTypes(config.addrSize)\n\n    this.concreteType = (t :Type) :BasicType => {\n      switch (t) {\n      case types.t_int:   return intt_s\n      case types.t_uint:  return intt_u\n      case types.t_isize: return sizet_s\n      case types.t_usize: return sizet_u\n      default:\n        assert(t instanceof BasicType, `${t} is not a BasicType`)\n        return t as BasicType\n      }\n    }\n  }\n\n  // addTopLevel is the primary interface to builder\n  //\n  addTopLevel(sfile :SrcFile, d :ast.Decl|ast.FunExpr) :Fun|null {\n    // Note: d must not contain unresolved references (including types).\n    // If there are unresolved references, behavior is undefined.\n    //\n    const r = this\n    r.sfile = sfile\n\n    if (d instanceof ast.MultiDecl) {\n      for (let d2 of d.decls) {\n        r.addTopLevel(sfile, d2)\n      }\n    } else if (d instanceof ast.VarDecl) {\n      r.global(d)\n    } else if (d instanceof ast.FunExpr) {\n      if (d.isInit) {\n        // Sanity checks (parser has already checked these things)\n        assert(d.sig.params.length == 0, 'init fun with parameters')\n        assert(d.sig.result === bitypes.nil, 'init fun with result')\n        assert(d.body, 'missing body')\n        r.initCode(d.body as ast.Expr)\n      } else if (d.body) {\n        // regular function with an implementation (d.body)\n        return r.fun(d)\n      } else {\n        dlog(`skipping pure function declaration ${d}`)\n      }\n    } else if (d instanceof ast.ImportDecl) {\n      dlog(`TODO ImportDecl`)\n    } else if (d instanceof ast.TypeDecl) {\n      dlog(`TODO TypeDecl`)\n    }\n    return null // TODO: return other top-level things\n  }\n\n  // startBlock sets the current block we're generating code in\n  //\n  startBlock(b :Block) {\n    const r = this\n    assert(r.b == null, \"starting block without ending block\")\n    r.b = b\n  }\n\n  // startSealedBlock is a convenience for sealBlock followed by startBlock\n  //\n  startSealedBlock(b :Block) {\n    this.sealBlock(b)\n    this.startBlock(b)\n  }\n\n  // sealBlock sets b.sealed=true, indicating that no further predecessors\n  // will be added (no changes to b.preds)\n  //\n  sealBlock(b :Block) {\n    const s = this\n    assert(!b.sealed, `block ${b} already sealed`)\n    dlog(`${b}`)\n    if (s.incompletePhis) {\n      let entries = s.incompletePhis.get(b)\n      if (entries) {\n        for (let [name, phi] of entries) {\n          dlog(`complete pending phi ${phi} (${name})`)\n          s.addPhiOperands(name, phi)\n        }\n        s.incompletePhis.delete(b)\n      }\n    }\n    b.sealed = true\n  }\n\n  // endBlock marks the end of generating code for the current block.\n  // Returns the (former) current block. Returns null if there is no current\n  // block, i.e. if no code flows to the current execution point.\n  // The block sealed if not already sealed.\n  //\n  endBlock() :Block {\n    const r = this\n    let b = r.b\n    assert(b != null, \"no current block\")\n\n    // move block-local vars to long-term definition data\n    // first we fill any holes in defvars\n    // while (r.defvars.length <= b.id) {\n    //   r.defvars.push(null)\n    // }\n    r.defvars[b.id] = r.vars\n\n    // reset block-local vars\n    r.vars = new Map<ByteStr,Value>()\n\n    if (DEBUG) {\n      // make sure we crash if we try to use b before a new block is started\n      ;(r as any).b = null\n    }\n\n    // [optimization] change last value to TailCall when block returns\n    // and last value is Call\n    if (\n      b.kind == BlockKind.Ret &&\n      b.values.length &&\n      b.values[b.values.length-1].op == ops.Call\n    ) {\n      b.values[b.values.length-1].op = ops.TailCall\n    }\n\n    return b\n  }\n\n  startFun(f :Fun) {\n    const s = this\n    assert(s.f == null, \"starting function with existing function\")\n    s.f = f\n  }\n\n  endFun() {\n    const s = this\n    assert(s.f, \"ending function without a current function\")\n\n    dlog(`s.f.namedValues:`)\n    for (let name of s.f.namedValues.keys()) {\n      let e = s.f.namedValues.get(name)\n      let line = `  {${name}}\\t=> `\n      if (e && e.values.length) {\n        line += e.values.join(', ')\n      } else {\n        line += '-'\n      }\n      dlog(line)\n    }\n\n    // TODO: run passes on s.f here\n\n    // if (s.config.optimize) {\n    //   // perform early dead-code elimination\n    //   optdce(s.f)\n    // }\n    // if (s.regalloc) {\n    //   // perform register allocation\n    //   s.regalloc.regallocFun(s.f)\n    // }\n\n    if (DEBUG) {\n      ;(s as any).f = null\n    }\n  }\n\n  // concreteType normalizes abstract types to concrete types.\n  // E.g. concreteType(int) -> i32  (if int->i32 exists in typemap)\n  //\n  concreteType(t :Type) :BasicType {\n    // Note: This functin is replaced by the constructor\n    return t_nil\n  }\n\n  // nilValue returns a placeholder value.\n  // This is meant to be used only during development and should be removed\n  // when the IR builder is complete.\n  //\n  nilValue() :Value {\n    assert(this.b, \"no current block\")\n    return this.b.newValue0(ops.Unknown, t_nil)\n  }\n\n  global(_ :ast.VarDecl) {\n    dlog(`TODO`)\n  }\n\n  initCode(_body :ast.Expr) {\n    // const r = this\n    // const f = r.pkg.init || (r.pkg.init = new Fun([], t_nil, 'init'))\n    // r.block(f, null, body, 'init')\n    // console.log(`\\n-----------------------\\n${f}`)\n  }\n\n  fun(x :ast.FunExpr) :Fun {\n    const r = this\n    assert(x.body, `unresolved function ${x}`)\n    assert(x.type, \"unresolved function type\")\n\n    let funtype = x.type as FunType\n    let f = new Fun(\n      funtype,\n      x.name ? x.name.value : null,\n      x.sig.params.length\n    )\n\n    // initialize locals\n    for (let i = 0; i < x.sig.params.length; i++) {\n      let p = x.sig.params[i]\n      if (p.name && !p.name.value.isUnderscore()) {\n        let t = r.concreteType(funtype.args[i])\n        let name = p.name.value\n        let v = f.entry.newValue0(ops.Arg, t, i)\n        if (r.flags & IRBuilderFlags.Comments) {\n          v.comment = name.toString()\n        }\n        r.vars.set(name, v)\n      }\n    }\n\n    r.startFun(f)\n    r.startSealedBlock(f.entry)\n\n    let bodyval = r.block(x.body as ast.Expr)\n\n    if (r.b as any) {\n      // end last block if not already ended\n      r.b.kind = BlockKind.Ret\n      if (!(x.body instanceof ast.Block)) {\n        // body is a single expression -- control value is that expression\n        // assert(!(x.body instanceof ast.ReturnStmt),\n        //   \"'return' as function expression body should have called \"+\n        //   \"ret() to close block\")\n        r.b.setControl(bodyval)\n      }\n      // when body is a block and it didn't end, it was empty and thus\n      // the return type is nil (no control value.)\n      r.endBlock()\n    }\n\n    assert((r as any).b == null,\n      \"function exit block not ended\")\n\n    assert(f.blocks[f.blocks.length-1].kind == BlockKind.Ret,\n      \"last block in function is not BlockKind.Ret\")\n    // assert(f.tailb.kind == BlockKind.Ret,\n    //   \"last block in function is not BlockKind.Ret\")\n\n    r.endFun()\n\n    r.pkg.funs.set(f.name, f)\n    return f\n  }\n\n\n  // block generates values from an AST block.\n  // It's the caller's responsibility to create and manage IR blocks.\n  //\n  block(x :ast.Expr) :Value|null {\n    const r = this\n    if (x instanceof ast.Block) {\n      let end = x.list.length\n      let lasti = end - 1\n      for (let i = 0; i != end; ++i) {\n        if (!r.b) {\n          dlog('block ended early')\n          // block ended early (i.e. from \"return\")\n          r.diag('warn', `unreachable code`, x.list[i].pos)\n          break\n        }\n        r.stmt(x.list[i], i == lasti)\n      }\n      return null\n    } else {\n      return r.expr(x)\n      // r.stmt(x, /*isLast=*/true)\n    }\n  }\n\n\n  // stmt adds one or more TAC to block b in function f from statement s\n  //\n  stmt(s :ast.Stmt, isLast :bool = false) {\n    const r = this\n\n    if (s instanceof ast.IfExpr) {\n      r.if_(s)\n\n    } else if (s instanceof ast.ReturnStmt) {\n      r.ret(r.expr(s.result))\n\n    } else if (s instanceof ast.WhileStmt) {\n      r.while_(s)\n\n    } else if (s instanceof ast.Expr) {\n      if (!isLast && s instanceof ast.Ident) {\n        r.diag('warn', `unused expression`, s.pos)\n      } else {\n        r.expr(s)\n      }\n\n    } else if (s instanceof ast.VarDecl) {\n      if (s.values) {\n        // explicit value; e.g. \"x = 3\"\n        for (let i = 0; i < s.idents.length; i++) {\n          let id = s.idents[i]\n          let v = r.expr(s.values[i])\n          assert(!r.vars.has(id.value), `redeclaration of var ${id.value}`)\n          r.vars.set(id.value, v)\n        }\n      } else {\n        // default value; e.g. \"x i32\"  =>  \"x = 0\"\n        assert(s.type, 'var decl without type or values')\n        let t = (s.type as ast.Expr).type as BasicType\n        assert(t, 'unresolved type')\n        assert(t instanceof BasicType, 'non-basic type not yet supported')\n        let v = r.f.constVal(t, 0)\n        for (let id of s.idents) {\n          assert(!r.vars.has(id.value), `redeclaration of var ${id.value}`)\n          r.vars.set(id.value, v)\n        }\n      }\n\n    } else {\n      dlog(`TODO: handle ${s.constructor.name}`)\n    }\n  }\n\n\n  ret(val :Value|null) {\n    const r = this\n    let b = r.endBlock()\n    b.kind = BlockKind.Ret\n    b.setControl(val)\n  }\n\n\n  // while_ builds a conditional loop.\n  //\n  // The current block is first ended as a simple \"cont\" and a new block\n  // is created for the loop condition, which when true branches to\n  // the loop body, and after the loop when false.\n  //\n  // Example:\n  //   x = 5\n  //   while x > 0 {\n  //     x--\n  //   }\n  // Becomes:\n  //   b0:\n  //     v0 = ConstI32 [5]  // x\n  //     v1 = ConstI32 [0]\n  //     v2 = ConstI32 [1]\n  //   cont -> b1\n  //   b1: <- b0  // while\n  //     v3 = Phi v1 v5\n  //     v4 = GreaterS32 v1 v2\n  //   if v4 -> b2, b3\n  //   b2: <- b1  // then\n  //     v5 = SubI32 v3 v2  // x = x - 1\n  //   cont -> b1\n  //   b3:  // end while\n  //   ret\n  // \n  //\n  while_(n: ast.WhileStmt) {\n    const s = this\n\n    // end \"entry\" block (whatever block comes before \"while\")\n    let entryb = s.endBlock()\n    assert(entryb.kind == BlockKind.Plain)\n    // create \"if\" block, for testing the while condition\n    let ifb = s.f.newBlock(BlockKind.If)\n    entryb.succs = [ifb] // entry -> if\n    ifb.preds = [entryb] // if <- entry[, then]\n    // start \"if\" block\n    s.startBlock(ifb) // note: not sealed\n    let control = s.expr(n.cond) // condition for looping\n\n    // potentially inline or eliminate branches when control is constant\n    if (s.config.optimize && control.op.constant) {\n      if (control.auxIsZero()) {\n        // while loop never taken\n\n        // convert condition block to continuation block and seal it\n        ifb.kind = BlockKind.Plain\n        s.sealBlock(ifb)  // no more preds\n\n        printir(entryb)\n\n        // Note: later fuse pass will combine the two immediately-adjacent\n        // blocks into one, so no need to do that here. It's non-trivial.\n\n        return\n      }\n      // else:\n      //   \"then\" branch always taken.\n      //\n      //   TODO:\n      //     - search body for a break condition\n      //     - search body for mutations of control\n      //\n      //   If no break or no control mutation is found, then the loop is\n      //   infinite and we should either emit an error (or a warning and\n      //   remove the branch)\n      //\n      //   For now, we have to assume there's a break or control mutation\n      //   in the loop body, so continue with generating the branch.\n    }\n    // else:\n    //   control is probably not constant\n    //\n    //   Later on when we have completed building the while construct, we\n    //   traverse possible Phi args of control to see if that makes it\n    //   constant If an arg of the control is used in the while loop, which\n    //   is common, it will be referenced by an incomplete Phi, which would\n    //   cause the constant-evaluator run in expr() to see that the operator\n    //   is variable, since the constant-evaluator doesn't have knowledge of\n    //   the fact that the arg is mutated only in the loop body.\n    //\n    //   But we know that. So, look at control.args and if an arg is an\n    //   incomplete Phi, then jump to the partial phi.arg and temporarily\n    //   replace the control.arg[N] with the phi.arg and attempt to run\n    //   the constant-evaluator. If the result is constant, we can perform\n    //   the steps above in the `if (control.op.constant) {...}` block.\n    //\n\n    // end \"if\" block and assign condition\n    ifb = s.endBlock()\n    ifb.setControl(control)\n\n    // create \"then\" block, to be visited on each loop iteration\n    let thenb = s.f.newBlock(BlockKind.Plain)\n    thenb.preds = [ifb]\n    // start \"then\" block (seal as well; preds are complete)\n    s.startSealedBlock(thenb)\n    s.block(n.body) // body (note: ignore return value)\n    // end \"then\" block\n    thenb = s.endBlock()\n    thenb.succs = [ifb] // thenb -> ifb\n\n    // complete & seal \"if\" block late, since it depends on \"then\" block\n    ifb.preds = [entryb, thenb] // if <- entry, then\n    s.sealBlock(ifb) // \"if\" block sealed here\n\n    // create \"next\" block, for whatever comes after the \"while\"\n    let nextb = s.f.newBlock(BlockKind.Plain)\n    nextb.preds = [ifb] // next <- if, then\n    ifb.succs = [thenb, nextb] // if -> next, then\n    // start \"next\" block and return\n    s.startSealedBlock(nextb)\n\n    // possibly eliminate dead while loop.\n    // (See notes earlier in this function.)\n    // if (s.config.optimize && !control.op.constant && control.op.argLen > 0) {\n    //   let args :Value[]|undefined\n    //   for (let i = 0; i < control.args.length; i++) {\n    //     let arg = control.args[i]\n    //     if (arg.op === ops.Phi && arg.b === ifb) {\n    //       if (!args) {\n    //         args = control.args.slice() // copy\n    //       }\n    //       assert(ifb.preds[0] === entryb, `entryb not at expected index`)\n    //       args[i] = arg.args[0]\n    //     }\n    //   }\n    //   // args will be set only if we found at least one Phi in control.args\n    //   if (args) {\n    //     // attempt constant evaluation of control value\n    //     let constctrl :Value|null = null\n    //     if (args.length == 2) {\n    //       constctrl = optcf_op2(ifb, control.op, args[0], args[1])\n    //     } else if (args.length == 1) {\n    //       constctrl = optcf_op1(ifb, control.op, args[0])\n    //     }\n    //     if (constctrl && constctrl.auxIsZero()) {\n    //       // while loop never taken -- shortcut entryb -> nextb\n    //       removeEdge(entryb, 0)\n    //       entryb.succs = [nextb]\n    //       removeEdge(ifb, 0)\n    //       nextb.preds = [entryb]\n    //       // s.f.removeBlock(ifb)\n    //       // s.f.removeBlock(thenb)\n    //     }\n    //   }\n    // }\n\n    // add comments\n    if (s.flags & IRBuilderFlags.Comments) {\n      ifb.comment = 'while'\n      thenb.comment = 'then'\n      nextb.comment = 'endwhile'\n    }\n  }\n\n\n  // if_ reads an if expression.\n  // Returns a new empty block that's the block after the if.\n  //\n  if_(s :ast.IfExpr) {\n    //\n    // if..end has the following semantics:\n    //\n    //   if cond b1 b2\n    //   b1:\n    //     <then-block>\n    //   goto b2\n    //   b2:\n    //     <continuation-block>\n    //\n    // if..else..end has the following semantics:\n    //\n    //   if cond b1 b2\n    //   b1:\n    //     <then-block>\n    //   goto b3\n    //   b2:\n    //     <else-block>\n    //   goto b3\n    //   b3:\n    //     <continuation-block>\n    // \n    const r = this\n\n    // generate control condition\n    let control = r.expr(s.cond)\n\n    // potentially inline or eliminate branches when control is constant\n    if (r.config.optimize && control.op.constant) {\n      if (control.auxIsZero()) {\n        // \"else\" branch always taken\n        if (s.els_) {\n          r.block(s.els_)\n        }\n        // else: no else branch -- entire if-expression is eliminated\n      } else {\n        // \"then\" branch always taken\n        r.block(s.then)\n      }\n      return\n    }\n\n    // end predecessor block (leading up to and including \"if\")\n    let ifb = r.endBlock()\n    ifb.kind = BlockKind.If\n    ifb.setControl(control)\n\n    // create blocks for then and else branches\n    let thenb = r.f.newBlock(BlockKind.Plain)\n    let elseb = r.f.newBlock(BlockKind.Plain)\n    ifb.succs = [thenb, elseb] // if -> then, else\n\n    // create \"then\" block\n    thenb.preds = [ifb] // then <- if\n    r.startSealedBlock(thenb)\n    r.block(s.then)\n    thenb = r.endBlock()\n\n    if (s.els_) {\n      // if cond then A else B end\n\n      // allocate \"cont\" block\n      let contb = r.f.newBlock(BlockKind.Plain)\n\n      // create \"else\" block\n      elseb.preds = [ifb] // else <- if\n      r.startSealedBlock(elseb)\n      r.block(s.els_)\n      elseb = r.endBlock()\n      elseb.succs = [contb]\n\n      thenb.succs = [contb] // then -> cont\n      contb.preds = [thenb, elseb] // cont <- then, else\n      r.startSealedBlock(contb)\n\n      if (r.flags & IRBuilderFlags.Comments) {\n        thenb.comment = 'then'\n        elseb.comment = 'else'\n        contb.comment = 'endif'\n      }\n    } else {\n      // if cond then A end\n      thenb.succs = [elseb] // then -> else\n      elseb.preds = [ifb, thenb] // else <- if, then\n      elseb.succs = []\n      r.startSealedBlock(elseb)\n\n      if (r.flags & IRBuilderFlags.Comments) {\n        thenb.comment = 'then'\n        elseb.comment = 'endif'\n      }\n    }\n  }\n\n\n  // assign does left = right.\n  // Right has already been evaluated to ssa, left has not.\n  assign(left :ast.Expr, right :Value) :Value {\n    const s = this\n\n    assert(left instanceof ast.Ident, `${left.constructor.name} not supported`)\n    let name = (left as ast.Ident).value\n\n    // s.addNamedValue(left, right)\n    // let t = rhs.type as BasicType\n    // assert(t instanceof BasicType, \"not a basic type\")\n    // let op = storeop(t)\n    // v = r.b.newValue1(op, t, src, dst)\n    // return right\n\n    // // Issue a \"copy\" to indicate \"store to variable\"\n    // let v = s.b.newValue1(ops.Copy, right.type, right)\n    // if (s.flags & IRBuilderFlags.Comments) {\n    //   v.comment = name.toString()\n    // }\n    // s.writeVariable(name, v)\n    // return v\n    // //\n    // // TODO: when we implement register allocation and stack allocation,\n    // // we can remove the \"Copy\" op and just do the following to track the\n    // // assignment:\n    // //\n\n    // instead of issuing an intermediate \"store\", simply associate variable\n    // name with the value on the right-hand side.\n    s.writeVariable(name, right)\n    return right\n  }\n\n\n  // process an assignment node\n  assignment(s :ast.Assignment) :Value {\n    const r = this\n\n    if (s.op == token.INC || s.op == token.DEC) {\n      // e.g. \"x++\"  =>  \"x = x + 1\"\n      assert(s.lhs.length == 1)\n      assert(s.rhs.length == 0)\n      let lhs = s.lhs[0]\n\n      // let t = r.concreteType(lhs.type)\n      let x = r.expr(lhs)\n      let y = r.f.constVal(x.type, 1)\n\n      // generate \"x = x op 1\"\n      let tok = s.op == token.INC ? token.ADD : token.SUB\n      let op = opselect2(tok, x.type, y.type)\n      let v = r.b.newValue2(op, x.type, x, y)\n      return r.assign(lhs, v)\n    }\n\n    if (s.op != token.ASSIGN) {\n      assert(\n        // i.e. not \"op=\"\n        s.op < token.assignop_beg || s.op > token.assignop_end,\n        `invalid assignment operation ${token[s.op]}`\n      )\n      // \"x += 4\", \"x *= 2\", etc  =>  \"x = x + 4\", \"x = x * 2\", etc.\n      assert(s.lhs.length == 1)\n      assert(s.rhs.length == 1)\n\n      let lhs = s.lhs[0]\n      // let t = r.concreteType(lhs.type)\n      let x = r.expr(lhs)\n      let y = r.expr(s.rhs[0])\n      let op = opselect2(s.op, x.type, y.type)\n      let v = r.b.newValue2(op, x.type, x, y)\n      return r.assign(lhs, v)\n    }\n\n    // if we get here, we're dealing with a regular assignment, e.g. \"x = y\"\n\n    // break up \"x, y = a, b\" assignments into simple \"x = a\", \"y = b\"\n    //\n    let z = s.lhs.length\n    let preloadRhs :(Value|undefined)[]|null = null  // \"holey\" array\n\n    if (z > 1) {\n      // potentially rewrite RHS with preloads and temps when an identifier\n      // appears on both the left and right side.\n      //\n      // e.g. \"x, y, z = y, x, 2\" causes x and y to be preloaded into\n      // temporaries:\n      //   t0 = load x\n      //   t1 = load y\n      //   store t1 x\n      //   store t0 y\n      //   z = 2\n      //\n      let leftnames = new Map<ByteStr,int>() // name => position\n      for (let i = 0; i < z; i++) {\n        let x = s.lhs[i]\n        if (x instanceof ast.Ident) {\n          leftnames.set(x.value, i)\n        }\n      }\n      for (let i = 0; i < z; i++) {\n        let x = s.rhs[i]\n        if (x instanceof ast.Ident) {\n          let Li = leftnames.get(x.value)\n          if (Li == i) {\n            // e.g. \"x, y = x, 2\"\n            r.diag('warn', `${x} assigned to itself`, x.pos)\n          } else if (Li !== undefined) {\n            // appears on the left -- preload\n            if (!preloadRhs) {\n              preloadRhs = new Array<Value|undefined>(s.rhs.length)\n            }\n            preloadRhs[i] = r.expr(x)\n          }\n        }\n      }\n    }\n\n    let v :Value|null = null\n\n    for (let i = 0; i < z; i++) {\n      let left = s.lhs[i]\n      let k :Value|undefined\n      if (preloadRhs && (k = preloadRhs[i])) {\n        v = k\n      } else {\n        v = r.expr(s.rhs[i])\n      }\n      v = r.assign(left, v)\n      if (r.flags & IRBuilderFlags.Comments && left.isIdent()) {\n        v.comment = left.toString()\n      }\n    }\n\n    return v as Value\n  }\n\n\n  expr(s :ast.Expr) :Value {\n    const r = this\n    \n    assert(s.type, `type not resolved for ${s}`)\n\n    if (s instanceof ast.NumLit) {\n      const t = r.concreteType(s.type)\n      return r.f.constVal(t, s.value)\n    }\n\n    if (s instanceof ast.Ident) {\n      const t = r.concreteType(s.type as Type)\n      return r.readVariable(s.value, t, null)\n    }\n\n    if (s instanceof ast.Assignment) {\n      return r.assignment(s)\n    }\n\n    if (s instanceof ast.Operation) {\n\n      // \"x op y\" => \"tmp = x op y\" -> tmp\n      if (s.op == token.OROR || s.op == token.ANDAND) {\n        return r.opAndAnd(s)\n      }\n\n      const t = r.concreteType(s.type as Type)\n\n      let left = r.expr(s.x)\n      if (s.y) {\n        // Basic binary operation\n        let right = r.expr(s.y)\n        let op = opselect2(s.op, left.type, right.type)\n\n        if (r.config.optimize) {\n          // attempt to evaluate constant expression\n          let v = optcf_op2(r.b, op, left, right)\n          if (v) {\n            // if (r.b !== v.b) {\n            //   // place a Copy when the definition is in a different block\n            //   // to maintain CFG integrity.\n            //   v = r.copy(v)\n            // }\n            return v\n          }\n        }\n\n        return r.b.newValue2(op, t, left, right)\n      }\n\n      // Basic unary operation\n      let op = opselect1(s.op, left.type)\n\n      if (r.config.optimize) {\n        // attempt to evaluate constant expression\n        let v = optcf_op1(r.b, op, left)\n        if (v) {\n          // if (r.b !== v.b) {\n          //   // place a Copy when the definition is in a different block\n          //   // to maintain CFG integrity.\n          //   v = r.copy(v)\n          // }\n          return v\n        }\n      }\n\n      return r.b.newValue1(op, t, left)\n    }\n\n    if (s instanceof ast.CallExpr) {\n      return r.funcall(s)\n    }\n\n    dlog(`TODO: handle ${s.constructor.name}`)\n    return r.nilValue()\n  }\n\n\n  copy(v :Value) :Value {\n    return this.b.newValue1(ops.Copy, v.type, v)\n  }\n\n\n  tmpNames :TmpName[] = []\n  tmpNameBytes :Uint8Array|null = null\n  tmpNameHash :int = 0\n\n  allocTmpName() :TmpName {\n    let n = this.tmpNames.pop()\n    if (!n) {\n      if (this.tmpNameBytes) {\n        n = new TmpName(this.tmpNameHash, this.tmpNameBytes)\n      } else {\n        n = asciiByteStr('tmp')\n        this.tmpNameBytes = n.bytes\n        this.tmpNameHash = n.hash\n      }\n    }\n    return n\n  }\n\n\n  freeTmpName(n :TmpName) {\n    this.tmpNames.push(n)\n  }\n\n\n  opAndAnd(n :ast.Operation) :Value {\n    // high-level \"&&\" or \"||\" operation, lowered to branching.\n    //\n    // We implement \"||\" and \"&&\" via a temporary var and \"if\" branch.\n    // E.g. source code\n    //    x && y\n    // is converted to\n    //    t = x\n    //    if t {\n    //      t = y\n    //    }\n    // and t is unsed in place.\n    // OROR is converted in a similar manner:\n    //    x || y\n    // is converted to\n    //    t = x\n    //    if !t {\n    //      t = y\n    //    }\n    //\n    // Reference of Go AST -> IR for OROR and ANDAND:\n    //   https://github.com/golang/go/blob/\n    //   10d096fec2fe8f3e88f847fd0ac17c0601bf6442/src/cmd/compile/internal/\n    //   gc/ssa.go#L1957\n    //\n    // -------------------------------------------------------------------\n    // Note on WASM:\n    // WebAssembly provides a \"select\" operator with these semantics:\n    //   t1 = A<T>\n    //   t2 = B<T>\n    //   select C<i32> t1 t2 => D<T>\n    // Where if C is not zero, value of A is used, otherwise value of B is\n    // used, resulting in D. A and B must be of the same type and both A\n    // and B are evaluated prior to the operator (not short-circuiting.)\n    // This would make sense to use only for special cases where both A\n    // and B are constants.\n    // In order to target this operator in WASM, we need a higher-level\n    // construct to represent ANDAND and OROR. After this (current)\n    // if-construction, it won't be easy to later \"revert\" to ANDAND and\n    // OROR.\n    // Idea 1: Include target information when generating IR and only\n    //         unroll into \"if\" branches if the target doesn't support\n    //         something like WASM's \"select\".\n    // Idea 2: Perform this step later \n    //\n    // However, for now, since it's a possibly-small RoI optimization\n    // opportunity, we're ignoring this.\n    // -------------------------------------------------------------------\n    //\n    const s = this\n    assert(n.y != null)\n\n    let tmpname = s.allocTmpName()\n\n    let left = s.expr(n.x)\n    s.writeVariable(tmpname, left)\n\n    let t = left.type\n\n    let rightb = s.f.newBlock(BlockKind.Plain)  // y\n    let contb = s.f.newBlock(BlockKind.Plain) // t\n\n    // end entry \"if\" block\n    let ifb = s.endBlock()\n    ifb.kind = BlockKind.If\n    ifb.setControl(left)\n\n    if (n.op == token.OROR) {\n      // flip branches; equivalent to \"ifFalse\"/\"ifz\"\n      // contb.likely = BranchPrediction.Likely\n      // rightb.likely = BranchPrediction.Unlikely\n      ifb.succs = [contb, rightb] // if -> contb, rightb\n    } else {\n      assert(n.op == token.ANDAND)\n      // rightb.likely = BranchPrediction.Likely\n      // contb.likely = BranchPrediction.Unlikely\n      ifb.succs = [rightb, contb] // if -> rightb, contb\n    }\n\n    // gen \"right\" block\n    rightb.preds = [ifb] // rightb <- if\n    s.startSealedBlock(rightb)\n    let right = s.expr(n.y as ast.Expr)\n\n    // TODO: do we really need a \"copy\" here? Can't we just do this instead\n    //   s.writeVariable(tmpname, right)\n    // and then navigate the resulting Phi when lowering to target code?\n    //\n    // let tmpv = s.b.newValue1(ops.Copy, right.type, right)\n    // s.writeVariable(tmpname, tmpv)\n    s.writeVariable(tmpname, right)\n\n    rightb = s.endBlock()\n    rightb.succs = [contb] // rightb -> contb\n\n    assert(t.equals(right.type), \"operands have different types\")\n\n    // start continuation block\n    contb.preds = [ifb, rightb] // contb <- ifb, rightb\n    s.startSealedBlock(contb)\n\n    let v = s.readVariable(tmpname, t_bool, null)\n\n    // remove tmpname\n    s.removeVariable(ifb, tmpname)\n    s.freeTmpName(tmpname)\n\n    return v\n  }\n\n\n  funcall(x :ast.CallExpr) :Value {\n    const s = this\n\n    if (x.hasDots) {\n      dlog(`TODO: handle call with hasDots`)\n    }\n\n    // first unroll argument values\n    let argvals :Value[] = []\n    for (let arg of x.args) {\n      argvals.push(s.expr(arg))\n    }\n\n    // push params\n    if (\n      s.flags & IRBuilderFlags.Comments &&\n      x.fun instanceof ast.Ident &&\n      x.fun.ent\n    ) {\n      // include comment with name of parameter, when available\n      let fx = x.fun.ent.decl as ast.FunExpr\n      let funstr = x.fun.toString() + '/'\n      for (let i = 0; i < argvals.length; i++) {\n        let v = argvals[i]\n        let v2 = s.b.newValue1(ops.CallArg, v.type, v)\n        if (s.flags & IRBuilderFlags.Comments) {\n          let param = fx.sig.params[i]\n          if (param.name) {\n            v2.comment = funstr + param.name.toString()\n          }\n        }\n      }\n    } else {\n      for (let v of argvals) {\n        s.b.newValue1(ops.CallArg, v.type, v)\n      }\n    }\n\n    // TODO: handle any function by\n    // let fv = s.expr(x.fun)\n    // and implementing function resolution somehow in readGlobal et al.\n\n    assert(x.fun instanceof ast.Ident, \"non-id callee not yet supported\")\n    let funid = x.fun as ast.Ident\n    assert(funid.ent, \"unresolved callee\")\n\n    let ft = funid.type as FunType\n    assert(ft, \"unresolved function type\")\n\n\n    let rt = ft.result as BasicType\n    assert(ft.result instanceof BasicType,\n      `non-basic type ${ft.result.constructor.name} not yet supported`)\n    return s.b.newValue0(ops.Call, rt, funid.value)\n  }\n\n\n  readVariable(name :ByteStr, t :BasicType, b :Block|null) :Value {\n    const s = this\n\n    if (!b || b === s.b) {\n      let v = s.vars.get(name)\n      if (v) {\n        return v\n      }\n      b = s.b\n    } else {\n      let m = s.defvars[b.id]\n      if (m) {\n        let v = m.get(name)\n        if (v) {\n          return v\n        }\n      }\n    }\n\n    // global value numbering\n    return s.readVariableRecursive(name, t, b)\n  }\n\n\n  removeVariable(b :Block, name :ByteStr) :bool {\n    if (b === this.b) {\n      return this.vars.delete(name)\n    }\n    let m = this.defvars[b.id]\n    return m ? m.delete(name) : false\n  }\n\n\n  readGlobal(name :ByteStr) :Value {\n    const s = this\n    dlog(`TODO readGlobal ${name}`)\n    return s.nilValue() // FIXME\n  }\n\n\n  writeVariable(name :ByteStr, v :Value, b? :Block) {\n    const s = this\n    dlog(`${b || s.b} ${name} = ${v.op} ${v}`)\n    if (!b || b === s.b) {\n      s.vars.set(name, v)\n    } else {\n      // while (s.defvars.length <= b.id) {\n      //   // fill any holes\n      //   s.defvars.push(null)\n      // }\n      let m = s.defvars[b.id]\n      if (m) {\n        m.set(name, v)\n      } else {\n        s.defvars[b.id] = new Map<ByteStr,Value>([[name, v]])\n      }\n    }\n\n    if (!(name instanceof TmpName)) {\n      // TODO: find a better and more efficient way to map a LocalSlot\n      // in a map structure. For now, we use a string representation of its\n      // internal state, but that's pretty slow.\n      // Also, when we find a way to actually key with a LocalSlot, we can\n      // simplify Fun.namedValues to be Map<LocalSlot,Value[]>\n      let local = new LocalSlot(name, v.type, 0)\n      let e = s.f.namedValues.get(local.key())\n      if (e) {\n        e.values.push(v)\n      } else {\n        s.f.namedValues.set(local.key(), { local, values: [v] })\n      }\n    }\n  }\n\n  addIncompletePhi(phi :Value, name :ByteStr, b :Block) {\n    const s = this\n    dlog(`${b} ${phi} var=${name}`)\n    let names = s.incompletePhis ? s.incompletePhis.get(b) : null\n    if (!names) {\n      names = new Map<ByteStr,Value>()\n      if (!s.incompletePhis) {\n        s.incompletePhis = new Map<Block,Map<ByteStr,Value>>()\n      }\n      s.incompletePhis.set(b, names)\n    }\n    names.set(name, phi)\n  }\n\n\n  readVariableRecursive(name :ByteStr, t :BasicType, b :Block) :Value {\n    const s = this\n    let val :Value\n\n    if (!b.sealed) {\n      // incomplete CFG\n      dlog(`${b} ${name} not yet sealed`)\n      val = b.newPhi(t)\n      s.addIncompletePhi(val, name, b)\n\n    } else if (b.preds.length == 1) {\n      dlog(`${b} ${name} common case: single predecessor ${b.preds[0]}`)\n      // Optimize the common case of one predecessor: No phi needed\n      val = s.readVariable(name, t, b.preds[0])\n      dlog(`found ${name} : ${val}`)\n\n    } else if (b.preds.length == 0) {\n      dlog(`${b} ${name} uncommon case: outside of function`)\n      // entry block\n      val = s.readGlobal(name)\n      // TODO: consider just returning the value here instead of falling\n      // through and causing writeVariable.\n\n    } else {\n      dlog(`${b} ${name} uncommon case: multiple predecessors`)\n      // Break potential cycles with operandless phi\n      val = b.newPhi(t)\n      s.writeVariable(name, val, b)\n      val = s.addPhiOperands(name, val)\n    }\n    s.writeVariable(name, val, b)\n    return val\n  }\n\n\n  addPhiOperands(name :ByteStr, phi :Value) :Value {\n    const s = this\n    assert(phi.op === ops.Phi)\n    assert(phi.b.preds.length > 0, 'phi in block without predecessors')\n    // Determine operands from predecessors\n    dlog(`${name} phi=${phi}`)\n    for (let pred of phi.b.preds) {\n      dlog(`  ${pred}`)\n      let v = s.readVariable(name, phi.type, pred)\n      if (v !== phi) {\n        dlog(`  ${pred} ${v}<${v.op}>`)\n        phi.addArg(v)\n      }\n    }\n    return phi\n  }\n\n\n  // diag reports a diagnostic message, or an error if k is ERROR\n  //\n  diag(k :DiagKind, msg :string, pos :Pos) {\n    const r = this\n    assert(k != \"error\", \"unexpected DiagKind 'error'\")\n    if (r.diagh) {\n      assert(r.sfile)\n      r.diagh((r.sfile as SrcFile).position(pos), msg, k)\n    }\n  }\n\n}\n\n","import { f64ToS32pair, SInt64 as _SInt64 } from './int64'\n\nexport type Duration = number\n\nexport const\n  Nanosecond  :Duration = 1,\n  Microsecond :Duration = 1000 * Nanosecond,\n  Millisecond :Duration = 1000 * Microsecond,\n  Second      :Duration = 1000 * Millisecond,\n  Minute      :Duration = 60 * Second,\n  Hour        :Duration = 60 * Minute\n\n\n// monotime returns a real timestamp\n//\nexport const monotime : ()=>Duration = (\n  typeof performance != 'undefined' ? () => performance.now() * Millisecond :\n  (typeof process != 'undefined' && process.hrtime) ? () => {\n    let t = process.hrtime()\n    return (t[0] * 1e9) + t[1]\n  } :\n  () => Date.now() * Millisecond\n)\n\n\ninterface WasmInterface {\n  // writes to buffer, returns buffer offset\n  fmtduration(low :int, hight :int) :int\n  bufptr() :int   // provides the address of the shared buffer\n  bufsize() :int  // provides the size of the shared buffer\n}\n\nconst wasmMemory = new WebAssembly.Memory({ initial:2, maximum:2 })\nconst wasm = (typeof WebAssembly != 'undefined' ?\n  new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    //!<wasmdata src=\"time_fmtduration.wast\">\n    0,97,115,109,1,0,0,0,1,11,2,96,0,1,127,96,2,127,127,1,127,2,16,1,3,101,\n    110,118,6,109,101,109,111,114,121,2,1,2,2,3,4,3,0,0,1,7,34,3,6,98,117,102,\n    112,116,114,0,0,7,98,117,102,115,105,122,101,0,1,11,102,109,116,100,117,\n    114,97,116,105,111,110,0,2,10,231,12,3,5,0,65,128,8,11,4,0,65,32,11,217,\n    12,5,2,127,3,126,2,127,1,126,4,127,32,0,173,32,1,173,66,32,134,132,33,4,\n    32,4,66,0,83,33,10,66,0,32,4,125,33,6,32,10,69,4,64,32,4,33,6,11,65,159,8,\n    65,243,0,58,0,0,2,64,32,6,66,128,148,235,220,3,84,4,64,2,64,32,6,66,0,81,\n    4,64,2,64,65,158,8,65,48,58,0,0,65,30,15,11,11,32,6,66,232,7,84,4,64,2,64,\n    65,158,8,65,238,0,58,0,0,65,30,33,2,11,5,2,64,32,6,66,192,132,61,84,4,127,\n    2,127,65,158,8,65,181,127,58,0,0,65,3,33,11,65,30,11,5,2,127,65,158,8,65,\n    237,0,58,0,0,65,6,33,11,65,30,11,11,33,2,32,6,33,4,3,64,32,4,32,4,66,10,\n    128,34,6,66,10,126,125,33,5,32,5,66,0,82,33,8,32,7,32,8,114,33,7,32,7,65,\n    255,1,113,69,33,12,32,2,65,127,106,33,8,32,12,69,4,64,2,64,32,8,65,128,8,\n    106,33,13,32,5,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,32,13,\n    32,2,58,0,0,32,8,33,2,11,11,32,3,65,1,106,33,3,32,3,32,11,71,4,64,2,64,32,\n    6,33,4,12,2,11,11,11,32,2,65,127,106,33,3,32,12,69,4,64,2,64,32,3,65,128,\n    8,106,33,2,32,2,65,46,58,0,0,32,3,33,2,11,11,32,4,66,10,84,4,64,2,64,32,2,\n    65,127,106,33,2,32,2,65,128,8,106,33,3,32,3,65,48,58,0,0,12,6,11,11,11,11,\n    3,64,32,2,65,127,106,33,2,32,6,32,6,66,10,128,34,4,66,10,126,125,33,5,32,\n    5,167,33,3,32,3,65,48,114,33,3,32,3,65,255,1,113,33,7,32,2,65,128,8,106,\n    33,3,32,3,32,7,58,0,0,32,6,66,10,90,4,64,2,64,32,4,33,6,12,2,11,11,11,11,\n    5,2,64,32,6,32,6,66,10,128,34,4,66,10,126,125,33,5,32,5,66,0,81,4,127,65,\n    31,5,2,127,32,5,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,65,\n    158,8,32,2,58,0,0,65,30,11,11,33,7,32,4,66,10,130,33,4,32,5,32,4,132,33,5,\n    32,5,66,0,81,33,2,32,7,65,127,106,33,3,32,2,4,64,32,7,33,2,5,2,64,32,3,65,\n    128,8,106,33,8,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,\n    32,8,32,2,58,0,0,32,3,33,2,32,7,65,126,106,33,3,11,11,32,6,66,228,0,128,\n    33,4,32,4,66,10,130,33,4,32,5,32,4,132,33,5,32,5,66,0,82,4,64,2,64,32,3,\n    65,128,8,106,33,7,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,\n    2,32,7,32,2,58,0,0,32,3,34,2,65,127,106,33,3,11,11,32,6,66,232,7,128,33,4,\n    32,4,66,10,130,33,4,32,5,32,4,132,33,5,32,5,66,0,82,4,64,2,64,32,3,65,128,\n    8,106,33,7,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,32,7,\n    32,2,58,0,0,32,3,34,2,65,127,106,33,3,11,11,32,6,66,144,206,0,128,33,4,32,\n    4,66,10,130,33,4,32,5,32,4,132,33,5,32,5,66,0,82,4,64,2,64,32,3,65,128,8,\n    106,33,7,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,32,7,32,\n    2,58,0,0,32,3,34,2,65,127,106,33,3,11,11,32,6,66,160,141,6,128,33,4,32,4,\n    66,10,130,33,4,32,5,32,4,132,33,5,32,5,66,0,82,4,64,2,64,32,3,65,128,8,\n    106,33,7,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,32,7,32,\n    2,58,0,0,32,3,34,2,65,127,106,33,3,11,11,32,6,66,192,132,61,128,33,4,32,4,\n    66,10,130,33,4,32,5,32,4,132,33,5,32,5,66,0,82,4,64,2,64,32,3,65,128,8,\n    106,33,7,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,32,7,32,\n    2,58,0,0,32,3,34,2,65,127,106,33,3,11,11,32,6,66,128,173,226,4,128,33,4,\n    32,4,66,10,130,33,4,32,5,32,4,132,33,9,32,9,66,0,82,4,64,2,64,32,3,65,128,\n    8,106,33,7,32,4,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,32,7,\n    32,2,58,0,0,32,3,34,2,65,127,106,33,3,11,11,32,6,66,128,194,215,47,128,33,\n    4,32,4,66,10,130,33,5,32,9,32,5,132,33,4,32,4,66,0,82,4,64,2,64,32,3,65,\n    128,8,106,33,7,32,5,167,33,2,32,2,65,48,114,33,2,32,2,65,255,1,113,33,2,\n    32,7,32,2,58,0,0,32,3,65,127,106,33,2,32,2,65,128,8,106,33,3,32,3,65,46,\n    58,0,0,11,11,32,6,66,128,148,235,220,3,128,33,4,32,4,66,60,130,33,4,32,4,\n    66,0,81,4,64,2,64,32,2,65,127,106,33,2,32,2,65,128,8,106,33,3,32,3,65,48,\n    58,0,0,11,5,3,64,32,2,65,127,106,33,2,32,4,32,4,66,10,128,34,5,66,10,126,\n    125,33,9,32,9,167,33,3,32,3,65,48,114,33,3,32,3,65,255,1,113,33,7,32,2,65,\n    128,8,106,33,3,32,3,32,7,58,0,0,32,4,66,10,90,4,64,2,64,32,5,33,4,12,2,11,\n    11,11,11,32,6,66,255,175,157,194,223,1,86,4,64,2,64,32,6,66,128,176,157,\n    194,223,1,128,33,4,32,2,65,127,106,33,3,32,3,65,128,8,106,33,7,32,7,65,\n    237,0,58,0,0,32,4,66,60,130,33,4,32,4,66,0,81,4,64,2,64,32,2,65,126,106,\n    33,2,32,2,65,128,8,106,33,3,32,3,65,48,58,0,0,11,5,2,64,32,3,33,2,3,64,32,\n    2,65,127,106,33,2,32,4,32,4,66,10,128,34,5,66,10,126,125,33,9,32,9,167,33,\n    3,32,3,65,48,114,33,3,32,3,65,255,1,113,33,7,32,2,65,128,8,106,33,3,32,3,\n    32,7,58,0,0,32,4,66,10,90,4,64,2,64,32,5,33,4,12,2,11,11,11,11,11,32,6,66,\n    255,191,226,133,227,232,0,86,4,64,2,64,32,6,66,128,192,226,133,227,232,0,\n    128,33,6,32,2,65,127,106,33,2,32,2,65,128,8,106,33,3,32,3,65,232,0,58,0,0,\n    3,64,32,2,65,127,106,33,2,32,6,32,6,66,10,128,34,4,66,10,126,125,33,5,32,\n    5,167,33,3,32,3,65,48,114,33,3,32,3,65,255,1,113,33,7,32,2,65,128,8,106,\n    33,3,32,3,32,7,58,0,0,32,6,66,10,90,4,64,2,64,32,4,33,6,12,2,11,11,11,11,\n    11,11,11,11,11,11,32,10,69,4,64,32,2,15,11,32,2,65,127,106,33,3,32,3,65,\n    128,8,106,33,2,32,2,65,45,58,0,0,32,3,11\n    //!</wasmdata>\n  ])), {\n    env: { memory: wasmMemory }\n  }).exports as any as WasmInterface :\n  null\n)\n\n\n// fmtduration produces a string representing d in the form \"72h3m0.5s\".\n// Leading zero units are omitted. As a special case, durations less than one\n// second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure\n// that the leading digit is non-zero. The zero duration formats as 0s.\n//\nexport const fmtduration : (d :Duration)=>string = (\n  wasm ? (() => {\n    let p = wasm.bufptr()\n    let z = wasm.bufsize()\n    let u8heap = new Uint8Array(wasmMemory.buffer)\n    return function fmtduration(d :Duration) :string {\n      let [low, high] = f64ToS32pair(d)\n      let w = wasm.fmtduration(low, high)\n      return String.fromCharCode.apply(null, u8heap.subarray(p + w, p + z))\n    }\n  })() : \n  (d :Duration) => {\n    // TODO\n    return `${(d/1e9).toFixed(1)}ms`\n  }\n)\n\n\n// fmtduration2 is like fmtduration, but rounds d to 2 decimals.\n//\nexport function fmtduration2(d :Duration) {\n  return fmtduration(\n    d < Nanosecond  ? 1 :\n    d < Microsecond ? Math.round(d / (Nanosecond/100)) * (Nanosecond/100) :\n    d < Millisecond ? Math.round(d / (Microsecond/100)) * (Microsecond/100) :\n    d < Second      ? Math.round(d / (Millisecond/100)) * (Millisecond/100) :\n    d\n  )\n}\n\n\nTEST(\"fmtduration\", () => {\n\n  const samples :[string,number][] = [\n    [ \"0s\", 0],\n    [ \"1ns\", 1 * Nanosecond],\n    [ \"1.1Âµs\", 1100 * Nanosecond],\n    [ \"2.2ms\", 2200 * Microsecond],\n    [ \"3.3s\", 3300 * Millisecond],\n    [ \"4m5s\", 4*Minute + 5*Second],\n    [ \"4m5.001s\", 4*Minute + 5001*Millisecond],\n    [ \"5h6m7.001s\", 5*Hour + 6*Minute + 7001*Millisecond],\n    [ \"8m0.000000001s\", 8*Minute + 1*Nanosecond],\n    [ \"2562047h47m16.854775807s\",\n      // (Duration)(((u64)(1) << 63) - 1)\n      _SInt64.ONE.shl(63).sub(_SInt64.ONE).toFloat64()\n    ],\n    [ \"-2562047h47m16.854775808s\",\n      // (Duration)((u64)(-1) << 63)\n      _SInt64.ONENEG.shl(63).toFloat64()\n    ],\n  ]\n  for (let [expectedResult, input] of samples) {\n    let actualResult = fmtduration(input)\n    assert(actualResult == expectedResult,\n      `${actualResult} == ${expectedResult}`)\n  }\n})\n","import { Value, Fun } from './ssa'\nimport { ops } from './op'\n\n// copyelim removes all uses of ops.Copy values from f.\n// A subsequent deadcode pass is needed to actually remove the copies.\n//\nexport function copyelim(f :Fun) {\n  // Modify all values so no arg (including args of ops.Copy) is a copy.\n  for (let b of f.blocks) {\n    for (let v of b.values) {\n      copyelimValue(v)\n    }\n  }\n\n  // Update block control values\n  for (let b of f.blocks) {\n    let v = b.control\n    if (v && v.op === ops.Copy) {\n      b.setControl(v.args[0])\n    }\n  }\n\n  // Update named values\n  for (let e of f.namedValues.values()) {\n    let values = e.values\n    for (let i = 0; i < values.length; i++) {\n      let v = values[i]\n      if (v.op === ops.Copy) {\n        values[i] = v.args[0]\n      }\n    }\n  }\n}\n\n// copySource returns the (non-copy) op which is the\n// ultimate source of v.  v must be a copy op.\n//\nexport function copySource(v :Value) :Value {\n  assert(v.op === ops.Copy)\n  assert(v.args.length == 1)\n\n  let w = v.args[0]\n\n  // This loop is just:\n  // for w.Op == OpCopy {\n  //     w = w.Args[0]\n  // }\n  // but we take some extra care to make sure we\n  // don't get stuck in an infinite loop.\n  // Infinite copy loops may happen in unreachable code.\n  // (TODO: or can they? Needs a test.)\n  let slow = w\n  let advance :bool = false\n  while (w.op === ops.Copy) {\n    w = w.args[0]\n    if (w === slow) {\n      w.reset(ops.Unknown)\n      break\n    }\n    if (advance) {\n      slow = slow.args[0]\n    }\n    advance = !advance\n  }\n\n  // The answer is w.  Update all the copies we saw\n  // to point directly to w.  Doing this update makes\n  // sure that we don't end up doing O(n^2) work\n  // for a chain of n copies.\n  while (v != w) {\n    let x = v.args[0]\n    v.setArg(0, w)\n    v = x\n  }\n  return w\n}\n\n\n// copyelimValue ensures that no args of v are copies\n//\nexport function copyelimValue(v :Value) {\n  for (let i = 0; i < v.args.length; i++) {\n    let a = v.args[i]\n    if (a.op === ops.Copy) {\n      v.setArg(i, copySource(a))\n    }\n  }\n}\n","import { debuglog as dlog } from '../util'\nimport { Value, Fun } from './ssa'\nimport { ops } from './op'\nimport { copyelimValue } from './copyelim'\n\n\n// phielim eliminates redundant phi values from f.\n// A phi is redundant if its arguments are all equal. For\n// purposes of counting, ignore the phi itself. Both of\n// these phis are redundant:\n//   v = phi(x,x,x)\n//   v = phi(x,v,x,v)\n// We repeat this process to also catch situations like:\n//   v = phi(x, phi(x, x), phi(x, v))\n//\nexport function phielim(f :Fun) {\n  while (true) {\n    let change = false\n    for (let b of f.blocks) {\n      for (let v of b.values) {\n        copyelimValue(v)\n        change = phielimValue(v) || change\n      }\n    }\n    if (!change) {\n      break\n    }\n  }\n}\n\n\n// phielimValue tries to convert the phi v to a copy.\nexport function phielimValue(v :Value) :bool {\n  if (v.op !== ops.Phi) {\n    return false\n  }\n\n  let args = v.args\n  assert(args, `Phi ${v} without args`)\n\n  // If there are two distinct args of v which\n  // are not v itself, then the phi must remain.\n  // Otherwise, we can replace it with a copy.\n  var w :Value|null = null\n  for (let x of args) {\n    if (x === v) {\n      continue\n    }\n    if (x === w) {\n      continue\n    }\n    if (w) {\n      return false\n    }\n    w = x\n  }\n\n  if (!w) {\n    // v references only itself. It must be in\n    // a dead code loop. Don't bother modifying it.\n    return false\n  }\n\n  v.op = ops.Copy\n  v.setArgs1(w)\n  dlog(`eliminated phi ${v}`) // at v.Pos\n  return true\n}\n","import { Value, Fun } from './ssa'\nimport { ops } from './op'\nimport { BlockRewriter, ValueRewriter } from './config'\nimport { phielimValue } from './phielim'\nimport { copySource } from './copyelim'\n\nexport function rewrite(f :Fun, rb :BlockRewriter, rv :ValueRewriter) {\n  // repeat rewrites until we find no more rewrites\n  while (true) {\n    let change = false\n    for (let b of f.blocks) {\n\n      // eliminate trivial copies in control\n      if (b.control && b.control.op === ops.Copy) {\n        while (b.control.op === ops.Copy) {\n          assert(b.control != null)\n          assert(b.control.args[0] != null)\n          b.setControl(b.control.args[0] as Value)\n        }\n      }\n\n      // dlog(`call BlockRewriter on b${b.id}`)\n      if (rb(b)) {\n        change = true\n      }\n\n      for (let j = 0; j < b.values.length; j++) {\n        let v = b.values[j]\n\n        // Attempt to eliminate/reduce Phi to a Copy, in case a previous\n        // dead-code pass removed one of the values, or short-circuited v.\n        //\n        // This is rarely useful since we effectively eliminate trivial Phis\n        // buring intial IR construction.\n        //\n        change = phielimValue(v) || change\n\n        // Eliminate copy inputs\n        // If any copy input becomes unused, mark it\n        // as invalid and discard its argument. Repeat\n        // recursively on the discarded argument.\n        // This phase helps remove phantom \"dead copy\" uses\n        // of a value so that a x.Uses==1 rule condition\n        // fires reliably.\n        for (let i = 0; i < v.args.length; i++) {\n          let a = v.args[i]\n          if (a.op !== ops.Copy) {\n            continue\n          }\n          let aa = copySource(a)\n          v.setArg(i, aa)\n\n          change = true\n          while (a.uses == 0) {\n            let b = a.args[0]\n            a.reset(ops.Invalid)\n            a = b\n          }\n        }\n\n        // apply rewrite function\n        change = rv(v) || change\n      }\n    }\n\n    if (!change) {\n      break\n    }\n  }\n\n  // remove clobbered values\n  for (let b of f.blocks) {\n    let j = 0\n    for (let i = 0; i < b.values.length; i++) {\n      let v = b.values[i]\n      if (v.op === ops.Invalid) {\n        f.freeValue(v)\n        continue\n      }\n      if (i != j) {\n        b.values[j] = v\n      }\n      j++\n    }\n    b.values.length = j\n  }\n\n}\n\n\n\n// // Note that Nilcheck often vanishes, but when it doesn't, you'd love to start the statement there\n// // so that a debugger-user sees the stop before the panic, and can examine the value.\n// const poorStatementOps = new Set<Op>([\n//   // ops.Addr,\n//   // ops.LocalAddr,\n//   // ops.OffPtr,\n//   // ops.StructSelect,\n//   ops.ConstBool,\n//   ops.ConstI8,\n//   ops.ConstI16,\n//   ops.ConstI32,\n//   ops.ConstI64,\n//   ops.ConstF32,\n//   ops.ConstF64,\n// ])\n\n// // nextGoodStatementIndex returns an index at i or later that is believed\n// // to be a good place to start the statement for b.  This decision is\n// // based on v's Op, the possibility of a better later operation, and\n// // whether the values following i are the same line as v.\n// // If a better statement index isn't found, then i is returned.\n// function nextGoodStatementIndex(v :Value, i :int, b :Block) :int {\n//   // If the value is the last one in the block, too bad, it will have to do\n//   // (this assumes that the value ordering vaguely corresponds to the source\n//   // program execution order, which tends to be true directly after ssa is\n//   // first built.\n//   if (i >= b.valcount - 1) {\n//     return i\n//   }\n//   // Only consider the likely-ephemeral/fragile opcodes expected to vanish\n//   // in a rewrite.\n//   if (!poorStatementOps.has(v.op)) {\n//     return i\n//   }\n//   // Look ahead to see what the line number is on the next thing that\n//   // could be a boundary.\n//   for (let j = i + 1; j < b.valcount; j++) {\n//     if (posIsStmt(b.values[j].pos) == PosNotStmt) { // ignore non-statements\n//       continue\n//     }\n//     if (posLine(b.values[j].pos) == posLince(v.pos)) {\n//       return j\n//     }\n//     return i\n//   }\n//   return i\n// }\n","import { rewrite } from './rewrite'\nimport { Value, Block, Fun } from './ssa'\nimport { Config } from './config'\n\nfunction nullLowerBlock(_ :Block) :bool { return false }\nfunction nullLowerValue(_ :Value) :bool { return false }\n\nexport function lower(f :Fun, c :Config) {\n  if (c.lowerBlock || c.lowerValue) {\n    rewrite(\n      f,\n      c.lowerBlock || nullLowerBlock,\n      c.lowerValue || nullLowerValue\n    )\n  }\n}\n","import { Value, Block, BlockKind, Fun, BranchPrediction } from './ssa'\nimport { phielimValue } from './phielim'\nimport { copyelim } from './copyelim'\nimport { ops } from './op'\n\n// import { debuglog as dlog } from '../util'\nconst dlog = function(..._ :any[]){} // silence dlog\n\n\n// deadcode removes dead code from f\n//\nexport function deadcode(f :Fun) {\n  // deadcode after regalloc is forbidden for now. Regalloc\n  // doesn't quite generate legal SSA which will lead to some\n  // required moves being eliminated.\n  assert(f.regAlloc == null, `deadcode after regalloc for ${f}`)\n\n  // Find reachable blocks.\n  let reachable = reachableBlocks(f)\n  dlog(`reachable blocks:`,\n    reachable\n      .map((reachable, id) => reachable ? id : undefined)\n      .filter(id => id !== undefined)\n      .join('  ')\n  )\n\n  // remove edges from dead to live code\n  for (let b of f.blocks) {\n    if (reachable[b.id]) {\n      continue\n    }\n    let nsuccs = b.succs ? b.succs.length : 0\n    for (let i = 0; i < nsuccs; ) {\n      let e = b.succs[i]\n      if (reachable[e.id]) {\n        removeEdge(b, i)\n      } else {\n        i++\n      }\n    }\n  }\n\n  // remove dead edges from live code\n  for (let b of f.blocks) {\n    if (!reachable[b.id]) {\n      continue\n    }\n    if (b.kind != BlockKind.First) {\n      continue\n    }\n    removeEdge(b, 1)\n    b.kind = BlockKind.Plain\n    b.likely = BranchPrediction.Unknown\n  }\n\n  // Splice out any copies introduced during dead block removal\n  copyelim(f)\n\n  // Find live values.\n  let live = liveValues(f, reachable)\n  dlog(`live values:`, Object.keys(live).map(k => 'v' + k).join(', '))\n\n\n  // Remove dead & duplicate entries from namedValues map.\n  let s = new Set<Value>()\n  for (let [key, e] of f.namedValues) {\n    // let loc = e.local\n    let j = 0\n    s.clear()\n    for (let v of e.values) {\n      if (live[v.id] && !s.has(v)) {\n        e.values[j] = v\n        j++\n        s.add(v)\n      }\n    }\n    if (j == 0) {\n      f.namedValues.delete(key)\n    } else {\n      for (let k = e.values.length - 1; k >= j; k--) {\n        e.values[k] = undefined as any as Value\n      }\n      e.values.length = j\n    }\n  }\n\n  dlog(`live names':`, Array.from(f.namedValues.keys()).join(', '))\n\n  // Unlink values and conserve statement boundaries\n  for (let b of f.blocks) {\n    if (!reachable[b.id]) {\n      b.setControl(null)\n    }\n    for (let v of b.values) {\n      if (!live[v.id]) {\n        v.resetArgs()\n      }\n    }\n  }\n\n  // Remove dead values from blocks' value list\n  for (let b of f.blocks) {\n    let i = 0\n    for (let v of b.values) {\n      if (live[v.id]) {\n        b.values[i] = v\n        i++\n      } else {\n        f.freeValue(v)\n      }\n    }\n    b.values.length = i\n  }\n\n  // Remove unreachable blocks\n  let i = 0\n  for (let b of f.blocks) {\n    if (reachable[b.id]) {\n      f.blocks[i] = b\n      i++\n    } else {\n      if (b.values.length > 0) {\n        panic(`live values in unreachable block ${b}: ${b.values.join(', ')}`)\n      }\n      f.freeBlock(b)\n    }\n  }\n\n  f.blocks.length = i\n\n} // deadcode\n\n\n\n// ReachableBlocks returns the reachable blocks in f\n//\nfunction reachableBlocks(f :Fun) :bool[] {\n  let reachable = new Array<bool>(f.numBlocks())\n  reachable[f.entry.id] = true\n\n  let p :Block[] = [] // stack-like worklist\n  p.push(f.entry)\n\n  while (p.length > 0) {\n    // Pop a reachable block\n    let b = p.pop() as Block\n\n    // Mark successors as reachable\n    let succs = b.succs\n    if (succs) {\n      if (b.kind == BlockKind.First) {\n        // Drop 2nd block from being considered reachable.\n        // BlockKind.First indicates that only the first path is\n        // ever taken, never the second.\n        succs = succs.slice(0, 1)\n      }\n      for (let c of succs) {\n        assert(c.id < reachable.length,\n          `block ${c} >= f.numBlocks()=${reachable.length}`)\n        if (!reachable[c.id]) {\n          reachable[c.id] = true\n          p.push(c)\n        }\n      }\n    }\n  }\n  return reachable\n}\n\n\n// liveValues returns the live values in f and a list of values that are\n// eligible to be statements in reversed data flow order.\n// reachable is a map from block ID to whether the block is reachable.\n//\nfunction liveValues(f :Fun, reachable :bool[]) :bool[] {\n  let live = new Array<bool>(f.numBlocks())\n\n  // After regalloc, consider all values to be live.\n  // See the comment at the top of regalloc.go and in deadcode for details.\n  if (f.regAlloc) {\n    live.fill(true)\n    // for (let i = 0; i < live.length; i++) {\n    //   live[i] = true\n    // }\n    return live\n  }\n\n  // Find all live values\n  let q :Value[] = [] // stack-like worklist of unscanned values\n\n  // Starting set: all control values of reachable blocks are live.\n  // Calls are live (because callee can observe the memory state).\n  for (let b of f.blocks) {\n    if (!reachable[b.id]) {\n      continue\n    }\n    let v = b.control\n    if (v && !live[v.id]) {\n      live[v.id] = true\n      q.push(v)\n    }\n    for (let v of b.values) {\n      if ((v.op.call || v.op.hasSideEffects) && !live[v.id]) {\n        live[v.id] = true\n        q.push(v)\n      }\n      if (v.op.nilCheck && !live[v.id]) {\n        // nil checks must be kept\n        live[v.id] = true\n        q.push(v)\n      }\n    }\n  }\n\n  // Compute transitive closure of live values\n  while (q.length > 0) {\n    // pop a reachable value\n    let v = q.pop() as Value\n    for (let i = 0; i < v.args.length; i++) {\n      let x = v.args[i]\n      if (v.op === ops.Phi && !reachable[v.b.preds[i].id]) {\n        continue\n      }\n      if (!live[x.id]) {\n        live[x.id] = true\n        q.push(x)\n      }\n    }\n  }\n\n  return live\n}\n\n\n// function constControl(ctrl :Value) :Value {\n//   let args :Value[]|undefined\n//   for (let i = 0; i < ctrl.args.length; i++) {\n//     let arg = ctrl.args[i]\n//     if (arg.op === ops.Phi && arg.b === ifb) {\n//       if (!args) {\n//         args = ctrl.args.slice() // copy\n//       }\n//       assert(ifb.preds[0] === entryb, `entryb not at expected index`)\n//       args[i] = arg.args[0]\n//     }\n//   }\n//   // args will be set only if we found at least one Phi in control.args\n//   if (args) {\n//     // attempt constant evaluation of control value\n//     let constctrl :Value|null = null\n//     if (args.length == 2) {\n//       constctrl = optcf_op2(ifb, control.op, args[0], args[1])\n//     } else if (args.length == 1) {\n//       constctrl = optcf_op1(ifb, control.op, args[0])\n//     }\n//     if (constctrl && constctrl.auxIsZero()) {\n//       // while loop never taken -- shortcut entryb -> nextb\n//       removeEdge(entryb, 0)\n//       entryb.succs = [nextb]\n//       removeEdge(ifb, 0)\n//       nextb.preds = [entryb]\n//       // s.f.removeBlock(ifb)\n//       // s.f.removeBlock(thenb)\n//     }\n//   }\n// }\n\n\n// removeEdge removes the i'th outgoing edge from b (and the corresponding\n// incoming edge from b.succs[i])\n//\nexport function removeEdge(b :Block, i :int) {\n  // e := b.Succs[i]\n  // c := e.b\n  // j := e.i\n  //\n  // // Adjust b.Succs\n  // b.removeSucc(i)\n  //\n  // // Adjust c.Preds\n  // c.removePred(j)\n\n  // index of reverse edge.  Invariant:\n  //   e := x.Succs[idx]\n  //   e.b.Preds[e.i] = Edge{x,idx}\n  // and similarly for predecessors.\n  //\n  // index of reverse edge.  Invariant:\n  //   e := x.Preds[idx]\n  //   e.b.Succs[e.i] = Edge{x,idx}\n  //\n\n  let c = b.succs[i]\n\n  // Adjust b.succs (see details of Adjust c.preds below)\n  b.removeNthSucc(i)\n\n  // Adjust c.preds.\n  // This removes b from c.preds and reduces c.preds.length by 1\n  // The returned value is the index of b as it was in c.preds before removal.\n  let j = c.removePred(b)\n\n  // Remove phi args from c's phis.\n  let n = c.preds.length\n  for (let v of c.values) {\n    if (v.op !== ops.Phi) {\n      continue\n    }\n    // remove the edge from Phi's args, i.e. (Phi x y) -> (Phi x)\n    v.args[j].uses--\n    v.args[j] = v.args[n]\n    v.args.length = n\n\n    // (Phi x) -> (Copy x)\n    phielimValue(v)\n\n    // [from go/src/cmd/compile/internal/ssa/deadcode.go]\n    //\n    // Note: this is trickier than it looks. Replacing\n    // a Phi with a Copy can in general cause problems because\n    // Phi and Copy don't have exactly the same semantics.\n    // Phi arguments always come from a predecessor block,\n    // whereas copies don't. This matters in loops like:\n    // 1: x = (Phi y)\n    //    y = (Add x 1)\n    //    goto 1\n    // If we replace Phi->Copy, we get\n    // 1: x = (Copy y)\n    //    y = (Add x 1)\n    //    goto 1\n    // (Phi y) refers to the *previous* value of y, whereas\n    // (Copy y) refers to the *current* value of y.\n    // The modified code has a cycle and the scheduler\n    // will barf on it.\n    //\n    // Fortunately, this situation can only happen for dead\n    // code loops. We know the code we're working with is\n    // not dead, so we're ok.\n    // Proof: If we have a potential bad cycle, we have a\n    // situation like this:\n    //   x = (Phi z)\n    //   y = (op1 x ...)\n    //   z = (op2 y ...)\n    // Where opX are not Phi ops. But such a situation\n    // implies a cycle in the dominator graph. In the\n    // example, x.Block dominates y.Block, y.Block dominates\n    // z.Block, and z.Block dominates x.Block (treating\n    // \"dominates\" as reflexive).  Cycles in the dominator\n    // graph can only happen in an unreachable cycle.\n  }\n}\n\n","// import { debuglog as dlog } from '../util'\nimport { Fun, BlockKind } from './ssa'\nimport { ops } from './op'\nimport { t_bool } from '../types'\n\n// Shortcircuit finds situations where branch directions\n// are always correlated and rewrites the CFG to take\n// advantage of that fact.\n// This optimization is useful for compiling && and || expressions.\n//\nexport function shortcircuit(f :Fun) {\n  // Step 1: Replace a phi arg with a constant if that arg\n  // is the control value of a preceding If block.\n  // b1:\n  //    If a goto b2 else b3\n  // b2: <- b1 ...\n  //    x = phi(a, ...)\n  //\n  // We can replace the \"a\" in the phi with the constant true.\n  // let ct :Value|null = null   // cont true\n  // let cf :Value|null = null;  // cont false\n  for (let b of f.blocks) {\n    // visit all Phis in the block\n    for (let v of b.values) {\n      if (v.op !== ops.Phi) {\n        continue\n      }\n      if (v.type !== t_bool) {\n        continue\n      }\n      for (let i = 0; i < v.args.length; i++) {\n        let p = b.preds[i]\n        // let e = b.preds[i]\n        // let p = e.b\n        if (p.kind != BlockKind.If) {\n          continue\n        }\n        let a = v.args[i]\n        if (p.control !== a) {\n          continue\n        }\n        // dlog(`${p}.control == ${a}`)\n        //\n        // TODO FIXME e.i is reverse edge index of succ -> b\n        //\n        // if e.i == 0 {\n        //   if ct == nil {\n        //     ct = f.ConstBool(f.Config.Types.Bool, true)\n        //   }\n        //   v.SetArg(i, ct)\n        // } else {\n        //   if cf == nil {\n        //     cf = f.ConstBool(f.Config.Types.Bool, false)\n        //   }\n        //   v.SetArg(i, cf)\n        // }\n      }\n    }\n  }\n\n  // // Step 2: Compute which values are live across blocks.\n  // live := make([]bool, f.NumValues())\n  // for _, b := range f.Blocks {\n  //   for _, v := range b.Values {\n  //     for _, a := range v.Args {\n  //       if a.Block != v.Block {\n  //         live[a.ID] = true\n  //       }\n  //     }\n  //   }\n  //   if b.Control != nil && b.Control.Block != b {\n  //     live[b.Control.ID] = true\n  //   }\n  // }\n\n  // // Step 3: Redirect control flow around known branches.\n  // // p:\n  // //   ... goto b ...\n  // // b: <- p ...\n  // //   v = phi(true, ...)\n  // //   if v goto t else u\n  // // We can redirect p to go directly to t instead of b.\n  // // (If v is not live after b).\n  // for _, b := range f.Blocks {\n  //   if b.Kind != BlockIf {\n  //     continue\n  //   }\n  //   if len(b.Values) != 1 {\n  //     continue\n  //   }\n  //   v := b.Values[0]\n  //   if v.Op != OpPhi {\n  //     continue\n  //   }\n  //   if b.Control != v {\n  //     continue\n  //   }\n  //   if live[v.ID] {\n  //     continue\n  //   }\n  //   for i := 0; i < len(v.Args); i++ {\n  //     a := v.Args[i]\n  //     if a.Op != OpConstBool {\n  //       continue\n  //     }\n\n  //     // The predecessor we come in from.\n  //     e1 := b.Preds[i]\n  //     p := e1.b\n  //     pi := e1.i\n\n  //     // The successor we always go to when coming in\n  //     // from that predecessor.\n  //     e2 := b.Succs[1-a.AuxInt]\n  //     t := e2.b\n  //     ti := e2.i\n\n  //     // Remove b's incoming edge from p.\n  //     b.removePred(i)\n  //     n := len(b.Preds)\n  //     v.Args[i].Uses--\n  //     v.Args[i] = v.Args[n]\n  //     v.Args[n] = nil\n  //     v.Args = v.Args[:n]\n\n  //     // Redirect p's outgoing edge to t.\n  //     p.Succs[pi] = Edge{t, len(t.Preds)}\n\n  //     // Fix up t to have one more predecessor.\n  //     t.Preds = append(t.Preds, Edge{p, pi})\n  //     for _, w := range t.Values {\n  //       if w.Op != OpPhi {\n  //         continue\n  //       }\n  //       w.AddArg(w.Args[ti])\n  //     }\n\n  //     if len(b.Preds) == 1 {\n  //       v.Op = OpCopy\n  //       // No longer a phi, stop optimizing here.\n  //       break\n  //     }\n  //     i--\n  //   }\n  // }\n}\n","import { UInt64 } from '../int64'\nimport { ID } from './ssa'\nimport { Reg, RegSet, emptyRegSet, noReg, fmtRegSet } from './reg'\n\ninterface DesiredStateEntry {\n  // (pre-regalloc) value\n  id :ID\n\n  // Registers it would like to be in, in priority order.\n  // Unused slots are filled with noReg.\n  regs :[Reg,Reg,Reg,Reg]\n}\n\n// DesiredState represents desired register assignments.\n//\nexport class DesiredState {\n  // Desired assignments will be small, so we just use a list\n  // of valueID+registers entries.\n  entries :DesiredStateEntry[] = []\n\n  // Registers that other values want to be in.  This value will\n  // contain at least the union of the regs fields of entries, but\n  // may contain additional entries for values that were once in\n  // this data structure but are no longer.\n  avoid :RegSet = emptyRegSet\n\n\n  constructor(copyOther? :DesiredState) {\n    if (copyOther) {\n      this.copy(copyOther)\n    }\n  }\n\n\n  toString() {\n    let s = '{'\n    s += this.entries.map(e =>\n      `v${e.id}[` + e.regs.filter(r =>\n        r != noReg\n      ).map(r => `r${r}`).join(' ') + ']'\n    ).join(', ')\n    s += `}`\n    if (!this.avoid.isZero()) {\n      s += `avoid=${fmtRegSet(this.avoid)}`\n    }\n    return s\n  }\n\n\n  clear() {\n    this.entries.length = 0\n    // this.entries = []\n    // this.entries.splice(0, this.entries.length)\n    this.avoid = emptyRegSet\n  }\n\n  // get returns a list of desired registers for value vid\n  //\n  get(vid :ID) :[Reg,Reg,Reg,Reg] {\n    for (let e of this.entries) {\n      if (e.id == vid) {\n        return e.regs\n      }\n    }\n    return [noReg, noReg, noReg, noReg]\n  }\n\n  // add records that we'd like value vid to be in register r\n  //\n  add(vid :ID, r :Reg) {\n    const d = this\n    // d.avoid |= RegSet(1) << r\n    d.avoid = d.avoid.or(UInt64.ONE.shl(r))\n    for (let e of d.entries) {\n      if (e.id != vid) {\n        continue\n      }\n      if (e.regs[0] == r) {\n        // Already known and highest priority\n        return\n      }\n      for (let j = 1; j < e.regs.length; j++) {\n        if (e.regs[j] == r) {\n          // Move from lower priority to top priority\n          // copy(e.regs[1:], e.regs[:j]) // copy: dst -> src\n          e.regs.copyWithin(1, 0, j)\n          e.regs[0] = r\n          return\n        }\n      }\n      // copy(e.regs[1:], e.regs[:])\n      e.regs.copyWithin(1, 0)\n      e.regs[0] = r\n      return\n    }\n    // d.entries = append(d.entries, desiredStateEntry{vid, [r, noReg, noReg, noReg]})\n    d.entries.push({ id: vid, regs: [r, noReg, noReg, noReg] })\n  }\n\n  addList(vid :ID, regs :[Reg,Reg,Reg,Reg]) {\n    // regs is in priority order, so iterate in reverse order.\n    for (let i = regs.length - 1; i >= 0; i--) {\n      let r = regs[i]\n      if (r != noReg) {\n        this.add(vid, r)\n      }\n    }\n  }\n\n  // clobber erases any desired registers in the set m.\n  clobber(m :RegSet) {\n    let d = this\n    for (let i = 0; i < d.entries.length; ) {\n      let e = d.entries[i]\n      let j = 0\n      for (let r of e.regs) {\n        //                (m >> r) & 1 == 0\n        if (r != noReg && m.shr(r).and(UInt64.ONE).isZero()) {\n          e.regs[j] = r\n          j++\n        }\n      }\n      if (j == 0) {\n        // No more desired registers for this value.\n        d.entries[i] = d.entries[d.entries.length-1]\n        // d.entries = d.entries[:d.entries.length-1]\n        d.entries.splice(d.entries.length-1, 1)\n        continue\n      }\n      for (; j < e.regs.length; j++) {\n        e.regs[j] = noReg\n      }\n      i++\n    }\n    // d.avoid &^= m\n    // d.avoid = d.avoid & ~m\n    d.avoid = d.avoid.and(m.not())\n  }\n\n  // copy copies a desired state from another desiredState x\n  copy(x :DesiredState) {\n    this.entries.splice(0, this.entries.length, ...x.entries)\n    this.avoid = x.avoid\n  }\n\n  // remove removes the desired registers for vid and returns them.\n  remove(vid :ID) :[Reg,Reg,Reg,Reg] {\n    for (let e of this.entries) {\n      if (e.id == vid) {\n        let regs = e.regs\n        let z = this.entries.length - 1\n        e = this.entries[z]\n        // this.entries = this.entries.slice(0, this.entries.length-1)\n        this.entries.splice(z, 1)\n        return regs\n      }\n    }\n    return [noReg, noReg, noReg, noReg]\n  }\n\n  // merge merges another desired state x into this\n  //\n  merge(x :DesiredState) {\n    this.avoid = this.avoid.or(x.avoid)\n    // There should only be a few desired registers, so linear insert is ok.\n    for (let e of x.entries) {\n      this.addList(e.id, e.regs)\n    }\n  }\n\n}\n","// IntGraph represents an undirected graph structure for integers.\n//\n// It's implementated with adjacency lists and has shown to provide\n// great performance in comparison with adjacency matrix implementations\n// and bitset implementations.\n//\n// This is primarily used to graph sparse values of a moderate magnitude,\n// around 15-300 values in total (common number of IR values in a function.)\n//\nexport class IntGraph {\n  nodes :Set<int>[]\n  readonly length :int\n\n  constructor() {\n    this.nodes = []\n    this.length = 0\n  }\n\n  copy() :IntGraph {\n    let g = new IntGraph()\n    ;(g as any).length = this.length\n    g.nodes = []\n    for (let id = 0; id < this.nodes.length; id++) {\n      let s = this.nodes[id]\n      if (s !== undefined) {\n        g.nodes[id] = new Set<int>(s)\n      }\n    }\n    return g\n  }\n\n  has(id :int) {\n    return !!this.nodes[id]\n  }\n\n  add(id :int) {\n    if (!this.nodes[id]) {\n      this.nodes[id] = new Set<int>()\n      ;(this as any).length++\n    }\n  }\n\n  remove(id :int) {\n    let s = this.nodes[id]\n    if (s) {\n      for (let id2 of s) {\n        this.nodes[id2].delete(id)\n      }\n      ;(this.nodes as any)[id] = undefined\n      ;(this as any).length--\n    }\n  }\n\n  connect(id1 :int, id2 :int) {\n    let s = this.nodes[id1]\n    if (!s) {\n      this.nodes[id1] = new Set<int>([id2])\n      ;(this as any).length++\n    } else {\n      s.add(id2)\n    }\n    s = this.nodes[id2]\n    if (!s) {\n      this.nodes[id2] = new Set<int>([id1])\n      ;(this as any).length++\n    } else {\n      s.add(id1)\n    }\n  }\n\n  connected(id1 :int, id2 :int) {\n    let s = this.nodes[id1]\n    return s && s.has(id2)\n  }\n\n  disconnect(id1 :int, id2 :int) {\n    let s = this.nodes[id1]\n    if (s) {\n      s.delete(id2)\n    }\n    s = this.nodes[id2]\n    if (s) {\n      s.delete(id1)\n    }\n  }\n\n  edges(id :int) :Set<int>|undefined {\n    return this.nodes[id]\n  }\n\n  degree(id :int) :int {\n    return this.nodes[id].size\n  }\n\n  any() :int|undefined {\n    for (let id = 0; id < this.nodes.length; id++) {\n      if (this.nodes[id] !== undefined) {\n        return id\n      }\n    }\n    return undefined\n  }\n\n  keys() :int[] {\n    let keys :int[] = []\n    for (let id = 0; id < this.nodes.length; id++) {\n      if (this.nodes[id] !== undefined) {\n        keys.push(id)\n      }\n    }\n    return keys\n  }\n\n  // fmt returns a dot-compatible string representation of the graph\n  //\n  fmt() :string {\n    let pairs = new Set<string>()\n    for (let k in this.nodes) {\n      let id = k as any as int\n      let edges = this.edges(id)\n      if (edges) {\n        if (edges.size > 0) {\n          for (let id2 of edges) {\n            if (id < id2) {\n              pairs.add(`${id} -- ${id2}`)\n            } else {\n              pairs.add(`${id2} -- ${id}`)\n            }\n          }\n        } else {\n          pairs.add(`${id}`)\n        }\n      }\n    }\n    return Array.from(pairs).join('\\n')\n  }\n\n}\n","import { UInt64 } from '../int64'\nimport { Pos } from '../pos'\nimport { Mem, t_u32, intTypes } from '../types'\nimport { ID, Fun, Block, Value, BranchPrediction, Location } from './ssa'\nimport { RegInfo, Op, ops } from './op'\nimport { Register, Reg, RegSet, fmtRegSet, emptyRegSet } from './reg'\nimport { Config } from './config'\nimport { DesiredState } from './reg_desiredstate'\nimport { IntGraph } from '../intgraph'\n\n// import { debuglog as dlog } from '../util'\nconst dlog = function(..._ :any[]){} // silence dlog\n\nconst allocatorCache = new Map<Config,RegAllocator>()\nlet allocator :RegAllocator|null = null\n\n// regalloc allocates registers for function f\n//\nexport function regalloc(f :Fun, config :Config) {\n  if (!allocator || allocator.config !== config) {\n    allocator = allocatorCache.get(config) || null\n    if (!allocator) {\n      allocator = new RegAllocator(config)\n      allocatorCache.set(config, allocator)\n    }\n  }\n  allocator.regallocFun(f)\n}\n\n\n// distance is a measure of how far into the future values are used.\n// distance is measured in units of instructions.\nconst\n  likelyDistance   = 1\n, normalDistance   = 10\n, unlikelyDistance = 100\n\n\n\ninterface LiveInfo {\n  id   :ID   // ID of value\n  dist :int  // # of instructions before next use\n  pos  :Pos  // source position of next use\n}\n\n\ninterface ValMapEntry {\n  val :int\n  pos :Pos\n}\n\n\nconst maxregs = 64  // maximum number of registers we can manage\nconst noReg :Reg = 255 >>> 0  // symbolizes \"none\"\n\n\n// countRegs returns the number of set bits in the register mask.\n//\nfunction countRegs(m :RegSet) :int {\n  return m.popcnt()\n  // let n = 0\n  // while (m != 0) {\n  //   n += m & 1\n  //   m >>= 1\n  // }\n  // return n\n}\n\n\n// pickReg picks an arbitrary register from the register mask.\n//\nfunction pickReg(m :RegSet) :Reg {\n  // pick the lowest one\n  if (m.isZero()) {\n    panic(\"can't pick a register from an empty set\")\n  }\n  for (let i :Reg = 0; ; i++) {\n    if (!m.and(UInt64.ONE).isZero()) {\n      return i\n    }\n    m = m.shr(1) // m = m >> 1\n  }\n}\n\n// interface Use {\n//   dist :int      // distance from start of the block to a use of a value\n//   next :Use|null // linked list of uses of a value in nondecreasing dist order\n//   // pos  :Pos   // source position of the use\n// }\n\n// ValState records the register allocation state for a (pre-regalloc) value.\nclass ValState {\n  v          :Value\n  regs       = emptyRegSet as RegSet\n    // the set of registers holding a Value (usually just one)\n  // uses       = null as Use|null   // list of uses in this block\n  // spill      = null as Value|null // spilled copy of the Value (if any)\n  // restoreMin = 0 as int  // minimum of all restores' blocks' sdom.entry\n  // restoreMax = 0 as int  // maximum of all restores' blocks' sdom.exit\n  needReg    = false as bool // cached value of\n    // !v.Type.IsMemory() && !v.Type.IsVoid() && !.v.Type.IsFlags()\n  rematerializeable = false as bool  // cached value of v.rematerializeable()\n\n  mindist :int = 0  // distance between definition and first use\n  maxdist :int = 0  // distance between definition and last use\n\n  constructor(v :Value) {\n    this.v = v\n  }\n}\n\n\n// interface RegState {\n//   v :Value|null // Original (preregalloc) Value stored in this register.\n//   c :Value|null // A Value equal to v which is currently in a register.\n//                 // Might be v or a copy of it.\n//   // If a register is unused, v==c==nil\n// }\n\n\nexport class RegAllocator {\n  readonly config :Config\n  readonly addrsize :Mem\n  readonly addrtype = t_u32\n\n  // labels :Map<Value,int>  // maps values to addresses\n\n  readonly registers   :Register[]  // registers of the target architecture\n  readonly numregs     :int         // always == registers.length\n  readonly allocatable :RegSet      // registers we are allowed to allocate\n\n  f          :Fun  // function being processed\n  visitOrder :Block[] = []\n\n  SPReg :Reg  // the SP register\n  SBReg :Reg  // the SB register\n  GReg  :Reg  // the g register (current coroutine)\n\n  // current state of each (preregalloc) Value\n  values :ValState[] = []\n\n  sp :int // ID of SP register Value\n  sb :int // ID of SB register Value\n\n  // current state of each register\n  // regs :RegState[]\n\n  nospill :RegSet  // registers that contain values which can't be kicked out\n  used    :RegSet  // registers currently in use\n  tmpused :RegSet  // registers used in the current instruction\n\n  // live and desired holds information about block's live values at the end\n  // of the block, and those value's desired registers (if any.)\n  // These are created by computeLive()\n  live    :LiveInfo[][] = []  // indexed by block\n  desired :DesiredState[] = []\n\n\n  constructor(config :Config) {\n    const a = this\n\n    this.config = config\n    this.addrtype = intTypes(config.addrSize)[1]\n    this.addrsize = config.addrSize\n\n    // TODO provide registers as an argument\n    this.registers = config.registers\n    this.numregs = config.registers.length\n    if (a.numregs == 0 || a.numregs > maxregs) {\n      panic(`invalid number of registers: ${a.numregs}`)\n    }\n\n    // Locate SP, SB, and g registers.\n    this.SPReg = noReg\n    this.SBReg = noReg\n    this.GReg = noReg\n    for (let r :Reg = 0; r < a.numregs; r++) {\n      switch (a.registers[r].name) {\n        case \"SP\": a.SPReg = r; break\n        case \"SB\": a.SBReg = r; break\n        case \"g\":  if (config.hasGReg) { a.GReg = r }; break\n      }\n    }\n    if (a.SPReg == noReg) { panic(\"no SP register found\") }\n    if (a.SBReg == noReg) { panic(\"no SB register found\") }\n    if (config.hasGReg && a.GReg == noReg) { panic(\"no g register found\") }\n\n    // Figure out which registers we're allowed to use.\n    this.allocatable = config.gpRegMask.or(config.fpRegMask.or(config.specialRegMask))\n\n    // .allocatable &^= 1 << s.SPReg\n    // .allocatable = .allocatable & ~(1 << s.SPReg)\n    this.allocatable = this.allocatable.and(UInt64.ONE.shl(a.SPReg).not())\n    this.allocatable = this.allocatable.and(UInt64.ONE.shl(a.SBReg).not())\n    this.allocatable = this.allocatable.and(UInt64.ONE.shl(a.GReg).not())\n    \n    // dlog(`allocatable:`, fmtRegSet(a.allocatable))\n  }\n\n  regallocFun(f :Fun) {\n    const a = this\n    a.f = f\n\n    assert(f.regAlloc == null, `registers already allocated for ${f}`)\n    f.regAlloc = new Array<Location>(f.numValues())  // TODO: fill this\n\n    // Add SP (stack pointer) value to the top of the entry block.\n    // TODO: track the need for this when generating the initial IR.\n    // Some functions do not need SP.\n    // Also consider always adding this during IR construction.\n    const SP = f.newValue(f.entry, ops.SP, a.addrtype, null)\n    SP.reg = a.registers[this.SPReg]\n    f.entry.pushValueFront(SP)\n\n    // Linear scan register allocation can be influenced by the order in which\n    // blocks appear.\n    // Decouple the register allocation order from the generated block order.\n    // This also creates an opportunity for experiments to find a better order.\n    // a.visitOrder = layoutRegallocOrder(f)\n    // if (a.config.optimize) {\n    //   // update function block order with new layout\n    //   f.blocks = a.visitOrder\n    // }\n    a.visitOrder = f.blocks\n\n    // Compute block order. This array allows us to distinguish forward edges\n    // from backward edges and compute how far they go.\n    // let blockOrder = new Array<int>(f.numBlocks())\n    // for (let i = 0; i < a.visitOrder.length; i++) {\n    //   blockOrder[a.visitOrder[i].id] = i >>> 0\n    // }\n\n    // s.regs = make([]regState, s.numRegs)\n    a.values = new Array<ValState>(f.numValues())\n    // s.orig = make([]*Value, f.NumValues())\n    // s.copies = make(map[*Value]bool)\n    for (let b of a.visitOrder) {\n      for (let v of b.values) {\n        let t = v.type\n        let val = new ValState(v)\n        a.values[v.id] = val\n        // if (!t.isMemory() && !t.IsVoid() && !t.IsFlags() && !t.IsTuple())\n        if (t.mem > 0 && !t.isTuple() && v !== SP) {\n          val.needReg = true\n          val.rematerializeable = v.rematerializeable()\n          // a.orig[v.id] = v\n        }\n      }\n    }\n    // dlog('a.values:', a.values)\n    \n\n    // we start by computing live ranges, mapping each value definition\n    // to a set of values alive at the point of the definition.\n    a.computeLive()\n    dlog(\"\\nlive values at end of each block\\n\" + a.fmtLive())\n\n    // debug valstate\n    dlog(`\\nvalstate:`)\n    for (let vs of a.values) {\n      if (vs) {\n        dlog(`  v${vs.v.id} - ` + [\n          ['needReg', vs.needReg],\n          ['mindist', vs.mindist],\n          ['maxdist', vs.maxdist],\n        ].map(v => v.join(': ')).join(', '))\n      }\n    }\n\n    // We then build an interference graph of values that interfere.\n    // Two values interfere if one of them is live at a definition point of\n    // the other.\n    let ig = a.buildInterferenceGraph()\n\n    // debug log state of interference graph\n    if (DEBUG) {\n      let ifstr = ig.fmt()\n      let vizurl = (\n        'https://rsms.me/co/doc/chaitin/?'+\n        'input=ifg&enable-briggs=1&immediate=1&ifg=' +\n        encodeURIComponent(\n          ifstr.trim().split(/[\\r\\n]+/).map(s => s.trim()).join('\\n')\n        ).replace(/\\%20/g, '+')\n      )\n      dlog(`\\ninterference:\\n` + ifstr + '\\nView at ' + vizurl)\n    }\n\n    a.pickValues(ig)\n  }\n\n\n  pickValues(ig :IntGraph) {\n    const a = this\n\n    // {gp,fp}k is the maximum number of registers we have available for\n    // general-purpose and floating-point registers.\n    let gpk = 3 //countRegs(this.config.gpRegMask)\n    // let fpk = 3 //countRegs(this.config.fpRegMask)\n\n    // Stack of values\n    let valstack :{id:ID, edges:Set<ID>}[] = []\n\n    // Values that spill\n    let spills = new Set<ID>()\n\n    // Move values to stack, from interference graph\n    let x = 20\n    // let ig2 = ig.copy()\n    let sortedIds = ig.keys()\n\n    function sortIds() {\n      sortedIds.sort((a, b) => ig.degree(a) - ig.degree(b))\n      // dlog('sortedIds:', sortedIds.map(id =>\n      //   `\\n  v${id} : ${ig.degree(id)}` ).join(''))\n    }\n\n    // initial sorting of IDs\n    sortIds()\n\n    dlog('\\n---------------------------------------------------------')\n\n    pick_loop: while (true && x--) {\n      // console.log('nodes:', ig.keys().map(id =>\n      //   `\\n  v${id} : ${ig.degree(id)}` ).join(''))\n\n      // try picking a node with degree < R\n      for (let i = 0; i < sortedIds.length; i++) {\n        let id = sortedIds[i]\n        let edges = ig.edges(id) as Set<ID>\n        assert(edges, `missing edge data for v${id}`)\n        if (edges.size < gpk) {\n          dlog(`pick v${id} with degree ${edges.size} < R`)\n          sortedIds.splice(i, 1)\n          ig.remove(id)\n          valstack.push({ id, edges })\n          continue pick_loop\n        }\n      }\n\n      if (ig.length == 0) {\n        dlog(`done`)\n        break\n      }\n\n      // we didn't find a node with degree < R.\n      // Optimistically pick next and continue\n      let id = sortedIds.shift() as ID\n      let edges = ig.edges(id) as Set<ID>\n      dlog(`pick v${id} with degree ${edges.size} >= R (maybe spill)`)\n      ig.remove(id as ID)\n      valstack.push({ id, edges })\n      spills.add(id)\n    }\n\n    dlog(`spills:`,\n      spills.size == 0 ? '(none)' :\n      Array.from(spills).map(id => `v${id}`).join(\" \")\n    )\n\n    dlog('valstack:', valstack.map(v =>\n      `v${v.id}`\n    ).join(' '))\n\n\n    // rebuild ig by moving back values from the stack\n    let reg = -1\n    while (true) {\n      let v = valstack.pop()\n      if (!v) {\n        return true\n      }\n\n      // pick next register (round-robin)\n      reg = (reg + 1) % gpk\n\n      // now, often round-robin is not enough. Resolve\n      let i = gpk\n      let conflict = true\n      reg_conflict_loop: while (i--) {\n        for (let id2 of v.edges) {\n          let reg2 = a.values[id2].v.reg\n          if (reg2 && reg2.num == reg) {\n            // dlog(`conflict -- interfering v${id2} already assigned r${reg}`)\n            reg = (reg + 1) % gpk\n            continue reg_conflict_loop\n          }\n        }\n        // ok -- picked reg does not conflict with interfering values\n        conflict = false\n        break\n      }\n\n      if (conflict) {\n        dlog(`unable to find register for v${v.id}`)\n        // let val = a.values[v.id]\n        // dlog(``, val.)\n        reg = noReg\n      }\n      // if (spills.has(v.id)) {\n      //   dlog(`** v${v.id} may spill`)\n      // }\n\n      dlog(`pop v${v.id} {${reg}} edges:`, v.edges)\n\n      // add back into graph\n      ig.add(v.id)\n      for (let id2 of v.edges) {\n        ig.connect(v.id, id2)\n      }\n\n      // assign register to value\n      // TODO: pick actual registers using\n      // this.registers\n      // this.allocatable\n      let val = a.values[v.id]\n      assert(val.needReg, `unexpected v${v.id}.needReg=false`)\n      // Note: computeLive() consults a.values and only includes values\n      // which needReg.\n      val.v.reg = a.registers[reg]\n\n      // dlog(`ig.fmt():\\n` + ig.fmt())\n    }\n\n  }\n\n\n  buildInterferenceGraph() :IntGraph {\n    const a = this\n    const f = a.f\n\n    // Chaitin's algorithm for building the interference graph is fairly\n    // straight forward:\n    //\n    //   for every block B in F:\n    //     CurrLive = LiveOut(B)\n    //     for I in B in reverse order:\n    //       for definition D in I:\n    //         add an interference from D to every element in ...\n    //         ... CurrLive - {D} creating nodes if necessary\n    //       for every definition D in I\n    //         remove D from CurrLive\n    //       for every use U in I\n    //         add U to CurrLive\n    //\n    // Since our IR is in SSA form, we always have exactly one definition\n    // per I, so the algorithm can be described in a simpler form:\n    //\n    //   for every block B in F:\n    //     CurrLive = LiveOut(B)\n    //     for I in B in reverse order:\n    //       let D be the definition of I\n    //       remove D from CurrLive\n    //       add an interference from D to every element in CurrLive\n    //       for every use U in I\n    //         add U to CurrLive\n    //\n\n    let g = new IntGraph()\n\n    // visit blocks in reverse order\n    for (let i = f.blocks.length, b :Block|undefined ; b = f.blocks[--i]; ) {\n      // live tracks currently-live IDs\n      let live = new Set<ID>()\n      let liveout :LiveInfo[] = a.live[b.id]\n      if (liveout) {\n        for (let e of liveout) {\n          live.add(e.id)\n        }\n      }\n\n      // visit instructions in reverse order\n      for (let i = b.values.length-1; i >= 0; --i) {\n        let v = b.values[i]\n\n        // remove definition from live set\n        live.delete(v.id)\n\n        // update interference graph to add an edge from the definition v\n        // to each other value alive at this point\n        for (let id2 of live) {\n          g.connect(v.id, id2)\n        }\n\n        for (let operand of v.args) {\n          live.add(operand.id)\n        }\n      }\n    }\n\n    return g\n  }\n\n\n  // regspec returns the RegInfo for operation op\n  //\n  regspec(op :Op) :RegInfo {\n    // const a = this\n    // if (op == ops.OpConvert) {\n    //   // OpConvert is a generic op, so it doesn't have a\n    //   // register set in the static table. It can use any\n    //   // allocatable integer register.\n    //   m := s.allocatable & s.f.Config.gpRegMask\n    //   return regInfo{inputs: []inputInfo{{regs: m}},\n    //     outputs: []outputInfo{{regs: m}}}\n    // }\n    return op.reg\n  }\n\n\n  // computeLive computes a map from block ID to a list of value IDs live at\n  // the end of that block. Together with the value ID is a count of how many\n  // instructions to the next use of that value.\n  // The resulting map is stored in this.live.\n  //\n  // computeLive also computes the desired register information at the end of\n  // each block. This desired register information is stored in this.desired.\n  //\n  // TODO: this could be quadratic if lots of variables are live across lots of\n  // basic blocks. Figure out a way to make this function (or, more precisely,\n  // the user of this function) require only linear size & time.\n  //\n  computeLive() {\n    const a = this\n    const f = a.f\n\n    a.live = new Array<LiveInfo[]>(f.numBlocks())\n    a.desired = new Array<DesiredState>(f.numBlocks())\n\n    let phis :Value[] = []\n\n    let live = new Map<ID,ValMapEntry>()\n    let t = new Map<ID,ValMapEntry>()\n\n    // Keep track of which value we want in each register.\n    let desired = new DesiredState()\n\n    // Instead of iterating over f.blocks, iterate over their postordering.\n    // Liveness information flows backward, so starting at the end increases\n    // the probability that we will stabilize quickly.\n    //\n    // TODO: Do a better job yet. Here's one possibility:\n    // Calculate the dominator tree and locate all strongly connected\n    // components. If a value is live in one block of an SCC, it is live in all.\n    // Walk the dominator tree from end to beginning, just once, treating SCC\n    // components as single blocks, duplicated calculated liveness information\n    // out to all of them.\n    //\n    let po = f.postorder()\n    // dlog('postorder blocks:', po.join(' '))\n\n    // will be set to true if f.invalidateCFG() needs to be called at the end\n    // let invalidateCFG = false\n\n\n    while (true) {\n      let changed = false\n\n      for (let b of po) {\n        // Start with known live values at the end of the block.\n        // Add b.values.length to adjust from end-of-block distance\n        // to beginning-of-block distance.\n        live.clear()\n        let liv = a.live[b.id];  // LiveInfo[] | undefined\n        if (liv) for (let e of liv) {\n          live.set(e.id, { val: e.dist + b.values.length, pos: e.pos })\n        }\n\n        // Mark control value as live\n        if (b.control && a.values[b.control.id].needReg) {\n          live.set(b.control.id, { val: b.values.length, pos: b.pos })\n        }\n\n        // dlog(`live: ` + Array.from(live).map(p =>\n        //   `v${p[0]} - v${p[1].val}`\n        // ).join('\\n'))\n\n        // Propagate backwards to the start of the block\n        // Assumes Values have been scheduled.\n        phis = []\n        for (let i = b.values.length - 1; i >= 0; i--) {\n          let v = b.values[i]\n\n          // definition of v -- remove from live\n          let x = live.get(v.id)\n          if (x) {\n            // save longest distance\n            a.values[v.id].maxdist = x.val\n            live.delete(v.id)\n          }\n\n          if (v.op === ops.Phi) {\n            // save phi ops for later\n            phis.push(v)\n            continue\n          }\n          if (v.op.call) {\n            for (let v of live.values()) {\n              v.val += unlikelyDistance\n            }\n          }\n          for (let arg of v.args) {\n            if (a.values[arg.id].needReg) {\n              live.set(arg.id, { val: i, pos: v.pos })\n            }\n          }\n        }\n\n        // Propagate desired registers backwards\n        let other = a.desired[b.id]\n        if (other) {\n          desired.copy(other)\n        } else {\n          desired.clear()\n        }\n\n        for (let i = b.values.length - 1; i >= 0; i--) {\n          let v = b.values[i]\n          let prefs = desired.remove(v.id)\n          if (v.op === ops.Phi) {\n            // TODO: if v is a phi, save desired register for phi inputs.\n            // For now, we just drop it and don't propagate\n            // desired registers back though phi nodes.\n            continue\n          }\n          let regspec = a.regspec(v.op)\n          // Cancel desired registers if they get clobbered.\n          desired.clobber(regspec.clobbers)\n          // Update desired registers if there are any fixed register inputs.\n          for (let j of regspec.inputs) {\n            if (countRegs(j.regs) != 1) {\n              continue\n            }\n            desired.clobber(j.regs)\n            desired.add(v.args[j.idx].id, pickReg(j.regs))\n          }\n          // Set desired register of input 0 if this is a 2-operand instruction.\n          if (v.op.resultInArg0) {\n            if (v.op.commutative) {\n              desired.addList(v.args[1].id, prefs)\n            }\n            desired.addList(v.args[0].id, prefs)\n          }\n        }\n\n        // dlog(`desired: ${desired}`)\n\n\n        // For each predecessor of b, expand its list of live-at-end values.\n        // invariant: live contains the values live at the start of b\n        // (excluding phi inputs)\n        for (let i = 0; i < b.preds.length; i++) {\n          let p = b.preds[i]\n\n          // Compute additional distance for the edge.\n          // Note: delta must be at least 1 to distinguish the control\n          // value use from the first user in a successor block.\n          let delta = normalDistance\n          if (p.succs.length == 2) {\n            if (\n              p.succs[0] == b && p.likely == BranchPrediction.Likely ||\n              p.succs[1] == b && p.likely == BranchPrediction.Unlikely\n            ) {\n              delta = likelyDistance\n            } else if (\n              p.succs[0] == b && p.likely == BranchPrediction.Unlikely ||\n              p.succs[1] == b && p.likely == BranchPrediction.Likely\n            ) {\n              delta = unlikelyDistance\n            }\n          }\n\n          // Update any desired registers at the end of p.\n          let pdesired = a.desired[p.id]\n          if (!pdesired) {\n            a.desired[p.id] = new DesiredState(desired)\n          } else {\n            pdesired.merge(desired)\n          }\n\n          // Start t off with the previously known live values at the end of p.\n          t.clear()\n          let plive = a.live[p.id]\n          if (plive) for (let e of plive) {\n            t.set(e.id, { val: e.dist, pos: e.pos })\n          }\n          \n          let update = false\n\n          // Add new live values from scanning this block.\n          for (let [key, e] of live) {\n            let d = e.val + delta\n            let e2 = t.get(key)\n            if (!e2 || d < e2.val) {\n              update = true\n              t.set(key, { val: d, pos: e.pos })\n            }\n          }\n          // Also add the correct arg from the saved phi values.\n          // All phis are at distance delta (we consider them\n          // simultaneously happening at the start of the block).\n          for (let v of phis) {\n            let id = v.args[i].id\n            if (a.values[id].needReg) {\n              let e2 = t.get(id)\n              if (!e2 || delta < e2.val) {\n                update = true\n                t.set(id, { val: delta, pos: v.pos })\n              }\n            }\n          }\n\n          if (!update) {\n            continue\n          }\n\n          // The live set has changed, update it.\n          let l :LiveInfo[] = new Array<LiveInfo>(t.size), j = 0\n          for (let [key, e] of t) {\n            l[j++] = { id: key, dist: e.val, pos: e.pos }\n          }\n          a.live[p.id] = l\n          changed = true\n        }\n      }\n\n      if (!changed) {\n        break\n      }\n\n      // break\n    }\n\n    // if (invalidateCFG) {\n    //   f.invalidateCFG()\n    // }\n\n  } // computeLive\n\n\n  fmtLive() :string {\n    const a = this\n    let s = ''\n    for (let b of a.f.blocks) {\n      s += `  ${b}:`\n      let blive = a.live[b.id]\n      if (blive) for (let x of blive) {\n        // s += `  v${x.id} (${x.dist})`\n        s += `  v${x.id}`\n        let desired = a.desired[b.id]\n        if (desired) for (let e of desired.entries) {\n          if (e.id != x.id) {\n            continue\n          }\n          s += \"[\"\n          let first = true\n          for (let r of e.regs) {\n            if (r == noReg) {\n              continue\n            }\n            if (!first) {\n              s += \",\"\n            }\n            let reg = a.registers[r]\n            s += `${reg.name}#${reg.num}`\n            first = false\n          }\n          s += \"]\"\n        }\n      }\n      if (a.desired[b.id]) {\n        let avoid = a.desired[b.id].avoid\n        if (!avoid.isZero()) {\n          s += \" avoid=\" + fmtRegSet(avoid)\n        }\n      }\n      s += \"\\n\"\n    }\n    return s.trimRight()\n  }\n\n}\n\n","// import { debuglog as dlog } from '../util'\nimport { monotime, fmtduration2 } from '../time'\nimport { Fun } from './ssa'\nimport { Config } from './config'\n\nimport { phielim } from './phielim'\nimport { copyelim } from './copyelim'\nimport { lower } from './lower'\nimport { deadcode } from './deadcode'\nimport { shortcircuit } from './shortcircuit'\nimport { regalloc } from './regalloc'\n\n\ntype PassFun = (f :Fun, c :Config) => void\n\nexport interface Pass {\n  name     :string\n  required :bool\n  fn       :PassFun\n}\n\nfunction optional(name :string, fn :PassFun) : Pass {\n  return { name, fn, required: false }\n}\n\nfunction required(name :string, fn :PassFun) : Pass {\n  return { name, fn, required:true }\n}\n\n\n// All IR passes run over functions\n//\nconst passes :Pass[] = [\n  optional(\"early phielim\", phielim),\n  optional(\"early copyelim\", copyelim),\n  optional(\"early deadcode\", deadcode),\n\n  optional(\"short circuit\", shortcircuit),\n\n  // required(\"decompose user\", decomposeUser),\n  // required(\"opt\", opt), // TODO: split required rules and optimizing rules\n  // required(\"zero arg cse\", zcse), // required to merge OpSB values\n  // required(\"opt deadcode\", deadcode),\n  //   // remove any blocks orphaned during opt\n  // optional(\"generic cse\", cse),\n  // optional(\"phiopt\", phiopt),\n  // optional(\"nilcheckelim\", nilcheckelim),\n  // optional(\"prove\", prove),\n  // required(\"decompose builtin\", decomposeBuiltIn),\n  // required(\"softfloat\", softfloat),\n  // required(\"late opt\", opt),\n  //   // TODO: split required rules and optimizing rules\n  // optional(\"dead auto elim\", elimDeadAutosGeneric),\n  required(\"generic deadcode\", deadcode),\n    // remove dead stores, which otherwise mess up store chain\n  // optional(\"check bce\", checkbce),\n  // optional(\"branchelim\", branchelim),\n  // optional(\"fuse\", fuse),\n  // optional(\"dse\", dse),\n  // required(\"writebarrier\", writebarrier), // expand write barrier ops\n\n  // optional(\"insert resched checks\", insertLoopReschedChecks),\n  //   // insert resched checks in loops.\n\n  required(\"lower\", lower),\n  // optional(\"lowered cse\", cse),\n  // optional(\"elim unread autos\", elimUnreadAutos),\n  required(\"lowered deadcode\", deadcode),\n  // required(\"checkLower\", checkLower),\n  optional(\"early phielim\", phielim),\n  optional(\"early copyelim\", copyelim),\n  // optional(\"tighten\", tighten), // move values closer to their uses\n  // optional(\"phi tighten\", phiTighten),\n  optional(\"late deadcode\", deadcode),\n  // required(\"critical\", critical), // remove critical edges\n  // optional(\"likelyadjust\", likelyadjust),\n\n  // required(\"layout\", layout),     // schedule blocks\n  // required(\"schedule\", schedule), // schedule values\n  // optional(\"late nilcheck\", nilcheckelim2),\n  // required(\"flagalloc\", flagalloc), // allocate flags register\n  required(\"regalloc\", regalloc),\n    // allocate int & float registers + stack slots\n  // optional(\"loop rotate\", loopRotate),\n  // required(\"stackframe\", stackframe),\n  // optional(\"trim\", trim), // remove empty blocks\n]\n\n\nexport function runPasses(f :Fun, c :Config, post? :(p:Pass)=>any) {\n  for (let p of passes) {\n    if (c.optimize || p.required) {\n      p.fn(f, c)\n      if (post) {\n        post(p)\n      }\n    }\n  }\n}\n\n\nexport function runPassesDev(\n  f :Fun,\n  c :Config,\n  stopAt :string,  // name of a pass to stop at (exclusive)\n  post? :(p:Pass)=>any\n) {\n  let totaltime = 0\n  for (let p of passes) {\n    if (p.name == stopAt) {\n      break\n    }\n    if (c.optimize || p.required) {\n      console.log(`running pass ${p.name}`)\n\n      let t = monotime()\n      p.fn(f, c)\n      t = monotime() - t\n      totaltime += t\n\n      console.log(`pass ${p.name} finished in ${fmtduration2(t)}`)\n\n      if (post) {\n        post(p)\n      }\n    }\n  }\n  console.log(`passes over ${f.name} finished in ${fmtduration2(totaltime)}`)\n}\n","import { Register, RegSet, emptyRegSet } from './reg'\nimport { Value, Block } from './ssa'\n\nexport type BlockRewriter = (b :Block)=>bool\nexport type ValueRewriter = (v :Value)=>bool\n\n// Config holds readonly compilation information.\n// It is created once, early during compilation, and shared across\n// all compilations.\n//\nexport class Config {\n  // arch           string // \"amd64\", etc.\n  // PtrSize        int64  // 4 or 8; copy of cmd/internal/sys.Arch.PtrSize\n  // RegSize        int64  // 4 or 8; copy of cmd/internal/sys.Arch.RegSize\n  // Types          Types\n  // lowerBlock     blockRewriter // lowering function\n  // lowerValue     valueRewriter // lowering function\n  // registers      []Register    // machine registers\n  // gpRegMask      regMask       // general purpose integer register mask\n  // fpRegMask      regMask       // floating point register mask\n  // specialRegMask regMask       // special register mask\n  // GCRegMap       []*Register   // garbage collector register map, by GC register index\n  // FPReg          int8          // register number of frame pointer, -1 if not used\n  // LinkReg        int8          // register number of link register if it is a general purpose register, -1 if not used\n  // hasGReg        bool          // has hardware g register\n  // ctxt           *obj.Link     // Generic arch information\n  // optimize       bool          // Do optimization\n  // noDuffDevice   bool          // Don't use Duff's device\n  // useSSE         bool          // Use SSE for non-float operations\n  // useAvg         bool          // Use optimizations that need Avg* operations\n  // useHmul        bool          // Use optimizations that need Hmul* operations\n  // nacl           bool          // GOOS=nacl\n  // use387         bool          // GO386=387\n  // SoftFloat      bool          //\n  // NeedsFpScratch bool          // No direct move between GP and FP register sets\n  // BigEndian      bool          //\n\n  arch      :string = '?' // e.g. \"covm\"\n  optimize  :bool = false  // Do optimization\n\n  addrSize  :int = 4  // 4 or 8 bytes\n  regSize   :int = 4  // 4 or 8 bytes\n  intSize   :int = 4  // 1, 2, 4 or 8 bytes\n\n  registers :Register[] = []   // machine registers\n\n  hasGReg        :bool = false         // has hardware g register\n  gpRegMask      :RegSet = emptyRegSet // general purpose integer register mask\n  fpRegMask      :RegSet = emptyRegSet // floating point register mask\n  specialRegMask :RegSet = emptyRegSet // special register mask\n  \n  lowerBlock     :BlockRewriter|null = null // lowering function\n  lowerValue     :ValueRewriter|null = null // lowering function\n\n  constructor(props?: Partial<Config>) {\n    if (props) for (let k of Object.keys(props as Object)) {\n      if (!(k in (this as any))) {\n        panic(`invalid config property ${k}`)\n      }\n      ;(this as any)[k] = (props as any)[k]\n    }\n  }\n\n\n  toString() :string {\n    return `${this.arch}/${this.addrSize * 8}/${this.optimize ? 'opt':'debug'}`\n  }\n}\n","import { Op } from '../ir/op'\nimport { Register, RegSet, emptyRegSet } from '../ir/reg'\nimport { Config, BlockRewriter, ValueRewriter } from '../ir/config'\n\n\nexport class ArchInfo {\n  readonly name            :string\n  readonly addrSize        :int = 4  // 4 or 8 bytes\n  readonly regSize         :int = 0  // 4 or 8 bytes\n  readonly intSize         :int = 0  // 1, 2, 4 or 8 bytes\n\n  readonly ops             = [] as Op[]\n  readonly regNames        = [] as string[]\n  readonly gpRegMask       = emptyRegSet as RegSet\n  readonly fpRegMask       = emptyRegSet as RegSet\n  readonly specialRegMask  = emptyRegSet as RegSet\n  readonly generic         = false as bool\n\n  readonly lowerBlock :BlockRewriter|null = null // lowering function\n  readonly lowerValue :ValueRewriter|null = null // lowering function\n\n  // readonly pkg     :string // obj package to import for this arch.\n  // readonly genfile :string // source file containing opcode code generation.\n  // readonly blocks  :[]blockData\n  // readonly fpReg   :int // int8; frame pointer -1 when not used\n  // readonly linkreg :int // int8; -1 when not used\n\n\n  constructor(name :string, props: Partial<ArchInfo>) {\n    this.name = name\n\n    for (let k of Object.keys(props)) {\n      assert(k in (this as any))\n      ;(this as any)[k] = (props as any)[k]\n    }\n\n    assert(this.regNames.length <= 64, 'too many registers')\n    assert(this.addrSize == 4 || this.addrSize == 8,\n      `invalid addrSize ${this.addrSize}`)\n\n    this.regSize = this.regSize || this.addrSize\n    this.intSize = this.intSize || this.addrSize\n  }\n\n\n  config(props? :Partial<Config>) :Config {\n    const registers :Register[] = this.regNames.map(\n      (name, num) => ({ num, name })\n    )\n\n    const c :Partial<Config> = {\n      arch: this.name,\n      registers,\n\n      addrSize:       this.addrSize,\n      regSize:        this.regSize,\n      intSize:        this.intSize,\n\n      hasGReg:        this.regNames.includes(\"g\"),\n      gpRegMask:      this.gpRegMask,\n      fpRegMask:      this.fpRegMask,\n      specialRegMask: this.specialRegMask,\n\n      lowerBlock:     this.lowerBlock,\n      lowerValue:     this.lowerValue,\n    }\n\n    if (props) {\n      Object.assign(c, props)\n    }\n\n    return new Config(c)\n  }\n\n}\n","import { debuglog as dlog } from '../util'\nimport { RegInfo, Op, ops } from '../ir/op'\nimport { regBuilder } from '../ir/reg'\nimport { Value, Block } from '../ir/ssa'\nimport { ValueRewriter } from '../ir/config'\nimport { ArchInfo } from './arch'\nimport * as T from '../types'\n\n\n// Note: registers not used in regalloc are not included in this list,\n// so that regmask stays within int64\n// Be careful when hand coding regmasks.\nconst regNames = [\n  \"R0\", // constant 0\n  \"R1\",\n  \"R2\",\n  \"R3\",\n  \"R4\",\n  \"R5\",\n  \"R6\",\n  \"R7\",\n  \"R8\",\n  \"R9\",\n  \"R10\",\n  \"R11\",\n  \"R12\",\n  \"R13\",\n  \"R14\",\n  \"R15\",\n  \"R16\",\n  \"R17\",\n  \"R18\",\n  \"R19\",\n  \"R20\",\n  \"R21\",\n  \"R22\",\n  //REGTMP\n  \"R24\",\n  \"R25\",\n  // R26 reserved by kernel\n  // R27 reserved by kernel\n  \"R28\",\n  \"R29\",\n  \"SP\",  // aka R30\n  \"g\",   // aka R31\n\n  \"F0\",\n  \"F2\",\n  \"F4\",\n  \"F6\",\n  \"F8\",\n  \"F10\",\n  \"F12\",\n  \"F14\",\n  \"F16\",\n  \"F18\",\n  \"F20\",\n  \"F22\",\n  \"F24\",\n  \"F26\",\n  \"F28\",\n  \"F30\",\n\n  // pseudo-registers\n  \"SB\",\n]\n\nexport const buildReg = regBuilder(regNames)\n\n// general-purpose registers\nconst gp = buildReg(`\n  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15 R16\n  R17 R18 R19 R20 R21 R22     R24 R25         R28 R29\n`)\n\n// floating-point registers\nconst fp = buildReg(`\n  F0 F2 F4 F6 F8 F10 F12 F14 F16 F18 F20 F22 F24 F26 F28 F30\n`)\n\n\n// --------------------------------------------------\n// HERE BE DRAGONS\n//\n// Setup Op.reg on all ops in op.ops for covm.\n// FIXME: remove this when we have a complete set of aops for covm.\n//\nfor (let name in ops as {[name:string]:Op}) {\n  let op = (ops as {[name:string]:Op})[name]\n  if (!op.zeroWidth && !op.call) {\n    // assign allowed input and output registers\n    let regs = gp // gpRegMask  // XXX FIXME this is specific to the covm arch\n    // TODO: add reg info to ops above. For instance, ConvI64toF32 accepts\n    // inputs in gp regs, and outputs in fp regs.\n    if (op.argLen > 0) {\n      op.reg.inputs = []\n      for (let i = 0; i < op.argLen; i++) {\n        op.reg.inputs[i] = { idx: i, regs }\n      }\n    }\n    op.reg.outputs = [ { idx: 0, regs } ]\n\n    // if (name == \"AddI32\") {\n    //   op.reg.inputs = [ { idx: 0, regs: covm_buildReg(\"R4\") } ]\n    // }\n  }\n}\n// --------------------------------------------------\n\n\n// Convenient register sets.\n// RegInfo(inputs :RegSet[], outputs :RegSet[])\n\nconst gpg   = gp.or(buildReg(\"g\"))   // gp + g\n// const gpsp  = gp.or(buildReg(\"SP\"))  // gp + SP\nconst gpspg = gpg.or(buildReg(\"SP\")) // gp + SP + g\n\nconst gp01 = new RegInfo([], [gp])\nconst gp21 = new RegInfo([gpg, gpg], [gp])\nconst gp11sp = new RegInfo([gpspg], [gp])\n\n\n// operators\nfunction op(name :string, argLen :int, props? :Partial<Op>) :Op {\n  return new Op(name, argLen, props)\n}\nconst aops :{ [name:string] : Op } = {\n\n  MOVWconst: op(\"MOVWconst\", 0, {\n    reg: gp01,\n    aux: T.t_u32,\n    type: T.t_u32,\n    rematerializeable: true,\n  }),\n\n  // arg0 + arg1\n  ADDW: op(\"ADDW\", 2, { reg: gp21, type: T.t_u32, commutative: true }),\n\n  // arg0 + aux\n  ADDWconst: op(\"ADDWconst\", 1, {\n    reg: gp11sp,\n    type: T.t_u32,\n    aux: T.t_u32,\n    commutative: true,\n  }),\n\n  // panic if arg0 is nil.  arg1=mem.\n  LowNilCheck: op(\"LowNilCheck\", 2, {\n    reg: new RegInfo([gpg], []),\n    nilCheck: true,\n    faultOnNilArg0: true,\n  }),\n\n}\n\n\n// Exported arch info\nexport default new ArchInfo(\"covm\", {\n  addrSize:   4,\n  ops:        Object.values(aops),\n  regNames:   regNames,\n  gpRegMask:  gp,\n  fpRegMask:  fp,\n  lowerBlock: lowerBlockCovm,\n  lowerValue: lowerValueCovm,\n})\n\n\nfunction lowerBlockCovm(b :Block) :bool {\n  return false\n}\n\n// value-lowering functions\n//\n// TODO: generate these from rules instead of manually defining them.\n//\nconst valueLoweringFuns = new Map<Op,ValueRewriter>([\n\n  [ ops.NilCheck, (v :Value) :bool => {\n    // match: (NilCheck ptr mem)\n    // cond:\n    // result: (LowNilCheck ptr mem)\n    v.op = aops.LowNilCheck\n    // let [ptr, mem] = v.args\n    // v.reset(aops.LowNilCheck)\n    // v.addArg(ptr)\n    // v.addArg(mem)\n    return true\n  } ],\n\n  [ ops.ConstI32, (v :Value) :bool => {\n    // match: (ConstI32 [val])\n    // cond:\n    // result: (MOVWconst [val])\n    let val = v.aux\n    v.reset(aops.MOVWconst)\n    v.aux = val\n    return true\n  } ],\n\n  [ ops.AddI32, (v :Value) :bool => {\n    // match: (AddI32 x y)\n    // cond:\n    // result: (ADDW x y)\n    let [x, y] = v.args\n    v.reset(aops.ADDW)\n    v.addArg(x)\n    v.addArg(y)\n    return true\n  } ],\n\n\n\n  [ aops.ADDW, (v :Value) :bool => {\n    // Based on rewriteValueMIPS_OpMIPSADD_0\n\n    // match: (ADD x (MOVWconst [c]))\n    // cond:\n    // result: (ADDWconst [c] x)\n    while (true) {\n      let x = v.args[0]\n      let v_1 = v.args[1]\n      if (v_1.op !== aops.MOVWconst) { break } // nomatch\n      let c = v_1.aux\n      v.reset(aops.ADDWconst)\n      v.aux = c\n      v.addArg(x)\n      dlog(`rewrite ${v} (ADD x (MOVWconst [c])) -> (ADDWconst [c] x)`)\n      return true\n    }\n\n    return false\n  } ],\n\n])\n\nfunction lowerValueCovm(v :Value) :bool {\n  let lf = valueLoweringFuns.get(v.op)\n  return lf ? lf(v) : false\n}\n","import { ArchInfo } from './arch'\nimport covm from './covm'\n\nexport const archs : {[name:string] : ArchInfo} = {\n  [covm.name]: covm,\n}\n","//\n// int64 pseudo-random number generator with seed control\n//\n// Exported functions:\n//   function seed(n :int) :void\n//   function sint64rand() :SInt64\n//   function uint64rand() :UInt64\n//\nimport { SInt64, UInt64 } from './int64'\n\ninterface WasmInterface {\n  seed(a :int) :void\n  xorshift128plus() :int\n  get_high() :int\n}\n\nconst wasm = (typeof WebAssembly != 'undefined' ?\n  new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    //!<wasmdata src=\"int64_rand.wast\">\n    0,97,115,109,1,0,0,0,1,9,2,96,0,1,127,96,1,127,0,3,4,3,0,1,0,6,16,3,126,1,\n    66,1,11,126,1,66,2,11,127,1,65,0,11,7,37,3,8,103,101,116,95,104,105,103,\n    104,0,0,4,115,101,101,100,0,1,15,120,111,114,115,104,105,102,116,49,50,56,\n    112,108,117,115,0,2,10,110,3,4,0,35,2,11,15,0,32,0,173,36,0,32,0,173,66,1,\n    124,36,1,11,87,1,4,126,35,0,33,0,35,1,33,1,32,1,36,0,32,0,66,23,134,33,2,\n    32,2,32,0,133,33,0,32,0,66,17,136,33,2,32,1,66,26,136,33,3,32,0,32,1,133,\n    33,0,32,0,32,3,133,33,0,32,0,32,2,133,33,0,32,0,36,1,32,0,32,1,124,33,1,\n    32,1,66,32,135,167,36,2,32,1,167,11\n    //!</wasmdata>\n  ])), {}).exports as any as WasmInterface :\n  null\n)\n\n// fallback function for when WebAssembly isn't available\nlet js_state0 = 1 | 0\nlet js_state1 = 2 | 0\nfunction i32rand_mwc1616() :int {\n  js_state0 = 18030 * (js_state0 & 0xffff) + (js_state0 >> 16)\n  js_state1 = 30903 * (js_state1 & 0xffff) + (js_state1 >> 16)\n  return js_state0 << 16 + (js_state1 & 0xffff)\n}\n\n\nexport const seed :(n :int)=>void = (\n  wasm !== null ? wasm.seed : (n :int) => {\n    js_state0 = n | 0\n    js_state1 = (n + 1) | 0\n  }\n)\n\nexport const sint64rand :()=>SInt64 = (\n  wasm !== null ? () => {\n    const low = (wasm as WasmInterface).xorshift128plus()\n    return new SInt64(low, (wasm as WasmInterface).get_high())\n  } : () =>\n    new SInt64(i32rand_mwc1616(), i32rand_mwc1616())\n)\n\nexport const uint64rand :()=>UInt64 = (\n  wasm !== null ? () => {\n    const low = (wasm as WasmInterface).xorshift128plus()\n    return new UInt64(low, (wasm as WasmInterface).get_high())\n  } : () =>\n    new UInt64(i32rand_mwc1616(), i32rand_mwc1616())\n)\n\n// make initial seed actually random\nseed((Math.random() * 0xffffffff) >>> 0)\n","import { monotime } from './time'\n\nexport function assertEq(actual :any, expected :any, context? :string) {\n  assert(\n    actual === expected,\n    `expected ${JSON.stringify(expected)} `+\n    `but instead got ${JSON.stringify(actual)}` +\n    (context ? ' â€” ' + context : ''),\n    assertEq\n  )\n}\n\nexport function assertEqList(\n  actualList :ArrayLike<any>,\n  expectedList :ArrayLike<any>,\n) {\n  if (actualList.length !== expectedList.length) {\n    assert(\n      false,\n      `expected list of length ${expectedList.length} ` +\n      `but got ${actualList.length}`,\n      assertEqList\n    )\n  }\n  for (let i = 0; i < expectedList.length; i++) {\n    assert(\n      actualList[i] === expectedList[i],\n      `expected list item #${i} to be ${JSON.stringify(expectedList[i])} ` +\n      `but got ${JSON.stringify(actualList[i])}`,\n      assertEqList\n    )\n  }\n}\n\nexport function assertEqObj(\n  actualObj :{[k:string]:any},\n  expectedObj :{[k:string]:any},\n) {\n  let actualKeys = Object.keys(actualObj)\n  let expectedKeys = Object.keys(expectedObj)\n  if (actualKeys.length !== expectedKeys.length) {\n    assert(\n      false,\n      `expected object with ${expectedKeys.length} properties ` +\n      `but got one with ${actualKeys.length} properties`,\n      assertEqObj\n    )\n  }\n  for (let i = 0; i < expectedKeys.length; i++) {\n    let k = expectedKeys[i]\n    assert(\n      actualObj[k] === expectedObj[k],\n      `expected property ${k} to be ${JSON.stringify(expectedObj[k])} ` +\n      `but got ${JSON.stringify(actualObj[k])}`,\n      assertEqObj\n    )\n  }\n}\n\nexport function assertThrows(fn :()=>any) {\n  try {\n    fn()\n    assert(false, 'expected exception to be thrown', assertThrows)\n  } catch (e) {\n  }\n}\n\n// quickcheck options\nexport interface QCOptions {\n  timeout? :int  // milliseconds; default is 1000\n}\n\n// quickcheck generator\nexport interface QCGen<T> extends QCOptions {\n  size: int\n  gen(i? :int) :T\n}\n\n\nclass QCGenBase<T> {\n  size: int\n\n  constructor(size :int = 0) {\n    this.size = size >>> 0\n  }\n\n  gen(i? :int) :T {\n    return undefined as any as T\n  }\n}\n\n\nclass QCF64Gen extends QCGenBase<number> {\n  constructor(a :number, b :number) {\n    if (a > b) {\n      let t = a ; a = b ; b = t\n    }\n    super(Math.ceil(b - a))\n    this.gen = () =>\n      Math.random() * (b - a) + a\n  }\n}\n\nclass QCS32Gen extends QCGenBase<int> {\n  constructor(a :int, b :int) {\n    a = a | 0\n    b = b | 0\n    if (a > b) {\n      let t = a ; a = b ; b = t\n    }\n    super(b - a)\n    this.gen = () =>\n      Math.floor(Math.random() * (b + 1 - a) + a) | 0\n  }\n}\n\nclass QCU32Gen extends QCGenBase<int> {\n  constructor(a :int, b :int) {\n    a = a >>> 0\n    b = b >>> 0\n    if (a > b) {\n      let t = a ; a = b ; b = t\n    }\n    super(b - a)\n    this.gen = () =>\n      Math.floor(Math.random() * (b + 1 - a) + a) >>> 0\n  }\n}\n\nexport function quickcheck<T>(\n  gen :QCGen<T> | [T,T],\n  check :((i :T)=>bool)) :void\n\nexport function quickcheck<T>(\n  gen :QCGen<T> | [T,T],\n  options :QCOptions,\n  check :((i :T)=>bool)) :void\n\nexport function quickcheck<T>(\n  gen :QCGen<T> | [T,T],\n  arg1 :QCOptions | ((i :T)=>bool),\n  arg2? :(i :T)=>bool,\n) :void\n{\n  let check = arg2 as (i :T)=>bool\n  let options = arg1 as QCOptions\n  if (arg2 === undefined) {\n    check = arg1 as (i :T)=>bool\n    options = {}\n  } else if (!options || typeof options != 'object') {\n    throw new Error('argument 2 is not an options object')\n  }\n\n  const opt = Object.assign({\n    // default options\n    timeout: 1000,\n  }, gen as QCOptions, options)\n\n  opt.timeout = Math.max(0, opt.timeout as number)\n\n  let g = gen as QCGen<T>\n\n  if (Array.isArray(gen)) {\n    let [a, b] = gen\n    if (typeof a == 'number' && typeof b == 'number') {\n      if (Math.round(a) != a) {\n        g = new QCF64Gen(a, b) as any as QCGen<T>\n      } else if (Math.min(a, b) < 0) {\n        g = new QCS32Gen(a, b) as any as QCGen<T>\n      } else {\n        g = new QCU32Gen(a, b) as any as QCGen<T>\n      }\n    } else {\n      throw new Error(`unexpected range type ${typeof a}`)\n    }\n  }\n\n  let timeStarted = monotime()\n\n  for (let i = 0; i < g.size; i++) {\n    let v = g.gen(i)\n    let ok = check(v)\n    if (!ok) {\n      assert(\n        false,\n        `quickcheck failure for input ${v}, generation ${i}`,\n        quickcheck\n      )\n    }\n    if (opt.timeout && i % 100 == 0 && monotime() - timeStarted > opt.timeout) {\n      // console.log(`qc time limit`)\n      break\n    }\n  }\n}\n\n","import { SInt64, UInt64, Int64 } from './int64'\nimport { sint64rand, uint64rand } from './int64_rand'\nimport { asciibuf } from './util'\nimport {\n  assertEq,\n  assertEqList,\n  assertEqObj,\n  assertThrows,\n  quickcheck,\n} from './test'\n\n\nTEST('basic', () => {\n  let s, u\n  \n  s = new SInt64(0xFFFFFFFF | 0, 0x7FFFFFFF | 0)\n  assertEq(s.toFloat64(), 9223372036854775807)\n  assertEq(s.toString(10), \"9223372036854775807\")\n\n  s = new SInt64(0 | 0, 0 | 0)\n  assertEq(s.toFloat64(), 0)\n  assertEq(s.toString(10), \"0\")\n\n  u = new UInt64(0xFFFFFFFF | 0, 0xFFFFFFFF | 0)\n  assertEq(u.toString(10), \"18446744073709551615\")\n})\n\n\nTEST('constants', () => {\n  let s, u\n  \n  s = new SInt64(0xFFFFFFFF | 0, 0x7FFFFFFF | 0)\n  assert(s.constructor === SInt64.MAX.constructor)\n  assert(s.eq(SInt64.MAX))\n\n  s = new SInt64(0, 0x80000000 | 0)\n  assert(s.constructor === SInt64.MIN.constructor)\n  assert(s.eq(SInt64.MIN))\n\n  s = new SInt64(0, 0)\n  assert(s.constructor === SInt64.ZERO.constructor)\n  assert(s.eq(SInt64.ZERO))\n\n  s = new SInt64(1, 0)\n  assert(s.constructor === SInt64.ONE.constructor)\n  assert(s.eq(SInt64.ONE))\n\n  s = new SInt64(-1 | 0, -1)\n  assert(s.constructor === SInt64.ONENEG.constructor)\n  assert(s.eq(SInt64.ONENEG))\n\n  u = new UInt64(0xFFFFFFFF | 0, 0xFFFFFFFF | 0)\n  assert(u.constructor === UInt64.MAX.constructor)\n  assert(u.eq(UInt64.MAX))\n\n  u = new UInt64(0, 0)\n  assert(u.constructor === UInt64.MIN.constructor)\n  assert(u.constructor === UInt64.ZERO.constructor)\n  assert(u.eq(UInt64.MIN))\n  assert(u.eq(UInt64.ZERO))\n})\n\n\nTEST('toString', () => {\n  let s, u\n\n  s = SInt64.MAX\n  assertEq(s.toString(16), \"7fffffffffffffff\")\n  assertEq(s.toString(10), \"9223372036854775807\")\n  assertEq(s.toString(8),  \"777777777777777777777\")\n  assertEq(s.toString(36), \"1y2p0ij32e8e7\")\n\n  s = SInt64.MIN\n  assertEq(s.toString(16), \"-8000000000000000\")\n  assertEq(s.toString(10), \"-9223372036854775808\")\n  assertEq(s.toString(8),  \"-1000000000000000000000\")\n  assertEq(s.toString(36), \"-1y2p0ij32e8e8\")\n\n  u = UInt64.MAX\n  assertEq(u.toString(16), \"ffffffffffffffff\")\n  assertEq(u.toString(10), \"18446744073709551615\")\n  assertEq(u.toString(8), \"1777777777777777777777\")\n  assertEq(u.toString(36), \"3w5e11264sgsf\")\n})\n\n\nTEST('fromStr', () => {\n  function t(I :any, s :string, radix :int) {\n    assertEq(I.fromStr(s, radix).toString(radix), s)\n  }\n\n  t(SInt64, \"7fffffffffffffff\", 16)\n  t(SInt64, \"9223372036854775807\", 10)\n  t(SInt64, \"777777777777777777777\", 8)\n  t(SInt64, \"1y2p0ij32e8e7\", 36)\n\n  t(SInt64, \"-8000000000000000\", 16)\n  t(SInt64, \"-9223372036854775808\", 10)\n  t(SInt64, \"-1000000000000000000000\", 8)\n  t(SInt64, \"-1y2p0ij32e8e8\", 36)\n\n  t(UInt64, \"efffffffffffffff\", 16) // this caught a bug once\n  t(UInt64, \"ffffffffffffffff\", 16)\n  t(UInt64, \"18446744073709551615\", 10)\n  t(UInt64, \"1777777777777777777777\", 8)\n  t(UInt64, \"3w5e11264sgsf\", 36)\n})\n\n\nTEST('fromByteStr', () => {\n  function t(I :any, str :string, radix :int) {\n    let inbuf = asciibuf(str)\n    let u = I.fromByteStr(inbuf, radix)\n    assertEq(u.toString(radix), str)\n  }\n\n  t(SInt64, \"7fffffffffffffff\", 16)\n  t(SInt64, \"9223372036854775807\", 10)\n  t(SInt64, \"777777777777777777777\", 8)\n  t(SInt64, \"1y2p0ij32e8e7\", 36)\n\n  t(SInt64, \"-8000000000000000\", 16)\n  t(SInt64, \"-9223372036854775808\", 10)\n  t(SInt64, \"-1000000000000000000000\", 8)\n  t(SInt64, \"-1y2p0ij32e8e8\", 36)\n\n  t(UInt64, \"efffffffffffffff\", 16) // this caught a bug once\n  t(UInt64, \"ffffffffffffffff\", 16)\n  t(UInt64, \"18446744073709551615\", 10)\n  t(UInt64, \"1777777777777777777777\", 8)\n  t(UInt64, \"3w5e11264sgsf\", 36)\n})\n\n\nTEST('fromByteStr0', () => {\n  function t(I :any, str :string, radix :int) {\n    let expectstr = str\n    if (str[0] == '-') {\n      str = str.substr(1)\n    }\n    let inbuf = asciibuf(str)\n    let u = I.fromByteStr0(inbuf, radix, 0, inbuf.length)\n    assertEq(u.toString(radix), expectstr)\n  }\n\n  t(SInt64, \"7fffffffffffffff\", 16)\n  t(SInt64, \"9223372036854775807\", 10)\n  t(SInt64, \"777777777777777777777\", 8)\n  t(SInt64, \"1y2p0ij32e8e7\", 36)\n\n  t(SInt64, \"-8000000000000000\", 16)\n  t(SInt64, \"-9223372036854775808\", 10)\n  t(SInt64, \"-1000000000000000000000\", 8)\n  t(SInt64, \"-1y2p0ij32e8e8\", 36)\n\n  t(UInt64, \"efffffffffffffff\", 16) // this caught a bug once\n  t(UInt64, \"ffffffffffffffff\", 16)\n  t(UInt64, \"18446744073709551615\", 10)\n  t(UInt64, \"1777777777777777777777\", 8)\n  t(UInt64, \"3w5e11264sgsf\", 36)\n})\n\n\nTEST('toBytes', () => {\n  let s\n  s = new SInt64(0x01234567, 0x12345678)\n  assertEqList(\n    s.toBytesBE(),\n    [ 0x12, 0x34, 0x56, 0x78, 0x01, 0x23, 0x45, 0x67 ]\n  )\n  assertEqList(\n    s.toBytesLE(),\n    [ 0x67, 0x45, 0x23, 0x01, 0x78, 0x56, 0x34, 0x12 ]\n  )\n  // Note: we are not testing toBytes separately for UInt64\n  // since SInt64 and UInt64 uses the same implementations.\n})\n\n\nTEST('fromBytes', () => {\n  let s, u\n  s = new SInt64(0x01234567, 0x12345678)\n  u = new UInt64(0x01234567, 0x12345678)\n  assertEqObj(SInt64.fromBytesLE(s.toBytesLE()), s)\n  assertEqObj(\n    SInt64.fromBytesBE([0x12, 0x34, 0x56, 0x78, 0x01, 0x23, 0x45, 0x67]),\n    s\n  )\n  assertEqObj(\n    SInt64.fromBytesLE([0x67, 0x45, 0x23, 0x01, 0x78, 0x56, 0x34, 0x12]),\n    s\n  )\n  assertEqObj(\n    UInt64.fromBytesLE([0x67, 0x45, 0x23, 0x01, 0x78, 0x56, 0x34, 0x12]),\n    u\n  )\n  // Note: we are not testing fromBytes separately for UInt64\n  // since SInt64 and UInt64 uses the same implementations.\n})\n\n\nTEST('fromInt32', () => {\n  let s, u\n\n  s = SInt64.fromInt32(0x7FFFFFFF)\n  assertEq(s.toString(10), '2147483647')\n  \n  s = SInt64.fromInt32(0xFFFFFFFF)\n  assertEq(s.toString(10), '-1')\n\n  s = SInt64.fromInt32(-0x80000000)\n  assertEq(s.toString(10), '-2147483648')\n\n  s = SInt64.fromInt32(-0x80000001)\n  assertEq(s.toString(10), '2147483647') // wraps around\n\n\n  u = UInt64.fromInt32(0xFFFFFFFF)\n  assertEq(u.toString(10), '4294967295')\n\n  u = UInt64.fromInt32(0xFFFFFFFFFF)  // limited to 0xFFFFFFFF\n  assertEq(u.toString(10), '4294967295')\n\n  u = UInt64.fromInt32(-0xFFFFFFFe)\n  assertEq(u.toString(10), '18446744069414584322') // wraps around\n\n  // sanity-check constructor before relying on _low and _high values\n  u = new UInt64(-1, -1)\n  assertEq(u._low, -1)\n  assertEq(u._high, -1)\n  assertEq(u.toString(10), '18446744073709551615')\n\n  u = UInt64.fromInt32(-1) // wraps around to UInt64\n  assertEq(u._low, -1)\n  assertEq(u._high, -1)\n  assertEq(u.toString(10), '18446744073709551615')\n\n  u = UInt64.fromInt32(-2) // wraps around with -1\n  assertEq(u.toString(10), '18446744073709551614')\n})\n\n\nTEST('fromFloat64/s', () => {\n  let s\n\n  s = SInt64.fromFloat64(0x7FFFFFFF)\n  assertEq(s.toFloat64(), 2147483647)\n  assertEq(s.toString(10), '2147483647')\n\n  s = SInt64.fromFloat64(0xFFFFFFFFFF)\n  assertEq(s.toFloat64(), 1099511627775)\n  assertEq(s.toString(10), '1099511627775')\n\n  s = SInt64.fromFloat64(-0xFFFFFFFFFF)\n  assertEq(s.toFloat64(), -1099511627775)\n  assertEq(s.toString(10), '-1099511627775')\n\n  s = SInt64.fromFloat64(0x7FFFFFFFFFFFFFFF)\n  assertEq(s.toFloat64(), 9223372036854775807)\n  assertEq(s.toString(10), '9223372036854775807')\n\n  s = SInt64.fromFloat64(-0x8000000000000000)\n  assertEq(s.toFloat64(), -9223372036854775808)\n  assertEq(s.toString(10), '-9223372036854775808')\n\n  s = SInt64.fromFloat64(0xFFFFFFFFFFFFFFFF) // limited to SInt64.MAX\n  assertEq(s.toFloat64(), 9223372036854775807)\n  assertEq(s.toString(10), '9223372036854775807')\n})\n\n\nTEST('fromFloat64/u', () => {\n  let u\n\n  u = UInt64.fromFloat64(0x7FFFFFFF)\n  assertEq(u.toFloat64(), 2147483647)\n  assertEq(u.toString(10), '2147483647')\n\n  u = UInt64.fromFloat64(0xFFFFFFFFFF)\n  assertEq(u.toFloat64(), 1099511627775)\n  assertEq(u.toString(10), '1099511627775')\n\n  u = UInt64.fromFloat64(0xFFFFFFFFFFFFFFFF)\n  assertEq(u.toFloat64(), 18446744073709551615)\n  assertEq(u.toString(10), '18446744073709551615')\n\n  u = UInt64.fromFloat64(-1) // limited to UInt64.MIN (zero)\n  assertEq(u.toFloat64(), 0)\n  assertEq(u.toString(10), '0')\n\n  u = UInt64.fromFloat64(-0xFFFFFFFFFF) // limited to UInt64.MIN (zero)\n  assertEq(u.toFloat64(), 0)\n  assertEq(u.toString(10), '0')\n})\n\n\nTEST('maybeFromFloat64/s', () => {\n  let s\n\n  s = SInt64.maybeFromFloat64(123) as UInt64\n  assert(s != null)\n  assertEq(s.toFloat64(), 123)\n  assertEq(s.toString(10), '123')\n\n  s = SInt64.maybeFromFloat64(0x7FFFFFFF) as UInt64\n  assert(s != null)\n  assertEq(s.toFloat64(), 2147483647)\n  assertEq(s.toString(10), '2147483647')\n\n  s = SInt64.maybeFromFloat64(0xFFFFFFFFFF) as UInt64\n  assert(s != null)\n  assertEq(s.toFloat64(), 1099511627775)\n  assertEq(s.toString(10), '1099511627775')\n\n  s = SInt64.maybeFromFloat64(-0xFFFFFFFFFF) as UInt64\n  assert(s != null)\n  assertEq(s.toFloat64(), -1099511627775)\n  assertEq(s.toString(10), '-1099511627775')\n\n  s = SInt64.maybeFromFloat64(0x7FFFFFFFFFFFFFFF) as UInt64\n  assert(s != null)\n  assertEq(s.toFloat64(), 9223372036854775807)\n  assertEq(s.toString(10), '9223372036854775807')\n\n  s = SInt64.maybeFromFloat64(-0x8000000000000000) as UInt64\n  assert(s != null)\n  assertEq(s.toFloat64(), -9223372036854775808)\n  assertEq(s.toString(10), '-9223372036854775808')\n\n  s = SInt64.maybeFromFloat64(0xFFFFFFFFFFFFFFFF) as null\n    // limited to SInt64.MAX\n  assertEq(s, null)\n})\n\n\nTEST('maybeFromFloat64/u', () => {\n  let u\n\n  u = UInt64.maybeFromFloat64(0x7FFFFFFF) as UInt64\n  assert(u != null)\n  assertEq(u.toFloat64(), 2147483647)\n  assertEq(u.toString(10), '2147483647')\n\n  u = UInt64.maybeFromFloat64(0xFFFFFFFFFF) as UInt64\n  assert(u != null)\n  assertEq(u.toFloat64(), 1099511627775)\n  assertEq(u.toString(10), '1099511627775')\n\n  u = UInt64.maybeFromFloat64(0xFFFFFFFFFFFFFFFF) as UInt64\n  assert(u != null)\n  assertEq(u.toFloat64(), 18446744073709551615)\n  assertEq(u.toString(10), '18446744073709551615')\n\n  u = UInt64.maybeFromFloat64(-1) as null // limited to UInt64.MIN\n  assertEq(u, null)\n\n  u = UInt64.maybeFromFloat64(-0xFFFFFFFFFF) as null // limited to UInt64.MIN\n  assertEq(u, null)\n})\n\n\nTEST('sign-conv', () => {\n  let s, u\n\n  s = SInt64.fromFloat64(-1)\n  assertEq(s.toFloat64(), -1)\n  assertEq(s.toString(10), '-1')\n  \n  u = s.toUnsigned()\n  assertEq(u.toFloat64(), 0xFFFFFFFFFFFFFFFF)\n  assertEq(u.toString(16), 'ffffffffffffffff')\n  \n  s = u.toSigned()\n  assertEq(s.toFloat64(), -1)\n  assertEq(s.toString(10), '-1')\n})\n\n\nTEST('sub-max-signed', () => {\n  let u\n  //\n  // UINT64_MAX - INT64_MAX - 1 == INT64_MAX\n  //\n  u = UInt64.MAX.sub(SInt64.MAX).sub(SInt64.ONE)\n  assertEq(u.toFloat64(), SInt64.MAX.toFloat64())\n  assertEq(u.toString(), SInt64.MAX.toString())\n})\n\n\nTEST('sub-max-unsigned', () => {\n  let u\n  //\n  // UINT64_MAX - UINT64_MAX == 0\n  //\n  u = UInt64.MAX.sub(UInt64.MAX)\n  assertEq(u._low, 0)\n  assertEq(u._high, 0)\n  assertEq(u.toFloat64(), 0)\n  assertEq(u.toString(), '0')\n})\n\n\nTEST('sub-zero-cross-sign', () => {\n  let s, u\n\n  // UINT64_MAX - uint64(1) == 0xFFFFFFFFFFFFFFFe\n  u = UInt64.MAX.sub(UInt64.ONE)\n  assertEq(u.toFloat64(), 0xFFFFFFFFFFFFFFFe)\n  assertEq(u.toString(), '18446744073709551614')\n\n  // UINT64_MAX - int64(-1) == 0\n  u = UInt64.MAX.sub(SInt64.ONENEG) // effectively addition -- wraps to 0\n  assertEq(u.toFloat64(), 0)\n  assertEq(u.toString(), '0')\n\n  // int64(-1)\n  s = SInt64.fromInt32(-1)\n  assertEq(s._low, -1)\n  assertEq(s._high, -1)\n\n  // uint64(0) - int64(-1) == UINT64_MAX\n  u = UInt64.fromInt32(0).add(s)\n  assertEq(u.toFloat64(), 0xFFFFFFFFFFFFFFFF)\n  assertEq(u.toString(), '18446744073709551615')\n})\n\n\n// if wasm is in use and DEBUG, then test JS impl of div as well\nlet js_mul   = (SInt64.prototype as any)._js_mul as (x:Int64)=>SInt64\nlet js_div_s = (SInt64.prototype as any)._js_div as (x:Int64)=>SInt64\nlet js_div_u = (UInt64.prototype as any)._js_div as (x:Int64)=>UInt64\nlet js_mod_s = (SInt64.prototype as any)._js_mod as (x:Int64)=>SInt64\n// let js_mod_u = (UInt64.prototype as any)._js_mod as (x:Int64)=>UInt64\nlet js_popcnt = (SInt64.prototype as any)._js_popcnt as ()=>int\n// TODO test js_mod_u\n\n\nTEST('div-max', () => {\n  let s, u\n\n  // UINT64_MAX / INT64_MAX == 2\n  s = UInt64.MAX.div(SInt64.MAX)\n  assertEq(s.toFloat64(), 2)\n  assertEq(s.toString(), '2')\n\n  // UINT64_MAX / UINT64_MAX == 1\n  u = UInt64.MAX.div(UInt64.MAX)\n  assertEq(u.toString(), '1')\n})\n\nif (js_div_u) TEST('div-max/js', () => {\n  let s, u\n\n  // UINT64_MAX / INT64_MAX == 2\n  s = js_div_u.call(UInt64.MAX, SInt64.MAX)\n  assertEq(s.toFloat64(), 2)\n  assertEq(s.toString(), '2')\n\n  // UINT64_MAX / UINT64_MAX == 1\n  u = js_div_u.call(UInt64.MAX, UInt64.MAX)\n  assertEq(u.toString(), '1')\n})\n\n\nTEST('div-neg', () => {\n  let s, u\n\n  // uint64(int64(-1)) == UINT64_MAX - 1 == 0xFFFFFFFFFFFFFFFe\n  s = SInt64.fromInt32(-2)\n  assertEq(s.toUnsigned().toString(), UInt64.MAX.sub(UInt64.ONE).toString())\n\n  // UINT64_MAX / (UINT64_MAX - 1) == 1\n  // 0xFFFFFFFFFFFFFFFf / 0xFFFFFFFFFFFFFFFe == 1\n  u = UInt64.MAX.div(s)\n  assertEq(u.toString(), '1')\n\n  // INT64_MIN - 1 == INT64_MIN\n  s = SInt64.MIN.div(SInt64.ONE)\n  assertEq(s.toString(), SInt64.MIN.toString())\n})\n\nif (js_div_u) TEST('div-neg/js', () => {\n  let s, u\n\n  s = SInt64.fromInt32(-2)\n\n  // UINT64_MAX / (UINT64_MAX - 1) == 1\n  // 0xFFFFFFFFFFFFFFFf / 0xFFFFFFFFFFFFFFFe == 1\n  u = js_div_u.call(UInt64.MAX, s)\n  assertEq(u.toString(), '1')\n\n  // INT64_MIN - 1 == INT64_MIN\n  s = js_div_s.call(SInt64.MIN, SInt64.ONE)\n  assertEq(s.toString(), SInt64.MIN.toString())\n})\n\n\nTEST('div-unsigned', () => {\n  // make sure division with unsigned numbers yield unsigned results\n  let a = new UInt64(0, 8)\n  let b = UInt64.fromFloat64(2656901066)\n  let x = a.div(b)\n  assertEq(x.toString(), '12')\n  assertEq(x.constructor, UInt64)\n})\n\nif (js_div_u) TEST('div-unsigned/js', () => {\n  // make sure division with unsigned numbers yield unsigned results\n  let a = new UInt64(0, 8)\n  let b = UInt64.fromFloat64(2656901066)\n  let x = js_div_u.call(a, b)\n  assertEq(x.toString(), '12')\n  assertEq(x.constructor, UInt64)\n})\n\n\nTEST('msb-unsigned', () => {\n  // most significant bit\n  // 1 << 63 == 0x8000000000000000\n  let u = UInt64.ONE.shl(63)\n  assert(u.eq(SInt64.MIN) == false)\n  assertEq(u.toString(), \"9223372036854775808\")\n})\n\n\nTEST('popcnt/s/quickcheck', () => {\n  // slow, naÃ¯ve and reliable popcnt implementation used as a reference\n  function popcnt_naive(n :Int64) {\n    let c = 0\n    while (!n.isZero()) {\n      n = n.and(n.sub(SInt64.ONE))  // clear the least significant bit set\n      // n = n & n - 1\n      c++\n    }\n    return c\n  }\n\n  quickcheck<SInt64>({ timeout: 100, size: Infinity, gen: sint64rand }, n =>\n    n.popcnt() == popcnt_naive(n))\n\n  quickcheck<SInt64>({ timeout: 100, size: Infinity, gen: sint64rand }, n =>\n    js_popcnt.call(n) == popcnt_naive(n))\n})\n\n\nTEST('popcnt/u/quickcheck', () => {\n  // slow, naÃ¯ve and reliable popcnt implementation used as a reference\n  function popcnt_naive(n :Int64) {\n    let c = 0\n    while (!n.isZero()) {\n      n = n.and(n.sub(UInt64.ONE))  // clear the least significant bit set\n      // n = n & n - 1\n      c++\n    }\n    return c\n  }\n\n  quickcheck<UInt64>({ timeout: 100, size: Infinity, gen: uint64rand }, n =>\n    n.popcnt() == popcnt_naive(n))\n\n  quickcheck<UInt64>({ timeout: 100, size: Infinity, gen: uint64rand }, n =>\n    js_popcnt.call(n) == popcnt_naive(n))\n})\n\n\n\n// ---------------------------------------------------------------------------\n// The remaining tests comes from Google Closure Library's goog/math/long\n// ---------------------------------------------------------------------------\n\n// Interprets the given numbers as the bits of a 32-bit int\nfunction i32array(v :number[]) :number[] {\n  for (let i = 0; i < v.length; ++i) {\n    v[i] = v[i] & 0xFFFFFFFF\n  }\n  return v\n}\n\n// Note that these are in numerical order.\nvar TEST_BITS = i32array([\n  // low,     high,       low,        high,       low,        high\n  0x80000000, 0x00000000, 0xb776d5f5, 0x5634e2db, 0xffefffff, 0xffffffff,\n  0xfff00000, 0x00000000, 0xfffeffff, 0xffffffff, 0xffff0000, 0x00000000,\n  0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0xffffffff, 0xfeffffff,\n  0xffffffff, 0xff000000, 0xffffffff, 0xfffeffff, 0xffffffff, 0xffff0000,\n  0xffffffff, 0xffff7fff, 0xffffffff, 0xffff8000, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000002, 0x00000000, 0x00007fff, 0x00000000, 0x00008000,\n  0x00000000, 0x0000ffff, 0x00000000, 0x00010000, 0x00000000, 0x00ffffff,\n  0x00000000, 0x01000000, 0x00000000, 0x5634e2db, 0x00000000, 0xb776d5f5,\n  0x00000000, 0xffffffff, 0x00000001, 0x00000000, 0x0000ffff, 0xffffffff,\n  0x00010000, 0x00000000, 0x000fffff, 0xffffffff, 0x00100000, 0x00000000,\n  0x5634e2db, 0xb776d5f5, 0x7fffffff, 0xffffffff\n])\n\nvar TEST_ADD_BITS = i32array([\n  0x3776d5f5, 0x5634e2db, 0x7fefffff, 0xffffffff, 0xb766d5f5, 0x5634e2da,\n  0x7ff00000, 0x00000000, 0xb766d5f5, 0x5634e2db, 0xffdfffff, 0xffffffff,\n  0x7ffeffff, 0xffffffff, 0xb775d5f5, 0x5634e2da, 0xffeeffff, 0xfffffffe,\n  0xffeeffff, 0xffffffff, 0x7fff0000, 0x00000000, 0xb775d5f5, 0x5634e2db,\n  0xffeeffff, 0xffffffff, 0xffef0000, 0x00000000, 0xfffdffff, 0xffffffff,\n  0x7ffffffe, 0xffffffff, 0xb776d5f4, 0x5634e2da, 0xffeffffe, 0xfffffffe,\n  0xffeffffe, 0xffffffff, 0xfffefffe, 0xfffffffe, 0xfffefffe, 0xffffffff,\n  0x7fffffff, 0x00000000, 0xb776d5f4, 0x5634e2db, 0xffeffffe, 0xffffffff,\n  0xffefffff, 0x00000000, 0xfffefffe, 0xffffffff, 0xfffeffff, 0x00000000,\n  0xfffffffd, 0xffffffff, 0x7fffffff, 0xfeffffff, 0xb776d5f5, 0x5534e2da,\n  0xffefffff, 0xfefffffe, 0xffefffff, 0xfeffffff, 0xfffeffff, 0xfefffffe,\n  0xfffeffff, 0xfeffffff, 0xfffffffe, 0xfefffffe, 0xfffffffe, 0xfeffffff,\n  0x7fffffff, 0xff000000, 0xb776d5f5, 0x5534e2db, 0xffefffff, 0xfeffffff,\n  0xffefffff, 0xff000000, 0xfffeffff, 0xfeffffff, 0xfffeffff, 0xff000000,\n  0xfffffffe, 0xfeffffff, 0xfffffffe, 0xff000000, 0xffffffff, 0xfdffffff,\n  0x7fffffff, 0xfffeffff, 0xb776d5f5, 0x5633e2da, 0xffefffff, 0xfffefffe,\n  0xffefffff, 0xfffeffff, 0xfffeffff, 0xfffefffe, 0xfffeffff, 0xfffeffff,\n  0xfffffffe, 0xfffefffe, 0xfffffffe, 0xfffeffff, 0xffffffff, 0xfefefffe,\n  0xffffffff, 0xfefeffff, 0x7fffffff, 0xffff0000, 0xb776d5f5, 0x5633e2db,\n  0xffefffff, 0xfffeffff, 0xffefffff, 0xffff0000, 0xfffeffff, 0xfffeffff,\n  0xfffeffff, 0xffff0000, 0xfffffffe, 0xfffeffff, 0xfffffffe, 0xffff0000,\n  0xffffffff, 0xfefeffff, 0xffffffff, 0xfeff0000, 0xffffffff, 0xfffdffff,\n  0x7fffffff, 0xffff7fff, 0xb776d5f5, 0x563462da, 0xffefffff, 0xffff7ffe,\n  0xffefffff, 0xffff7fff, 0xfffeffff, 0xffff7ffe, 0xfffeffff, 0xffff7fff,\n  0xfffffffe, 0xffff7ffe, 0xfffffffe, 0xffff7fff, 0xffffffff, 0xfeff7ffe,\n  0xffffffff, 0xfeff7fff, 0xffffffff, 0xfffe7ffe, 0xffffffff, 0xfffe7fff,\n  0x7fffffff, 0xffff8000, 0xb776d5f5, 0x563462db, 0xffefffff, 0xffff7fff,\n  0xffefffff, 0xffff8000, 0xfffeffff, 0xffff7fff, 0xfffeffff, 0xffff8000,\n  0xfffffffe, 0xffff7fff, 0xfffffffe, 0xffff8000, 0xffffffff, 0xfeff7fff,\n  0xffffffff, 0xfeff8000, 0xffffffff, 0xfffe7fff, 0xffffffff, 0xfffe8000,\n  0xffffffff, 0xfffeffff, 0x7fffffff, 0xfffffffe, 0xb776d5f5, 0x5634e2d9,\n  0xffefffff, 0xfffffffd, 0xffefffff, 0xfffffffe, 0xfffeffff, 0xfffffffd,\n  0xfffeffff, 0xfffffffe, 0xfffffffe, 0xfffffffd, 0xfffffffe, 0xfffffffe,\n  0xffffffff, 0xfefffffd, 0xffffffff, 0xfefffffe, 0xffffffff, 0xfffefffd,\n  0xffffffff, 0xfffefffe, 0xffffffff, 0xffff7ffd, 0xffffffff, 0xffff7ffe,\n  0x7fffffff, 0xffffffff, 0xb776d5f5, 0x5634e2da, 0xffefffff, 0xfffffffe,\n  0xffefffff, 0xffffffff, 0xfffeffff, 0xfffffffe, 0xfffeffff, 0xffffffff,\n  0xfffffffe, 0xfffffffe, 0xfffffffe, 0xffffffff, 0xffffffff, 0xfefffffe,\n  0xffffffff, 0xfeffffff, 0xffffffff, 0xfffefffe, 0xffffffff, 0xfffeffff,\n  0xffffffff, 0xffff7ffe, 0xffffffff, 0xffff7fff, 0xffffffff, 0xfffffffd,\n  0x80000000, 0x00000000, 0xb776d5f5, 0x5634e2db, 0xffefffff, 0xffffffff,\n  0xfff00000, 0x00000000, 0xfffeffff, 0xffffffff, 0xffff0000, 0x00000000,\n  0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0xffffffff, 0xfeffffff,\n  0xffffffff, 0xff000000, 0xffffffff, 0xfffeffff, 0xffffffff, 0xffff0000,\n  0xffffffff, 0xffff7fff, 0xffffffff, 0xffff8000, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffffffff, 0x80000000, 0x00000001, 0xb776d5f5, 0x5634e2dc,\n  0xfff00000, 0x00000000, 0xfff00000, 0x00000001, 0xffff0000, 0x00000000,\n  0xffff0000, 0x00000001, 0xffffffff, 0x00000000, 0xffffffff, 0x00000001,\n  0xffffffff, 0xff000000, 0xffffffff, 0xff000001, 0xffffffff, 0xffff0000,\n  0xffffffff, 0xffff0001, 0xffffffff, 0xffff8000, 0xffffffff, 0xffff8001,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x80000000, 0x00000002, 0xb776d5f5, 0x5634e2dd, 0xfff00000, 0x00000001,\n  0xfff00000, 0x00000002, 0xffff0000, 0x00000001, 0xffff0000, 0x00000002,\n  0xffffffff, 0x00000001, 0xffffffff, 0x00000002, 0xffffffff, 0xff000001,\n  0xffffffff, 0xff000002, 0xffffffff, 0xffff0001, 0xffffffff, 0xffff0002,\n  0xffffffff, 0xffff8001, 0xffffffff, 0xffff8002, 0x00000000, 0x00000000,\n  0x00000000, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000003,\n  0x80000000, 0x00007fff, 0xb776d5f5, 0x563562da, 0xfff00000, 0x00007ffe,\n  0xfff00000, 0x00007fff, 0xffff0000, 0x00007ffe, 0xffff0000, 0x00007fff,\n  0xffffffff, 0x00007ffe, 0xffffffff, 0x00007fff, 0xffffffff, 0xff007ffe,\n  0xffffffff, 0xff007fff, 0xffffffff, 0xffff7ffe, 0xffffffff, 0xffff7fff,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0x00007ffd,\n  0x00000000, 0x00007ffe, 0x00000000, 0x00007fff, 0x00000000, 0x00008000,\n  0x00000000, 0x00008001, 0x80000000, 0x00008000, 0xb776d5f5, 0x563562db,\n  0xfff00000, 0x00007fff, 0xfff00000, 0x00008000, 0xffff0000, 0x00007fff,\n  0xffff0000, 0x00008000, 0xffffffff, 0x00007fff, 0xffffffff, 0x00008000,\n  0xffffffff, 0xff007fff, 0xffffffff, 0xff008000, 0xffffffff, 0xffff7fff,\n  0xffffffff, 0xffff8000, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00007ffe, 0x00000000, 0x00007fff, 0x00000000, 0x00008000,\n  0x00000000, 0x00008001, 0x00000000, 0x00008002, 0x00000000, 0x0000ffff,\n  0x80000000, 0x0000ffff, 0xb776d5f5, 0x5635e2da, 0xfff00000, 0x0000fffe,\n  0xfff00000, 0x0000ffff, 0xffff0000, 0x0000fffe, 0xffff0000, 0x0000ffff,\n  0xffffffff, 0x0000fffe, 0xffffffff, 0x0000ffff, 0xffffffff, 0xff00fffe,\n  0xffffffff, 0xff00ffff, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff,\n  0x00000000, 0x00007ffe, 0x00000000, 0x00007fff, 0x00000000, 0x0000fffd,\n  0x00000000, 0x0000fffe, 0x00000000, 0x0000ffff, 0x00000000, 0x00010000,\n  0x00000000, 0x00010001, 0x00000000, 0x00017ffe, 0x00000000, 0x00017fff,\n  0x80000000, 0x00010000, 0xb776d5f5, 0x5635e2db, 0xfff00000, 0x0000ffff,\n  0xfff00000, 0x00010000, 0xffff0000, 0x0000ffff, 0xffff0000, 0x00010000,\n  0xffffffff, 0x0000ffff, 0xffffffff, 0x00010000, 0xffffffff, 0xff00ffff,\n  0xffffffff, 0xff010000, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00007fff, 0x00000000, 0x00008000, 0x00000000, 0x0000fffe,\n  0x00000000, 0x0000ffff, 0x00000000, 0x00010000, 0x00000000, 0x00010001,\n  0x00000000, 0x00010002, 0x00000000, 0x00017fff, 0x00000000, 0x00018000,\n  0x00000000, 0x0001ffff, 0x80000000, 0x00ffffff, 0xb776d5f5, 0x5734e2da,\n  0xfff00000, 0x00fffffe, 0xfff00000, 0x00ffffff, 0xffff0000, 0x00fffffe,\n  0xffff0000, 0x00ffffff, 0xffffffff, 0x00fffffe, 0xffffffff, 0x00ffffff,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0x00fefffe,\n  0x00000000, 0x00feffff, 0x00000000, 0x00ff7ffe, 0x00000000, 0x00ff7fff,\n  0x00000000, 0x00fffffd, 0x00000000, 0x00fffffe, 0x00000000, 0x00ffffff,\n  0x00000000, 0x01000000, 0x00000000, 0x01000001, 0x00000000, 0x01007ffe,\n  0x00000000, 0x01007fff, 0x00000000, 0x0100fffe, 0x00000000, 0x0100ffff,\n  0x80000000, 0x01000000, 0xb776d5f5, 0x5734e2db, 0xfff00000, 0x00ffffff,\n  0xfff00000, 0x01000000, 0xffff0000, 0x00ffffff, 0xffff0000, 0x01000000,\n  0xffffffff, 0x00ffffff, 0xffffffff, 0x01000000, 0xffffffff, 0xffffffff,\n  0x00000000, 0x00000000, 0x00000000, 0x00feffff, 0x00000000, 0x00ff0000,\n  0x00000000, 0x00ff7fff, 0x00000000, 0x00ff8000, 0x00000000, 0x00fffffe,\n  0x00000000, 0x00ffffff, 0x00000000, 0x01000000, 0x00000000, 0x01000001,\n  0x00000000, 0x01000002, 0x00000000, 0x01007fff, 0x00000000, 0x01008000,\n  0x00000000, 0x0100ffff, 0x00000000, 0x01010000, 0x00000000, 0x01ffffff,\n  0x80000000, 0x5634e2db, 0xb776d5f5, 0xac69c5b6, 0xfff00000, 0x5634e2da,\n  0xfff00000, 0x5634e2db, 0xffff0000, 0x5634e2da, 0xffff0000, 0x5634e2db,\n  0xffffffff, 0x5634e2da, 0xffffffff, 0x5634e2db, 0x00000000, 0x5534e2da,\n  0x00000000, 0x5534e2db, 0x00000000, 0x5633e2da, 0x00000000, 0x5633e2db,\n  0x00000000, 0x563462da, 0x00000000, 0x563462db, 0x00000000, 0x5634e2d9,\n  0x00000000, 0x5634e2da, 0x00000000, 0x5634e2db, 0x00000000, 0x5634e2dc,\n  0x00000000, 0x5634e2dd, 0x00000000, 0x563562da, 0x00000000, 0x563562db,\n  0x00000000, 0x5635e2da, 0x00000000, 0x5635e2db, 0x00000000, 0x5734e2da,\n  0x00000000, 0x5734e2db, 0x80000000, 0xb776d5f5, 0xb776d5f6, 0x0dabb8d0,\n  0xfff00000, 0xb776d5f4, 0xfff00000, 0xb776d5f5, 0xffff0000, 0xb776d5f4,\n  0xffff0000, 0xb776d5f5, 0xffffffff, 0xb776d5f4, 0xffffffff, 0xb776d5f5,\n  0x00000000, 0xb676d5f4, 0x00000000, 0xb676d5f5, 0x00000000, 0xb775d5f4,\n  0x00000000, 0xb775d5f5, 0x00000000, 0xb77655f4, 0x00000000, 0xb77655f5,\n  0x00000000, 0xb776d5f3, 0x00000000, 0xb776d5f4, 0x00000000, 0xb776d5f5,\n  0x00000000, 0xb776d5f6, 0x00000000, 0xb776d5f7, 0x00000000, 0xb77755f4,\n  0x00000000, 0xb77755f5, 0x00000000, 0xb777d5f4, 0x00000000, 0xb777d5f5,\n  0x00000000, 0xb876d5f4, 0x00000000, 0xb876d5f5, 0x00000001, 0x0dabb8d0,\n  0x80000000, 0xffffffff, 0xb776d5f6, 0x5634e2da, 0xfff00000, 0xfffffffe,\n  0xfff00000, 0xffffffff, 0xffff0000, 0xfffffffe, 0xffff0000, 0xffffffff,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0xfefffffe,\n  0x00000000, 0xfeffffff, 0x00000000, 0xfffefffe, 0x00000000, 0xfffeffff,\n  0x00000000, 0xffff7ffe, 0x00000000, 0xffff7fff, 0x00000000, 0xfffffffd,\n  0x00000000, 0xfffffffe, 0x00000000, 0xffffffff, 0x00000001, 0x00000000,\n  0x00000001, 0x00000001, 0x00000001, 0x00007ffe, 0x00000001, 0x00007fff,\n  0x00000001, 0x0000fffe, 0x00000001, 0x0000ffff, 0x00000001, 0x00fffffe,\n  0x00000001, 0x00ffffff, 0x00000001, 0x5634e2da, 0x00000001, 0xb776d5f4,\n  0x80000001, 0x00000000, 0xb776d5f6, 0x5634e2db, 0xfff00000, 0xffffffff,\n  0xfff00001, 0x00000000, 0xffff0000, 0xffffffff, 0xffff0001, 0x00000000,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0xfeffffff,\n  0x00000000, 0xff000000, 0x00000000, 0xfffeffff, 0x00000000, 0xffff0000,\n  0x00000000, 0xffff7fff, 0x00000000, 0xffff8000, 0x00000000, 0xfffffffe,\n  0x00000000, 0xffffffff, 0x00000001, 0x00000000, 0x00000001, 0x00000001,\n  0x00000001, 0x00000002, 0x00000001, 0x00007fff, 0x00000001, 0x00008000,\n  0x00000001, 0x0000ffff, 0x00000001, 0x00010000, 0x00000001, 0x00ffffff,\n  0x00000001, 0x01000000, 0x00000001, 0x5634e2db, 0x00000001, 0xb776d5f5,\n  0x00000001, 0xffffffff, 0x8000ffff, 0xffffffff, 0xb777d5f5, 0x5634e2da,\n  0xfff0ffff, 0xfffffffe, 0xfff0ffff, 0xffffffff, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffffffff, 0x0000fffe, 0xfffffffe, 0x0000fffe, 0xffffffff,\n  0x0000ffff, 0xfefffffe, 0x0000ffff, 0xfeffffff, 0x0000ffff, 0xfffefffe,\n  0x0000ffff, 0xfffeffff, 0x0000ffff, 0xffff7ffe, 0x0000ffff, 0xffff7fff,\n  0x0000ffff, 0xfffffffd, 0x0000ffff, 0xfffffffe, 0x0000ffff, 0xffffffff,\n  0x00010000, 0x00000000, 0x00010000, 0x00000001, 0x00010000, 0x00007ffe,\n  0x00010000, 0x00007fff, 0x00010000, 0x0000fffe, 0x00010000, 0x0000ffff,\n  0x00010000, 0x00fffffe, 0x00010000, 0x00ffffff, 0x00010000, 0x5634e2da,\n  0x00010000, 0xb776d5f4, 0x00010000, 0xfffffffe, 0x00010000, 0xffffffff,\n  0x80010000, 0x00000000, 0xb777d5f5, 0x5634e2db, 0xfff0ffff, 0xffffffff,\n  0xfff10000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x0000fffe, 0xffffffff, 0x0000ffff, 0x00000000, 0x0000ffff, 0xfeffffff,\n  0x0000ffff, 0xff000000, 0x0000ffff, 0xfffeffff, 0x0000ffff, 0xffff0000,\n  0x0000ffff, 0xffff7fff, 0x0000ffff, 0xffff8000, 0x0000ffff, 0xfffffffe,\n  0x0000ffff, 0xffffffff, 0x00010000, 0x00000000, 0x00010000, 0x00000001,\n  0x00010000, 0x00000002, 0x00010000, 0x00007fff, 0x00010000, 0x00008000,\n  0x00010000, 0x0000ffff, 0x00010000, 0x00010000, 0x00010000, 0x00ffffff,\n  0x00010000, 0x01000000, 0x00010000, 0x5634e2db, 0x00010000, 0xb776d5f5,\n  0x00010000, 0xffffffff, 0x00010001, 0x00000000, 0x0001ffff, 0xffffffff,\n  0x800fffff, 0xffffffff, 0xb786d5f5, 0x5634e2da, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffffffff, 0x000effff, 0xfffffffe, 0x000effff, 0xffffffff,\n  0x000ffffe, 0xfffffffe, 0x000ffffe, 0xffffffff, 0x000fffff, 0xfefffffe,\n  0x000fffff, 0xfeffffff, 0x000fffff, 0xfffefffe, 0x000fffff, 0xfffeffff,\n  0x000fffff, 0xffff7ffe, 0x000fffff, 0xffff7fff, 0x000fffff, 0xfffffffd,\n  0x000fffff, 0xfffffffe, 0x000fffff, 0xffffffff, 0x00100000, 0x00000000,\n  0x00100000, 0x00000001, 0x00100000, 0x00007ffe, 0x00100000, 0x00007fff,\n  0x00100000, 0x0000fffe, 0x00100000, 0x0000ffff, 0x00100000, 0x00fffffe,\n  0x00100000, 0x00ffffff, 0x00100000, 0x5634e2da, 0x00100000, 0xb776d5f4,\n  0x00100000, 0xfffffffe, 0x00100000, 0xffffffff, 0x0010ffff, 0xfffffffe,\n  0x0010ffff, 0xffffffff, 0x80100000, 0x00000000, 0xb786d5f5, 0x5634e2db,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x000effff, 0xffffffff,\n  0x000f0000, 0x00000000, 0x000ffffe, 0xffffffff, 0x000fffff, 0x00000000,\n  0x000fffff, 0xfeffffff, 0x000fffff, 0xff000000, 0x000fffff, 0xfffeffff,\n  0x000fffff, 0xffff0000, 0x000fffff, 0xffff7fff, 0x000fffff, 0xffff8000,\n  0x000fffff, 0xfffffffe, 0x000fffff, 0xffffffff, 0x00100000, 0x00000000,\n  0x00100000, 0x00000001, 0x00100000, 0x00000002, 0x00100000, 0x00007fff,\n  0x00100000, 0x00008000, 0x00100000, 0x0000ffff, 0x00100000, 0x00010000,\n  0x00100000, 0x00ffffff, 0x00100000, 0x01000000, 0x00100000, 0x5634e2db,\n  0x00100000, 0xb776d5f5, 0x00100000, 0xffffffff, 0x00100001, 0x00000000,\n  0x0010ffff, 0xffffffff, 0x00110000, 0x00000000, 0x001fffff, 0xffffffff,\n  0xd634e2db, 0xb776d5f5, 0x0dabb8d1, 0x0dabb8d0, 0x5624e2db, 0xb776d5f4,\n  0x5624e2db, 0xb776d5f5, 0x5633e2db, 0xb776d5f4, 0x5633e2db, 0xb776d5f5,\n  0x5634e2da, 0xb776d5f4, 0x5634e2da, 0xb776d5f5, 0x5634e2db, 0xb676d5f4,\n  0x5634e2db, 0xb676d5f5, 0x5634e2db, 0xb775d5f4, 0x5634e2db, 0xb775d5f5,\n  0x5634e2db, 0xb77655f4, 0x5634e2db, 0xb77655f5, 0x5634e2db, 0xb776d5f3,\n  0x5634e2db, 0xb776d5f4, 0x5634e2db, 0xb776d5f5, 0x5634e2db, 0xb776d5f6,\n  0x5634e2db, 0xb776d5f7, 0x5634e2db, 0xb77755f4, 0x5634e2db, 0xb77755f5,\n  0x5634e2db, 0xb777d5f4, 0x5634e2db, 0xb777d5f5, 0x5634e2db, 0xb876d5f4,\n  0x5634e2db, 0xb876d5f5, 0x5634e2dc, 0x0dabb8d0, 0x5634e2dc, 0x6eedabea,\n  0x5634e2dc, 0xb776d5f4, 0x5634e2dc, 0xb776d5f5, 0x5635e2db, 0xb776d5f4,\n  0x5635e2db, 0xb776d5f5, 0x5644e2db, 0xb776d5f4, 0x5644e2db, 0xb776d5f5,\n  0xffffffff, 0xffffffff, 0x3776d5f5, 0x5634e2da, 0x7fefffff, 0xfffffffe,\n  0x7fefffff, 0xffffffff, 0x7ffeffff, 0xfffffffe, 0x7ffeffff, 0xffffffff,\n  0x7ffffffe, 0xfffffffe, 0x7ffffffe, 0xffffffff, 0x7fffffff, 0xfefffffe,\n  0x7fffffff, 0xfeffffff, 0x7fffffff, 0xfffefffe, 0x7fffffff, 0xfffeffff,\n  0x7fffffff, 0xffff7ffe, 0x7fffffff, 0xffff7fff, 0x7fffffff, 0xfffffffd,\n  0x7fffffff, 0xfffffffe, 0x7fffffff, 0xffffffff, 0x80000000, 0x00000000,\n  0x80000000, 0x00000001, 0x80000000, 0x00007ffe, 0x80000000, 0x00007fff,\n  0x80000000, 0x0000fffe, 0x80000000, 0x0000ffff, 0x80000000, 0x00fffffe,\n  0x80000000, 0x00ffffff, 0x80000000, 0x5634e2da, 0x80000000, 0xb776d5f4,\n  0x80000000, 0xfffffffe, 0x80000000, 0xffffffff, 0x8000ffff, 0xfffffffe,\n  0x8000ffff, 0xffffffff, 0x800fffff, 0xfffffffe, 0x800fffff, 0xffffffff,\n  0xd634e2db, 0xb776d5f4\n])\n\nvar TEST_SUB_BITS = i32array([\n  0x00000000, 0x00000000, 0xc8892a0a, 0xa9cb1d25, 0x80100000, 0x00000001,\n  0x80100000, 0x00000000, 0x80010000, 0x00000001, 0x80010000, 0x00000000,\n  0x80000001, 0x00000001, 0x80000001, 0x00000000, 0x80000000, 0x01000001,\n  0x80000000, 0x01000000, 0x80000000, 0x00010001, 0x80000000, 0x00010000,\n  0x80000000, 0x00008001, 0x80000000, 0x00008000, 0x80000000, 0x00000002,\n  0x80000000, 0x00000001, 0x80000000, 0x00000000, 0x7fffffff, 0xffffffff,\n  0x7fffffff, 0xfffffffe, 0x7fffffff, 0xffff8001, 0x7fffffff, 0xffff8000,\n  0x7fffffff, 0xffff0001, 0x7fffffff, 0xffff0000, 0x7fffffff, 0xff000001,\n  0x7fffffff, 0xff000000, 0x7fffffff, 0xa9cb1d25, 0x7fffffff, 0x48892a0b,\n  0x7fffffff, 0x00000001, 0x7fffffff, 0x00000000, 0x7fff0000, 0x00000001,\n  0x7fff0000, 0x00000000, 0x7ff00000, 0x00000001, 0x7ff00000, 0x00000000,\n  0x29cb1d24, 0x48892a0b, 0x00000000, 0x00000001, 0x3776d5f5, 0x5634e2db,\n  0x00000000, 0x00000000, 0xb786d5f5, 0x5634e2dc, 0xb786d5f5, 0x5634e2db,\n  0xb777d5f5, 0x5634e2dc, 0xb777d5f5, 0x5634e2db, 0xb776d5f6, 0x5634e2dc,\n  0xb776d5f6, 0x5634e2db, 0xb776d5f5, 0x5734e2dc, 0xb776d5f5, 0x5734e2db,\n  0xb776d5f5, 0x5635e2dc, 0xb776d5f5, 0x5635e2db, 0xb776d5f5, 0x563562dc,\n  0xb776d5f5, 0x563562db, 0xb776d5f5, 0x5634e2dd, 0xb776d5f5, 0x5634e2dc,\n  0xb776d5f5, 0x5634e2db, 0xb776d5f5, 0x5634e2da, 0xb776d5f5, 0x5634e2d9,\n  0xb776d5f5, 0x563462dc, 0xb776d5f5, 0x563462db, 0xb776d5f5, 0x5633e2dc,\n  0xb776d5f5, 0x5633e2db, 0xb776d5f5, 0x5534e2dc, 0xb776d5f5, 0x5534e2db,\n  0xb776d5f5, 0x00000000, 0xb776d5f4, 0x9ebe0ce6, 0xb776d5f4, 0x5634e2dc,\n  0xb776d5f4, 0x5634e2db, 0xb775d5f5, 0x5634e2dc, 0xb775d5f5, 0x5634e2db,\n  0xb766d5f5, 0x5634e2dc, 0xb766d5f5, 0x5634e2db, 0x6141f319, 0x9ebe0ce6,\n  0x3776d5f5, 0x5634e2dc, 0x7fefffff, 0xffffffff, 0x48792a0a, 0xa9cb1d24,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xfff10000, 0x00000000,\n  0xfff0ffff, 0xffffffff, 0xfff00001, 0x00000000, 0xfff00000, 0xffffffff,\n  0xfff00000, 0x01000000, 0xfff00000, 0x00ffffff, 0xfff00000, 0x00010000,\n  0xfff00000, 0x0000ffff, 0xfff00000, 0x00008000, 0xfff00000, 0x00007fff,\n  0xfff00000, 0x00000001, 0xfff00000, 0x00000000, 0xffefffff, 0xffffffff,\n  0xffefffff, 0xfffffffe, 0xffefffff, 0xfffffffd, 0xffefffff, 0xffff8000,\n  0xffefffff, 0xffff7fff, 0xffefffff, 0xffff0000, 0xffefffff, 0xfffeffff,\n  0xffefffff, 0xff000000, 0xffefffff, 0xfeffffff, 0xffefffff, 0xa9cb1d24,\n  0xffefffff, 0x48892a0a, 0xffefffff, 0x00000000, 0xffeffffe, 0xffffffff,\n  0xffef0000, 0x00000000, 0xffeeffff, 0xffffffff, 0xffe00000, 0x00000000,\n  0xffdfffff, 0xffffffff, 0xa9bb1d24, 0x48892a0a, 0x7ff00000, 0x00000000,\n  0x7ff00000, 0x00000000, 0x48792a0a, 0xa9cb1d25, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xfff10000, 0x00000001, 0xfff10000, 0x00000000,\n  0xfff00001, 0x00000001, 0xfff00001, 0x00000000, 0xfff00000, 0x01000001,\n  0xfff00000, 0x01000000, 0xfff00000, 0x00010001, 0xfff00000, 0x00010000,\n  0xfff00000, 0x00008001, 0xfff00000, 0x00008000, 0xfff00000, 0x00000002,\n  0xfff00000, 0x00000001, 0xfff00000, 0x00000000, 0xffefffff, 0xffffffff,\n  0xffefffff, 0xfffffffe, 0xffefffff, 0xffff8001, 0xffefffff, 0xffff8000,\n  0xffefffff, 0xffff0001, 0xffefffff, 0xffff0000, 0xffefffff, 0xff000001,\n  0xffefffff, 0xff000000, 0xffefffff, 0xa9cb1d25, 0xffefffff, 0x48892a0b,\n  0xffefffff, 0x00000001, 0xffefffff, 0x00000000, 0xffef0000, 0x00000001,\n  0xffef0000, 0x00000000, 0xffe00000, 0x00000001, 0xffe00000, 0x00000000,\n  0xa9bb1d24, 0x48892a0b, 0x7ff00000, 0x00000001, 0x7ffeffff, 0xffffffff,\n  0x48882a0a, 0xa9cb1d24, 0x000f0000, 0x00000000, 0x000effff, 0xffffffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffff0001, 0x00000000,\n  0xffff0000, 0xffffffff, 0xffff0000, 0x01000000, 0xffff0000, 0x00ffffff,\n  0xffff0000, 0x00010000, 0xffff0000, 0x0000ffff, 0xffff0000, 0x00008000,\n  0xffff0000, 0x00007fff, 0xffff0000, 0x00000001, 0xffff0000, 0x00000000,\n  0xfffeffff, 0xffffffff, 0xfffeffff, 0xfffffffe, 0xfffeffff, 0xfffffffd,\n  0xfffeffff, 0xffff8000, 0xfffeffff, 0xffff7fff, 0xfffeffff, 0xffff0000,\n  0xfffeffff, 0xfffeffff, 0xfffeffff, 0xff000000, 0xfffeffff, 0xfeffffff,\n  0xfffeffff, 0xa9cb1d24, 0xfffeffff, 0x48892a0a, 0xfffeffff, 0x00000000,\n  0xfffefffe, 0xffffffff, 0xfffe0000, 0x00000000, 0xfffdffff, 0xffffffff,\n  0xffef0000, 0x00000000, 0xffeeffff, 0xffffffff, 0xa9ca1d24, 0x48892a0a,\n  0x7fff0000, 0x00000000, 0x7fff0000, 0x00000000, 0x48882a0a, 0xa9cb1d25,\n  0x000f0000, 0x00000001, 0x000f0000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffff0001, 0x00000001, 0xffff0001, 0x00000000,\n  0xffff0000, 0x01000001, 0xffff0000, 0x01000000, 0xffff0000, 0x00010001,\n  0xffff0000, 0x00010000, 0xffff0000, 0x00008001, 0xffff0000, 0x00008000,\n  0xffff0000, 0x00000002, 0xffff0000, 0x00000001, 0xffff0000, 0x00000000,\n  0xfffeffff, 0xffffffff, 0xfffeffff, 0xfffffffe, 0xfffeffff, 0xffff8001,\n  0xfffeffff, 0xffff8000, 0xfffeffff, 0xffff0001, 0xfffeffff, 0xffff0000,\n  0xfffeffff, 0xff000001, 0xfffeffff, 0xff000000, 0xfffeffff, 0xa9cb1d25,\n  0xfffeffff, 0x48892a0b, 0xfffeffff, 0x00000001, 0xfffeffff, 0x00000000,\n  0xfffe0000, 0x00000001, 0xfffe0000, 0x00000000, 0xffef0000, 0x00000001,\n  0xffef0000, 0x00000000, 0xa9ca1d24, 0x48892a0b, 0x7fff0000, 0x00000001,\n  0x7ffffffe, 0xffffffff, 0x48892a09, 0xa9cb1d24, 0x000fffff, 0x00000000,\n  0x000ffffe, 0xffffffff, 0x0000ffff, 0x00000000, 0x0000fffe, 0xffffffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0x01000000,\n  0xffffffff, 0x00ffffff, 0xffffffff, 0x00010000, 0xffffffff, 0x0000ffff,\n  0xffffffff, 0x00008000, 0xffffffff, 0x00007fff, 0xffffffff, 0x00000001,\n  0xffffffff, 0x00000000, 0xfffffffe, 0xffffffff, 0xfffffffe, 0xfffffffe,\n  0xfffffffe, 0xfffffffd, 0xfffffffe, 0xffff8000, 0xfffffffe, 0xffff7fff,\n  0xfffffffe, 0xffff0000, 0xfffffffe, 0xfffeffff, 0xfffffffe, 0xff000000,\n  0xfffffffe, 0xfeffffff, 0xfffffffe, 0xa9cb1d24, 0xfffffffe, 0x48892a0a,\n  0xfffffffe, 0x00000000, 0xfffffffd, 0xffffffff, 0xfffeffff, 0x00000000,\n  0xfffefffe, 0xffffffff, 0xffefffff, 0x00000000, 0xffeffffe, 0xffffffff,\n  0xa9cb1d23, 0x48892a0a, 0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000,\n  0x48892a09, 0xa9cb1d25, 0x000fffff, 0x00000001, 0x000fffff, 0x00000000,\n  0x0000ffff, 0x00000001, 0x0000ffff, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0x01000001, 0xffffffff, 0x01000000,\n  0xffffffff, 0x00010001, 0xffffffff, 0x00010000, 0xffffffff, 0x00008001,\n  0xffffffff, 0x00008000, 0xffffffff, 0x00000002, 0xffffffff, 0x00000001,\n  0xffffffff, 0x00000000, 0xfffffffe, 0xffffffff, 0xfffffffe, 0xfffffffe,\n  0xfffffffe, 0xffff8001, 0xfffffffe, 0xffff8000, 0xfffffffe, 0xffff0001,\n  0xfffffffe, 0xffff0000, 0xfffffffe, 0xff000001, 0xfffffffe, 0xff000000,\n  0xfffffffe, 0xa9cb1d25, 0xfffffffe, 0x48892a0b, 0xfffffffe, 0x00000001,\n  0xfffffffe, 0x00000000, 0xfffeffff, 0x00000001, 0xfffeffff, 0x00000000,\n  0xffefffff, 0x00000001, 0xffefffff, 0x00000000, 0xa9cb1d23, 0x48892a0b,\n  0x7fffffff, 0x00000001, 0x7fffffff, 0xfeffffff, 0x48892a0a, 0xa8cb1d24,\n  0x000fffff, 0xff000000, 0x000fffff, 0xfeffffff, 0x0000ffff, 0xff000000,\n  0x0000ffff, 0xfeffffff, 0x00000000, 0xff000000, 0x00000000, 0xfeffffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xff010000,\n  0xffffffff, 0xff00ffff, 0xffffffff, 0xff008000, 0xffffffff, 0xff007fff,\n  0xffffffff, 0xff000001, 0xffffffff, 0xff000000, 0xffffffff, 0xfeffffff,\n  0xffffffff, 0xfefffffe, 0xffffffff, 0xfefffffd, 0xffffffff, 0xfeff8000,\n  0xffffffff, 0xfeff7fff, 0xffffffff, 0xfeff0000, 0xffffffff, 0xfefeffff,\n  0xffffffff, 0xfe000000, 0xffffffff, 0xfdffffff, 0xffffffff, 0xa8cb1d24,\n  0xffffffff, 0x47892a0a, 0xfffffffe, 0xff000000, 0xfffffffe, 0xfeffffff,\n  0xfffeffff, 0xff000000, 0xfffeffff, 0xfeffffff, 0xffefffff, 0xff000000,\n  0xffefffff, 0xfeffffff, 0xa9cb1d24, 0x47892a0a, 0x7fffffff, 0xff000000,\n  0x7fffffff, 0xff000000, 0x48892a0a, 0xa8cb1d25, 0x000fffff, 0xff000001,\n  0x000fffff, 0xff000000, 0x0000ffff, 0xff000001, 0x0000ffff, 0xff000000,\n  0x00000000, 0xff000001, 0x00000000, 0xff000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xff010001, 0xffffffff, 0xff010000,\n  0xffffffff, 0xff008001, 0xffffffff, 0xff008000, 0xffffffff, 0xff000002,\n  0xffffffff, 0xff000001, 0xffffffff, 0xff000000, 0xffffffff, 0xfeffffff,\n  0xffffffff, 0xfefffffe, 0xffffffff, 0xfeff8001, 0xffffffff, 0xfeff8000,\n  0xffffffff, 0xfeff0001, 0xffffffff, 0xfeff0000, 0xffffffff, 0xfe000001,\n  0xffffffff, 0xfe000000, 0xffffffff, 0xa8cb1d25, 0xffffffff, 0x47892a0b,\n  0xfffffffe, 0xff000001, 0xfffffffe, 0xff000000, 0xfffeffff, 0xff000001,\n  0xfffeffff, 0xff000000, 0xffefffff, 0xff000001, 0xffefffff, 0xff000000,\n  0xa9cb1d24, 0x47892a0b, 0x7fffffff, 0xff000001, 0x7fffffff, 0xfffeffff,\n  0x48892a0a, 0xa9ca1d24, 0x000fffff, 0xffff0000, 0x000fffff, 0xfffeffff,\n  0x0000ffff, 0xffff0000, 0x0000ffff, 0xfffeffff, 0x00000000, 0xffff0000,\n  0x00000000, 0xfffeffff, 0x00000000, 0x00ff0000, 0x00000000, 0x00feffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xffff7fff, 0xffffffff, 0xffff0001, 0xffffffff, 0xffff0000,\n  0xffffffff, 0xfffeffff, 0xffffffff, 0xfffefffe, 0xffffffff, 0xfffefffd,\n  0xffffffff, 0xfffe8000, 0xffffffff, 0xfffe7fff, 0xffffffff, 0xfffe0000,\n  0xffffffff, 0xfffdffff, 0xffffffff, 0xfeff0000, 0xffffffff, 0xfefeffff,\n  0xffffffff, 0xa9ca1d24, 0xffffffff, 0x48882a0a, 0xfffffffe, 0xffff0000,\n  0xfffffffe, 0xfffeffff, 0xfffeffff, 0xffff0000, 0xfffeffff, 0xfffeffff,\n  0xffefffff, 0xffff0000, 0xffefffff, 0xfffeffff, 0xa9cb1d24, 0x48882a0a,\n  0x7fffffff, 0xffff0000, 0x7fffffff, 0xffff0000, 0x48892a0a, 0xa9ca1d25,\n  0x000fffff, 0xffff0001, 0x000fffff, 0xffff0000, 0x0000ffff, 0xffff0001,\n  0x0000ffff, 0xffff0000, 0x00000000, 0xffff0001, 0x00000000, 0xffff0000,\n  0x00000000, 0x00ff0001, 0x00000000, 0x00ff0000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffff8001, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xffff0002, 0xffffffff, 0xffff0001, 0xffffffff, 0xffff0000,\n  0xffffffff, 0xfffeffff, 0xffffffff, 0xfffefffe, 0xffffffff, 0xfffe8001,\n  0xffffffff, 0xfffe8000, 0xffffffff, 0xfffe0001, 0xffffffff, 0xfffe0000,\n  0xffffffff, 0xfeff0001, 0xffffffff, 0xfeff0000, 0xffffffff, 0xa9ca1d25,\n  0xffffffff, 0x48882a0b, 0xfffffffe, 0xffff0001, 0xfffffffe, 0xffff0000,\n  0xfffeffff, 0xffff0001, 0xfffeffff, 0xffff0000, 0xffefffff, 0xffff0001,\n  0xffefffff, 0xffff0000, 0xa9cb1d24, 0x48882a0b, 0x7fffffff, 0xffff0001,\n  0x7fffffff, 0xffff7fff, 0x48892a0a, 0xa9ca9d24, 0x000fffff, 0xffff8000,\n  0x000fffff, 0xffff7fff, 0x0000ffff, 0xffff8000, 0x0000ffff, 0xffff7fff,\n  0x00000000, 0xffff8000, 0x00000000, 0xffff7fff, 0x00000000, 0x00ff8000,\n  0x00000000, 0x00ff7fff, 0x00000000, 0x00008000, 0x00000000, 0x00007fff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffff8001,\n  0xffffffff, 0xffff8000, 0xffffffff, 0xffff7fff, 0xffffffff, 0xffff7ffe,\n  0xffffffff, 0xffff7ffd, 0xffffffff, 0xffff0000, 0xffffffff, 0xfffeffff,\n  0xffffffff, 0xfffe8000, 0xffffffff, 0xfffe7fff, 0xffffffff, 0xfeff8000,\n  0xffffffff, 0xfeff7fff, 0xffffffff, 0xa9ca9d24, 0xffffffff, 0x4888aa0a,\n  0xfffffffe, 0xffff8000, 0xfffffffe, 0xffff7fff, 0xfffeffff, 0xffff8000,\n  0xfffeffff, 0xffff7fff, 0xffefffff, 0xffff8000, 0xffefffff, 0xffff7fff,\n  0xa9cb1d24, 0x4888aa0a, 0x7fffffff, 0xffff8000, 0x7fffffff, 0xffff8000,\n  0x48892a0a, 0xa9ca9d25, 0x000fffff, 0xffff8001, 0x000fffff, 0xffff8000,\n  0x0000ffff, 0xffff8001, 0x0000ffff, 0xffff8000, 0x00000000, 0xffff8001,\n  0x00000000, 0xffff8000, 0x00000000, 0x00ff8001, 0x00000000, 0x00ff8000,\n  0x00000000, 0x00008001, 0x00000000, 0x00008000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffff8002, 0xffffffff, 0xffff8001,\n  0xffffffff, 0xffff8000, 0xffffffff, 0xffff7fff, 0xffffffff, 0xffff7ffe,\n  0xffffffff, 0xffff0001, 0xffffffff, 0xffff0000, 0xffffffff, 0xfffe8001,\n  0xffffffff, 0xfffe8000, 0xffffffff, 0xfeff8001, 0xffffffff, 0xfeff8000,\n  0xffffffff, 0xa9ca9d25, 0xffffffff, 0x4888aa0b, 0xfffffffe, 0xffff8001,\n  0xfffffffe, 0xffff8000, 0xfffeffff, 0xffff8001, 0xfffeffff, 0xffff8000,\n  0xffefffff, 0xffff8001, 0xffefffff, 0xffff8000, 0xa9cb1d24, 0x4888aa0b,\n  0x7fffffff, 0xffff8001, 0x7fffffff, 0xfffffffe, 0x48892a0a, 0xa9cb1d23,\n  0x000fffff, 0xffffffff, 0x000fffff, 0xfffffffe, 0x0000ffff, 0xffffffff,\n  0x0000ffff, 0xfffffffe, 0x00000000, 0xffffffff, 0x00000000, 0xfffffffe,\n  0x00000000, 0x00ffffff, 0x00000000, 0x00fffffe, 0x00000000, 0x0000ffff,\n  0x00000000, 0x0000fffe, 0x00000000, 0x00007fff, 0x00000000, 0x00007ffe,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xfffffffd, 0xffffffff, 0xfffffffc, 0xffffffff, 0xffff7fff,\n  0xffffffff, 0xffff7ffe, 0xffffffff, 0xfffeffff, 0xffffffff, 0xfffefffe,\n  0xffffffff, 0xfeffffff, 0xffffffff, 0xfefffffe, 0xffffffff, 0xa9cb1d23,\n  0xffffffff, 0x48892a09, 0xfffffffe, 0xffffffff, 0xfffffffe, 0xfffffffe,\n  0xfffeffff, 0xffffffff, 0xfffeffff, 0xfffffffe, 0xffefffff, 0xffffffff,\n  0xffefffff, 0xfffffffe, 0xa9cb1d24, 0x48892a09, 0x7fffffff, 0xffffffff,\n  0x7fffffff, 0xffffffff, 0x48892a0a, 0xa9cb1d24, 0x00100000, 0x00000000,\n  0x000fffff, 0xffffffff, 0x00010000, 0x00000000, 0x0000ffff, 0xffffffff,\n  0x00000001, 0x00000000, 0x00000000, 0xffffffff, 0x00000000, 0x01000000,\n  0x00000000, 0x00ffffff, 0x00000000, 0x00010000, 0x00000000, 0x0000ffff,\n  0x00000000, 0x00008000, 0x00000000, 0x00007fff, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xfffffffd, 0xffffffff, 0xffff8000, 0xffffffff, 0xffff7fff,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xfffeffff, 0xffffffff, 0xff000000,\n  0xffffffff, 0xfeffffff, 0xffffffff, 0xa9cb1d24, 0xffffffff, 0x48892a0a,\n  0xffffffff, 0x00000000, 0xfffffffe, 0xffffffff, 0xffff0000, 0x00000000,\n  0xfffeffff, 0xffffffff, 0xfff00000, 0x00000000, 0xffefffff, 0xffffffff,\n  0xa9cb1d24, 0x48892a0a, 0x80000000, 0x00000000, 0x80000000, 0x00000000,\n  0x48892a0a, 0xa9cb1d25, 0x00100000, 0x00000001, 0x00100000, 0x00000000,\n  0x00010000, 0x00000001, 0x00010000, 0x00000000, 0x00000001, 0x00000001,\n  0x00000001, 0x00000000, 0x00000000, 0x01000001, 0x00000000, 0x01000000,\n  0x00000000, 0x00010001, 0x00000000, 0x00010000, 0x00000000, 0x00008001,\n  0x00000000, 0x00008000, 0x00000000, 0x00000002, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffff8001, 0xffffffff, 0xffff8000, 0xffffffff, 0xffff0001,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xff000001, 0xffffffff, 0xff000000,\n  0xffffffff, 0xa9cb1d25, 0xffffffff, 0x48892a0b, 0xffffffff, 0x00000001,\n  0xffffffff, 0x00000000, 0xffff0000, 0x00000001, 0xffff0000, 0x00000000,\n  0xfff00000, 0x00000001, 0xfff00000, 0x00000000, 0xa9cb1d24, 0x48892a0b,\n  0x80000000, 0x00000001, 0x80000000, 0x00000001, 0x48892a0a, 0xa9cb1d26,\n  0x00100000, 0x00000002, 0x00100000, 0x00000001, 0x00010000, 0x00000002,\n  0x00010000, 0x00000001, 0x00000001, 0x00000002, 0x00000001, 0x00000001,\n  0x00000000, 0x01000002, 0x00000000, 0x01000001, 0x00000000, 0x00010002,\n  0x00000000, 0x00010001, 0x00000000, 0x00008002, 0x00000000, 0x00008001,\n  0x00000000, 0x00000003, 0x00000000, 0x00000002, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffff8002,\n  0xffffffff, 0xffff8001, 0xffffffff, 0xffff0002, 0xffffffff, 0xffff0001,\n  0xffffffff, 0xff000002, 0xffffffff, 0xff000001, 0xffffffff, 0xa9cb1d26,\n  0xffffffff, 0x48892a0c, 0xffffffff, 0x00000002, 0xffffffff, 0x00000001,\n  0xffff0000, 0x00000002, 0xffff0000, 0x00000001, 0xfff00000, 0x00000002,\n  0xfff00000, 0x00000001, 0xa9cb1d24, 0x48892a0c, 0x80000000, 0x00000002,\n  0x80000000, 0x00000002, 0x48892a0a, 0xa9cb1d27, 0x00100000, 0x00000003,\n  0x00100000, 0x00000002, 0x00010000, 0x00000003, 0x00010000, 0x00000002,\n  0x00000001, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x01000003,\n  0x00000000, 0x01000002, 0x00000000, 0x00010003, 0x00000000, 0x00010002,\n  0x00000000, 0x00008003, 0x00000000, 0x00008002, 0x00000000, 0x00000004,\n  0x00000000, 0x00000003, 0x00000000, 0x00000002, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffff8003, 0xffffffff, 0xffff8002,\n  0xffffffff, 0xffff0003, 0xffffffff, 0xffff0002, 0xffffffff, 0xff000003,\n  0xffffffff, 0xff000002, 0xffffffff, 0xa9cb1d27, 0xffffffff, 0x48892a0d,\n  0xffffffff, 0x00000003, 0xffffffff, 0x00000002, 0xffff0000, 0x00000003,\n  0xffff0000, 0x00000002, 0xfff00000, 0x00000003, 0xfff00000, 0x00000002,\n  0xa9cb1d24, 0x48892a0d, 0x80000000, 0x00000003, 0x80000000, 0x00007fff,\n  0x48892a0a, 0xa9cb9d24, 0x00100000, 0x00008000, 0x00100000, 0x00007fff,\n  0x00010000, 0x00008000, 0x00010000, 0x00007fff, 0x00000001, 0x00008000,\n  0x00000001, 0x00007fff, 0x00000000, 0x01008000, 0x00000000, 0x01007fff,\n  0x00000000, 0x00018000, 0x00000000, 0x00017fff, 0x00000000, 0x00010000,\n  0x00000000, 0x0000ffff, 0x00000000, 0x00008001, 0x00000000, 0x00008000,\n  0x00000000, 0x00007fff, 0x00000000, 0x00007ffe, 0x00000000, 0x00007ffd,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xffff7fff, 0xffffffff, 0xff008000, 0xffffffff, 0xff007fff,\n  0xffffffff, 0xa9cb9d24, 0xffffffff, 0x4889aa0a, 0xffffffff, 0x00008000,\n  0xffffffff, 0x00007fff, 0xffff0000, 0x00008000, 0xffff0000, 0x00007fff,\n  0xfff00000, 0x00008000, 0xfff00000, 0x00007fff, 0xa9cb1d24, 0x4889aa0a,\n  0x80000000, 0x00008000, 0x80000000, 0x00008000, 0x48892a0a, 0xa9cb9d25,\n  0x00100000, 0x00008001, 0x00100000, 0x00008000, 0x00010000, 0x00008001,\n  0x00010000, 0x00008000, 0x00000001, 0x00008001, 0x00000001, 0x00008000,\n  0x00000000, 0x01008001, 0x00000000, 0x01008000, 0x00000000, 0x00018001,\n  0x00000000, 0x00018000, 0x00000000, 0x00010001, 0x00000000, 0x00010000,\n  0x00000000, 0x00008002, 0x00000000, 0x00008001, 0x00000000, 0x00008000,\n  0x00000000, 0x00007fff, 0x00000000, 0x00007ffe, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xffff8001, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xff008001, 0xffffffff, 0xff008000, 0xffffffff, 0xa9cb9d25,\n  0xffffffff, 0x4889aa0b, 0xffffffff, 0x00008001, 0xffffffff, 0x00008000,\n  0xffff0000, 0x00008001, 0xffff0000, 0x00008000, 0xfff00000, 0x00008001,\n  0xfff00000, 0x00008000, 0xa9cb1d24, 0x4889aa0b, 0x80000000, 0x00008001,\n  0x80000000, 0x0000ffff, 0x48892a0a, 0xa9cc1d24, 0x00100000, 0x00010000,\n  0x00100000, 0x0000ffff, 0x00010000, 0x00010000, 0x00010000, 0x0000ffff,\n  0x00000001, 0x00010000, 0x00000001, 0x0000ffff, 0x00000000, 0x01010000,\n  0x00000000, 0x0100ffff, 0x00000000, 0x00020000, 0x00000000, 0x0001ffff,\n  0x00000000, 0x00018000, 0x00000000, 0x00017fff, 0x00000000, 0x00010001,\n  0x00000000, 0x00010000, 0x00000000, 0x0000ffff, 0x00000000, 0x0000fffe,\n  0x00000000, 0x0000fffd, 0x00000000, 0x00008000, 0x00000000, 0x00007fff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xff010000,\n  0xffffffff, 0xff00ffff, 0xffffffff, 0xa9cc1d24, 0xffffffff, 0x488a2a0a,\n  0xffffffff, 0x00010000, 0xffffffff, 0x0000ffff, 0xffff0000, 0x00010000,\n  0xffff0000, 0x0000ffff, 0xfff00000, 0x00010000, 0xfff00000, 0x0000ffff,\n  0xa9cb1d24, 0x488a2a0a, 0x80000000, 0x00010000, 0x80000000, 0x00010000,\n  0x48892a0a, 0xa9cc1d25, 0x00100000, 0x00010001, 0x00100000, 0x00010000,\n  0x00010000, 0x00010001, 0x00010000, 0x00010000, 0x00000001, 0x00010001,\n  0x00000001, 0x00010000, 0x00000000, 0x01010001, 0x00000000, 0x01010000,\n  0x00000000, 0x00020001, 0x00000000, 0x00020000, 0x00000000, 0x00018001,\n  0x00000000, 0x00018000, 0x00000000, 0x00010002, 0x00000000, 0x00010001,\n  0x00000000, 0x00010000, 0x00000000, 0x0000ffff, 0x00000000, 0x0000fffe,\n  0x00000000, 0x00008001, 0x00000000, 0x00008000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xff010001, 0xffffffff, 0xff010000,\n  0xffffffff, 0xa9cc1d25, 0xffffffff, 0x488a2a0b, 0xffffffff, 0x00010001,\n  0xffffffff, 0x00010000, 0xffff0000, 0x00010001, 0xffff0000, 0x00010000,\n  0xfff00000, 0x00010001, 0xfff00000, 0x00010000, 0xa9cb1d24, 0x488a2a0b,\n  0x80000000, 0x00010001, 0x80000000, 0x00ffffff, 0x48892a0a, 0xaacb1d24,\n  0x00100000, 0x01000000, 0x00100000, 0x00ffffff, 0x00010000, 0x01000000,\n  0x00010000, 0x00ffffff, 0x00000001, 0x01000000, 0x00000001, 0x00ffffff,\n  0x00000000, 0x02000000, 0x00000000, 0x01ffffff, 0x00000000, 0x01010000,\n  0x00000000, 0x0100ffff, 0x00000000, 0x01008000, 0x00000000, 0x01007fff,\n  0x00000000, 0x01000001, 0x00000000, 0x01000000, 0x00000000, 0x00ffffff,\n  0x00000000, 0x00fffffe, 0x00000000, 0x00fffffd, 0x00000000, 0x00ff8000,\n  0x00000000, 0x00ff7fff, 0x00000000, 0x00ff0000, 0x00000000, 0x00feffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xaacb1d24,\n  0xffffffff, 0x49892a0a, 0xffffffff, 0x01000000, 0xffffffff, 0x00ffffff,\n  0xffff0000, 0x01000000, 0xffff0000, 0x00ffffff, 0xfff00000, 0x01000000,\n  0xfff00000, 0x00ffffff, 0xa9cb1d24, 0x49892a0a, 0x80000000, 0x01000000,\n  0x80000000, 0x01000000, 0x48892a0a, 0xaacb1d25, 0x00100000, 0x01000001,\n  0x00100000, 0x01000000, 0x00010000, 0x01000001, 0x00010000, 0x01000000,\n  0x00000001, 0x01000001, 0x00000001, 0x01000000, 0x00000000, 0x02000001,\n  0x00000000, 0x02000000, 0x00000000, 0x01010001, 0x00000000, 0x01010000,\n  0x00000000, 0x01008001, 0x00000000, 0x01008000, 0x00000000, 0x01000002,\n  0x00000000, 0x01000001, 0x00000000, 0x01000000, 0x00000000, 0x00ffffff,\n  0x00000000, 0x00fffffe, 0x00000000, 0x00ff8001, 0x00000000, 0x00ff8000,\n  0x00000000, 0x00ff0001, 0x00000000, 0x00ff0000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffffffff, 0xaacb1d25, 0xffffffff, 0x49892a0b,\n  0xffffffff, 0x01000001, 0xffffffff, 0x01000000, 0xffff0000, 0x01000001,\n  0xffff0000, 0x01000000, 0xfff00000, 0x01000001, 0xfff00000, 0x01000000,\n  0xa9cb1d24, 0x49892a0b, 0x80000000, 0x01000001, 0x80000000, 0x5634e2db,\n  0x48892a0b, 0x00000000, 0x00100000, 0x5634e2dc, 0x00100000, 0x5634e2db,\n  0x00010000, 0x5634e2dc, 0x00010000, 0x5634e2db, 0x00000001, 0x5634e2dc,\n  0x00000001, 0x5634e2db, 0x00000000, 0x5734e2dc, 0x00000000, 0x5734e2db,\n  0x00000000, 0x5635e2dc, 0x00000000, 0x5635e2db, 0x00000000, 0x563562dc,\n  0x00000000, 0x563562db, 0x00000000, 0x5634e2dd, 0x00000000, 0x5634e2dc,\n  0x00000000, 0x5634e2db, 0x00000000, 0x5634e2da, 0x00000000, 0x5634e2d9,\n  0x00000000, 0x563462dc, 0x00000000, 0x563462db, 0x00000000, 0x5633e2dc,\n  0x00000000, 0x5633e2db, 0x00000000, 0x5534e2dc, 0x00000000, 0x5534e2db,\n  0x00000000, 0x00000000, 0xffffffff, 0x9ebe0ce6, 0xffffffff, 0x5634e2dc,\n  0xffffffff, 0x5634e2db, 0xffff0000, 0x5634e2dc, 0xffff0000, 0x5634e2db,\n  0xfff00000, 0x5634e2dc, 0xfff00000, 0x5634e2db, 0xa9cb1d24, 0x9ebe0ce6,\n  0x80000000, 0x5634e2dc, 0x80000000, 0xb776d5f5, 0x48892a0b, 0x6141f31a,\n  0x00100000, 0xb776d5f6, 0x00100000, 0xb776d5f5, 0x00010000, 0xb776d5f6,\n  0x00010000, 0xb776d5f5, 0x00000001, 0xb776d5f6, 0x00000001, 0xb776d5f5,\n  0x00000000, 0xb876d5f6, 0x00000000, 0xb876d5f5, 0x00000000, 0xb777d5f6,\n  0x00000000, 0xb777d5f5, 0x00000000, 0xb77755f6, 0x00000000, 0xb77755f5,\n  0x00000000, 0xb776d5f7, 0x00000000, 0xb776d5f6, 0x00000000, 0xb776d5f5,\n  0x00000000, 0xb776d5f4, 0x00000000, 0xb776d5f3, 0x00000000, 0xb77655f6,\n  0x00000000, 0xb77655f5, 0x00000000, 0xb775d5f6, 0x00000000, 0xb775d5f5,\n  0x00000000, 0xb676d5f6, 0x00000000, 0xb676d5f5, 0x00000000, 0x6141f31a,\n  0x00000000, 0x00000000, 0xffffffff, 0xb776d5f6, 0xffffffff, 0xb776d5f5,\n  0xffff0000, 0xb776d5f6, 0xffff0000, 0xb776d5f5, 0xfff00000, 0xb776d5f6,\n  0xfff00000, 0xb776d5f5, 0xa9cb1d25, 0x00000000, 0x80000000, 0xb776d5f6,\n  0x80000000, 0xffffffff, 0x48892a0b, 0xa9cb1d24, 0x00100001, 0x00000000,\n  0x00100000, 0xffffffff, 0x00010001, 0x00000000, 0x00010000, 0xffffffff,\n  0x00000002, 0x00000000, 0x00000001, 0xffffffff, 0x00000001, 0x01000000,\n  0x00000001, 0x00ffffff, 0x00000001, 0x00010000, 0x00000001, 0x0000ffff,\n  0x00000001, 0x00008000, 0x00000001, 0x00007fff, 0x00000001, 0x00000001,\n  0x00000001, 0x00000000, 0x00000000, 0xffffffff, 0x00000000, 0xfffffffe,\n  0x00000000, 0xfffffffd, 0x00000000, 0xffff8000, 0x00000000, 0xffff7fff,\n  0x00000000, 0xffff0000, 0x00000000, 0xfffeffff, 0x00000000, 0xff000000,\n  0x00000000, 0xfeffffff, 0x00000000, 0xa9cb1d24, 0x00000000, 0x48892a0a,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffff0001, 0x00000000,\n  0xffff0000, 0xffffffff, 0xfff00001, 0x00000000, 0xfff00000, 0xffffffff,\n  0xa9cb1d25, 0x48892a0a, 0x80000001, 0x00000000, 0x80000001, 0x00000000,\n  0x48892a0b, 0xa9cb1d25, 0x00100001, 0x00000001, 0x00100001, 0x00000000,\n  0x00010001, 0x00000001, 0x00010001, 0x00000000, 0x00000002, 0x00000001,\n  0x00000002, 0x00000000, 0x00000001, 0x01000001, 0x00000001, 0x01000000,\n  0x00000001, 0x00010001, 0x00000001, 0x00010000, 0x00000001, 0x00008001,\n  0x00000001, 0x00008000, 0x00000001, 0x00000002, 0x00000001, 0x00000001,\n  0x00000001, 0x00000000, 0x00000000, 0xffffffff, 0x00000000, 0xfffffffe,\n  0x00000000, 0xffff8001, 0x00000000, 0xffff8000, 0x00000000, 0xffff0001,\n  0x00000000, 0xffff0000, 0x00000000, 0xff000001, 0x00000000, 0xff000000,\n  0x00000000, 0xa9cb1d25, 0x00000000, 0x48892a0b, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xffff0001, 0x00000001, 0xffff0001, 0x00000000,\n  0xfff00001, 0x00000001, 0xfff00001, 0x00000000, 0xa9cb1d25, 0x48892a0b,\n  0x80000001, 0x00000001, 0x8000ffff, 0xffffffff, 0x488a2a0a, 0xa9cb1d24,\n  0x00110000, 0x00000000, 0x0010ffff, 0xffffffff, 0x00020000, 0x00000000,\n  0x0001ffff, 0xffffffff, 0x00010001, 0x00000000, 0x00010000, 0xffffffff,\n  0x00010000, 0x01000000, 0x00010000, 0x00ffffff, 0x00010000, 0x00010000,\n  0x00010000, 0x0000ffff, 0x00010000, 0x00008000, 0x00010000, 0x00007fff,\n  0x00010000, 0x00000001, 0x00010000, 0x00000000, 0x0000ffff, 0xffffffff,\n  0x0000ffff, 0xfffffffe, 0x0000ffff, 0xfffffffd, 0x0000ffff, 0xffff8000,\n  0x0000ffff, 0xffff7fff, 0x0000ffff, 0xffff0000, 0x0000ffff, 0xfffeffff,\n  0x0000ffff, 0xff000000, 0x0000ffff, 0xfeffffff, 0x0000ffff, 0xa9cb1d24,\n  0x0000ffff, 0x48892a0a, 0x0000ffff, 0x00000000, 0x0000fffe, 0xffffffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xfff10000, 0x00000000,\n  0xfff0ffff, 0xffffffff, 0xa9cc1d24, 0x48892a0a, 0x80010000, 0x00000000,\n  0x80010000, 0x00000000, 0x488a2a0a, 0xa9cb1d25, 0x00110000, 0x00000001,\n  0x00110000, 0x00000000, 0x00020000, 0x00000001, 0x00020000, 0x00000000,\n  0x00010001, 0x00000001, 0x00010001, 0x00000000, 0x00010000, 0x01000001,\n  0x00010000, 0x01000000, 0x00010000, 0x00010001, 0x00010000, 0x00010000,\n  0x00010000, 0x00008001, 0x00010000, 0x00008000, 0x00010000, 0x00000002,\n  0x00010000, 0x00000001, 0x00010000, 0x00000000, 0x0000ffff, 0xffffffff,\n  0x0000ffff, 0xfffffffe, 0x0000ffff, 0xffff8001, 0x0000ffff, 0xffff8000,\n  0x0000ffff, 0xffff0001, 0x0000ffff, 0xffff0000, 0x0000ffff, 0xff000001,\n  0x0000ffff, 0xff000000, 0x0000ffff, 0xa9cb1d25, 0x0000ffff, 0x48892a0b,\n  0x0000ffff, 0x00000001, 0x0000ffff, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xfff10000, 0x00000001, 0xfff10000, 0x00000000,\n  0xa9cc1d24, 0x48892a0b, 0x80010000, 0x00000001, 0x800fffff, 0xffffffff,\n  0x48992a0a, 0xa9cb1d24, 0x00200000, 0x00000000, 0x001fffff, 0xffffffff,\n  0x00110000, 0x00000000, 0x0010ffff, 0xffffffff, 0x00100001, 0x00000000,\n  0x00100000, 0xffffffff, 0x00100000, 0x01000000, 0x00100000, 0x00ffffff,\n  0x00100000, 0x00010000, 0x00100000, 0x0000ffff, 0x00100000, 0x00008000,\n  0x00100000, 0x00007fff, 0x00100000, 0x00000001, 0x00100000, 0x00000000,\n  0x000fffff, 0xffffffff, 0x000fffff, 0xfffffffe, 0x000fffff, 0xfffffffd,\n  0x000fffff, 0xffff8000, 0x000fffff, 0xffff7fff, 0x000fffff, 0xffff0000,\n  0x000fffff, 0xfffeffff, 0x000fffff, 0xff000000, 0x000fffff, 0xfeffffff,\n  0x000fffff, 0xa9cb1d24, 0x000fffff, 0x48892a0a, 0x000fffff, 0x00000000,\n  0x000ffffe, 0xffffffff, 0x000f0000, 0x00000000, 0x000effff, 0xffffffff,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xa9db1d24, 0x48892a0a,\n  0x80100000, 0x00000000, 0x80100000, 0x00000000, 0x48992a0a, 0xa9cb1d25,\n  0x00200000, 0x00000001, 0x00200000, 0x00000000, 0x00110000, 0x00000001,\n  0x00110000, 0x00000000, 0x00100001, 0x00000001, 0x00100001, 0x00000000,\n  0x00100000, 0x01000001, 0x00100000, 0x01000000, 0x00100000, 0x00010001,\n  0x00100000, 0x00010000, 0x00100000, 0x00008001, 0x00100000, 0x00008000,\n  0x00100000, 0x00000002, 0x00100000, 0x00000001, 0x00100000, 0x00000000,\n  0x000fffff, 0xffffffff, 0x000fffff, 0xfffffffe, 0x000fffff, 0xffff8001,\n  0x000fffff, 0xffff8000, 0x000fffff, 0xffff0001, 0x000fffff, 0xffff0000,\n  0x000fffff, 0xff000001, 0x000fffff, 0xff000000, 0x000fffff, 0xa9cb1d25,\n  0x000fffff, 0x48892a0b, 0x000fffff, 0x00000001, 0x000fffff, 0x00000000,\n  0x000f0000, 0x00000001, 0x000f0000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0xa9db1d24, 0x48892a0b, 0x80100000, 0x00000001,\n  0xd634e2db, 0xb776d5f5, 0x9ebe0ce6, 0x6141f31a, 0x5644e2db, 0xb776d5f6,\n  0x5644e2db, 0xb776d5f5, 0x5635e2db, 0xb776d5f6, 0x5635e2db, 0xb776d5f5,\n  0x5634e2dc, 0xb776d5f6, 0x5634e2dc, 0xb776d5f5, 0x5634e2db, 0xb876d5f6,\n  0x5634e2db, 0xb876d5f5, 0x5634e2db, 0xb777d5f6, 0x5634e2db, 0xb777d5f5,\n  0x5634e2db, 0xb77755f6, 0x5634e2db, 0xb77755f5, 0x5634e2db, 0xb776d5f7,\n  0x5634e2db, 0xb776d5f6, 0x5634e2db, 0xb776d5f5, 0x5634e2db, 0xb776d5f4,\n  0x5634e2db, 0xb776d5f3, 0x5634e2db, 0xb77655f6, 0x5634e2db, 0xb77655f5,\n  0x5634e2db, 0xb775d5f6, 0x5634e2db, 0xb775d5f5, 0x5634e2db, 0xb676d5f6,\n  0x5634e2db, 0xb676d5f5, 0x5634e2db, 0x6141f31a, 0x5634e2db, 0x00000000,\n  0x5634e2da, 0xb776d5f6, 0x5634e2da, 0xb776d5f5, 0x5633e2db, 0xb776d5f6,\n  0x5633e2db, 0xb776d5f5, 0x5624e2db, 0xb776d5f6, 0x5624e2db, 0xb776d5f5,\n  0x00000000, 0x00000000, 0xd634e2db, 0xb776d5f6, 0xffffffff, 0xffffffff,\n  0xc8892a0a, 0xa9cb1d24, 0x80100000, 0x00000000, 0x800fffff, 0xffffffff,\n  0x80010000, 0x00000000, 0x8000ffff, 0xffffffff, 0x80000001, 0x00000000,\n  0x80000000, 0xffffffff, 0x80000000, 0x01000000, 0x80000000, 0x00ffffff,\n  0x80000000, 0x00010000, 0x80000000, 0x0000ffff, 0x80000000, 0x00008000,\n  0x80000000, 0x00007fff, 0x80000000, 0x00000001, 0x80000000, 0x00000000,\n  0x7fffffff, 0xffffffff, 0x7fffffff, 0xfffffffe, 0x7fffffff, 0xfffffffd,\n  0x7fffffff, 0xffff8000, 0x7fffffff, 0xffff7fff, 0x7fffffff, 0xffff0000,\n  0x7fffffff, 0xfffeffff, 0x7fffffff, 0xff000000, 0x7fffffff, 0xfeffffff,\n  0x7fffffff, 0xa9cb1d24, 0x7fffffff, 0x48892a0a, 0x7fffffff, 0x00000000,\n  0x7ffffffe, 0xffffffff, 0x7fff0000, 0x00000000, 0x7ffeffff, 0xffffffff,\n  0x7ff00000, 0x00000000, 0x7fefffff, 0xffffffff, 0x29cb1d24, 0x48892a0a,\n  0x00000000, 0x00000000\n])\n\nvar TEST_MUL_BITS = i32array([\n  0x80000000, 0x00000000, 0x80000000, 0x00000000, 0x1ad92a0a, 0xa9cb1d25,\n  0x00000000, 0x00000000, 0xd2500000, 0x00000000, 0x00100000, 0x00000000,\n  0x80000000, 0x00000000, 0x65ae2a0a, 0xa9cb1d25, 0x00110000, 0x00000001,\n  0x00100000, 0x00000000, 0x00000000, 0x00000000, 0x1d250000, 0x00000000,\n  0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000,\n  0x80000000, 0x00000000, 0xf254472f, 0xa9cb1d25, 0x00100001, 0x00000001,\n  0x00100000, 0x00000000, 0x00010001, 0x00000001, 0x00010000, 0x00000000,\n  0x00000000, 0x00000000, 0xa9cb1d25, 0x00000000, 0x00000001, 0x00000000,\n  0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000,\n  0x00000001, 0x00000000, 0x80000000, 0x00000000, 0x5332f527, 0xcecb1d25,\n  0x00100000, 0x01000001, 0x00100000, 0x00000000, 0x00010000, 0x01000001,\n  0x00010000, 0x00000000, 0x01000001, 0x01000001, 0x01000001, 0x00000000,\n  0x00000000, 0x00000000, 0x0aa9cb1d, 0x25000000, 0x00000000, 0x01000000,\n  0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x00000000, 0x00000000,\n  0x01000000, 0x01000000, 0x01000000, 0x00000000, 0x00010000, 0x01000000,\n  0x80000000, 0x00000000, 0x7293d3d5, 0xc6f01d25, 0x00100000, 0x00010001,\n  0x00100000, 0x00000000, 0x00010000, 0x00010001, 0x00010000, 0x00000000,\n  0x00010001, 0x00010001, 0x00010001, 0x00000000, 0x00000100, 0x01010001,\n  0x00000100, 0x01000000, 0x00000000, 0x00000000, 0x2a0aa9cb, 0x1d250000,\n  0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00010000,\n  0x00000000, 0x00000000, 0x00010000, 0x00010000, 0x00010000, 0x00000000,\n  0x00000100, 0x00010000, 0x00000100, 0x00000000, 0x00000001, 0x00010000,\n  0x80000000, 0x00000000, 0xdd8e7ef0, 0x385d9d25, 0x00100000, 0x00008001,\n  0x00100000, 0x00000000, 0x80010000, 0x00008001, 0x80010000, 0x00000000,\n  0x00008001, 0x00008001, 0x00008001, 0x00000000, 0x00000080, 0x01008001,\n  0x00000080, 0x01000000, 0x00000000, 0x80018001, 0x00000000, 0x80010000,\n  0x00000000, 0x00000000, 0x950554e5, 0x8e928000, 0x00000000, 0x00008000,\n  0x00000000, 0x00000000, 0x80000000, 0x00008000, 0x80000000, 0x00000000,\n  0x00008000, 0x00008000, 0x00008000, 0x00000000, 0x00000080, 0x00008000,\n  0x00000080, 0x00000000, 0x00000000, 0x80008000, 0x00000000, 0x80000000,\n  0x00000000, 0x40008000, 0x00000000, 0x00000000, 0x91125415, 0x53963a4a,\n  0x00200000, 0x00000002, 0x00200000, 0x00000000, 0x00020000, 0x00000002,\n  0x00020000, 0x00000000, 0x00000002, 0x00000002, 0x00000002, 0x00000000,\n  0x00000000, 0x02000002, 0x00000000, 0x02000000, 0x00000000, 0x00020002,\n  0x00000000, 0x00020000, 0x00000000, 0x00010002, 0x00000000, 0x00010000,\n  0x80000000, 0x00000000, 0x48892a0a, 0xa9cb1d25, 0x00100000, 0x00000001,\n  0x00100000, 0x00000000, 0x00010000, 0x00000001, 0x00010000, 0x00000000,\n  0x00000001, 0x00000001, 0x00000001, 0x00000000, 0x00000000, 0x01000001,\n  0x00000000, 0x01000000, 0x00000000, 0x00010001, 0x00000000, 0x00010000,\n  0x00000000, 0x00008001, 0x00000000, 0x00008000, 0x00000000, 0x00000002,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x80000000, 0x00000000, 0xb776d5f5, 0x5634e2db,\n  0xffefffff, 0xffffffff, 0xfff00000, 0x00000000, 0xfffeffff, 0xffffffff,\n  0xffff0000, 0x00000000, 0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000,\n  0xffffffff, 0xfeffffff, 0xffffffff, 0xff000000, 0xffffffff, 0xfffeffff,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xffff7fff, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x6eedabea, 0xac69c5b6, 0xffdfffff, 0xfffffffe,\n  0xffe00000, 0x00000000, 0xfffdffff, 0xfffffffe, 0xfffe0000, 0x00000000,\n  0xfffffffd, 0xfffffffe, 0xfffffffe, 0x00000000, 0xffffffff, 0xfdfffffe,\n  0xffffffff, 0xfe000000, 0xffffffff, 0xfffdfffe, 0xffffffff, 0xfffe0000,\n  0xffffffff, 0xfffefffe, 0xffffffff, 0xffff0000, 0xffffffff, 0xfffffffc,\n  0xffffffff, 0xfffffffe, 0x00000000, 0x00000000, 0x00000000, 0x00000002,\n  0x80000000, 0x00000000, 0xb383d525, 0x1b389d25, 0x000fffff, 0xffff8001,\n  0x00100000, 0x00000000, 0x8000ffff, 0xffff8001, 0x80010000, 0x00000000,\n  0xffff8000, 0xffff8001, 0xffff8001, 0x00000000, 0xffffff80, 0x00ff8001,\n  0xffffff80, 0x01000000, 0xffffffff, 0x80008001, 0xffffffff, 0x80010000,\n  0xffffffff, 0xc0000001, 0xffffffff, 0xc0008000, 0xffffffff, 0xffff0002,\n  0xffffffff, 0xffff8001, 0x00000000, 0x00000000, 0x00000000, 0x00007fff,\n  0x00000000, 0x0000fffe, 0x00000000, 0x00000000, 0x6afaab1a, 0x716d8000,\n  0xffffffff, 0xffff8000, 0x00000000, 0x00000000, 0x7fffffff, 0xffff8000,\n  0x80000000, 0x00000000, 0xffff7fff, 0xffff8000, 0xffff8000, 0x00000000,\n  0xffffff7f, 0xffff8000, 0xffffff80, 0x00000000, 0xffffffff, 0x7fff8000,\n  0xffffffff, 0x80000000, 0xffffffff, 0xbfff8000, 0xffffffff, 0xc0000000,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xffff8000, 0x00000000, 0x00000000,\n  0x00000000, 0x00008000, 0x00000000, 0x00010000, 0x00000000, 0x3fff8000,\n  0x80000000, 0x00000000, 0x1e7e803f, 0x8ca61d25, 0x000fffff, 0xffff0001,\n  0x00100000, 0x00000000, 0x0000ffff, 0xffff0001, 0x00010000, 0x00000000,\n  0xffff0000, 0xffff0001, 0xffff0001, 0x00000000, 0xffffff00, 0x00ff0001,\n  0xffffff00, 0x01000000, 0xffffffff, 0x00000001, 0xffffffff, 0x00010000,\n  0xffffffff, 0x7fff8001, 0xffffffff, 0x80008000, 0xffffffff, 0xfffe0002,\n  0xffffffff, 0xffff0001, 0x00000000, 0x00000000, 0x00000000, 0x0000ffff,\n  0x00000000, 0x0001fffe, 0x00000000, 0x7ffe8001, 0x00000000, 0x7fff8000,\n  0x00000000, 0x00000000, 0xd5f55634, 0xe2db0000, 0xffffffff, 0xffff0000,\n  0x00000000, 0x00000000, 0xffffffff, 0xffff0000, 0x00000000, 0x00000000,\n  0xfffeffff, 0xffff0000, 0xffff0000, 0x00000000, 0xfffffeff, 0xffff0000,\n  0xffffff00, 0x00000000, 0xfffffffe, 0xffff0000, 0xffffffff, 0x00000000,\n  0xffffffff, 0x7fff0000, 0xffffffff, 0x80000000, 0xffffffff, 0xfffe0000,\n  0xffffffff, 0xffff0000, 0x00000000, 0x00000000, 0x00000000, 0x00010000,\n  0x00000000, 0x00020000, 0x00000000, 0x7fff0000, 0x00000000, 0x80000000,\n  0x00000000, 0xffff0000, 0x80000000, 0x00000000, 0x3ddf5eed, 0x84cb1d25,\n  0x000fffff, 0xff000001, 0x00100000, 0x00000000, 0x0000ffff, 0xff000001,\n  0x00010000, 0x00000000, 0xff000000, 0xff000001, 0xff000001, 0x00000000,\n  0xffff0000, 0x00000001, 0xffff0000, 0x01000000, 0xfffffeff, 0xff010001,\n  0xffffff00, 0x00010000, 0xffffff7f, 0xff008001, 0xffffff80, 0x00008000,\n  0xffffffff, 0xfe000002, 0xffffffff, 0xff000001, 0x00000000, 0x00000000,\n  0x00000000, 0x00ffffff, 0x00000000, 0x01fffffe, 0x0000007f, 0xfeff8001,\n  0x0000007f, 0xffff8000, 0x000000ff, 0xfeff0001, 0x000000ff, 0xffff0000,\n  0x00000000, 0x00000000, 0xf55634e2, 0xdb000000, 0xffffffff, 0xff000000,\n  0x00000000, 0x00000000, 0xffffffff, 0xff000000, 0x00000000, 0x00000000,\n  0xfeffffff, 0xff000000, 0xff000000, 0x00000000, 0xfffeffff, 0xff000000,\n  0xffff0000, 0x00000000, 0xfffffeff, 0xff000000, 0xffffff00, 0x00000000,\n  0xffffff7f, 0xff000000, 0xffffff80, 0x00000000, 0xffffffff, 0xfe000000,\n  0xffffffff, 0xff000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000,\n  0x00000000, 0x02000000, 0x0000007f, 0xff000000, 0x00000080, 0x00000000,\n  0x000000ff, 0xff000000, 0x00000100, 0x00000000, 0x0000ffff, 0xff000000,\n  0x80000000, 0x00000000, 0xbc56e5ef, 0x15ff6759, 0xd24fffff, 0xa9cb1d25,\n  0xd2500000, 0x00000000, 0x1d24ffff, 0xa9cb1d25, 0x1d250000, 0x00000000,\n  0xa9cb1d24, 0xa9cb1d25, 0xa9cb1d25, 0x00000000, 0xffa9cb1c, 0xcecb1d25,\n  0xffa9cb1d, 0x25000000, 0xffffa9ca, 0xc6f01d25, 0xffffa9cb, 0x1d250000,\n  0xffffd4e5, 0x385d9d25, 0xffffd4e5, 0x8e928000, 0xffffffff, 0x53963a4a,\n  0xffffffff, 0xa9cb1d25, 0x00000000, 0x00000000, 0x00000000, 0x5634e2db,\n  0x00000000, 0xac69c5b6, 0x00002b1a, 0x1b389d25, 0x00002b1a, 0x716d8000,\n  0x00005634, 0x8ca61d25, 0x00005634, 0xe2db0000, 0x005634e2, 0x84cb1d25,\n  0x005634e2, 0xdb000000, 0x80000000, 0x00000000, 0x74756f10, 0x9f4f5297,\n  0xa0afffff, 0x48892a0b, 0xa0b00000, 0x00000000, 0x2a0affff, 0x48892a0b,\n  0x2a0b0000, 0x00000000, 0x48892a0a, 0x48892a0b, 0x48892a0b, 0x00000000,\n  0xff488929, 0x53892a0b, 0xff48892a, 0x0b000000, 0xffff4888, 0x72942a0b,\n  0xffff4889, 0x2a0b0000, 0xffffa443, 0xdd8eaa0b, 0xffffa444, 0x95058000,\n  0xfffffffe, 0x91125416, 0xffffffff, 0x48892a0b, 0x00000000, 0x00000000,\n  0x00000000, 0xb776d5f5, 0x00000001, 0x6eedabea, 0x00005bba, 0xb383aa0b,\n  0x00005bbb, 0x6afa8000, 0x0000b776, 0x1e7e2a0b, 0x0000b776, 0xd5f50000,\n  0x00b776d5, 0x3d892a0b, 0x00b776d5, 0xf5000000, 0x3dc7d297, 0x9f4f5297,\n  0x80000000, 0x00000000, 0x9ebe0ce5, 0xa9cb1d25, 0x000fffff, 0x00000001,\n  0x00100000, 0x00000000, 0x0000ffff, 0x00000001, 0x00010000, 0x00000000,\n  0x00000000, 0x00000001, 0x00000001, 0x00000000, 0xfeffffff, 0x01000001,\n  0xff000000, 0x01000000, 0xfffeffff, 0x00010001, 0xffff0000, 0x00010000,\n  0xffff7fff, 0x00008001, 0xffff8000, 0x00008000, 0xfffffffe, 0x00000002,\n  0xffffffff, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0xffffffff,\n  0x00000001, 0xfffffffe, 0x00007ffe, 0xffff8001, 0x00007fff, 0xffff8000,\n  0x0000fffe, 0xffff0001, 0x0000ffff, 0xffff0000, 0x00fffffe, 0xff000001,\n  0x00ffffff, 0xff000000, 0x5634e2da, 0xa9cb1d25, 0xb776d5f4, 0x48892a0b,\n  0x00000000, 0x00000000, 0x5634e2db, 0x00000000, 0xffffffff, 0x00000000,\n  0x00000000, 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0xfeffffff, 0x00000000,\n  0xff000000, 0x00000000, 0xfffeffff, 0x00000000, 0xffff0000, 0x00000000,\n  0xffff7fff, 0x00000000, 0xffff8000, 0x00000000, 0xfffffffe, 0x00000000,\n  0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000,\n  0x00000002, 0x00000000, 0x00007fff, 0x00000000, 0x00008000, 0x00000000,\n  0x0000ffff, 0x00000000, 0x00010000, 0x00000000, 0x00ffffff, 0x00000000,\n  0x01000000, 0x00000000, 0x5634e2db, 0x00000000, 0xb776d5f5, 0x00000000,\n  0xffffffff, 0x00000000, 0x80000000, 0x00000000, 0x2b642a0a, 0xa9cb1d25,\n  0x000f0000, 0x00000001, 0x00100000, 0x00000000, 0x00000000, 0x00000001,\n  0x00010000, 0x00000000, 0xffff0001, 0x00000001, 0x00000001, 0x00000000,\n  0xffff0000, 0x01000001, 0x00000000, 0x01000000, 0xffff0000, 0x00010001,\n  0x00000000, 0x00010000, 0x7fff0000, 0x00008001, 0x80000000, 0x00008000,\n  0xfffe0000, 0x00000002, 0xffff0000, 0x00000001, 0x00000000, 0x00000000,\n  0x0000ffff, 0xffffffff, 0x0001ffff, 0xfffffffe, 0x7ffeffff, 0xffff8001,\n  0x7fffffff, 0xffff8000, 0xfffeffff, 0xffff0001, 0xffffffff, 0xffff0000,\n  0xfffeffff, 0xff000001, 0xffffffff, 0xff000000, 0xe2daffff, 0xa9cb1d25,\n  0xd5f4ffff, 0x48892a0b, 0xfffeffff, 0x00000001, 0xffffffff, 0x00000000,\n  0x00000000, 0x00000000, 0xe2db0000, 0x00000000, 0xffff0000, 0x00000000,\n  0x00000000, 0x00000000, 0xffff0000, 0x00000000, 0x00000000, 0x00000000,\n  0xffff0000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x00000000,\n  0x00000000, 0x00000000, 0xffff0000, 0x00000000, 0x00000000, 0x00000000,\n  0x7fff0000, 0x00000000, 0x80000000, 0x00000000, 0xfffe0000, 0x00000000,\n  0xffff0000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000,\n  0x00020000, 0x00000000, 0x7fff0000, 0x00000000, 0x80000000, 0x00000000,\n  0xffff0000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x00000000,\n  0x00000000, 0x00000000, 0xe2db0000, 0x00000000, 0xd5f50000, 0x00000000,\n  0xffff0000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x00000000,\n  0x80000000, 0x00000000, 0x76392a0a, 0xa9cb1d25, 0x00000000, 0x00000001,\n  0x00100000, 0x00000000, 0xfff10000, 0x00000001, 0x00010000, 0x00000000,\n  0xfff00001, 0x00000001, 0x00000001, 0x00000000, 0xfff00000, 0x01000001,\n  0x00000000, 0x01000000, 0xfff00000, 0x00010001, 0x00000000, 0x00010000,\n  0xfff00000, 0x00008001, 0x00000000, 0x00008000, 0xffe00000, 0x00000002,\n  0xfff00000, 0x00000001, 0x00000000, 0x00000000, 0x000fffff, 0xffffffff,\n  0x001fffff, 0xfffffffe, 0xffefffff, 0xffff8001, 0xffffffff, 0xffff8000,\n  0xffefffff, 0xffff0001, 0xffffffff, 0xffff0000, 0xffefffff, 0xff000001,\n  0xffffffff, 0xff000000, 0x2dafffff, 0xa9cb1d25, 0x5f4fffff, 0x48892a0b,\n  0xffefffff, 0x00000001, 0xffffffff, 0x00000000, 0xffef0000, 0x00000001,\n  0xffff0000, 0x00000000, 0x00000000, 0x00000000, 0x2db00000, 0x00000000,\n  0xfff00000, 0x00000000, 0x00000000, 0x00000000, 0xfff00000, 0x00000000,\n  0x00000000, 0x00000000, 0xfff00000, 0x00000000, 0x00000000, 0x00000000,\n  0xfff00000, 0x00000000, 0x00000000, 0x00000000, 0xfff00000, 0x00000000,\n  0x00000000, 0x00000000, 0xfff00000, 0x00000000, 0x00000000, 0x00000000,\n  0xffe00000, 0x00000000, 0xfff00000, 0x00000000, 0x00000000, 0x00000000,\n  0x00100000, 0x00000000, 0x00200000, 0x00000000, 0xfff00000, 0x00000000,\n  0x00000000, 0x00000000, 0xfff00000, 0x00000000, 0x00000000, 0x00000000,\n  0xfff00000, 0x00000000, 0x00000000, 0x00000000, 0x2db00000, 0x00000000,\n  0x5f500000, 0x00000000, 0xfff00000, 0x00000000, 0x00000000, 0x00000000,\n  0xfff00000, 0x00000000, 0x00000000, 0x00000000, 0xfff00000, 0x00000000,\n  0x80000000, 0x00000000, 0x8a74d669, 0x9f4f5297, 0x4a7b1d24, 0x48892a0b,\n  0xa0b00000, 0x00000000, 0xd3d61d24, 0x48892a0b, 0x2a0b0000, 0x00000000,\n  0xf254472f, 0x48892a0b, 0x48892a0b, 0x00000000, 0xce13a64e, 0x53892a0b,\n  0x2448892a, 0x0b000000, 0xc6ef65ad, 0x72942a0b, 0x1d244889, 0x2a0b0000,\n  0x385d4168, 0xdd8eaa0b, 0x8e922444, 0x95058000, 0x53963a48, 0x91125416,\n  0xa9cb1d24, 0x48892a0b, 0x00000000, 0x00000000, 0x5634e2db, 0xb776d5f5,\n  0xac69c5b7, 0x6eedabea, 0x1b38f8df, 0xb383aa0b, 0x716ddbbb, 0x6afa8000,\n  0x8ca6d49b, 0x1e7e2a0b, 0xe2dbb776, 0xd5f50000, 0x858293fa, 0x3d892a0b,\n  0xdbb776d5, 0xf5000000, 0x53c739f0, 0x9f4f5297, 0x22ca6fa5, 0x36ad9c79,\n  0x6141f319, 0x48892a0b, 0xb776d5f5, 0x00000000, 0x7fc01d24, 0x48892a0b,\n  0xd5f50000, 0x00000000, 0x091b1d24, 0x48892a0b, 0x5f500000, 0x00000000,\n  0x80000000, 0x00000000, 0xc8892a0a, 0xa9cb1d25, 0x80100000, 0x00000001,\n  0x00100000, 0x00000000, 0x80010000, 0x00000001, 0x00010000, 0x00000000,\n  0x80000001, 0x00000001, 0x00000001, 0x00000000, 0x80000000, 0x01000001,\n  0x00000000, 0x01000000, 0x80000000, 0x00010001, 0x00000000, 0x00010000,\n  0x80000000, 0x00008001, 0x00000000, 0x00008000, 0x00000000, 0x00000002,\n  0x80000000, 0x00000001, 0x00000000, 0x00000000, 0x7fffffff, 0xffffffff,\n  0xffffffff, 0xfffffffe, 0x7fffffff, 0xffff8001, 0xffffffff, 0xffff8000,\n  0x7fffffff, 0xffff0001, 0xffffffff, 0xffff0000, 0x7fffffff, 0xff000001,\n  0xffffffff, 0xff000000, 0x7fffffff, 0xa9cb1d25, 0x7fffffff, 0x48892a0b,\n  0x7fffffff, 0x00000001, 0xffffffff, 0x00000000, 0x7fff0000, 0x00000001,\n  0xffff0000, 0x00000000, 0x7ff00000, 0x00000001, 0xfff00000, 0x00000000,\n  0x29cb1d24, 0x48892a0b\n])\n\nvar TEST_DIV_BITS = i32array([\n  0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x000007ff,\n  0x00000000, 0x00000800, 0x00000000, 0x00007fff, 0x00000000, 0x00008000,\n  0x00000000, 0x7fffffff, 0x00000000, 0x80000000, 0x0000007f, 0xffff8000,\n  0x00000080, 0x00000000, 0x00007fff, 0x80007fff, 0x00008000, 0x00000000,\n  0x0000fffe, 0x0003fff8, 0x00010000, 0x00000000, 0x40000000, 0x00000000,\n  0x80000000, 0x00000000, 0x80000000, 0x00000000, 0xc0000000, 0x00000000,\n  0xfffefffd, 0xfffbfff8, 0xffff0000, 0x00000000, 0xffff7fff, 0x7fff8000,\n  0xffff8000, 0x00000000, 0xffffff7f, 0xffff8000, 0xffffff80, 0x00000000,\n  0xfffffffe, 0x83e3cc1a, 0xffffffff, 0x4d64985a, 0xffffffff, 0x80000000,\n  0xffffffff, 0x80000000, 0xffffffff, 0xffff8000, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xfffff800, 0xffffffff, 0xfffff800, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000488, 0x00000000, 0x00000488, 0x00000000, 0x00004889,\n  0x00000000, 0x00004889, 0x00000000, 0x48892a0a, 0x00000000, 0x48892a0a,\n  0x00000048, 0x8929c220, 0x00000048, 0x892a0aa9, 0x00004888, 0xe181c849,\n  0x00004889, 0x2a0aa9cb, 0x00009111, 0x31f2efb0, 0x00009112, 0x54155396,\n  0x24449505, 0x54e58e92, 0x48892a0a, 0xa9cb1d25, 0xb776d5f5, 0x5634e2db,\n  0xdbbb6afa, 0xab1a716e, 0xffff6eec, 0x89c3bff2, 0xffff6eed, 0xabeaac6a,\n  0xffffb776, 0x8d6be3a1, 0xffffb776, 0xd5f55635, 0xffffffb7, 0x76d5acce,\n  0xffffffb7, 0x76d5f557, 0xffffffff, 0x2898cfc6, 0xffffffff, 0x9ac930b4,\n  0xffffffff, 0xb776d5f6, 0xffffffff, 0xb776d5f6, 0xffffffff, 0xffffb777,\n  0xffffffff, 0xffffb777, 0xffffffff, 0xfffffb78, 0xffffffff, 0xfffffb78,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x0000000f, 0x00000000, 0x00000010, 0x00000000, 0x000fffff,\n  0x00000000, 0x00100000, 0x00000000, 0x0ffffff0, 0x00000000, 0x10000000,\n  0x0000000f, 0xfff0000f, 0x00000010, 0x00000000, 0x0000001f, 0xffc0007f,\n  0x00000020, 0x00000000, 0x00080000, 0x00000000, 0x00100000, 0x00000001,\n  0xffefffff, 0xffffffff, 0xfff80000, 0x00000000, 0xffffffdf, 0xffbfff80,\n  0xffffffe0, 0x00000000, 0xffffffef, 0xffeffff0, 0xfffffff0, 0x00000000,\n  0xffffffff, 0xeffffff0, 0xffffffff, 0xf0000000, 0xffffffff, 0xffd07c7a,\n  0xffffffff, 0xffe9ac94, 0xffffffff, 0xfff00000, 0xffffffff, 0xfff00000,\n  0xffffffff, 0xfffffff0, 0xffffffff, 0xfffffff0, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000001, 0x00000000, 0x0000000f, 0x00000000, 0x00000010,\n  0x00000000, 0x000fffff, 0x00000000, 0x00100000, 0x00000000, 0x0ffffff0,\n  0x00000000, 0x10000000, 0x0000000f, 0xfff0000f, 0x00000010, 0x00000000,\n  0x0000001f, 0xffc0007f, 0x00000020, 0x00000000, 0x00080000, 0x00000000,\n  0x00100000, 0x00000000, 0xfff00000, 0x00000000, 0xfff80000, 0x00000000,\n  0xffffffdf, 0xffbfff80, 0xffffffe0, 0x00000000, 0xffffffef, 0xffeffff0,\n  0xfffffff0, 0x00000000, 0xffffffff, 0xeffffff0, 0xffffffff, 0xf0000000,\n  0xffffffff, 0xffd07c7a, 0xffffffff, 0xffe9ac94, 0xffffffff, 0xfff00000,\n  0xffffffff, 0xfff00000, 0xffffffff, 0xfffffff0, 0xffffffff, 0xfffffff0,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000001, 0x00000000, 0x0000ffff, 0x00000000, 0x00010000,\n  0x00000000, 0x00ffffff, 0x00000000, 0x01000000, 0x00000000, 0xffff0001,\n  0x00000001, 0x00000000, 0x00000001, 0xfffc0007, 0x00000002, 0x00000000,\n  0x00008000, 0x00000000, 0x00010000, 0x00000001, 0xfffeffff, 0xffffffff,\n  0xffff8000, 0x00000000, 0xfffffffd, 0xfffbfff8, 0xfffffffe, 0x00000000,\n  0xfffffffe, 0xfffeffff, 0xffffffff, 0x00000000, 0xffffffff, 0xfeffffff,\n  0xffffffff, 0xff000000, 0xffffffff, 0xfffd07c8, 0xffffffff, 0xfffe9aca,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xffff0000, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000ffff,\n  0x00000000, 0x00010000, 0x00000000, 0x00ffffff, 0x00000000, 0x01000000,\n  0x00000000, 0xffff0000, 0x00000001, 0x00000000, 0x00000001, 0xfffc0007,\n  0x00000002, 0x00000000, 0x00008000, 0x00000000, 0x00010000, 0x00000000,\n  0xffff0000, 0x00000000, 0xffff8000, 0x00000000, 0xfffffffd, 0xfffbfff8,\n  0xfffffffe, 0x00000000, 0xfffffffe, 0xfffeffff, 0xffffffff, 0x00000000,\n  0xffffffff, 0xfeffffff, 0xffffffff, 0xff000000, 0xffffffff, 0xfffd07c8,\n  0xffffffff, 0xfffe9aca, 0xffffffff, 0xffff0000, 0xffffffff, 0xffff0000,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x000000ff,\n  0x00000000, 0x00000100, 0x00000000, 0x0000ffff, 0x00000000, 0x00010000,\n  0x00000000, 0x0001fffc, 0x00000000, 0x00020000, 0x00000000, 0x80000000,\n  0x00000001, 0x00000001, 0xfffffffe, 0xffffffff, 0xffffffff, 0x80000000,\n  0xffffffff, 0xfffdfffc, 0xffffffff, 0xfffe0000, 0xffffffff, 0xfffeffff,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xffffff00, 0xffffffff, 0xffffff00,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x000000ff, 0x00000000, 0x00000100, 0x00000000, 0x0000ffff,\n  0x00000000, 0x00010000, 0x00000000, 0x0001fffc, 0x00000000, 0x00020000,\n  0x00000000, 0x80000000, 0x00000001, 0x00000000, 0xffffffff, 0x00000000,\n  0xffffffff, 0x80000000, 0xffffffff, 0xfffdfffc, 0xffffffff, 0xfffe0000,\n  0xffffffff, 0xfffeffff, 0xffffffff, 0xffff0000, 0xffffffff, 0xffffff00,\n  0xffffffff, 0xffffff00, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x000000ff, 0x00000000, 0x00000100, 0x00000000, 0x000001ff,\n  0x00000000, 0x00000200, 0x00000000, 0x00800000, 0x00000000, 0x01000001,\n  0xffffffff, 0xfeffffff, 0xffffffff, 0xff800000, 0xffffffff, 0xfffffe00,\n  0xffffffff, 0xfffffe00, 0xffffffff, 0xffffff00, 0xffffffff, 0xffffff00,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000001, 0x00000000, 0x000000ff, 0x00000000, 0x00000100,\n  0x00000000, 0x000001ff, 0x00000000, 0x00000200, 0x00000000, 0x00800000,\n  0x00000000, 0x01000000, 0xffffffff, 0xff000000, 0xffffffff, 0xff800000,\n  0xffffffff, 0xfffffe00, 0xffffffff, 0xfffffe00, 0xffffffff, 0xffffff00,\n  0xffffffff, 0xffffff00, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000002,\n  0x00000000, 0x00008000, 0x00000000, 0x00010001, 0xffffffff, 0xfffeffff,\n  0xffffffff, 0xffff8000, 0xffffffff, 0xfffffffe, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x00000002, 0x00000000, 0x00008000, 0x00000000, 0x00010000,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xffff8000, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00004000,\n  0x00000000, 0x00008001, 0xffffffff, 0xffff7fff, 0xffffffff, 0xffffc000,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n  0x00000000, 0x00004000, 0x00000000, 0x00008000, 0xffffffff, 0xffff8000,\n  0xffffffff, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000002,\n  0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000001, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff,\n  0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xfffffffe, 0x00000000, 0x00000002, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffc001, 0xffffffff, 0xffff8001, 0x00000000, 0x00007fff,\n  0x00000000, 0x00003fff, 0x00000000, 0x00000001, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffc000, 0xffffffff, 0xffff8000,\n  0x00000000, 0x00008000, 0x00000000, 0x00004000, 0x00000000, 0x00000001,\n  0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffff8001,\n  0xffffffff, 0xffff0001, 0x00000000, 0x0000ffff, 0x00000000, 0x00007fff,\n  0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe,\n  0xffffffff, 0xffff8000, 0xffffffff, 0xffff0000, 0x00000000, 0x00010000,\n  0x00000000, 0x00008000, 0x00000000, 0x00000002, 0x00000000, 0x00000002,\n  0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffff01, 0xffffffff, 0xffffff01, 0xffffffff, 0xfffffe01,\n  0xffffffff, 0xfffffe01, 0xffffffff, 0xff800001, 0xffffffff, 0xff000001,\n  0x00000000, 0x00ffffff, 0x00000000, 0x007fffff, 0x00000000, 0x00000200,\n  0x00000000, 0x000001ff, 0x00000000, 0x00000100, 0x00000000, 0x000000ff,\n  0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffffff, 0xffffffff, 0xffffff01, 0xffffffff, 0xffffff00,\n  0xffffffff, 0xfffffe01, 0xffffffff, 0xfffffe00, 0xffffffff, 0xff800000,\n  0xffffffff, 0xff000000, 0x00000000, 0x01000000, 0x00000000, 0x00800000,\n  0x00000000, 0x00000200, 0x00000000, 0x00000200, 0x00000000, 0x00000100,\n  0x00000000, 0x00000100, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0xffffffff, 0xffffffaa, 0xffffffff, 0xffffffaa, 0xffffffff, 0xffffa9cc,\n  0xffffffff, 0xffffa9cc, 0xffffffff, 0xffff5398, 0xffffffff, 0xffff5397,\n  0xffffffff, 0xd4e58e93, 0xffffffff, 0xa9cb1d25, 0x00000000, 0x5634e2db,\n  0x00000000, 0x2b1a716d, 0x00000000, 0x0000ac6b, 0x00000000, 0x0000ac69,\n  0x00000000, 0x00005635, 0x00000000, 0x00005634, 0x00000000, 0x00000056,\n  0x00000000, 0x00000056, 0x00000000, 0x00000001, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffff49, 0xffffffff, 0xffffff49,\n  0xffffffff, 0xffff488a, 0xffffffff, 0xffff488a, 0xffffffff, 0xfffe9116,\n  0xffffffff, 0xfffe9113, 0xffffffff, 0xa4449506, 0xffffffff, 0x48892a0b,\n  0x00000000, 0xb776d5f5, 0x00000000, 0x5bbb6afa, 0x00000000, 0x00016ef0,\n  0x00000000, 0x00016eed, 0x00000000, 0x0000b777, 0x00000000, 0x0000b776,\n  0x00000000, 0x000000b7, 0x00000000, 0x000000b7, 0x00000000, 0x00000002,\n  0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffff01,\n  0xffffffff, 0xffffff01, 0xffffffff, 0xffff0001, 0xffffffff, 0xffff0001,\n  0xffffffff, 0xfffe0004, 0xffffffff, 0xfffe0001, 0xffffffff, 0x80000001,\n  0xffffffff, 0x00000001, 0x00000000, 0xffffffff, 0x00000000, 0x7fffffff,\n  0x00000000, 0x00020004, 0x00000000, 0x0001ffff, 0x00000000, 0x00010001,\n  0x00000000, 0x0000ffff, 0x00000000, 0x00000100, 0x00000000, 0x000000ff,\n  0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffffff01, 0xffffffff, 0xffffff00, 0xffffffff, 0xffff0001,\n  0xffffffff, 0xffff0000, 0xffffffff, 0xfffe0004, 0xffffffff, 0xfffe0000,\n  0xffffffff, 0x80000000, 0xffffffff, 0x00000000, 0x00000001, 0x00000000,\n  0x00000000, 0x80000000, 0x00000000, 0x00020004, 0x00000000, 0x00020000,\n  0x00000000, 0x00010001, 0x00000000, 0x00010000, 0x00000000, 0x00000100,\n  0x00000000, 0x00000100, 0x00000000, 0x00000002, 0x00000000, 0x00000001,\n  0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffff0001,\n  0xffffffff, 0xffff0001, 0xffffffff, 0xff000001, 0xffffffff, 0xff000001,\n  0xffffffff, 0x00010000, 0xffffffff, 0x00000001, 0xfffffffe, 0x0003fff9,\n  0xfffffffe, 0x00000001, 0xffff8000, 0x00000001, 0xffff0000, 0x00000001,\n  0x0000ffff, 0xffffffff, 0x00007fff, 0xffffffff, 0x00000002, 0x00040008,\n  0x00000001, 0xffffffff, 0x00000001, 0x00010001, 0x00000000, 0xffffffff,\n  0x00000000, 0x01000001, 0x00000000, 0x00ffffff, 0x00000000, 0x0002f838,\n  0x00000000, 0x00016536, 0x00000000, 0x00010000, 0x00000000, 0x0000ffff,\n  0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xffff0001, 0xffffffff, 0xffff0000, 0xffffffff, 0xff000001,\n  0xffffffff, 0xff000000, 0xffffffff, 0x00010000, 0xffffffff, 0x00000000,\n  0xfffffffe, 0x0003fff9, 0xfffffffe, 0x00000000, 0xffff8000, 0x00000000,\n  0xffff0000, 0x00000000, 0x00010000, 0x00000000, 0x00008000, 0x00000000,\n  0x00000002, 0x00040008, 0x00000002, 0x00000000, 0x00000001, 0x00010001,\n  0x00000001, 0x00000000, 0x00000000, 0x01000001, 0x00000000, 0x01000000,\n  0x00000000, 0x0002f838, 0x00000000, 0x00016536, 0x00000000, 0x00010000,\n  0x00000000, 0x00010000, 0x00000000, 0x00000001, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xfffffff1,\n  0xffffffff, 0xfffffff1, 0xffffffff, 0xfff00001, 0xffffffff, 0xfff00001,\n  0xffffffff, 0xf0000010, 0xffffffff, 0xf0000001, 0xfffffff0, 0x000ffff1,\n  0xfffffff0, 0x00000001, 0xffffffe0, 0x003fff81, 0xffffffe0, 0x00000001,\n  0xfff80000, 0x00000001, 0xfff00000, 0x00000001, 0x000fffff, 0xffffffff,\n  0x0007ffff, 0xffffffff, 0x00000020, 0x00400080, 0x0000001f, 0xffffffff,\n  0x00000010, 0x00100010, 0x0000000f, 0xffffffff, 0x00000000, 0x10000010,\n  0x00000000, 0x0fffffff, 0x00000000, 0x002f8386, 0x00000000, 0x0016536c,\n  0x00000000, 0x00100000, 0x00000000, 0x000fffff, 0x00000000, 0x00000010,\n  0x00000000, 0x0000000f, 0x00000000, 0x00000001, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xfffffff1, 0xffffffff, 0xfffffff0, 0xffffffff, 0xfff00001,\n  0xffffffff, 0xfff00000, 0xffffffff, 0xf0000010, 0xffffffff, 0xf0000000,\n  0xfffffff0, 0x000ffff1, 0xfffffff0, 0x00000000, 0xffffffe0, 0x003fff81,\n  0xffffffe0, 0x00000000, 0xfff80000, 0x00000000, 0xfff00000, 0x00000000,\n  0x00100000, 0x00000000, 0x00080000, 0x00000000, 0x00000020, 0x00400080,\n  0x00000020, 0x00000000, 0x00000010, 0x00100010, 0x00000010, 0x00000000,\n  0x00000000, 0x10000010, 0x00000000, 0x10000000, 0x00000000, 0x002f8386,\n  0x00000000, 0x0016536c, 0x00000000, 0x00100000, 0x00000000, 0x00100000,\n  0x00000000, 0x00000010, 0x00000000, 0x00000010, 0x00000000, 0x00000001,\n  0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n  0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffffa9d,\n  0xffffffff, 0xfffffa9d, 0xffffffff, 0xffffa9cc, 0xffffffff, 0xffffa9cc,\n  0xffffffff, 0xa9cb1d25, 0xffffffff, 0xa9cb1d25, 0xffffffa9, 0xcb1d7a7e,\n  0xffffffa9, 0xcb1d2449, 0xffffa9cb, 0x7358d531, 0xffffa9cb, 0x1d24488a,\n  0xffff5397, 0x93196ae0, 0xffff5396, 0x3a489113, 0xd4e58e92, 0x24449506,\n  0xa9cb1d24, 0x48892a0b, 0x5634e2db, 0xb776d5f5, 0x2b1a716d, 0xdbbb6afa,\n  0x0000ac6b, 0x1e8dac09, 0x0000ac69, 0xc5b76eed, 0x00005635, 0x3910f087,\n  0x00005634, 0xe2dbb776, 0x00000056, 0x34e331ec, 0x00000056, 0x34e2dbb7,\n  0x00000001, 0x00000002, 0x00000000, 0x784a3552, 0x00000000, 0x5634e2dc,\n  0x00000000, 0x5634e2db, 0x00000000, 0x00005634, 0x00000000, 0x00005634,\n  0x00000000, 0x00000563, 0x00000000, 0x00000563, 0x00000000, 0x00000001,\n  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff,\n  0xffffffff, 0xfffff801, 0xffffffff, 0xfffff801, 0xffffffff, 0xffff8001,\n  0xffffffff, 0xffff8001, 0xffffffff, 0x80000001, 0xffffffff, 0x80000001,\n  0xffffff80, 0x00008000, 0xffffff80, 0x00000001, 0xffff8000, 0x7fff8001,\n  0xffff8000, 0x00000001, 0xffff0001, 0xfffc0008, 0xffff0000, 0x00000001,\n  0xc0000000, 0x00000001, 0x80000000, 0x00000001, 0x7fffffff, 0xffffffff,\n  0x3fffffff, 0xffffffff, 0x00010002, 0x00040008, 0x0000ffff, 0xffffffff,\n  0x00008000, 0x80008000, 0x00007fff, 0xffffffff, 0x00000080, 0x00008000,\n  0x0000007f, 0xffffffff, 0x00000001, 0x7c1c33e6, 0x00000000, 0xb29b67a6,\n  0x00000000, 0x80000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00008000,\n  0x00000000, 0x00007fff, 0x00000000, 0x00000800, 0x00000000, 0x000007ff,\n  0x00000000, 0x00000001, 0x00000000, 0x00000001\n])\n\nvar TEST_STRINGS = [\n  '-9223372036854775808',\n  '-5226755067826871589',\n  '-4503599627370497',\n  '-4503599627370496',\n  '-281474976710657',\n  '-281474976710656',\n  '-4294967297',\n  '-4294967296',\n  '-16777217',\n  '-16777216',\n  '-65537',\n  '-65536',\n  '-32769',\n  '-32768',\n  '-2',\n  '-1',\n  '0',\n  '1',\n  '2',\n  '32767',\n  '32768',\n  '65535',\n  '65536',\n  '16777215',\n  '16777216',\n  '1446306523',\n  '3078018549',\n  '4294967295',\n  '4294967296',\n  '281474976710655',\n  '281474976710656',\n  '4503599627370495',\n  '4503599627370496',\n  '6211839219354490357',\n  '9223372036854775807'\n]\n\n\nTEST('ToFromBits', () => {\n  for (var i = 0; i < TEST_BITS.length; i += 2) {\n    let val = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    assertEq(val._low, TEST_BITS[i + 1])\n    assertEq(val._high, TEST_BITS[i])\n  }\n})\n\nTEST('ToFromInt32', () => {\n  for (var i = 0; i < TEST_BITS.length; i += 1) {\n    let val = SInt64.fromInt32(TEST_BITS[i])\n    assertEq(val.toInt32(), TEST_BITS[i])\n  }\n})\n\nTEST('ToFromFloat64', () => {\n  for (var i = 0; i < TEST_BITS.length; i += 2) {\n    let num = TEST_BITS[i] * Math.pow(2, 32) + TEST_BITS[i + 1] >= 0 ?\n        TEST_BITS[i + 1] :\n        Math.pow(2, 32) + TEST_BITS[i + 1];\n    let val = SInt64.fromFloat64(num)\n    assertEq(val.toFloat64(), num)\n  }\n  // Test edge cases\n  assertEq(SInt64.fromFloat64(NaN), SInt64.ZERO)\n  assertEq(SInt64.fromFloat64(Infinity), SInt64.MAX)\n  assertEq(SInt64.fromFloat64(-Infinity), SInt64.MIN)\n})\n\nTEST('FromDecimalCachedValues', () => {\n  // Make sure we are not leaking longs by incorrect caching of decimal\n  // numbers and failing-fast in debug mode.\n  assertThrows(() => SInt64.fromInt32(0.1))\n  assertThrows(() => SInt64.fromInt32(0.2))\n  assertThrows(() => SInt64.fromInt32(1.1))\n})\n\nTEST('egz', () => {\n  for (var i = 0; i < TEST_BITS.length; i += 2) {\n    let val = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    assertEq(val.eqz(), TEST_BITS[i] == 0 && TEST_BITS[i + 1] == 0)\n  }\n})\n\nTEST('isNeg', () => {\n  for (var i = 0; i < TEST_BITS.length; i += 2) {\n    let val = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    assertEq(val.isNeg(), (TEST_BITS[i] >> 31) != 0)\n  }\n})\n\nTEST('isOdd', () => {\n  for (var i = 0; i < TEST_BITS.length; i += 2) {\n    let val = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    assertEq(val.isOdd(), (TEST_BITS[i + 1] & 1) != 0)\n  }\n})\n\nTEST('comparisons', () => {\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    for (let j = 0; j < TEST_BITS.length; j += 2) {\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      assertEq(vi.eq(vj),  i == j, \"comparison#\" + i)\n      assertEq(vi.lt(vj),  i < j,  \"comparison#\" + i)\n      assertEq(vi.lte(vj), i <= j, \"comparison#\" + i)\n      assertEq(vi.gt(vj),  i > j,  \"comparison#\" + i)\n      assertEq(vi.gte(vj), i >= j, \"comparison#\" + i)\n    }\n  }\n})\n\nTEST('bitOperations', () => {\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let actx = `bitOperations[i=${i}]`\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    assertEq(vi.not()._high, ~TEST_BITS[i], actx)\n    assertEq(vi.not()._low, ~TEST_BITS[i + 1], actx)\n\n    for (let j = 0; j < TEST_BITS.length; j += 2) {\n      actx = `bitOperations[i=${i},j=${j}]`\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      assertEq(vi.and(vj)._high, TEST_BITS[i]     & TEST_BITS[j], actx)\n      assertEq(vi.and(vj)._low,  TEST_BITS[i + 1] & TEST_BITS[j + 1], actx)\n      assertEq(vi.or(vj)._high,  TEST_BITS[i]     | TEST_BITS[j], actx)\n      assertEq(vi.or(vj)._low,   TEST_BITS[i + 1] | TEST_BITS[j + 1], actx)\n      assertEq(vi.xor(vj)._high, TEST_BITS[i]     ^ TEST_BITS[j], actx)\n      assertEq(vi.xor(vj)._low,  TEST_BITS[i + 1] ^ TEST_BITS[j + 1], actx)\n    }\n\n    actx = `bitOperations[i=${i}]`\n    assertEq(vi.shl(0)._high,          TEST_BITS[i], actx)\n    assertEq(vi.shl(0)._low,           TEST_BITS[i + 1], actx)\n    assertEq(vi.shr_s(0)._high,         TEST_BITS[i], actx)\n    assertEq(vi.shr_s(0)._low,          TEST_BITS[i + 1], actx)\n    assertEq(vi.shr_u(0)._high, TEST_BITS[i], actx)\n    assertEq(vi.shr_u(0)._low,  TEST_BITS[i + 1], actx)\n\n    for (let len = 1; len < 64; ++len) {\n      actx = `bitOperations[i=${i},len=${len}]`\n      if (len < 32) {\n        assertEq(\n          vi.shl(len)._high,\n          (TEST_BITS[i] << len) | (TEST_BITS[i + 1] >>> (32 - len)),\n          actx\n        )\n        assertEq(vi.shl(len)._low, TEST_BITS[i + 1] << len, actx)\n\n        assertEq(vi.shr_s(len)._high, TEST_BITS[i] >> len, actx)\n        assertEq(\n          vi.shr_s(len)._low,\n          (TEST_BITS[i + 1] >>> len) | (TEST_BITS[i] << (32 - len)),\n          actx\n        )\n\n        assertEq(vi.shr_u(len)._high, TEST_BITS[i] >>> len, actx)\n        assertEq(\n          vi.shr_u(len)._low,\n          (TEST_BITS[i + 1] >>> len) | (TEST_BITS[i] << (32 - len)),\n          actx\n        )\n      } else {\n        assertEq(vi.shl(len)._high, TEST_BITS[i + 1] << (len - 32), actx)\n        assertEq(vi.shl(len)._low, 0, actx)\n\n        assertEq(vi.shr_s(len)._high, TEST_BITS[i] >= 0 ? 0 : -1, actx)\n        assertEq(vi.shr_s(len)._low, TEST_BITS[i] >> (len - 32), actx)\n\n        assertEq(vi.shr_u(len)._high, 0, actx)\n        if (len == 32) {\n          assertEq(vi.shr_u(len)._low, TEST_BITS[i], actx)\n        } else {\n          assertEq(\n            vi.shr_u(len)._low,\n            TEST_BITS[i] >>> (len - 32),\n            actx\n          )\n        }\n      }\n    }\n\n    actx = `bitOperations[i=${i}]`\n    assertEq(vi.shl(64)._high,   TEST_BITS[i], actx)\n    assertEq(vi.shl(64)._low,    TEST_BITS[i + 1], actx)\n    assertEq(vi.shr_s(64)._high, TEST_BITS[i], actx)\n    assertEq(vi.shr_s(64)._low,  TEST_BITS[i + 1], actx)\n    assertEq(vi.shr_u(64)._high, TEST_BITS[i], actx)\n    assertEq(vi.shr_u(64)._low,  TEST_BITS[i + 1], actx)\n  }\n})\n\nTEST('neg', () => {\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    if (TEST_BITS[i + 1] == 0) {\n      assertEq(vi.neg()._high, (~TEST_BITS[i] + 1) | 0)\n      assertEq(vi.neg()._low, 0)\n    } else {\n      assertEq(vi.neg()._high, ~TEST_BITS[i])\n      assertEq(vi.neg()._low,  (~TEST_BITS[i + 1] + 1) | 0)\n    }\n  }\n})\n\nTEST('add', () => {\n  let count = 0\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    for (let j = 0; j < i; j += 2) {\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      let result = vi.add(vj)\n      assertEq(result._high, TEST_ADD_BITS[count++])\n      assertEq(result._low,  TEST_ADD_BITS[count++])\n    }\n  }\n})\n\nTEST('sub', () => {\n  let count = 0\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    for (let j = 0; j < TEST_BITS.length; j += 2) {\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      let result = vi.sub(vj)\n      assertEq(result._high, TEST_SUB_BITS[count++])\n      assertEq(result._low,  TEST_SUB_BITS[count++])\n    }\n  }\n})\n\nTEST('mul', () => {\n  let count = 0;\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    for (let j = 0; j < i; j += 2) {\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      let result = vi.mul(vj)\n      assertEq(result._high, TEST_MUL_BITS[count++])\n      assertEq(result._low,  TEST_MUL_BITS[count++])\n    }\n  }\n})\n\nif (js_mul) TEST('mul/js', () => {\n  let count = 0;\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    for (let j = 0; j < i; j += 2) {\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      let result = js_mul.call(vi, vj)\n      assertEq(result._high, TEST_MUL_BITS[count++])\n      assertEq(result._low,  TEST_MUL_BITS[count++])\n    }\n  }\n})\n\nTEST('div-mod', () => {\n  let countPerDivModCall = 0\n  for (let j = 0; j < TEST_BITS.length; j += 2) {\n    let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n    if (!vj.eqz()) {\n      countPerDivModCall += 2\n    }\n  }\n\n  let countDivMod = 0\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    // goog.global['testDivMod' + i] = createTestDivMod(i, countDivMod)\n    // function createTestDivMod(i, countDivMod) {\n    //return function() {\n    let count = countDivMod\n    countDivMod += countPerDivModCall\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    for (let j = 0; j < TEST_BITS.length; j += 2) {\n      let vj = new SInt64(TEST_BITS[j + 1], TEST_BITS[j])\n      if (!vj.eqz()) {\n        let divResult = vi.div(vj)\n        assertEq(divResult._high, TEST_DIV_BITS[count])\n        assertEq(divResult._low,  TEST_DIV_BITS[count + 1])\n\n        let modResult = vi.mod(vj)\n        let combinedResult = divResult.mul(vj).add(modResult)\n        assert(vi.eq(combinedResult))\n\n        if (js_div_s) {\n          assert(js_mod_s)\n          divResult = js_div_s.call(vi, vj)\n          assertEq(divResult._high, TEST_DIV_BITS[count])\n          assertEq(divResult._low,  TEST_DIV_BITS[count + 1])\n\n          let modResult = js_mod_s.call(vi, vj)\n          let combinedResult = divResult.mul(vj).add(modResult)\n          assert(vi.eq(combinedResult))\n        }\n\n        count += 2\n      }\n    }\n  }\n})\n\n\nTEST('ToFromString', () => {\n  for (let i = 0; i < TEST_BITS.length; i += 2) {\n    let vi = new SInt64(TEST_BITS[i + 1], TEST_BITS[i])\n    let str = vi.toString(10)\n    assertEq(str, TEST_STRINGS[i / 2])\n    let n = SInt64.fromStr(str, 10)\n    assertEq(n._high, TEST_BITS[i])\n    assertEq(n._low,  TEST_BITS[i + 1])\n\n    for (let radix = 2; radix <= 36; ++radix) {\n      let result = vi.toString(radix)\n      n = SInt64.fromStr(result, radix)\n      assertEq(n._high, TEST_BITS[i])\n      assertEq(n._low,  TEST_BITS[i + 1])\n    }\n  }\n\n  // this was once wrong in goog.math.Long\n  assertEq(SInt64.fromStr(\"zzzzzz\", 36).toString(36), \"zzzzzz\")\n  assertEq(SInt64.fromStr(\"-zzzzzz\", 36).toString(36), \"-zzzzzz\")\n})\n\n","import { assertEq } from './test'\nimport { asciibuf } from './util'\nimport { Position, SrcFileSet } from './pos'\nimport { token, tokstr } from './token'\nimport * as scanner from './scanner'\n\nconst SEMIC = token.SEMICOLON\nconst ReportErrors = false\n\n\nfunction dedentMultiLineString(s :string) :string {\n  let p = s.lastIndexOf('\\n')\n  if (p == -1 || p == s.length - 1) {\n    return s\n  }\n  let ind = s.substr(p)\n  let v :string[] = []\n  for (let line of s.split('\\n')) {\n    if (line.indexOf(ind) != 0) {\n      // some line has a lower indentation -- abort and don't change s\n      return s\n    }\n    v.push(line.substr(ind.length))\n  }\n  return v.join('\\n')\n}\n\nfunction onScanError(position :Position, message :string) {\n  console.error(`[error] ${message} at ${position}`)\n}\n\nexport function dumpTokens(s :scanner.Scanner) {\n  s.next()\n  while (s.tok != token.EOF) {\n    console.log(`>> ${tokstr(s.tok)}`)\n    s.next()\n  }\n}\n\nexport function sourceScanner(srctext :string) :scanner.Scanner {\n  let s = new scanner.Scanner()\n  let fileSet = new SrcFileSet()\n  let src = asciibuf(dedentMultiLineString(srctext))\n  let file = fileSet.addFile('a', src.length)\n  s.init(file, src, ReportErrors ? onScanError : null)\n  return s\n}\n\nexport function assertTokens(srctext :string, tokens :token[]) {\n  let s = sourceScanner(srctext)\n  let i = 0\n  s.next()\n  while (s.tok != token.EOF) {\n    assert(\n      i < tokens.length,\n      `too many tokens produced; ` +\n      `got extra ${token[s.tok]} (${tokstr(s.tok)}) ` +\n      `at ${s.sfile.position(s.pos)}`,\n      assertTokens\n    )\n\n    let etok = tokens[i++] // expected token\n\n    assert(\n      etok === s.tok,\n      `expected ${token[etok]} (${tokstr(etok)}) ` +\n      `but got ${token[s.tok]} (${tokstr(s.tok)}) `+\n      `at ${s.sfile.position(s.pos)}`,\n      assertTokens\n    )\n\n    s.next()\n  }\n  assert(i == tokens.length, `too few tokens produced`, assertTokens)\n}\n\nexport function assertGotTok(s :scanner.Scanner, t :token) {\n  s.next()\n  assert(\n    s.tok == t,\n    `expected token.${token[t]} ` +\n    `but got ${token[s.tok]} (${tokstr(s.tok)}) `+\n    `at ${s.sfile.position(s.pos)}`,\n    assertGotTok\n  )\n}\n\n// ===========================================================================\n\n\nTEST('basics', () => {\n  assertTokens(`\n    123  // implicit semicolon here\n    // line comment\n    bob; // explicit semicolon doesn't generate implicit semicolon\n    /* multi-line\n       comment\n       ignored */\n    ]  // implicit semicolon here\n    `, [\n    token.INT,      SEMIC,\n    token.NAME,     SEMIC,\n    token.RBRACKET, SEMIC,\n  ])\n})\n\n\nTEST('char', () => {\n  let samples = [\n    ['a',           0x61],\n    ['K',           0x4B],\n    ['\\\\n',         0xA],\n    ['\\\\t',         0x9],\n    ['\\\\f',         0xC],\n    ['\\\\0',         0],\n    ['\\\\x00',       0],\n    ['\\\\x0A',       0xA],\n    ['\\\\xff',       0xff],\n    ['\\\\u221A',     0x221A],\n    ['\\\\U00010299', 0x10299],\n  ]\n\n  let src = samples.map(sample => `'${sample[0]}'`).join('\\n')\n  let s = sourceScanner(src)\n  // dumpTokens(sourceScanner(src))\n\n  for (let [_, value] of samples) {\n    assertGotTok(s, token.CHAR)\n    assertEq(s.int32val, value)\n    assertGotTok(s, SEMIC)\n  }\n\n  assertGotTok(s, token.EOF)\n})\n\n\nTEST('char/invalid', () => {\n  let singleInvalidCharSources = [\n    \"''\",     // empty\n    \"'ab'\",   // too long\n    \"'\\n'\",   // literal linebreak\n    \"'\\x00'\", // literal null\n    \"'\\x09'\", // literal tab\n    \"'\\\\'\",   // escape eats terminator\n    \"'\\\\2'\",  // invalid escape\n    \"'a\",     // unterminated\n    \"'\\\\U00110000'\", // invalid unicode point\n  ]\n  for (let src of singleInvalidCharSources) {\n    let s = sourceScanner(src)\n    assertGotTok(s, token.ILLEGAL)\n    assert(isNaN(s.int32val))\n    assertGotTok(s, SEMIC)\n    assertGotTok(s, token.EOF)\n  }\n})\n","import { quickcheck } from './test'\nimport { token } from './token'\nimport * as scanner from './scanner'\nimport {\n  sourceScanner,\n  assertGotTok,\n} from './scanner_test'\n\n\nfunction numberBaseForToken(t :token) :int {\n  return (\n    t == token.INT_HEX ? 16 :\n    t == token.INT_OCT ? 8 :\n    t == token.INT_BIN ? 2 :\n    10\n  )\n}\n\nfunction assertGotI32Val(s :scanner.Scanner, t :token, expectedString :string) {\n  assertGotTok(s, t)\n  let base = numberBaseForToken(t)\n  if (isNaN(s.int32val)) {\n    assert(\n      false,\n      `expected int32 value but none was parsed (s.int32val=NaN)` +\n      ` at ${s.sfile.position(s.pos)}`,\n      assertGotI32Val\n    )\n  } else if (base == 16) {\n    assert(\n      s.int32val.toString(base) === expectedString,\n      `expected int32 value ${expectedString}` +\n      ` but got 0x${s.int32val.toString(base)}` +\n      ` at ${s.sfile.position(s.pos)}`,\n      assertGotI32Val\n    )\n  } else {\n    assert(\n      s.int32val.toString(base) === expectedString,\n      `expected int32 value ${expectedString}` +\n      ` but got ${s.int32val.toString(base)} (0x${s.int32val.toString(16)})` +\n      ` at ${s.sfile.position(s.pos)}`,\n      assertGotI32Val\n    )\n  }\n}\n\nfunction assertGotF64Val(s :scanner.Scanner, expectedVal :number) {\n  assertGotTok(s, token.FLOAT)\n  assert(\n    !isNaN(s.floatval),\n    `expected float value but none was parsed (s.floatval=NaN)` +\n    ` at ${s.sfile.position(s.pos)}`,\n    assertGotF64Val\n  )\n  assert(\n    s.floatval === expectedVal,\n    `expected float value ${expectedVal} but got ${s.floatval}` +\n    ` at ${s.sfile.position(s.pos)}`,\n    assertGotF64Val\n  )\n}\n\nfunction assertGotI64Val(s :scanner.Scanner, t :token, expectedString :string) {\n  assertGotTok(s, t)\n  let base = numberBaseForToken(t)\n  if (!s.int64val) {\n    assert(\n      false,\n      `expected int64 value but none was parsed` +\n      ` at ${s.sfile.position(s.pos)}`,\n      assertGotI64Val\n    )\n  } else if (base == 16) {\n    assert(\n      s.int64val.toString(base) === expectedString,\n      `expected int64 value ${expectedString}` +\n      ` but got 0x${s.int64val.toString(base)}` +\n      ` at ${s.sfile.position(s.pos)}`,\n      assertGotI64Val\n    )\n  } else {\n    assert(\n      s.int64val.toString(base) === expectedString,\n      `expected int64 value ${expectedString}` +\n      ` but got ${s.int64val.toString(base)} (0x${s.int64val.toString(16)})` +\n      ` at ${s.sfile.position(s.pos)}`,\n      assertGotI64Val\n    )\n  }\n}\n\n\nfunction assertGotInvalidInt(s :scanner.Scanner, t :token) {\n  let base = numberBaseForToken(t)\n  assertGotTok(s, t)\n  assert(\n    isNaN(s.int32val),\n    `expected invalid int but got` +\n    ` int32val ${s.int32val.toString(base)} (0x${s.int32val.toString(16)})` +\n    ` at ${s.sfile.position(s.pos)}`,\n    assertGotInvalidInt\n  )\n  assert(\n    s.int64val == null,\n    `expected invalid int` +\n    ` but got int64val ${s.int64val ? s.int64val.toString(base) : '0'}`+\n    ` (0x${s.int64val ? s.int64val.toString(16) : '0'})` +\n    ` at ${s.sfile.position(s.pos)}`,\n    assertGotInvalidInt\n  )\n}\n\nfunction expectedStringFromSource(s :string, t :token) :string {\n  let base = numberBaseForToken(t)\n  if (s[0] == '+') {\n    s = s.substr(1) // remove \"+\" used to force parser into signed int\n  }\n  if (base != 10) {\n    // strip prefix, e.g. \"0x\"\n    s = (\n      s[0] == '-' ? '-' + s.substr(3) :\n      s.substr(2)\n    )\n  }\n  return (\n    s == '-0' ? '0' :\n    s[0] == '+' ? s.substr(1) :\n    s\n  )\n}\n\nfunction assertScanI32s(samples :[string,token][]) {\n  for (let sample of samples) {\n    let source = sample[0]\n    let expectToken = sample[1]\n    let expectString = expectedStringFromSource(source, expectToken)\n    let s = sourceScanner(source)\n    // console.log(`>> scan \"${source}\"`)\n    assertGotI32Val(s, expectToken, expectString)\n  }\n}\n\nfunction assertScanI64s(samples :[string,token][]) {\n  for (let sample of samples) {\n    let source = sample[0]\n    let expectToken = sample[1]\n    let expectString = expectedStringFromSource(source, expectToken)\n    let s = sourceScanner(source)\n    // console.log(`>> scan \"${source}\"`)\n    assertGotI64Val(s, expectToken, expectString)\n  }\n}\n\nfunction assertScanBigInts(samples :[string,token][]) {\n  for (let sample of samples) {\n    let source = sample[0]\n    let expectToken = sample[1]\n    let s = sourceScanner(source)\n    // console.log(`>> scan \"${source}\"`)\n    assertGotInvalidInt(s, expectToken)\n  }\n}\n\nfunction assertScanF64s(samples :string[]) {\n  for (let source of samples) {\n    let expectVal = parseFloat(source)\n    let s = sourceScanner(source)\n    // console.log(`>> scan \"${source}\" -> ${expectVal}`)\n    assertGotF64Val(s, expectVal)\n  }\n}\n\n\n// ===========================================================================\n\n\nTEST('int/unsigned/base16', () => {\n  // unsigned 32-bit integers\n  assertScanI32s([\n    ['0x0',        token.INT_HEX],\n    ['0x1',        token.INT_HEX],\n    ['0x123',      token.INT_HEX],\n    ['0xff0099',   token.INT_HEX],\n    ['0xdeadbeef', token.INT_HEX],\n    ['0xffffffff', token.INT_HEX], // UINT32_MAX\n  ])\n\n  // unsigned 64-bit integers\n  assertScanI64s([\n    // 64-bit integers\n    ['0x100000000',        token.INT_HEX], // UINT32_MAX + 1\n    ['0x53e2d6238da3',     token.INT_HEX],\n    ['0x346dc5d638865',    token.INT_HEX],\n    ['0x20c49ba5e353f7',   token.INT_HEX],\n    ['0x147ae147ae147ae',  token.INT_HEX],\n    ['0xccccccccccccccc',  token.INT_HEX],\n    ['0xde0b6b3a763ffff',  token.INT_HEX],\n    ['0xde0b6b3a7640000',  token.INT_HEX],\n    ['0x7fffffffffffffff', token.INT_HEX], // SINT64_MAX\n    ['0x8000000000000000', token.INT_HEX], // SINT64_MAX + 1\n    ['0x8ac7230335dc1bff', token.INT_HEX], // \n      // largest number that fits in two i32 passes\n    ['0xffffffffffffffff', token.INT_HEX], // 18446744073709551615  U64_MAX\n  ])\n\n  // unsigned bit integers\n  assertScanBigInts([\n    // large integers\n    ['0x10000000000000000',   token.INT_HEX], // UINT64_MAX + 1\n    ['0x10000000000000002',   token.INT_HEX], // UINT64_MAX + 3\n    ['0x100000000fffffffe',   token.INT_HEX], // UINT64_MAX + UINT32_MAX\n    ['0x100000000ffffffff',   token.INT_HEX], // UINT64_MAX + UINT32_MAX + 1\n    ['0x100000000fffffffd',   token.INT_HEX], // UINT64_MAX + UINT32_MAX - 1\n    ['0x29d42b64e76714244cb', token.INT_HEX],\n  ])\n})\n\n\nTEST('int/unsigned/base10', () => {\n  // unsigned 32-bit integers\n  assertScanI32s([\n    ['0',          token.INT],\n    ['1',          token.INT],\n    ['123',        token.INT],\n    ['4294967295', token.INT], // UINT32_MAX\n  ])\n\n  // unsigned 64-bit integers\n  assertScanI64s([\n    ['4294967296',           token.INT], // UINT32_MAX + 1\n    ['92233720368547',       token.INT],\n    ['922337203685477',      token.INT],\n    ['9223372036854775',     token.INT],\n    ['92233720368547758',    token.INT],\n    ['922337203685477580',   token.INT],\n    ['999999999999999999',   token.INT],\n    ['1000000000000000000',  token.INT],\n    ['9223372036854775807',  token.INT], // SINT64_MAX\n    ['9223372036854775808',  token.INT], // SINT64_MAX + 1\n    ['9999999994294967295',  token.INT],\n      // largest number that fits in two i32 passes\n    ['10000000000000000000', token.INT],\n    ['10000000009999999999', token.INT],\n    ['9999999999999999999',  token.INT],\n    ['9999999999800000000',  token.INT],\n    ['18446744073709551615', token.INT], // U64_MAX\n  ])\n\n  // unsigned bit integers\n  assertScanBigInts([\n    ['18446744073709551616',   token.INT],  // U64_MAX + 1\n    ['18446744073709551618',   token.INT],  // U64_MAX + 3\n    ['18446744078004518910',   token.INT],  // U64_MAX + U32_MAX\n    ['18446744078004518911',   token.INT],  // U64_MAX + U32_MAX + 1\n    ['18446744078004518909',   token.INT],  // U64_MAX + U32_MAX - 1\n    ['90000000000000000000',   token.INT],\n    ['20000000000000000000',   token.INT],\n    ['22222222222222222222',   token.INT],\n    ['99999999999999999999',   token.INT],\n    ['12345678901234567890123', token.INT],\n    ['99999999999999999999999999999999999',token.INT],\n  ])\n})\n\n\nTEST('int/unsigned/base8', () => {\n  // unsigned 32-bit integers\n  assertScanI32s([\n    ['0o0',           token.INT_OCT],\n    ['0o1',           token.INT_OCT],\n    ['0o123',         token.INT_OCT],\n    ['0o4671',        token.INT_OCT],\n    ['0o37777777777', token.INT_OCT], // UINT32_MAX\n  ])\n\n  // unsigned 64-bit integers\n  assertScanI64s([\n    // 64-bit integers\n    ['0o40000000000',            token.INT_OCT], // UINT32_MAX + 1\n    ['0o2476132610706643',       token.INT_OCT], // \n    ['0o32155613530704145',      token.INT_OCT], // \n    ['0o406111564570651767',     token.INT_OCT], // \n    ['0o5075341217270243656',    token.INT_OCT], // \n    ['0o63146314631463146314',   token.INT_OCT], // \n    ['0o67405553164730777777',   token.INT_OCT], // \n    ['0o67405553164731000000',   token.INT_OCT], // \n    ['0o777777777777777777777',  token.INT_OCT], // I64_MAX\n    ['0o1000000000000000000000', token.INT_OCT], // I64_MAX + 1\n    ['0o1053071060146567015777', token.INT_OCT],\n      // largest number that fits in two i32 passes\n    ['0o1777777777777777777777', token.INT_OCT], // U64_MAX\n  ])\n\n  // unsigned bit integers\n  assertScanBigInts([\n    ['0o2000000000000000000000',    token.INT_OCT], // U64_MAX + 1\n    ['0o2000000000037777777776',    token.INT_OCT], // U64_MAX + U32_MAX\n    ['0o2000000000037777777777',    token.INT_OCT], // U64_MAX + U32_MAX + 1\n    ['0o2000000000037777777775',    token.INT_OCT], // U64_MAX + U32_MAX - 1\n    ['0o7777777777777777777777',    token.INT_OCT],\n    ['0o10000000000000000000000',   token.INT_OCT],\n    ['0o2472412662347316120442313', token.INT_OCT],\n  ])\n})\n\n\nTEST('int/unsigned/base2', () => {\n  // unsigned 32-bit integers\n  assertScanI32s([\n    ['0b0',           token.INT_BIN],\n    ['0b1',           token.INT_BIN],\n    ['0b100',         token.INT_BIN],\n    ['0b111',         token.INT_BIN],\n    ['0b10101',       token.INT_BIN],\n    ['0b11111111111111111111111111111111', token.INT_BIN], // UINT32_MAX\n  ])\n\n  // unsigned 64-bit integers\n  assertScanI64s([\n    // 64-bit integers\n    [ '0b100000000000000000000000000000000',\n      token.INT_BIN ], // UINT32_MAX + 1\n    [ '0b10100111110001011010110001000111000110110100011',\n      token.INT_BIN ],\n    [ '0b11010001101101110001011101011000111000100001100101',\n      token.INT_BIN ],\n    [ '0b100000110001001001101110100101111000110101001111110111',\n      token.INT_BIN ],\n    [ '0b101000111101011100001010001111010111000010100011110101110',\n      token.INT_BIN ],\n    [ '0b110011001100110011001100110011001100110011001100110011001100',\n      token.INT_BIN ],\n    [ '0b110111100000101101101011001110100111011000111111111111111111',\n      token.INT_BIN ],\n    [ '0b110111100000101101101011001110100111011001000000000000000000',\n      token.INT_BIN ],\n    [ '0b111111111111111111111111111111111111111111111111111111111111111',\n      token.INT_BIN ], // I64_MAX\n    [ '0b1000000000000000000000000000000000000000000000000000000000000000',\n      token.INT_BIN ], // I64_MAX + 1\n    [ '0b1000101011000111001000110000001100110101110111000001101111111111',\n      token.INT_BIN ], // largest number that fits in two i32 passes\n    [ '0b1111111111111111111111111111111111111111111111111111111111111111',\n      token.INT_BIN ], // U64_MAX\n  ])\n\n  // unsigned bit integers\n  assertScanBigInts([\n    [ '0b10000000000000000000000000000000000000000000000000000000000000000',\n      token.INT_BIN], // U64_MAX + 1\n    [ '0b10000000000000000000000000000000011111111111111111111111111111110',\n      token.INT_BIN], // U64_MAX + U32_MAX\n    [ '0b10000000000000000000000000000000011111111111111111111111111111111',\n      token.INT_BIN], // U64_MAX + U32_MAX + 1\n    [ '0b10000000000000000000000000000000011111111111111111111111111111101',\n      token.INT_BIN], // U64_MAX + U32_MAX - 1\n    [\n'0b10100111010100001010110110010011100111011001110001010000100100010011001011',\n      token.INT_BIN], // 12345678901234567890123\n  ])\n})\n\n\nTEST('int/signed/base16', () => {\n  // signed 32-bit integers\n  assertScanI32s([\n    ['-0x0',        token.INT_HEX],\n    ['+0x0',        token.INT_HEX],\n    ['-0x1',        token.INT_HEX],\n    ['+0x12c',      token.INT_HEX],\n    ['-0x12c',      token.INT_HEX],\n    ['+0xaff',      token.INT_HEX],\n    ['-0xaff',      token.INT_HEX],\n    ['-0x80000000', token.INT_HEX], // SINT32_MIN\n    ['+0x7fffffff', token.INT_HEX], // SINT32_MAX\n  ])\n\n  // signed 64-bit integers\n  assertScanI64s([\n    ['-0x80000001',         token.INT_HEX], // SINT32_MIN - 1\n    ['+0x80000000',         token.INT_HEX], // SINT32_MAX + 1\n    ['-0x100000000',        token.INT_HEX],\n    ['-0x1000000000000000', token.INT_HEX],\n    ['+0x1000000000000000', token.INT_HEX],\n    ['-0xfffffffffffffff',  token.INT_HEX],\n    ['+0xfffffffffffffff',  token.INT_HEX],\n    ['-0x7fffffffffffffff', token.INT_HEX], // SINT64_MIN + 1\n    ['-0x8000000000000000', token.INT_HEX], // SINT64_MIN\n    ['+0x7fffffffffffffff', token.INT_HEX], // SINT64_MAX\n  ])\n\n  // signed bit integers\n  assertScanBigInts([\n    ['-0x8000000000000001',       token.INT_HEX], // SINT64_MIN - 1\n    ['-0x8000000000000002',       token.INT_HEX], // SINT64_MIN - 2\n    ['+0x8000000000000000',       token.INT_HEX], // SINT64_MAX + 1\n    ['+0x8000000000000001',       token.INT_HEX], // SINT64_MAX + 2\n    ['+0xffffffffffffffff',       token.INT_HEX],\n    ['-0xffffffffffffffff',       token.INT_HEX],\n    ['+0x1000000000000000f',      token.INT_HEX],\n    ['-0x1000000000000000f',      token.INT_HEX],\n    ['+0xcacacacacaccacacacacac', token.INT_HEX],\n  ])\n})\n\n\nTEST('int/signed/base10', () => {\n  // signed 32-bit integers\n  assertScanI32s([\n    ['-1',          token.INT],\n    ['+1',          token.INT],\n    ['-0',          token.INT],\n    ['+0',          token.INT],\n    ['-123',        token.INT],\n    ['+123',        token.INT],\n    ['-987',        token.INT],\n    ['-2147483648', token.INT], // SINT32_MIN\n    ['+2147483647', token.INT], // SINT32_MAX\n  ])\n\n  // signed 64-bit integers\n  assertScanI64s([\n    ['-2147483649',          token.INT], // SINT32_MIN - 1\n    ['+2147483648',          token.INT], // SINT32_MAX + 1\n    ['-10000000000',         token.INT],\n    ['-92233720368547',      token.INT],\n    ['-9223372036854775807', token.INT], // SINT64_MIN + 1\n    ['-9223372036854775808', token.INT], // SINT64_MIN\n    ['+9223372036854775807', token.INT], // SINT64_MAX\n  ])\n\n  // signed bit integers\n  assertScanBigInts([\n    ['-9223372036854775809',      token.INT], // SINT64_MIN - 1\n    ['+9223372036854775808',      token.INT], // SINT64_MAX + 1\n    ['-9999999999999999999',      token.INT],\n    ['+9999999999999999999',      token.INT],\n    ['-999999999999999999999999', token.INT],\n    ['+999999999999999999999999', token.INT],\n  ])\n})\n\n\nTEST('int/signed/base8', () => {\n  // signed 32-bit integers\n  assertScanI32s([\n    ['-0o1',           token.INT_OCT],\n    ['+0o1',           token.INT_OCT],\n    ['-0o0',           token.INT_OCT],\n    ['+0o0',           token.INT_OCT],\n    ['-0o173',         token.INT_OCT], // -123\n    ['+0o173',         token.INT_OCT], // 123\n    ['-0o1467',        token.INT_OCT],\n    ['-0o20000000000', token.INT_OCT], // SINT32_MIN\n    ['+0o17777777777', token.INT_OCT], // SINT32_MAX\n  ])\n\n  // signed 64-bit integers\n  assertScanI64s([\n    ['-0o20000000001',            token.INT_OCT], // SINT32_MIN - 1\n    ['+0o20000000000',            token.INT_OCT], // SINT32_MAX + 1\n    ['+0o651341234707',           token.INT_OCT],\n    ['-0o777777777777777777777',  token.INT_OCT], // SINT64_MIN + 1\n    ['-0o1000000000000000000000', token.INT_OCT], // SINT64_MIN\n    ['+0o777777777777777777777',  token.INT_OCT], // SINT64_MAX\n  ])\n\n  // signed bit integers\n  assertScanBigInts([\n    ['-0o1000000000000000000001',     token.INT_OCT], // SINT64_MIN - 1\n    ['+0o1000000000000000000000',     token.INT_OCT], // SINT64_MAX + 1\n    ['+0o1000000000000000000001',     token.INT_OCT], // SINT64_MAX + 2\n    ['+0o7777777777777777777777',     token.INT_OCT],\n    ['+0o10000000000000000000000',    token.INT_OCT],\n    ['-0o10000000000000000000000',    token.INT_OCT],\n    ['-0o12345671234567123456712345', token.INT_OCT],\n  ])\n})\n\n\nTEST('int/signed/base2', () => {\n  // signed 32-bit integers\n  assertScanI32s([\n    ['-0b1',          token.INT_BIN],\n    ['+0b1',          token.INT_BIN],\n    ['-0b0',          token.INT_BIN],\n    ['+0b0',          token.INT_BIN],\n    ['-0b110',        token.INT_BIN],\n    ['+0b110',        token.INT_BIN],\n    ['-0b111001',     token.INT_BIN],\n    ['-0b10000000000000000000000000000000', token.INT_BIN], // SINT32_MIN\n    ['+0b1111111111111111111111111111111',  token.INT_BIN], // SINT32_MAX\n  ])\n\n  // signed 64-bit integers\n  assertScanI64s([\n    ['-0b10000000000000000000000000000001',   token.INT_BIN], // SINT32_MIN - 1\n    ['+0b10000000000000000000000000000000',   token.INT_BIN], // SINT32_MAX + 1\n    ['+0b110101010101010101010101010101010',  token.INT_BIN],\n    ['+0b1101111110000001111111000001111111', token.INT_BIN],\n    ['-0b111111111111111111111111111111111111111111111111111111111111111',\n      token.INT_BIN], // SINT64_MIN + 1\n    ['-0b1000000000000000000000000000000000000000000000000000000000000000',\n      token.INT_BIN], // SINT64_MIN\n    ['+0b111111111111111111111111111111111111111111111111111111111111111',\n      token.INT_BIN], // SINT64_MAX\n  ])\n\n  // signed bit integers\n  assertScanBigInts([\n    ['-0b1000000000000000000000000000000000000000000000000000000000000001',\n      token.INT_BIN], // SINT64_MIN - 1\n    ['+0b1000000000000000000000000000000000000000000000000000000000000000',\n      token.INT_BIN], // SINT64_MAX + 1\n    ['-0b10000000000000000000000000000000000000000000000000000000000000000',\n      token.INT_BIN],\n    ['+0b10000000000000000000000000000000000000000000000000000000000000000',\n      token.INT_BIN],\n    ['-0b11111111111111111111111111111111111111111111111111111111111111111111',\n      token.INT_BIN],\n    ['+0b11111111111111111111111111111111111111111111111111111111111111111111',\n      token.INT_BIN],\n  ])\n})\n\n\n\nTEST('int/neg-base10-quickcheck', () => {\n  function negI64Gen(i :int) :string {\n    return '-9223372036854775' + (i >= 0 ? i.toString() : '')\n  }\n\n  // negative i64s\n  quickcheck([-1, 808], i => {\n    let src = negI64Gen(i)\n    let s = sourceScanner(src)\n    s.next()\n    return (\n      s.tok == token.INT &&\n      isNaN(s.int32val) &&\n      s.int64val != null &&\n      s.int64val.toString() === src\n    )\n  })\n\n  // negative bigs\n  quickcheck([809, 10000], i => {\n    let src = negI64Gen(i)\n    let s = sourceScanner(src)\n    s.next()\n    return (\n      s.tok == token.INT &&\n      isNaN(s.int32val) &&\n      s.int64val == null\n    )\n  })\n\n})\n\n\nTEST('float', () => {\n  assertScanF64s([\n    '1.0',\n    '0.',\n    '0.0',\n    '72.40',\n    '072.40',\n    '2.71828',\n    '1.e+0',\n    '6.67428e-11',\n    '1E6',\n    '.25',\n    '.12345E+5',\n  ])\n\n  // negative\n  assertScanF64s([\n    '-1.0',\n    '-0.',\n    '-0.0',\n    '-72.40',\n    '-072.40',\n    '-2.71828',\n    '-1.e+0',\n    '-6.67428e-11',\n    '-1E6',\n    '-.25',\n    '-.12345E+5',\n  ])\n\n  // + sign (simply for compatibility with signed int syntax)\n  assertScanF64s([\n    '+1.0',\n    '+0.',\n    '+0.0',\n    '+72.40',\n    '+072.40',\n    '+2.71828',\n    '+1.e+0',\n    '+6.67428e-11',\n    '+1E6',\n    '+.25',\n    '+.12345E+5',\n  ])\n\n})\n\n","import { IntGraph } from './intgraph'\n\n\nfunction uintpairs(s :string) {\n  return s\n    .trim()\n    .split(/[\\n;]+/)\n    .map(s => s.trim())\n    .filter(s => s.length)\n    .map(uints)\n}\n\nfunction uints(s :string) {\n  return s.trim().split(/\\s+/).map(v => Number(v) >>> 0)\n}\n\n\nlet samples = {\n  nodes: uints(\n    `1 2 3 4 5 6 7 8   10 11 12 13 14    16 17 18 19 20 21 22\n     23 24 25 26 27 28\n     210 211 212 213 214     216 217 218 219 220\n    `),\n  holes: uints(\n    ` 9 15 30 40 50 60 120 123 215 `),\n  edges: uintpairs(`\n    2 1\n    3 2 ; 3 1\n    4 2 ; 4 1\n    5 4 ; 5 2\n    6 4 ; 6 1\n    7 4 ; 7 2 ; 7 6\n    8 4 ; 8 7\n    10 4 ; 10 8 ; 10 7\n    11 4 ; 11 8\n    12 4 ; 12 7\n    13 4 ; 13 8 ; 13 12 ; 13 1 ; 13 2 ; 13 26 ; 13 218\n    14 13 ; 14 4\n    16 14 ; 16 13 ; 16 4\n    17 14\n    18 13\n    19 14 ; 19 18\n    20 19\n\n    22  21\n    23  22  ; 23  21\n    24  22  ; 24  21\n    25  24  ; 25  22\n    26  24  ; 26  21\n    27  24  ; 27  22  ; 27 26\n    28  24  ; 28  27\n    210 24  ; 210 28  ; 210 27 ; 210 5 ; 210 2 ; 210 3 ; 210 25\n    211 24  ; 211 28\n    212 24  ; 212 27\n    213 24  ; 213 28  ; 213 212\n    214 213 ; 214 24\n    216 214 ; 216 213 ; 216 24\n    217 214\n    218 213\n    219 214 ; 219 218\n    220 219\n  `)\n}\n\n\nTEST('general', () => {\n  let g = new IntGraph()\n\n  // add\n  for (let id of samples.nodes) {\n    g.add(id)\n  }\n\n  // check existence\n  let maxid = 0\n  for (let id of samples.nodes) {\n    assert(g.has(id), `g.has(${id})`)\n    maxid = Math.max(maxid, id)\n  }\n  // check holes\n  for (let id of samples.holes) {\n    assert(!g.has(id), `!g.has(/* hole */ ${id})`)\n  }\n  // check non-existence\n  for (let id of samples.nodes) {\n    assert(!g.has(id + maxid + 1), `!g.has(${id + maxid + 1})`)\n    assert(!g.has(id - maxid - 1), `!g.has(${id - maxid - 1})`)\n  }\n\n  // connect edges\n  let connections = new Map()\n  for (let e of samples.edges) {\n    g.connect(e[0], e[1])\n\n    let s0 = connections.get(e[0])\n    if (s0) { s0.add(e[1]) } else { connections.set(e[0], new Set([ e[1] ])) }\n\n    let s1 = connections.get(e[1])\n    if (s1) { s1.add(e[0]) } else { connections.set(e[1], new Set([ e[0] ])) }\n  }\n\n  for (let id of samples.nodes) {\n    let expectedDegree = connections.get(id) ? connections.get(id).size : 0\n    assert(g.degree(id) == expectedDegree,\n      `g.degree(${id}) = ${g.degree(id)} = ${expectedDegree}`)\n  }\n\n  // verify connections\n  for (let e of samples.edges) {\n    assert(g.connected(e[0], e[1]), `g.connected(${e[0]}, ${e[1]})`)\n    assert(g.connected(e[1], e[0]), `g.connected(${e[1]}, ${e[0]})`)\n  }\n  // full connection check using connections map\n  for (let id1 of samples.nodes) {\n    let expectedEdges = connections.get(id1)\n    for (let id2 of samples.nodes) {\n      let isConnected = g.connected(id1, id2)\n      if (expectedEdges && expectedEdges.has(id2)) {\n        assert(isConnected, `g.connected(${id1}, ${id2})`)\n      } else {\n        assert(!isConnected, `!g.connected(${id1}, ${id2})`)\n      }\n    }\n  }\n\n  // verify edges\n  // for (let edge of samples.edges) {\n  //   let edges0 = g.edges(edge[0])\n  //   assert(edges0.indexOf(edge[1]) != -1,\n  //     `g.edges(${edge[0]}) contains ${edge[1]}`)\n\n  //   let edges1 = g.edges(edge[1])\n  //   assert(edges1.indexOf(edge[0]) != -1,\n  //     `g.edges(${edge[1]}) contains ${edge[0]}`)\n  // }\n\n  // remove\n  let removed = new Set()\n  for (let id of samples.nodes) {\n    // console.log(`remove ${id}; state before:`); g.inspect()\n    g.remove(id)\n    removed.add(id)\n    // console.log(`removed ${id}; state after:`); g.inspect()\n    assert(!g.has(id), `!g.has(${id}) after removing it`)\n\n\n    // verify connections\n    for (let [id1, id2] of samples.edges) {\n      let isconn1 = g.connected(id1, id2)\n      let isconn2 = g.connected(id2, id1)\n      if (removed.has(id1)) {\n        assert(!isconn1,\n          `g.connected(${id1}, ${id2}) even though ${id1} has been removed`)\n        assert(!isconn2,\n          `g.connected(${id2}, ${id1}) even though ${id1} has been removed`)\n      } else if (removed.has(id2)) {\n        assert(!isconn1,\n          `g.connected(${id1}, ${id2}) even though ${id2} has been removed`)\n        assert(!isconn2,\n          `g.connected(${id2}, ${id1}) even though ${id2} has been removed`)\n      } else {\n        assert(isconn1, `g.connected(${id1}, ${id2})`)\n        assert(isconn2, `g.connected(${id2}, ${id1})`)\n      }\n    }\n  }\n\n})\n","import { Parser } from './parser'\nimport { bindpkg } from './bind'\nimport * as scanner from './scanner'\nimport { Position, SrcFileSet } from './pos'\nimport { ByteStrSet } from './bytestr'\nimport { TypeSet } from './typeset'\nimport { Package, Scope, Ent } from './ast'\nimport { astRepr } from './ast_repr'\nimport { Universe } from './universe'\nimport { TypeResolver } from './resolve'\nimport { stdoutStyle, stdoutSupportsStyle } from './termstyle'\n\nimport { Pkg as IRPkg } from './ir/ssa'\nimport { IRBuilder, IRBuilderFlags } from './ir/builder'\nimport { printir, fmtir } from './ir/repr'\n// import { IRVirtualMachine } from './ir/vm'\nimport { runPassesDev } from './ir/passes'\n\nimport { archs } from './arch/all'\nimport './all_tests'\n\n\n// fs\ntype SyncFileReader = (fn :string, options? :{[k:string]:any}) => Uint8Array\nlet readFileSync :SyncFileReader\nlet isNodeJsLikeEnv = false\ntry {\n  const _readFileSync = require('fs').readFileSync\n  readFileSync = _readFileSync as SyncFileReader\n  isNodeJsLikeEnv = true\n} catch(_) {\n  // Hack to support the playground.\n  // TODO: export a nice API instead of this mess.\n  let global_readFileSync = global['readFileSync']\n  if (global_readFileSync && typeof global_readFileSync == 'function') {\n    readFileSync = global_readFileSync as SyncFileReader\n  } else {\n    readFileSync = (fn :string, options? :{[k:string]:any}) => {\n      // FIXME\n      console.log('TODO read', fn, 'options:', options)\n      return new Uint8Array(0)\n    }\n  }\n}\n\n\nconst reprOptions = {colors:stdoutSupportsStyle}\n\n// TODO FIXME this collects errors and diagnostics for the web playground.\n// replace this with a better API.\ninterface diaginfo {\n  type: string  // info | warn | error\n  errcode?: string // available when type==\"error\"\n  message: string\n  pos: Position\n}\nlet diagnostics :diaginfo[]\n\nfunction errh(pos :Position, message :string, errcode :string) {\n  if (isNodeJsLikeEnv) {\n    let msg = `${pos}: ${message} (${errcode})`\n    console.error(stdoutStyle.red(msg))\n  }\n  diagnostics.push({ type: 'error', errcode, message, pos })\n}\n\nfunction diagh(pos :Position, message :string, type :string) {\n  if (isNodeJsLikeEnv) {\n    const msg = `${pos}: ${type}: ${message}`\n    console.log(\n      '[diag] ' +\n      ( type == \"info\" ? stdoutStyle.cyan(msg) :\n        stdoutStyle.lightyellow(msg)\n      )\n    )\n  }\n  diagnostics.push({ type, message, pos })\n}\n\ninterface ParseResults {\n  pkg     :Package\n  success :bool\n}\n\nfunction parsePkg(\n  name     :string,\n  sources  :string[],\n  universe :Universe,\n  parser   :Parser,\n  typeres  :TypeResolver,\n) :Promise<ParseResults> {\n\n  const pkg = new Package(name, new Scope(universe.scope))\n  const fset = new SrcFileSet()\n\n  typeres.init(fset, universe, errh)\n\n  for (let filename of sources) {\n    if (isNodeJsLikeEnv) {\n      banner(`parse ${filename}`)\n    }\n\n    const sdata = readFileSync(filename, {flag:'r'}) as Uint8Array\n    const sfile = fset.addFile(filename, sdata.length)\n\n    parser.initParser(\n      sfile,\n      sdata,\n      universe,\n      pkg.scope,\n      typeres,\n      errh,\n      diagh,\n      scanner.Mode.ScanComments\n    )\n\n    const file = parser.parseFile()\n    pkg.files.push(file)\n\n    if (isNodeJsLikeEnv) {\n      if (file.imports) {\n        console.log(`${file.imports.length} imports`)\n        for (let imp of file.imports) {\n          console.log(astRepr(imp, reprOptions))\n        }\n      }\n\n      if (file.unresolved) {\n        console.log(`${file.unresolved.size} unresolved references`)\n        for (let ident of file.unresolved) {\n          console.log(' - ' + astRepr(ident, reprOptions))\n        }\n      }\n\n      console.log(`${file.decls.length} declarations`)\n      // for (let decl of file.decls) {\n      //   console.log(astRepr(decl, reprOptions))\n      // }\n      console.log(astRepr(file, reprOptions))\n    }\n  }\n\n  if (parser.errorCount > 0 || typeres.errorCount > 0) {\n    return Promise.resolve({ pkg, success: false })\n  }\n\n  // bind and assemble package\n  if (isNodeJsLikeEnv) {\n    banner(`bind & assemble ${pkg}`)\n  }\n  function importer(_imports :Map<string,Ent>, _path :string) :Promise<Ent> {\n    return Promise.reject(new Error(`not found`))\n  }\n\n  return bindpkg(pkg, fset, importer, typeres, errh)\n    .then(hasErrors => ( { pkg, success: !hasErrors } ))\n}\n\ninterface MainResult {\n  success     :bool\n  diagnostics :diaginfo[]\n  ast?        :Package\n  ir?         :IRPkg\n  error?      :Error\n}\n\ninterface MainOptions {\n  sources?    :string[]\n  noOptimize? :bool\n  noIR?       :bool\n  genericIR?  :bool  // stop IR pipeline early. (don't do regalloc etc.)\n}\n\nasync function main(options? :MainOptions) :Promise<MainResult> {\n  const strSet = new ByteStrSet()\n  const typeSet = new TypeSet()\n  const universe = new Universe(strSet, typeSet)\n  const typeres = new TypeResolver()\n  const parser = new Parser()\n\n  options = options || {}\n\n  const _sources = (\n    options.sources && options.sources.length ? options.sources :\n    ['example/ssa1.xl']\n  )\n\n  // clear diagnostics from past run (this is a global var)\n  diagnostics = []\n\n  let r = await parsePkg(\"example\", _sources, universe, parser, typeres)\n  if (!r.success) {\n    return { success: false, diagnostics, ast: r.pkg }\n  }\n\n  // skip code generation?\n  if (options.noIR) {\n    return { success: true, diagnostics, ast: r.pkg }\n  }\n\n  // select target arch and build configuration\n  console.log('available target archs:', Object.keys(archs).join(', '))\n  const arch = archs['covm']\n  const config = arch.config({\n    optimize: !options.noOptimize,\n  })\n  console.log(`selected target config: ${config}`)\n\n\n  const irb = new IRBuilder()  // reusable\n\n  irb.init(config, diagh, IRBuilderFlags.Comments)\n\n  // print AST & build IR\n  try {\n    for (let file of r.pkg.files) {\n\n      if (isNodeJsLikeEnv) {\n        banner(\n          `${r.pkg} ${file.sfile.name} ${file.decls.length} declarations`\n        )\n        console.log(astRepr(r.pkg, reprOptions))\n        // for (let decl of file.decls) {\n        //   console.log(astRepr(decl, reprOptions))\n        // }\n        banner(`ssa-ir ${file.sfile.name}`)\n      }\n\n      // build IR\n      let sfile = file.sfile\n      for (let d of file.decls) {\n        let fn = irb.addTopLevel(sfile, d)\n        if (isNodeJsLikeEnv && fn) {\n          console.log(`\\n-----------------------\\n`)\n          printir(fn)\n        }\n      }\n\n\n      // run IP passes separately for debugging (normally run online)\n      let stopAtPass = options.genericIR ? \"lower\" : \"\"\n      for (let [_, f] of irb.pkg.funs) {\n        runPassesDev(f, config, stopAtPass, pass => {\n          if (isNodeJsLikeEnv) {\n            console.log(\n              `------------------------------------------------\\n` +\n              `after ${pass.name}\\n`\n            )\n            printir(f)\n            console.log(\n              `------------------------------------------------`)\n          }\n        })\n      }\n\n    }\n\n    // Run in development VM\n    // banner(`vm`)\n    // const vm = new IRVirtualMachine(irb.pkg, diagh)\n    // let mainfun = irb.pkg.mainFun() || null\n    // if (mainfun) {\n    //   vm.execFun(mainfun)\n    // } else {\n    //   console.warn('no main function found in package -- not executing')\n    // }\n\n    return {\n      success: true,\n      diagnostics,\n      ast: r.pkg,\n      ir: irb.pkg,\n      // code: codegen.something\n    }\n  } catch (error) {\n    if (isNodeJsLikeEnv) {\n      throw error\n    }\n    return { success: false, error, diagnostics, ast: r.pkg }\n  }\n}\n\n\n// banner prints a large message, using terminal styling when available.\n//\nfunction banner(message :string) {\n  if (stdoutSupportsStyle) {\n    // '\\x1b[47;30m'    black on white\n    // '\\x1b[40;37;1m'  bold white on black\n    // '\\x1b[44;37;1m'  bold white on blue\n    const s = (s :string) => '\\x1b[40m' + stdoutStyle.white(s) + '\\x1b[0m'\n    process.stdout.write(\n      s('\\n\\n  ' + message + '\\n') + '\\n\\n'\n    )\n  } else {\n    console.log(\n      '\\n========================================================\\n' +\n      message +\n      '\\n--------------------------------------------------------'\n    )\n  }\n}\n\nif (typeof global.runAllTests == 'function') {\n  global.runAllTests()\n}\n\nif (isNodeJsLikeEnv) {\n  if (process.argv.includes('-test-only')) {\n    console.log('only running unit tests')\n  } else {\n    // if (!sources && isNodeJsLikeEnv) {\n    //   return p.catch(err => {\n    //     console.error(err.stack || ''+err)\n    //     process.exit(1)\n    //     return { success: false, diagnostics }\n    //   })\n    // }\n    main({\n      sources: process.argv.slice(2).filter(v => !v.startsWith('-')),\n      noOptimize: process.argv.includes('-no-optimize'),\n    }).catch(err => {\n      console.error(err.stack || ''+err)\n      process.exit(1)\n      // return { success: false, diagnostics }\n    })\n  }\n} else {\n  global['colang'] = {\n    main,\n    fmtast: astRepr,\n    fmtir,\n    printir,\n  }\n}\n"],"names":["utf8.encodeAsString","path.dir","utf8.decode","utf8.UniSelf","unicode.repr","unicode.isEmojiModifier","unicode.isEmojiModifierBase","unicode.MaxRune","utf8.UTFMax","utf8.encode","unicode.isValid","unicode.isLetter","unicode.isDigit","bufcmp","utf8.decodeToString","path.clean","path.isAbs","path.join","unicode.isEmojiPresentation","dlog","types.t_nil","types.t_char","types.t_bool","types.t_u8","types.t_i8","types.t_u16","types.t_i16","types.t_u32","types.t_i32","types.t_u64","types.t_i64","types.t_uint","types.t_int","types.t_usize","types.t_isize","types.t_f32","types.t_f64","types.t_byte","types.t_str","scanner.Scanner","scanner.Mode","bitypes","util.search","ast.Field","ast.VarDecl","ast.TypeDecl","ast.Ident","ast.Block","ast.FunExpr","ast.TupleExpr","ast.RestTypeExpr","ast.CallExpr","ast.Assignment","ast.Operation","ast.IndexExpr","ast.IfExpr","Block","style","ast.builtInTypes","types.intTypes","ast.MultiDecl","ast.ImportDecl","ast.ReturnStmt","ast.WhileStmt","ast.Expr","ast.NumLit","wasm","_SInt64","noReg","op","T.t_u32"],"mappings":"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AI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IA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,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAA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IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ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AC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG;QACtE,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC;QACvE,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC;QACxE,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG;QACvE,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG;QACxE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACzE,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE;QACzE,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG;QACxE,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACvE,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE;QACzE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EA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,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,CAAC;IACD,CAAC;IACD,CAAC;IACD,CAAC;IACD,CAAC;IACD,CAAC;IACD,CAAC;IACD,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,CAAC;IACD,CAAC;IACD,CAAC;IACD,CAAC;IACD,SAAS,GAAG,cAAc;IAC1B,CAAC;IACD,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,SAAS,GAAG,cAAc;IAC1B,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C,GAAG;QACzE,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG;QACvE,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG;QACvE,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC;QACzE,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACxE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG;QACzE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE;QACxE,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE;QACvE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACxE,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC;QACxE,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG;QACxE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC;QACzE,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACxE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE;QACxE,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE;QACxE,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACtE,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACzE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC;QACvE,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE;QACxE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACzE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG;QACzE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC;QACxE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACxE,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC;QACtE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACzE,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC;QACtE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG;QACzE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACvE,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE;QACvE,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE;QACxE,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG;QACxE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG;QACvE,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACtE,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE;QACzE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACzE,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC;QACxE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC;QACzE,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACxE,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG;QACvE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE;QACxE,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;QACvE,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE;KAEzC,CAAC,CAAC,EA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C,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG;QACvE,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE;QACzE,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACzE,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG;QACxE,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAA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AE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU;CACvB,CAAC,CAAA;AAEF,IAAI,aAAa,GAAG,QAAQ,CAAC;IAC3B,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU;CACvB,CAAC,CAAA;AAEF,IAAI,aAAa,GAAG,QAAQ,CAAC;IAC3B,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU;CACvB,CAAC,CAAA;AAEF,IAAI,aAAa,GAAG,QAAQ,CAAC;IAC3B,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IACtE,UAAU,EAAE,UAAU,EAAE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"}