{"version":3,"file":"xlang.debug.js","sources":["../src/btree.ts","../src/token.ts","../src/utf8.ts","../src/util.ts","../src/unicode.ts","../src/error.ts","../src/path.ts","../src/scanner.ts","../src/ast.ts","../src/universe.ts","../src/parser.ts","../src/bind.ts","../src/pos.ts","../src/bytestr.ts","../src/typeset.ts","../src/termstyle.ts","../src/ast-repr.ts","../src/resolve.ts","../src/main.ts"],"sourcesContent":["export interface BTreeNode<T> {\n  k  :ArrayLike<byte>\n  v  :T\n  L? :BTreeNode<T>\n  R? :BTreeNode<T>\n}\n\nexport class BTree<T> {\n  readonly root :BTreeNode<T>\n  constructor(root :BTreeNode<T>) {\n    this.root = root\n  }\n\n  get(key :ArrayLike<byte>) :T|null {\n    return lookup(key, this.root)\n  }\n}\n\n// function lookup<T>(key :ArrayLike<byte>, n :BTreeNode<T>) :T|null {\n//   let c = bufcmp(key, n.k)\n//   return (\n//     (c == -1) ? n.L ? lookup(key, n.L) : null :\n//     (c == 1) ? n.R ? lookup(key, n.R) : null :\n//     (key.length == n.k.length) ? n.v :\n//     null\n//   )\n// }\n\nfunction lookup<T>(key :ArrayLike<byte>, n :BTreeNode<T>) :T|null {\n  while (n) {\n    const c = bufcmp(key, n.k)\n    if (c == -1) {\n      n = n.L as BTreeNode<T>\n    } else if (c == 1) {\n      n = n.R as BTreeNode<T>\n    } else if (key.length == n.k.length) {\n      return n.v\n    } else {\n      break\n    }\n  }\n  return null\n}\n\nfunction bufcmp(a :ArrayLike<byte>, b :ArrayLike<byte>) :int {\n  const aL = a.length, bL = b.length, L = (aL < bL ? aL : bL)\n  for (let i = 0; i != L; ++i) {\n    if (a[i] < b[i]) { return -1 }\n    if (b[i] < a[i]) { return 1 }\n  }\n  return (\n    aL < bL ? -1 :\n    bL < aL ? 1 :\n    0\n  )\n}\n","import { BTree } from './btree'\n\nexport function tokIsKeyword(t :token) :bool {\n  return token.keyword_beg < t && t < token.keyword_end\n}\n\nexport function hasIntValue(t :token) :bool {\n  return t == token.CHAR\n}\n\nexport function hasByteValue(t :token) :bool {\n  return (\n    (token.literal_beg < t && t < token.literal_end) ||\n    t == token.COMMENT\n  )\n}\n\nexport function tokstr(t :token) :string {\n  return tokenStrings.get(t) || token[t].toLowerCase()\n}\n\n// Operator precedences\nexport enum prec {\n  LOWEST, // = := ! <- ->\n  OR,     // ||\n  AND,    // &&\n  CMP,    // == != < <= > >=\n  ADD,    // + - | ^\n  MUL,    // * / % & &^ << >>\n}\n\nexport enum token {\n  // Special tokens\n  ILLEGAL = 0,\n  EOF,\n  COMMENT,\n\n  literal_beg,\n  // Identifiers and basic type literals\n  // (these tokens stand for classes of literals)\n  NAME,    // main\n  NAMEAT,  // @foo, @\n  INT,     // 12345\n  INT_BIN, // 0b1010\n  INT_OCT, // 0o6737\n  INT_HEX, // 0xBE3f\n  FLOAT,   // 123.45\n  RATIO,   // 22/7\n  CHAR,    // 'a'\n  STRING,  // \"abc\"\n  STRING_MULTI, // \"ab\\nc\" â€” multi-line\n  STRING_PIECE, // \"a ${...} b\" -- the \"a \" part (\" b\" is STRING)\n  literal_end,\n\n  // Delimiters\n  delim_beg,\n  LPAREN,    // (\n  LBRACK,    // [\n  LBRACE,    // {\n  COMMA,     // ,\n  DOT,       // .\n  PERIODS,   // ..\n  ELLIPSIS,  // ...\n  RPAREN,    // )\n  RBRACK,    // ]\n  RBRACE,    // }\n  SEMICOLON, // ;\n  COLON,     // :\n  delim_end,\n\n  // Operators\n  operator_beg,\n\n  // prec.LOWEST\n  ASSIGN,         // =\n  assignop_beg,\n  ADD_ASSIGN,     // +=\n  SUB_ASSIGN,     // -=\n  MUL_ASSIGN,     // *=\n  QUO_ASSIGN,     // /=\n  REM_ASSIGN,     // %=\n  AND_ASSIGN,     // &=\n  OR_ASSIGN,      // |=\n  XOR_ASSIGN,     // ^=\n  SHL_ASSIGN,     // <<=\n  SHR_ASSIGN,     // >>=\n  AND_NOT_ASSIGN, // &^=\n  assignop_end,\n  INC,            // ++\n  DEC,            // --\n  SET_ASSIGN,     // :=\n  NOT,            // !\n  ARROWL,         // <-\n  ARROWR,         // ->\n\n  // prec.OR\n  LOR, // ||\n  \n  // prec.AND\n  LAND, // &&\n\n  // prec.CMP\n  EQL, // ==\n  NEQ, // !=\n  LSS, // <\n  LEQ, // <=\n  GTR, // >\n  GEQ, // >=\n  \n  // prec.ADD\n  ADD, // +\n  SUB, // -\n  OR,  // |\n  XOR, // ^\n  \n  // prec.MUL\n  MUL,     // *\n  QUO,     // /\n  REM,     // %\n  AND,     // &\n  AND_NOT, // &^\n  SHL,     // <<\n  SHR,     // >>\n\n  operator_end,\n\n  // Keywords\n  keyword_beg,\n  BREAK,\n  //CASE,\n  //CHAN,\n  //CONST,\n  CONTINUE,\n  DEFAULT,\n  DEFER,\n  ELSE,\n  ENUM,\n  FALLTHROUGH,\n  FOR,\n  FUN,\n  GO,\n  //GOTO,\n  IF,\n  IMPORT,\n  INTERFACE,\n  IN,\n  //MAP,\n  //PACKAGE,\n  //RANGE,\n  RETURN,\n  SELECT,\n  //STRUCT,\n  SWITCH,\n  SYMBOL,\n  TYPE,\n  // VAR,\n  keyword_end\n} // enum T\n\n\n// Keywords\n// When you add, change or remove a keyword, make sure to run gen-btree.js\n// with the changes and update the code below.\n// Keyword token names should be the UPPER-CASE version of the actual keyword\n// name. This convention is used to populate tokenStrings.\n\n\nconst tokenStrings = new Map<token, string>([\n  [token.NAMEAT, \"@\"],\n\n  [token.ADD, \"+\"],\n  [token.SUB, \"-\"],\n  [token.MUL, \"*\"],\n  [token.QUO, \"/\"],\n  [token.REM, \"%\"],\n\n  [token.AND,     \"&\"],\n  [token.OR,      \"|\"],\n  [token.XOR,     \"^\"],\n  [token.SHL,     \"<<\"],\n  [token.SHR,     \">>\"],\n  [token.AND_NOT, \"&^\"],\n\n  [token.ADD_ASSIGN, \"+=\"],\n  [token.SUB_ASSIGN, \"-=\"],\n  [token.MUL_ASSIGN, \"*=\"],\n  [token.QUO_ASSIGN, \"/=\"],\n  [token.REM_ASSIGN, \"%=\"],\n\n  [token.AND_ASSIGN,     \"&=\"],\n  [token.OR_ASSIGN,      \"|=\"],\n  [token.XOR_ASSIGN,     \"^=\"],\n  [token.SHL_ASSIGN,     \"<<=\"],\n  [token.SHR_ASSIGN,     \">>=\"],\n  [token.AND_NOT_ASSIGN, \"&^=\"],\n\n  [token.LAND,   \"&&\"],\n  [token.LOR,    \"||\"],\n  [token.ARROWL, \"<-\"],\n  [token.ARROWR, \"->\"],\n  [token.INC,    \"++\"],\n  [token.DEC,    \"--\"],\n\n  [token.EQL,    \"==\"],\n  [token.LSS,    \"<\"],\n  [token.GTR,    \">\"],\n  [token.ASSIGN, \"=\"],\n  [token.NOT,    \"!\"],\n\n  [token.NEQ,        \"!=\"],\n  [token.LEQ,        \"<=\"],\n  [token.GEQ,        \">=\"],\n  [token.SET_ASSIGN, \":=\"],\n  [token.ELLIPSIS,   \"...\"],\n  [token.PERIODS,    \"..\"],\n\n  [token.LPAREN, \"(\"],\n  [token.LBRACK, \"[\"],\n  [token.LBRACE, \"{\"],\n  [token.COMMA,  \",\"],\n  [token.DOT,    \".\"],\n\n  [token.RPAREN,    \")\"],\n  [token.RBRACK,    \"]\"],\n  [token.RBRACE,    \"}\"],\n  [token.SEMICOLON, \";\"],\n  [token.COLON,     \":\"],\n]) // tokenStrings\n\nfor (let i = token.keyword_beg+1; i < token.keyword_end; ++i) {\n  const t = token[i] as string\n  tokenStrings.set((token as any)[t] as token, t.toLowerCase())\n}\n\n// generated by gen-keywords.js\nconst cdat = new Uint8Array([\n  102,117,110,100,101,102,101,114,98,114,101,97,107,99,111,110,116,105,110,117\n  ,101,100,101,102,97,117,108,116,101,110,117,109,101,108,115,101,102,97,108\n  ,108,116,104,114,111,117,103,104,102,111,114,105,110,116,101,114,102,97,99\n  ,101,105,102,103,111,105,109,112,111,114,116,105,110,115,101,108,101,99,116\n  ,114,101,116,117,114,110,115,119,105,116,99,104,115,121,109,98,111,108,116\n  ,121,112,101]);\nconst keywords = new BTree<token>(\n  { k: cdat.subarray(0,3) /*fun*/, v: token.FUN,\n    L:{ k: cdat.subarray(3,8) /*defer*/, v: token.DEFER,\n      L:{ k: cdat.subarray(8,13) /*break*/, v: token.BREAK,\n        R:{ k: cdat.subarray(13,21) /*continue*/, v: token.CONTINUE,\n          R:{ k: cdat.subarray(21,28) /*default*/, v: token.DEFAULT}}},\n      R:{ k: cdat.subarray(28,32) /*enum*/, v: token.ENUM,\n        L:{ k: cdat.subarray(32,36) /*else*/, v: token.ELSE},\n        R:{ k: cdat.subarray(36,47) /*fallthrough*/, v: token.FALLTHROUGH,\n          R:{ k: cdat.subarray(47,50) /*for*/, v: token.FOR}}}},\n    R:{ k: cdat.subarray(50,59) /*interface*/, v: token.INTERFACE,\n      L:{ k: cdat.subarray(59,61) /*if*/, v: token.IF,\n        L:{ k: cdat.subarray(61,63) /*go*/, v: token.GO},\n        R:{ k: cdat.subarray(63,69) /*import*/, v: token.IMPORT,\n          R:{ k: cdat.subarray(69,71) /*in*/, v: token.IN}}},\n      R:{ k: cdat.subarray(71,77) /*select*/, v: token.SELECT,\n        L:{ k: cdat.subarray(77,83) /*return*/, v: token.RETURN},\n        R:{ k: cdat.subarray(83,89) /*switch*/, v: token.SWITCH,\n          R:{ k: cdat.subarray(89,95) /*symbol*/, v: token.SYMBOL,\n            R:{ k: cdat.subarray(95,99) /*type*/, v: token.TYPE}}}}}}\n)\n\n// lookupKeyword maps an identifier to its keyword token or NAME\n// (if not a keyword).\n//\nexport function lookupKeyword(ident :ArrayLike<byte>) :token {\n  return keywords.get(ident) || token.NAME\n}\n","// UTF-8\n//\n// codepoint -> UTF-8 bytes\n//   encode         (dst WArrayLike<byte>, offset int, codepoint) -> nwrite int\n//   encodeString   (src string) -> Uint8Array\n//   encodeAsString (codepoint) -> string\n//\n// UTF-8 bytes -> codepoint\n//   decode         (src ArrayLike<byte>, offset int, DecodeResult) -> ok bool\n//   decodeToString (src ArrayLike<byte>) -> string\n//\n// misc\n//   byteSize(codepoint) -> size int\n//\n\nexport const\n  UniError = 0xFFFD,   // the \"error\" Rune or \"Unicode replacement character\"\n  UniSelf  = 0x80,     // characters below UniSelf are represented as\n                       // themselves in a single byte.\n  UTFMax   = 4         // Maximum number of bytes of a UTF8-encoded char\n\nconst\n  maxCp        = 0x10FFFF, // Maximum valid Unicode code point.\n  // Code points in the surrogate range are not valid for UTF-8.\n  surrogateMin = 0xD800,\n  surrogateMax = 0xDFFF,\n  // rune1Max = 1<<8 - 1  // 0x80\n  rune2Max = 1<<11 - 1 // 0x400\n  // rune3Max = 1<<16 - 1  // 0x8000\n\nexport interface DecodeResult {\n  c :int // codepoint -- UniError on error\n  w :int // width in bytes -- may be 0 on error\n}\n\nexport function decode(\n  src    :ArrayLike<byte>,\n  offset :int,\n  r      :DecodeResult\n) :bool {\n  const b = src[offset]\n\n  if (b < UniSelf) {\n    r.c = isNaN(b) ? UniError : b\n    r.w = 1\n  } else {\n    const end = src.length\n\n    if ((b >> 5) == 0x6) {\n      r.c = offset + 2 > end ? UniError :\n            ((b << 6) & 0x7ff) +\n            ((src[++offset]) & 0x3f),\n      r.w = 2\n    } else if ((b >> 4) == 0xe) {\n      r.c = offset + 3 > end ? UniError :\n            ((b << 12) & 0xffff) +\n            ((src[++offset] << 6) & 0xfff) +\n            ((src[++offset]) & 0x3f),\n      r.w = 3\n    } else if ((b >> 3) == 0x1e) {\n      r.c=  offset + 4 > end ? UniError :\n            ((b << 18) & 0x1fffff) +\n            ((src[++offset] << 12) & 0x3ffff) +\n            ((src[++offset] << 6) & 0xfff) +\n             (src[++offset] & 0x3f),\n      r.w = 4\n    } else {\n      return false\n    }\n  }\n\n  return true\n}\n\ninterface TextDecoderOptions {\n  fatal?: boolean\n  ignoreBOM?: boolean\n}\ninterface TextDecodeOptions {\n  stream?: boolean\n}\n\ndeclare class TextDecoder {\n  constructor(utfLabel?: string, options?: TextDecoderOptions)\n  encoding: string\n  fatal: boolean\n  ignoreBOM: boolean\n  decode(input?: ArrayBufferView, options?: TextDecodeOptions): string\n}\n\n\nexport let decodeToString :(src :ArrayLike<byte>) => string\n\nif (typeof TextDecoder != 'undefined') {\n  const dec = new TextDecoder('utf-8')\n  decodeToString = (src :ArrayLike<byte>) => dec.decode(\n    (src as any).buffer != undefined ? src as Uint8Array :\n    new Uint8Array(src)\n  )\n} else if (typeof Buffer != 'undefined') {\n  // nodejs\n  decodeToString = (src :ArrayLike<byte>) => {\n    let buf :Buffer\n    if (src instanceof Buffer) {\n      buf = src\n    } else if (\n      (src as any).buffer &&\n      (src as any).byteOffset !== undefined &&\n      (src as any).byteLength !== undefined\n    ) {\n      buf = Buffer.from(\n        (src as any).buffer as ArrayBuffer,\n        (src as any).byteOffset as int,\n        (src as any).byteLength as int\n      )\n    } else {\n      buf = Buffer.allocUnsafe(src.length)\n      for (let i = 0; i < src.length; ++i) {\n        buf[i] = src[i]\n      }\n    }\n    return buf.toString('utf8')\n  }\n} else {\n  // todo: fallback implementation\n  panic('missing TextDecoder')\n}\n\n\ndeclare class TextEncoder  {\n  constructor(utfLabel?: string)\n    // utfLabel ignored since Firefox >=48 and Chrome >=53 (always utf-8)\n  encoding :string // always \"utf-8\"\n  encode(input? :string, options? :TextEncodeOptions) :Uint8Array\n}\n\ninterface TextEncodeOptions {\n  stream?: boolean\n}\n\nexport let encodeString :(src :string) => Uint8Array\n\nif (typeof TextEncoder != 'undefined') {\n  const enc = new TextEncoder('utf-8')\n  encodeString = (s :string) => enc.encode(s)\n} else if (typeof Buffer != 'undefined') {\n  encodeString = (s :string) => Buffer.from(s, 'utf8') as Uint8Array\n} else {\n  // todo: fallback implementation\n  panic('missing TextEncoder')\n}\n\n\n// encode writes into b (which must be large enough) the UTF-8 encoding\n// of the character. Never writes more than UTFMax bytes.\n// Returns the number of bytes written.\n//\nexport function encode(b :WArrayLike<byte>, offs :int, cp :int) :int {\n  if (cp < UniSelf) {\n    b[offs] = cp\n    return 1\n  }\n  if (cp < 0x800) {\n    b[offs]   = (cp >> 6)   | 0xc0\n    b[++offs] = (cp & 0x3f) | 0x80\n    return 2\n  }\n  if (cp > maxCp || (surrogateMin <= cp && cp <= surrogateMax)) {\n    // invalid codepoint\n    cp = UniError\n  }\n  if (cp < 0x10000) {\n    b[offs]   = (cp >> 12)         | 0xe0\n    b[++offs] = ((cp >> 6) & 0x3f) | 0x80\n    b[++offs] = (cp & 0x3f)        | 0x80\n    return 3\n  }\n  b[offs]   = (cp >> 18)         | 0xf0\n  b[++offs] = ((cp >> 12) & 0x3f)| 0x80\n  b[++offs] = ((cp >> 6) & 0x3f) | 0x80\n  b[++offs] = (cp & 0x3f)        | 0x80\n  return 4\n}\n\nexport function byteSize(cp :int) :int {\n  return (\n    (cp < 0x80) ? 1 :\n    (cp < 0x800) ? 2 :\n    (cp < 0x10000) ? 3 :\n    4\n  )\n}\n\nexport function encodeAsString(cp :int) :string {\n  if (cp < 0 || cp > maxCp) {\n    panic(`invalid unicode code point ${cp}`)\n  }\n  if (cp < 0x10000) {\n    return String.fromCharCode(cp)\n  }\n  cp -= 0x10000\n  return String.fromCharCode(\n    (cp >> 10) + surrogateMin,\n    (cp % rune2Max) + 0xDC00\n  )\n}\n","import * as utf8 from './utf8'\n\n// export function SplitFileExt(path :string) :[string, string] {\n//   let p = path.lastIndexOf('/')\n//   p = path.lastIndexOf('.', p == -1 ? 0 : p)\n//   return p == -1 ? [path, ''] : [path.substr(0, p), path.substr(p)]\n// }\n\n// export function SplitPath(path :string) :[string, string] {\n//   const p = path.lastIndexOf('/')\n//   return p == -1 ? ['.', path] : [path.substr(0, p), path.substr(p+1)]\n// }\n\nexport function search(n :number, f :(n:number)=>bool) :int {\n  // Define f(-1) == false and f(n) == true.\n  // Invariant: f(i-1) == false, f(j) == true.\n  let i = 0, j = n\n  while (i < j) {\n    const mid = i + (((j-i)/2) >> 0) // avoid overflow and truncate to int\n    // i â‰¤ h < j\n    if (!f(mid)) {\n      i = mid + 1 // preserves f(i-1) == false\n    } else {\n      j = mid // preserves f(j) == true\n    }\n  }\n  // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n  return i\n}\n\n// bufcopy creates a new buffer containing bytes with some additional space.\n//\nfunction bufcopy(bytes :ArrayLike<byte>, addlSize :int) {\n  const size = bytes.length + addlSize\n  const b2 = new Uint8Array(size)\n  b2.set(bytes, 0)\n  // const b = Buffer.allocUnsafe(size)\n  // this.buffer.copy(b)\n  return b2\n}\n\n\n// asciibuf creates a new buffer based on a string. It simply creates an array\n// of bytes where each byte corresponds to the character value of the input\n// string. Thus, the string must only contain characters in the range [0-127]\n//\nexport function asciibuf(s :string) :Uint8Array {\n  return Uint8Array.from(\n    s as any as ArrayLike<number>,\n    (v: number, k: number) => s.charCodeAt(k)\n  )\n}\n\n// buf8str interprets a byte array as UTF-8 text\n//\nexport function buf8str(b :Uint8Array) :string {\n  return utf8.decodeToString(b)\n}\n\n\n// bufcmp compares two arrays of bytes\n//\nexport function bufcmp(\n  a       :ArrayLike<byte>,\n  b       :ArrayLike<byte>,\n  aStart  :int = 0,\n  aEnd    :int = a.length,\n  bStart  :int = 0,\n  bEnd    :int = b.length,\n) :int {\n  if (a === b) {\n    return 0\n  }\n  var ai = aStart, bi = bStart\n  for (; ai != aEnd && bi != bEnd; ++ai, ++bi) {\n    if (a[ai] < b[bi]) { return -1 }\n    if (b[bi] < a[ai]) { return 1 }\n  }\n  var aL = aEnd - aStart, bL = bEnd - bStart\n  return (\n    aL < bL ? -1 :\n    bL < aL ? 1 :\n    0\n  )\n}\n\n\n// asbuf returns a byte buffer for a\n// \nexport let asbuf :(a :ArrayLike<byte>) => Uint8Array\n\n\nif (typeof Buffer != 'undefined') {\n\n  asbuf = (a :ArrayLike<byte>) => {\n    if (a instanceof Buffer || a instanceof Uint8Array) {\n      return a as Uint8Array\n    }\n\n    if (\n      (a as any).buffer &&\n      (a as any).byteOffset !== undefined &&\n      (a as any).byteLength !== undefined\n    ) {\n      return Buffer.from(\n        (a as any).buffer as ArrayBuffer,\n        (a as any).byteOffset as int,\n        (a as any).byteLength as int\n      ) as Uint8Array\n    }\n\n    const buf = Buffer.allocUnsafe(a.length)\n    for (let i = 0; i < a.length; ++i) {\n      buf[i] = a[i]\n    }\n    return buf as Uint8Array\n  }\n\n  // function asnodebuf(a :ArrayLike<byte>) :Buffer {\n  //   return (a instanceof Buffer) ? a : new Buffer(asbuf(a))\n  // }\n\n  // bufcmp1 = (a, b, aStart, aEnd, bStart, bEnd) => {\n  //   if (a === b) {\n  //     return 0\n  //   }\n\n  //   // Note: although TS type decarations may say that Buffer.compare\n  //   // only accepts a Buffer, in fact it also accepts a Uint8Array.\n  //   if (a instanceof Buffer &&\n  //       (b instanceof Buffer || b instanceof Uint8Array))\n  //   {\n  //     return a.compare(b as Buffer, bStart, bEnd, aStart, aEnd)\n  //   }\n\n  //   if (b instanceof Buffer &&\n  //       (a instanceof Buffer || a instanceof Uint8Array))\n  //   {\n  //     return b.compare(a as Buffer, aStart, aEnd, bStart, bEnd)\n  //   }\n\n  //   const abuf = asnodebuf(a)\n  //   const bbuf = asbuf(b) as Buffer\n\n  //   return abuf.compare(bbuf, bStart, bEnd, aStart, aEnd)\n  // }\n}\n\n\nexport class AppendBuffer {\n  buffer :Uint8Array\n  length :int // current offset\n\n  constructor(size :int) {\n    this.length = 0\n    this.buffer = new Uint8Array(size)\n  }\n\n  reset() {\n    this.length = 0\n  }\n\n  // Make sure there's space for at least `size` additional bytes\n  reserve(addlSize :int) {\n    if (this.length + addlSize >= this.buffer.length) {\n      this._grow(addlSize)\n    }\n  }\n\n  subarray() :Uint8Array {\n    return this.buffer.subarray(0, this.length)\n  }\n\n  // slice() :Uint8Array {\n  //   return this.buffer.slice(0, this.length)\n  // }\n  // slice(start :int = 0, end? :int) :Uint8Array {\n  //   const _end = end === undefined ? this.length : Math.min(this.length, end)\n  //   if (this.buffer.length - (_end - start) < 128) {\n  //     // trade memory usage for speed by avoiding allocation & copy\n  //     return this.buffer.subarray(start, _end)\n  //   }\n  //   return this.buffer.slice(start, _end)\n  // }\n\n  append(b :int) :void {\n    if (this.length >= this.buffer.length) {\n      this._grow()\n    }\n    this.buffer[this.length++] = b\n  }\n\n  appendRange(src :Uint8Array, srcStart :int, srcEnd? :int) :void {\n    const end = (srcEnd === undefined) ? src.length : srcEnd\n    const size = end - srcStart\n    if (this.length + size >= this.buffer.length) {\n      this._grow(size)\n    }\n    this.buffer.set(src.subarray(srcStart, srcEnd), this.length)\n    this.length += size\n  }\n\n  private _grow(minAddlSize :int = 8) {\n    this.buffer = bufcopy(\n      this.buffer,\n      Math.min(minAddlSize, this.buffer.length)\n    )\n  }\n}\n\n// debug function\nexport const debuglog = DEBUG ? function(...v :any[]) {\n  let e = new Error()\n  let prefix = ''\n\n  if (e.stack) {\n    // let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)/.exec(e.stack.split(/\\n/, 3)[2])\n    let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)\\s+\\(.+\\/src\\/(.+)\\)/.exec(\n      e.stack.split(/\\n/, 3)[2]\n    )\n    if (m) {\n      const fun = m[1]\n      const origin = m[2]\n      if (origin) {\n        const filename = origin.split('.ts:', 1)[0]\n        const trmsg = String(v[0])\n        if (trmsg.indexOf('TODO:') == 0 || trmsg.indexOf('TODO ') == 0) {\n          // message start with \"TODO\"\n          prefix = 'TODO src/' + origin + ' ' + fun + '>'\n          v[0] = trmsg.substr(5).replace(/^\\s*/, '')\n        } else {\n          prefix = filename + '/' + fun + '>'\n        }\n      } else {\n        prefix = fun + '>'\n      }\n    } else {\n      prefix = 'DEBUG>'\n    }\n  }\n\n  v.splice(0, 0, prefix)\n  console.log.apply(console, v)\n} : function(...v :any[]){}\n\n","import * as utf8 from './utf8'\n\nexport const\n  MaxRune     = 0x10FFFF, // Maximum valid Unicode code point.\n  MaxASCII    = 0x007F,   // maximum ASCII value.\n  MaxLatin1   = 0x00FF,   // maximum Latin-1 value.\n  InvalidChar = 0xFFFD    // Represents invalid code points.\n\n\nconst fmt4 = '0000'\n\nexport function repr(cp :int) :string {\n  let s = cp.toString(16)\n  if (cp <= 0xFFFF) {\n    s = fmt4.substr(0, fmt4.length - s.length) + s\n  }\n  let str = JSON.stringify(utf8.encodeAsString(cp))\n  str = str.substr(1, str.length-2)\n  return `U+${s} '${str}'`\n}\n\nexport function isValid(c :int) :bool {\n  return c <= MaxRune && (c < 0xD800 || 0xE000 < c)\n  // D800..E000 surrogate range\n}\n\n// the rest of this file was generated by misc/gen-unicode-data.js\n\nexport function isLetter(c :int) :bool {\n  return (\n    0x41 <= c && c <= 0x1E943 && ( // LATIN CAPITAL LETTER A..ADLAM SMALL LETTER SHA\n    (0x41 <= c && c <= 0x5A) || // LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z\n    (0x61 <= c && c <= 0x7A) || // LATIN SMALL LETTER A..LATIN SMALL LETTER Z\n    c == 0xB5 || // MICRO SIGN\n    (0xC0 <= c && c <= 0xD6) || // LATIN CAPITAL LETTER A WITH GRAVE..LATIN CAPITAL LETTER O WITH DIAERESIS\n    (0xD8 <= c && c <= 0xF6) || // LATIN CAPITAL LETTER O WITH STROKE..LATIN SMALL LETTER O WITH DIAERESIS\n    (0xF8 <= c && c <= 0x1BA) || // LATIN SMALL LETTER O WITH STROKE..LATIN SMALL LETTER EZH WITH TAIL\n    (0x1BC <= c && c <= 0x1BF) || // LATIN CAPITAL LETTER TONE FIVE..LATIN LETTER WYNN\n    c == 0x1C4 || // LATIN CAPITAL LETTER DZ WITH CARON\n    (0x1C6 <= c && c <= 0x1C7) || // LATIN SMALL LETTER DZ WITH CARON..LATIN CAPITAL LETTER LJ\n    (0x1C9 <= c && c <= 0x1CA) || // LATIN SMALL LETTER LJ..LATIN CAPITAL LETTER NJ\n    (0x1CC <= c && c <= 0x1F1) || // LATIN SMALL LETTER NJ..LATIN CAPITAL LETTER DZ\n    (0x1F3 <= c && c <= 0x293) || // LATIN SMALL LETTER DZ..LATIN SMALL LETTER EZH WITH CURL\n    (0x295 <= c && c <= 0x2AF) || // LATIN LETTER PHARYNGEAL VOICED FRICATIVE..LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL\n    (0x370 <= c && c <= 0x373) || // GREEK CAPITAL LETTER HETA..GREEK SMALL LETTER ARCHAIC SAMPI\n    (0x376 <= c && c <= 0x377) || // GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA..GREEK SMALL LETTER PAMPHYLIAN DIGAMMA\n    (0x37B <= c && c <= 0x37D) || // GREEK SMALL REVERSED LUNATE SIGMA SYMBOL..GREEK SMALL REVERSED DOTTED LUNATE SIGMA SYMBOL\n    c == 0x37F || // GREEK CAPITAL LETTER YOT\n    c == 0x386 || // GREEK CAPITAL LETTER ALPHA WITH TONOS\n    (0x388 <= c && c <= 0x38A) || // GREEK CAPITAL LETTER EPSILON WITH TONOS..GREEK CAPITAL LETTER IOTA WITH TONOS\n    c == 0x38C || // GREEK CAPITAL LETTER OMICRON WITH TONOS\n    (0x38E <= c && c <= 0x3A1) || // GREEK CAPITAL LETTER UPSILON WITH TONOS..GREEK CAPITAL LETTER RHO\n    (0x3A3 <= c && c <= 0x3F5) || // GREEK CAPITAL LETTER SIGMA..GREEK LUNATE EPSILON SYMBOL\n    (0x3F7 <= c && c <= 0x481) || // GREEK CAPITAL LETTER SHO..CYRILLIC SMALL LETTER KOPPA\n    (0x48A <= c && c <= 0x52F) || // CYRILLIC CAPITAL LETTER SHORT I WITH TAIL..CYRILLIC SMALL LETTER EL WITH DESCENDER\n    (0x531 <= c && c <= 0x556) || // ARMENIAN CAPITAL LETTER AYB..ARMENIAN CAPITAL LETTER FEH\n    (0x561 <= c && c <= 0x587) || // ARMENIAN SMALL LETTER AYB..ARMENIAN SMALL LIGATURE ECH YIWN\n    (0x10A0 <= c && c <= 0x10C5) || // GEORGIAN CAPITAL LETTER AN..GEORGIAN CAPITAL LETTER HOE\n    c == 0x10C7 || // GEORGIAN CAPITAL LETTER YN\n    c == 0x10CD || // GEORGIAN CAPITAL LETTER AEN\n    (0x13A0 <= c && c <= 0x13F5) || // CHEROKEE LETTER A..CHEROKEE LETTER MV\n    (0x13F8 <= c && c <= 0x13FD) || // CHEROKEE SMALL LETTER YE..CHEROKEE SMALL LETTER MV\n    (0x1C80 <= c && c <= 0x1C88) || // CYRILLIC SMALL LETTER ROUNDED VE..CYRILLIC SMALL LETTER UNBLENDED UK\n    (0x1D00 <= c && c <= 0x1D2B) || // LATIN LETTER SMALL CAPITAL A..CYRILLIC LETTER SMALL CAPITAL EL\n    (0x1D6B <= c && c <= 0x1D77) || // LATIN SMALL LETTER UE..LATIN SMALL LETTER TURNED G\n    (0x1D79 <= c && c <= 0x1D9A) || // LATIN SMALL LETTER INSULAR G..LATIN SMALL LETTER EZH WITH RETROFLEX HOOK\n    (0x1E00 <= c && c <= 0x1F15) || // LATIN CAPITAL LETTER A WITH RING BELOW..GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA\n    (0x1F18 <= c && c <= 0x1F1D) || // GREEK CAPITAL LETTER EPSILON WITH PSILI..GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA\n    (0x1F20 <= c && c <= 0x1F45) || // GREEK SMALL LETTER ETA WITH PSILI..GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA\n    (0x1F48 <= c && c <= 0x1F4D) || // GREEK CAPITAL LETTER OMICRON WITH PSILI..GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA\n    (0x1F50 <= c && c <= 0x1F57) || // GREEK SMALL LETTER UPSILON WITH PSILI..GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI\n    c == 0x1F59 || // GREEK CAPITAL LETTER UPSILON WITH DASIA\n    c == 0x1F5B || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA\n    c == 0x1F5D || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA\n    (0x1F5F <= c && c <= 0x1F7D) || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI..GREEK SMALL LETTER OMEGA WITH OXIA\n    (0x1F80 <= c && c <= 0x1F87) || // GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1F90 <= c && c <= 0x1F97) || // GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1FA0 <= c && c <= 0x1FA7) || // GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1FB0 <= c && c <= 0x1FB4) || // GREEK SMALL LETTER ALPHA WITH VRACHY..GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FB6 <= c && c <= 0x1FBB) || // GREEK SMALL LETTER ALPHA WITH PERISPOMENI..GREEK CAPITAL LETTER ALPHA WITH OXIA\n    c == 0x1FBE || // GREEK PROSGEGRAMMENI\n    (0x1FC2 <= c && c <= 0x1FC4) || // GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI..GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FC6 <= c && c <= 0x1FCB) || // GREEK SMALL LETTER ETA WITH PERISPOMENI..GREEK CAPITAL LETTER ETA WITH OXIA\n    (0x1FD0 <= c && c <= 0x1FD3) || // GREEK SMALL LETTER IOTA WITH VRACHY..GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA\n    (0x1FD6 <= c && c <= 0x1FDB) || // GREEK SMALL LETTER IOTA WITH PERISPOMENI..GREEK CAPITAL LETTER IOTA WITH OXIA\n    (0x1FE0 <= c && c <= 0x1FEC) || // GREEK SMALL LETTER UPSILON WITH VRACHY..GREEK CAPITAL LETTER RHO WITH DASIA\n    (0x1FF2 <= c && c <= 0x1FF4) || // GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI..GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FF6 <= c && c <= 0x1FFB) || // GREEK SMALL LETTER OMEGA WITH PERISPOMENI..GREEK CAPITAL LETTER OMEGA WITH OXIA\n    c == 0x2102 || // DOUBLE-STRUCK CAPITAL C\n    c == 0x2107 || // EULER CONSTANT\n    (0x210A <= c && c <= 0x2113) || // SCRIPT SMALL G..SCRIPT SMALL L\n    c == 0x2115 || // DOUBLE-STRUCK CAPITAL N\n    (0x2119 <= c && c <= 0x211D) || // DOUBLE-STRUCK CAPITAL P..DOUBLE-STRUCK CAPITAL R\n    c == 0x2124 || // DOUBLE-STRUCK CAPITAL Z\n    c == 0x2126 || // OHM SIGN\n    c == 0x2128 || // BLACK-LETTER CAPITAL Z\n    (0x212A <= c && c <= 0x212D) || // KELVIN SIGN..BLACK-LETTER CAPITAL C\n    (0x212F <= c && c <= 0x2134) || // SCRIPT SMALL E..SCRIPT SMALL O\n    c == 0x2139 || // INFORMATION SOURCE\n    (0x213C <= c && c <= 0x213F) || // DOUBLE-STRUCK SMALL PI..DOUBLE-STRUCK CAPITAL PI\n    (0x2145 <= c && c <= 0x2149) || // DOUBLE-STRUCK ITALIC CAPITAL D..DOUBLE-STRUCK ITALIC SMALL J\n    c == 0x214E || // TURNED SMALL F\n    (0x2183 <= c && c <= 0x2184) || // ROMAN NUMERAL REVERSED ONE HUNDRED..LATIN SMALL LETTER REVERSED C\n    (0x2C00 <= c && c <= 0x2C2E) || // GLAGOLITIC CAPITAL LETTER AZU..GLAGOLITIC CAPITAL LETTER LATINATE MYSLITE\n    (0x2C30 <= c && c <= 0x2C5E) || // GLAGOLITIC SMALL LETTER AZU..GLAGOLITIC SMALL LETTER LATINATE MYSLITE\n    (0x2C60 <= c && c <= 0x2C7B) || // LATIN CAPITAL LETTER L WITH DOUBLE BAR..LATIN LETTER SMALL CAPITAL TURNED E\n    (0x2C7E <= c && c <= 0x2CE4) || // LATIN CAPITAL LETTER S WITH SWASH TAIL..COPTIC SYMBOL KAI\n    (0x2CEB <= c && c <= 0x2CEE) || // COPTIC CAPITAL LETTER CRYPTOGRAMMIC SHEI..COPTIC SMALL LETTER CRYPTOGRAMMIC GANGIA\n    (0x2CF2 <= c && c <= 0x2CF3) || // COPTIC CAPITAL LETTER BOHAIRIC KHEI..COPTIC SMALL LETTER BOHAIRIC KHEI\n    (0x2D00 <= c && c <= 0x2D25) || // GEORGIAN SMALL LETTER AN..GEORGIAN SMALL LETTER HOE\n    c == 0x2D27 || // GEORGIAN SMALL LETTER YN\n    c == 0x2D2D || // GEORGIAN SMALL LETTER AEN\n    (0xA640 <= c && c <= 0xA66D) || // CYRILLIC CAPITAL LETTER ZEMLYA..CYRILLIC SMALL LETTER DOUBLE MONOCULAR O\n    (0xA680 <= c && c <= 0xA69B) || // CYRILLIC CAPITAL LETTER DWE..CYRILLIC SMALL LETTER CROSSED O\n    (0xA722 <= c && c <= 0xA76F) || // LATIN CAPITAL LETTER EGYPTOLOGICAL ALEF..LATIN SMALL LETTER CON\n    (0xA771 <= c && c <= 0xA787) || // LATIN SMALL LETTER DUM..LATIN SMALL LETTER INSULAR T\n    (0xA78B <= c && c <= 0xA78E) || // LATIN CAPITAL LETTER SALTILLO..LATIN SMALL LETTER L WITH RETROFLEX HOOK AND BELT\n    (0xA790 <= c && c <= 0xA7AE) || // LATIN CAPITAL LETTER N WITH DESCENDER..LATIN CAPITAL LETTER SMALL CAPITAL I\n    (0xA7B0 <= c && c <= 0xA7B7) || // LATIN CAPITAL LETTER TURNED K..LATIN SMALL LETTER OMEGA\n    c == 0xA7FA || // LATIN LETTER SMALL CAPITAL TURNED M\n    (0xAB30 <= c && c <= 0xAB5A) || // LATIN SMALL LETTER BARRED ALPHA..LATIN SMALL LETTER Y WITH SHORT RIGHT LEG\n    (0xAB60 <= c && c <= 0xAB65) || // LATIN SMALL LETTER SAKHA YAT..GREEK LETTER SMALL CAPITAL OMEGA\n    (0xAB70 <= c && c <= 0xABBF) || // CHEROKEE SMALL LETTER A..CHEROKEE SMALL LETTER YA\n    (0xFB00 <= c && c <= 0xFB06) || // LATIN SMALL LIGATURE FF..LATIN SMALL LIGATURE ST\n    (0xFB13 <= c && c <= 0xFB17) || // ARMENIAN SMALL LIGATURE MEN NOW..ARMENIAN SMALL LIGATURE MEN XEH\n    (0xFF21 <= c && c <= 0xFF3A) || // FULLWIDTH LATIN CAPITAL LETTER A..FULLWIDTH LATIN CAPITAL LETTER Z\n    (0xFF41 <= c && c <= 0xFF5A) || // FULLWIDTH LATIN SMALL LETTER A..FULLWIDTH LATIN SMALL LETTER Z\n    (0x10400 <= c && c <= 0x1044F) || // DESERET CAPITAL LETTER LONG I..DESERET SMALL LETTER EW\n    (0x104B0 <= c && c <= 0x104D3) || // OSAGE CAPITAL LETTER A..OSAGE CAPITAL LETTER ZHA\n    (0x104D8 <= c && c <= 0x104FB) || // OSAGE SMALL LETTER A..OSAGE SMALL LETTER ZHA\n    (0x10C80 <= c && c <= 0x10CB2) || // OLD HUNGARIAN CAPITAL LETTER A..OLD HUNGARIAN CAPITAL LETTER US\n    (0x10CC0 <= c && c <= 0x10CF2) || // OLD HUNGARIAN SMALL LETTER A..OLD HUNGARIAN SMALL LETTER US\n    (0x118A0 <= c && c <= 0x118DF) || // WARANG CITI CAPITAL LETTER NGAA..WARANG CITI SMALL LETTER VIYO\n    (0x1D400 <= c && c <= 0x1D454) || // MATHEMATICAL BOLD CAPITAL A..MATHEMATICAL ITALIC SMALL G\n    (0x1D456 <= c && c <= 0x1D49C) || // MATHEMATICAL ITALIC SMALL I..MATHEMATICAL SCRIPT CAPITAL A\n    (0x1D49E <= c && c <= 0x1D49F) || // MATHEMATICAL SCRIPT CAPITAL C..MATHEMATICAL SCRIPT CAPITAL D\n    c == 0x1D4A2 || // MATHEMATICAL SCRIPT CAPITAL G\n    (0x1D4A5 <= c && c <= 0x1D4A6) || // MATHEMATICAL SCRIPT CAPITAL J..MATHEMATICAL SCRIPT CAPITAL K\n    (0x1D4A9 <= c && c <= 0x1D4AC) || // MATHEMATICAL SCRIPT CAPITAL N..MATHEMATICAL SCRIPT CAPITAL Q\n    (0x1D4AE <= c && c <= 0x1D4B9) || // MATHEMATICAL SCRIPT CAPITAL S..MATHEMATICAL SCRIPT SMALL D\n    c == 0x1D4BB || // MATHEMATICAL SCRIPT SMALL F\n    (0x1D4BD <= c && c <= 0x1D4C3) || // MATHEMATICAL SCRIPT SMALL H..MATHEMATICAL SCRIPT SMALL N\n    (0x1D4C5 <= c && c <= 0x1D505) || // MATHEMATICAL SCRIPT SMALL P..MATHEMATICAL FRAKTUR CAPITAL B\n    (0x1D507 <= c && c <= 0x1D50A) || // MATHEMATICAL FRAKTUR CAPITAL D..MATHEMATICAL FRAKTUR CAPITAL G\n    (0x1D50D <= c && c <= 0x1D514) || // MATHEMATICAL FRAKTUR CAPITAL J..MATHEMATICAL FRAKTUR CAPITAL Q\n    (0x1D516 <= c && c <= 0x1D51C) || // MATHEMATICAL FRAKTUR CAPITAL S..MATHEMATICAL FRAKTUR CAPITAL Y\n    (0x1D51E <= c && c <= 0x1D539) || // MATHEMATICAL FRAKTUR SMALL A..MATHEMATICAL DOUBLE-STRUCK CAPITAL B\n    (0x1D53B <= c && c <= 0x1D53E) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL D..MATHEMATICAL DOUBLE-STRUCK CAPITAL G\n    (0x1D540 <= c && c <= 0x1D544) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL I..MATHEMATICAL DOUBLE-STRUCK CAPITAL M\n    c == 0x1D546 || // MATHEMATICAL DOUBLE-STRUCK CAPITAL O\n    (0x1D54A <= c && c <= 0x1D550) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL S..MATHEMATICAL DOUBLE-STRUCK CAPITAL Y\n    (0x1D552 <= c && c <= 0x1D6A5) || // MATHEMATICAL DOUBLE-STRUCK SMALL A..MATHEMATICAL ITALIC SMALL DOTLESS J\n    (0x1D6A8 <= c && c <= 0x1D6C0) || // MATHEMATICAL BOLD CAPITAL ALPHA..MATHEMATICAL BOLD CAPITAL OMEGA\n    (0x1D6C2 <= c && c <= 0x1D6DA) || // MATHEMATICAL BOLD SMALL ALPHA..MATHEMATICAL BOLD SMALL OMEGA\n    (0x1D6DC <= c && c <= 0x1D6FA) || // MATHEMATICAL BOLD EPSILON SYMBOL..MATHEMATICAL ITALIC CAPITAL OMEGA\n    (0x1D6FC <= c && c <= 0x1D714) || // MATHEMATICAL ITALIC SMALL ALPHA..MATHEMATICAL ITALIC SMALL OMEGA\n    (0x1D716 <= c && c <= 0x1D734) || // MATHEMATICAL ITALIC EPSILON SYMBOL..MATHEMATICAL BOLD ITALIC CAPITAL OMEGA\n    (0x1D736 <= c && c <= 0x1D74E) || // MATHEMATICAL BOLD ITALIC SMALL ALPHA..MATHEMATICAL BOLD ITALIC SMALL OMEGA\n    (0x1D750 <= c && c <= 0x1D76E) || // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL..MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA\n    (0x1D770 <= c && c <= 0x1D788) || // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA..MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA\n    (0x1D78A <= c && c <= 0x1D7A8) || // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL..MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA\n    (0x1D7AA <= c && c <= 0x1D7C2) || // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA..MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA\n    (0x1D7C4 <= c && c <= 0x1D7CB) || // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL..MATHEMATICAL BOLD SMALL DIGAMMA\n    (0x1E900 <= c && c <= 0x1E943) // ADLAM CAPITAL LETTER ALIF..ADLAM SMALL LETTER SHA\n  ))\n}\n\nexport function isDigit(c :int) :bool {\n  return (\n    0x30 <= c && c <= 0x1E959 && ( // DIGIT ZERO..ADLAM DIGIT NINE\n    (0x30 <= c && c <= 0x39) || // DIGIT ZERO..DIGIT NINE\n    (0x660 <= c && c <= 0x669) || // ARABIC-INDIC DIGIT ZERO..ARABIC-INDIC DIGIT NINE\n    (0x6F0 <= c && c <= 0x6F9) || // EXTENDED ARABIC-INDIC DIGIT ZERO..EXTENDED ARABIC-INDIC DIGIT NINE\n    (0x7C0 <= c && c <= 0x7C9) || // NKO DIGIT ZERO..NKO DIGIT NINE\n    (0x966 <= c && c <= 0x96F) || // DEVANAGARI DIGIT ZERO..DEVANAGARI DIGIT NINE\n    (0x9E6 <= c && c <= 0x9EF) || // BENGALI DIGIT ZERO..BENGALI DIGIT NINE\n    (0xA66 <= c && c <= 0xA6F) || // GURMUKHI DIGIT ZERO..GURMUKHI DIGIT NINE\n    (0xAE6 <= c && c <= 0xAEF) || // GUJARATI DIGIT ZERO..GUJARATI DIGIT NINE\n    (0xB66 <= c && c <= 0xB6F) || // ORIYA DIGIT ZERO..ORIYA DIGIT NINE\n    (0xBE6 <= c && c <= 0xBEF) || // TAMIL DIGIT ZERO..TAMIL DIGIT NINE\n    (0xC66 <= c && c <= 0xC6F) || // TELUGU DIGIT ZERO..TELUGU DIGIT NINE\n    (0xCE6 <= c && c <= 0xCEF) || // KANNADA DIGIT ZERO..KANNADA DIGIT NINE\n    (0xD66 <= c && c <= 0xD6F) || // MALAYALAM DIGIT ZERO..MALAYALAM DIGIT NINE\n    (0xDE6 <= c && c <= 0xDEF) || // SINHALA LITH DIGIT ZERO..SINHALA LITH DIGIT NINE\n    (0xE50 <= c && c <= 0xE59) || // THAI DIGIT ZERO..THAI DIGIT NINE\n    (0xED0 <= c && c <= 0xED9) || // LAO DIGIT ZERO..LAO DIGIT NINE\n    (0xF20 <= c && c <= 0xF29) || // TIBETAN DIGIT ZERO..TIBETAN DIGIT NINE\n    (0x1040 <= c && c <= 0x1049) || // MYANMAR DIGIT ZERO..MYANMAR DIGIT NINE\n    (0x1090 <= c && c <= 0x1099) || // MYANMAR SHAN DIGIT ZERO..MYANMAR SHAN DIGIT NINE\n    (0x17E0 <= c && c <= 0x17E9) || // KHMER DIGIT ZERO..KHMER DIGIT NINE\n    (0x1810 <= c && c <= 0x1819) || // MONGOLIAN DIGIT ZERO..MONGOLIAN DIGIT NINE\n    (0x1946 <= c && c <= 0x194F) || // LIMBU DIGIT ZERO..LIMBU DIGIT NINE\n    (0x19D0 <= c && c <= 0x19D9) || // NEW TAI LUE DIGIT ZERO..NEW TAI LUE DIGIT NINE\n    (0x1A80 <= c && c <= 0x1A89) || // TAI THAM HORA DIGIT ZERO..TAI THAM HORA DIGIT NINE\n    (0x1A90 <= c && c <= 0x1A99) || // TAI THAM THAM DIGIT ZERO..TAI THAM THAM DIGIT NINE\n    (0x1B50 <= c && c <= 0x1B59) || // BALINESE DIGIT ZERO..BALINESE DIGIT NINE\n    (0x1BB0 <= c && c <= 0x1BB9) || // SUNDANESE DIGIT ZERO..SUNDANESE DIGIT NINE\n    (0x1C40 <= c && c <= 0x1C49) || // LEPCHA DIGIT ZERO..LEPCHA DIGIT NINE\n    (0x1C50 <= c && c <= 0x1C59) || // OL CHIKI DIGIT ZERO..OL CHIKI DIGIT NINE\n    (0xA620 <= c && c <= 0xA629) || // VAI DIGIT ZERO..VAI DIGIT NINE\n    (0xA8D0 <= c && c <= 0xA8D9) || // SAURASHTRA DIGIT ZERO..SAURASHTRA DIGIT NINE\n    (0xA900 <= c && c <= 0xA909) || // KAYAH LI DIGIT ZERO..KAYAH LI DIGIT NINE\n    (0xA9D0 <= c && c <= 0xA9D9) || // JAVANESE DIGIT ZERO..JAVANESE DIGIT NINE\n    (0xA9F0 <= c && c <= 0xA9F9) || // MYANMAR TAI LAING DIGIT ZERO..MYANMAR TAI LAING DIGIT NINE\n    (0xAA50 <= c && c <= 0xAA59) || // CHAM DIGIT ZERO..CHAM DIGIT NINE\n    (0xABF0 <= c && c <= 0xABF9) || // MEETEI MAYEK DIGIT ZERO..MEETEI MAYEK DIGIT NINE\n    (0xFF10 <= c && c <= 0xFF19) || // FULLWIDTH DIGIT ZERO..FULLWIDTH DIGIT NINE\n    (0x104A0 <= c && c <= 0x104A9) || // OSMANYA DIGIT ZERO..OSMANYA DIGIT NINE\n    (0x11066 <= c && c <= 0x1106F) || // BRAHMI DIGIT ZERO..BRAHMI DIGIT NINE\n    (0x110F0 <= c && c <= 0x110F9) || // SORA SOMPENG DIGIT ZERO..SORA SOMPENG DIGIT NINE\n    (0x11136 <= c && c <= 0x1113F) || // CHAKMA DIGIT ZERO..CHAKMA DIGIT NINE\n    (0x111D0 <= c && c <= 0x111D9) || // SHARADA DIGIT ZERO..SHARADA DIGIT NINE\n    (0x112F0 <= c && c <= 0x112F9) || // KHUDAWADI DIGIT ZERO..KHUDAWADI DIGIT NINE\n    (0x11450 <= c && c <= 0x11459) || // NEWA DIGIT ZERO..NEWA DIGIT NINE\n    (0x114D0 <= c && c <= 0x114D9) || // TIRHUTA DIGIT ZERO..TIRHUTA DIGIT NINE\n    (0x11650 <= c && c <= 0x11659) || // MODI DIGIT ZERO..MODI DIGIT NINE\n    (0x116C0 <= c && c <= 0x116C9) || // TAKRI DIGIT ZERO..TAKRI DIGIT NINE\n    (0x11730 <= c && c <= 0x11739) || // AHOM DIGIT ZERO..AHOM DIGIT NINE\n    (0x118E0 <= c && c <= 0x118E9) || // WARANG CITI DIGIT ZERO..WARANG CITI DIGIT NINE\n    (0x11C50 <= c && c <= 0x11C59) || // BHAIKSUKI DIGIT ZERO..BHAIKSUKI DIGIT NINE\n    (0x11D50 <= c && c <= 0x11D59) || // MASARAM GONDI DIGIT ZERO..MASARAM GONDI DIGIT NINE\n    (0x16A60 <= c && c <= 0x16A69) || // MRO DIGIT ZERO..MRO DIGIT NINE\n    (0x16B50 <= c && c <= 0x16B59) || // PAHAWH HMONG DIGIT ZERO..PAHAWH HMONG DIGIT NINE\n    (0x1D7CE <= c && c <= 0x1D7FF) || // MATHEMATICAL BOLD DIGIT ZERO..MATHEMATICAL MONOSPACE DIGIT NINE\n    (0x1E950 <= c && c <= 0x1E959) // ADLAM DIGIT ZERO..ADLAM DIGIT NINE\n  ))\n}\n\nexport function isWhitespace(c :int) :bool {\n  return (\n    0x0 <= c && c <= 0x3000 && ( // <control>..IDEOGRAPHIC SPACE\n    (0x0 <= c && c <= 0x20) || // <control>..SPACE\n    (0x7F <= c && c <= 0xA0) || // <control>..NO-BREAK SPACE\n    c == 0x1680 || // OGHAM SPACE MARK\n    (0x2000 <= c && c <= 0x200A) || // EN QUAD..HAIR SPACE\n    (0x2028 <= c && c <= 0x2029) || // LINE SEPARATOR..PARAGRAPH SEPARATOR\n    c == 0x202F || // NARROW NO-BREAK SPACE\n    c == 0x205F || // MEDIUM MATHEMATICAL SPACE\n    c == 0x3000 // IDEOGRAPHIC SPACE\n  ))\n}\n\n\nexport function isEmojiPresentation(c :int) :bool {\n  return (\n    0x231A <= c && c <= 0x1F9E6 && ( // WATCH..SOCKS\n    (0x231A <= c && c <= 0x231B) || // WATCH..HOURGLASS\n    (0x23E9 <= c && c <= 0x23EC) || // BLACK RIGHT-POINTING DOUBLE TRIANGLE..BLACK DOWN-POINTING DOUBLE TRIANGLE\n    c == 0x23F0 || // <unknown>\n    c == 0x23F3 || // <unknown>\n    (0x25FD <= c && c <= 0x25FE) || // WHITE MEDIUM SMALL SQUARE..BLACK MEDIUM SMALL SQUARE\n    (0x2614 <= c && c <= 0x2615) || // UMBRELLA WITH RAIN DROPS..HOT BEVERAGE\n    (0x2648 <= c && c <= 0x2653) || // ARIES..PISCES\n    c == 0x267F || // <unknown>\n    c == 0x2693 || // <unknown>\n    c == 0x26A1 || // <unknown>\n    (0x26AA <= c && c <= 0x26AB) || // MEDIUM WHITE CIRCLE..MEDIUM BLACK CIRCLE\n    (0x26BD <= c && c <= 0x26BE) || // SOCCER BALL..BASEBALL\n    (0x26C4 <= c && c <= 0x26C5) || // SNOWMAN WITHOUT SNOW..SUN BEHIND CLOUD\n    c == 0x26CE || // <unknown>\n    c == 0x26D4 || // <unknown>\n    c == 0x26EA || // <unknown>\n    (0x26F2 <= c && c <= 0x26F3) || // FOUNTAIN..FLAG IN HOLE\n    c == 0x26F5 || // <unknown>\n    c == 0x26FA || // <unknown>\n    c == 0x26FD || // <unknown>\n    c == 0x2705 || // <unknown>\n    (0x270A <= c && c <= 0x270B) || // RAISED FIST..RAISED HAND\n    c == 0x2728 || // <unknown>\n    c == 0x274C || // <unknown>\n    c == 0x274E || // <unknown>\n    (0x2753 <= c && c <= 0x2755) || // BLACK QUESTION MARK ORNAMENT..WHITE EXCLAMATION MARK ORNAMENT\n    c == 0x2757 || // <unknown>\n    (0x2795 <= c && c <= 0x2797) || // HEAVY PLUS SIGN..HEAVY DIVISION SIGN\n    c == 0x27B0 || // <unknown>\n    c == 0x27BF || // <unknown>\n    (0x2B1B <= c && c <= 0x2B1C) || // BLACK LARGE SQUARE..WHITE LARGE SQUARE\n    c == 0x2B50 || // <unknown>\n    c == 0x2B55 || // <unknown>\n    c == 0x1F004 || // <unknown>\n    c == 0x1F0CF || // <unknown>\n    c == 0x1F18E || // <unknown>\n    (0x1F191 <= c && c <= 0x1F19A) || // SQUARED CL..SQUARED VS\n    (0x1F1E6 <= c && c <= 0x1F1FF) || // REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z\n    c == 0x1F201 || // <unknown>\n    c == 0x1F21A || // <unknown>\n    c == 0x1F22F || // <unknown>\n    (0x1F232 <= c && c <= 0x1F236) || // SQUARED CJK UNIFIED IDEOGRAPH-7981..SQUARED CJK UNIFIED IDEOGRAPH-6709\n    (0x1F238 <= c && c <= 0x1F23A) || // SQUARED CJK UNIFIED IDEOGRAPH-7533..SQUARED CJK UNIFIED IDEOGRAPH-55B6\n    (0x1F250 <= c && c <= 0x1F251) || // CIRCLED IDEOGRAPH ADVANTAGE..CIRCLED IDEOGRAPH ACCEPT\n    (0x1F300 <= c && c <= 0x1F320) || // CYCLONE..SHOOTING STAR\n    (0x1F32D <= c && c <= 0x1F335) || // HOT DOG..CACTUS\n    (0x1F337 <= c && c <= 0x1F37C) || // TULIP..BABY BOTTLE\n    (0x1F37E <= c && c <= 0x1F393) || // BOTTLE WITH POPPING CORK..GRADUATION CAP\n    (0x1F3A0 <= c && c <= 0x1F3C4) || // CAROUSEL HORSE..SURFER\n    c == 0x1F3C5 || // <unknown>\n    (0x1F3C6 <= c && c <= 0x1F3CA) || // TROPHY..SWIMMER\n    (0x1F3CF <= c && c <= 0x1F3D3) || // CRICKET BAT AND BALL..TABLE TENNIS PADDLE AND BALL\n    (0x1F3E0 <= c && c <= 0x1F3F0) || // HOUSE BUILDING..EUROPEAN CASTLE\n    c == 0x1F3F4 || // <unknown>\n    (0x1F3F8 <= c && c <= 0x1F43E) || // BADMINTON RACQUET AND SHUTTLECOCK..PAW PRINTS\n    c == 0x1F440 || // <unknown>\n    (0x1F442 <= c && c <= 0x1F4F7) || // EAR..CAMERA\n    c == 0x1F4F8 || // <unknown>\n    (0x1F4F9 <= c && c <= 0x1F4FC) || // VIDEO CAMERA..VIDEOCASSETTE\n    c == 0x1F4FF || // <unknown>\n    (0x1F500 <= c && c <= 0x1F53D) || // TWISTED RIGHTWARDS ARROWS..DOWN-POINTING SMALL RED TRIANGLE\n    (0x1F54B <= c && c <= 0x1F54E) || // KAABA..MENORAH WITH NINE BRANCHES\n    (0x1F550 <= c && c <= 0x1F567) || // CLOCK FACE ONE OCLOCK..CLOCK FACE TWELVE-THIRTY\n    c == 0x1F57A || // <unknown>\n    (0x1F595 <= c && c <= 0x1F596) || // REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS\n    c == 0x1F5A4 || // <unknown>\n    (0x1F5FB <= c && c <= 0x1F5FF) || // MOUNT FUJI..MOYAI\n    c == 0x1F600 || // <unknown>\n    (0x1F601 <= c && c <= 0x1F610) || // GRINNING FACE WITH SMILING EYES..NEUTRAL FACE\n    c == 0x1F611 || // <unknown>\n    (0x1F612 <= c && c <= 0x1F614) || // UNAMUSED FACE..PENSIVE FACE\n    c == 0x1F615 || // <unknown>\n    c == 0x1F616 || // <unknown>\n    c == 0x1F617 || // <unknown>\n    c == 0x1F618 || // <unknown>\n    c == 0x1F619 || // <unknown>\n    c == 0x1F61A || // <unknown>\n    c == 0x1F61B || // <unknown>\n    (0x1F61C <= c && c <= 0x1F61E) || // FACE WITH STUCK-OUT TONGUE AND WINKING EYE..DISAPPOINTED FACE\n    c == 0x1F61F || // <unknown>\n    (0x1F620 <= c && c <= 0x1F62B) || // ANGRY FACE..TIRED FACE\n    c == 0x1F62C || // <unknown>\n    c == 0x1F62D || // <unknown>\n    (0x1F62E <= c && c <= 0x1F633) || // FACE WITH OPEN MOUTH..FLUSHED FACE\n    c == 0x1F634 || // <unknown>\n    (0x1F635 <= c && c <= 0x1F64F) || // DIZZY FACE..PERSON WITH FOLDED HANDS\n    (0x1F680 <= c && c <= 0x1F6C5) || // ROCKET..LEFT LUGGAGE\n    c == 0x1F6CC || // <unknown>\n    c == 0x1F6D0 || // <unknown>\n    (0x1F6D1 <= c && c <= 0x1F6D2) || // OCTAGONAL SIGN..SHOPPING TROLLEY\n    (0x1F6EB <= c && c <= 0x1F6EC) || // AIRPLANE DEPARTURE..AIRPLANE ARRIVING\n    (0x1F6F4 <= c && c <= 0x1F6F8) || // SCOOTER..FLYING SAUCER\n    (0x1F910 <= c && c <= 0x1F91E) || // ZIPPER-MOUTH FACE..HAND WITH INDEX AND MIDDLE FINGERS CROSSED\n    c == 0x1F91F || // <unknown>\n    (0x1F920 <= c && c <= 0x1F92F) || // FACE WITH COWBOY HAT..SHOCKED FACE WITH EXPLODING HEAD\n    c == 0x1F930 || // <unknown>\n    (0x1F931 <= c && c <= 0x1F93A) || // BREAST-FEEDING..FENCER\n    (0x1F93C <= c && c <= 0x1F93E) || // WRESTLERS..HANDBALL\n    (0x1F940 <= c && c <= 0x1F945) || // WILTED FLOWER..GOAL NET\n    (0x1F947 <= c && c <= 0x1F94B) || // FIRST PLACE MEDAL..MARTIAL ARTS UNIFORM\n    c == 0x1F94C || // <unknown>\n    (0x1F950 <= c && c <= 0x1F96B) || // CROISSANT..CANNED FOOD\n    (0x1F980 <= c && c <= 0x1F997) || // CRAB..CRICKET\n    c == 0x1F9C0 || // <unknown>\n    (0x1F9D0 <= c && c <= 0x1F9E6) // FACE WITH MONOCLE..SOCKS\n  ))\n}\n\nexport function isEmojiModifierBase(c :int) :bool {\n  return (\n    0x261D <= c && c <= 0x1F9DD && ( // <unknown>..ELF\n    c == 0x261D || // <unknown>\n    c == 0x26F9 || // <unknown>\n    (0x270A <= c && c <= 0x270D) || // RAISED FIST..WRITING HAND\n    c == 0x1F385 || // <unknown>\n    (0x1F3C2 <= c && c <= 0x1F3C4) || // SNOWBOARDER..SURFER\n    c == 0x1F3C7 || // <unknown>\n    c == 0x1F3CA || // <unknown>\n    (0x1F3CB <= c && c <= 0x1F3CC) || // WEIGHT LIFTER..GOLFER\n    (0x1F442 <= c && c <= 0x1F443) || // EAR..NOSE\n    (0x1F446 <= c && c <= 0x1F450) || // WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN\n    (0x1F466 <= c && c <= 0x1F469) || // BOY..WOMAN\n    c == 0x1F46E || // <unknown>\n    (0x1F470 <= c && c <= 0x1F478) || // BRIDE WITH VEIL..PRINCESS\n    c == 0x1F47C || // <unknown>\n    (0x1F481 <= c && c <= 0x1F483) || // INFORMATION DESK PERSON..DANCER\n    (0x1F485 <= c && c <= 0x1F487) || // NAIL POLISH..HAIRCUT\n    c == 0x1F4AA || // <unknown>\n    (0x1F574 <= c && c <= 0x1F575) || // MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY\n    c == 0x1F57A || // <unknown>\n    c == 0x1F590 || // <unknown>\n    (0x1F595 <= c && c <= 0x1F596) || // REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS\n    (0x1F645 <= c && c <= 0x1F647) || // FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY\n    (0x1F64B <= c && c <= 0x1F64F) || // HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS\n    c == 0x1F6A3 || // <unknown>\n    (0x1F6B4 <= c && c <= 0x1F6B6) || // BICYCLIST..PEDESTRIAN\n    c == 0x1F6C0 || // <unknown>\n    c == 0x1F6CC || // <unknown>\n    c == 0x1F918 || // <unknown>\n    (0x1F919 <= c && c <= 0x1F91C) || // CALL ME HAND..RIGHT-FACING FIST\n    c == 0x1F91E || // <unknown>\n    c == 0x1F91F || // <unknown>\n    c == 0x1F926 || // <unknown>\n    c == 0x1F930 || // <unknown>\n    (0x1F931 <= c && c <= 0x1F939) || // BREAST-FEEDING..JUGGLING\n    (0x1F93D <= c && c <= 0x1F93E) || // WATER POLO..HANDBALL\n    (0x1F9D1 <= c && c <= 0x1F9DD) // ADULT..ELF\n  ))\n}\n\nexport function isEmojiModifier(c :int) :bool {\n  return (\n    (0x1F3FB <= c && c <= 0x1F3FF) // EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6\n  )\n}\n","import { Position } from './pos'\n\n// error codes\nclass _errors {\n  E_SYNTAX  = 'syntax'\n  E_CONV    = 'type or value conversion'\n  E_RESOLVE = 'reference resolution'\n  E_UNUSED_VAR   = 'declared and not used'\n  E_UNUSED_PARAM = 'unused parameter'\n  E_UNUSED_FIELD = 'unused field'\n}\nexport const errors = new _errors()\n\n// error code type\nexport type ErrorCode = keyof(_errors)\n\n// An ErrorHandler may be provided to Scanner.init. If a syntax error is\n// encountered and a handler was installed, the handler is called with a\n// position and an error message. The position points to the beginning of\n// the offending token.\n//\nexport type ErrorHandler = (pos :Position, msg :string, c :ErrorCode) => void\n\n// ErrorReporter serves as a base for other types that report source errors.\n//\nexport class ErrorReporter {\n  errorCount :number = 0\n\n  constructor(\n    public defaultErrCode :ErrorCode,\n    public errh :ErrorHandler|null = null,\n  ) {}\n\n  errorAt(msg :string, position :Position, code? :ErrorCode) {\n    if (this.errh) {\n      this.errh(position, msg, code || this.defaultErrCode)\n    }\n    this.errorCount++\n  }\n}\n","// TODO: to support good old windows...\n// const iswin32 = typeof process != 'undefined' && process.platform == 'win32'\n// and check for \\ in paths.\n\n\nconst SL = 0x2F  // '/'\n    , DOT = 0x2E // .'\n\n\n// dir returns the directory part of a path, or \".\" if no directory part.\n//\nexport function dir(path :string) :string {\n  if (path.indexOf('/') == -1) {\n    return '.'\n  }\n  path = clean(path)\n  let p = path.lastIndexOf('/')\n  return (\n    p == -1 ? '.' :\n    p == path.length - 1 ? path : // \"/\"\n    path.substr(0, p)\n  )\n}\n\nTEST(\"path.dir\", () => {\n  assert(dir(\"/a/b/c\") == \"/a/b\")\n  assert(dir(\"a/b/c\") == \"a/b\")\n  assert(dir(\"a/b\") == \"a\")\n  assert(dir(\"/\") == \"/\")\n  assert(dir(\"a\") == \".\")\n  assert(dir(\"\") == \".\")\n})\n\n\nclass lazybuf {\n  // The code in this class has been ported from Go and the following\n  // license applies:\n  //   Copyright 2009 The Go Authors. All rights reserved.\n  //   Use of this source code is governed by a BSD-style\n  //   license that can be found in the LICENSE file.\n  //   https://golang.org/LICENSE\n\n  buf :string|null = null\n  w   :int = 0\n\n  constructor(\n    public s :string,\n  ) {}\n\n  index(i :int) :int {\n    return this.buf !== null ? this.buf.charCodeAt(i) : this.s.charCodeAt(i)\n  }\n\n  append(c :int) {\n    if (this.buf === null) {\n      if (this.w < this.s.length && this.s.charCodeAt(this.w) == c) {\n        this.w++\n        return\n      }\n      this.buf = this.s.substr(0, this.w)\n    }\n    if (this.w < this.buf.length-1) {\n      // w was reverted\n      this.buf = this.buf.substr(0, this.w)\n    }\n    this.buf += String.fromCharCode(c) // ugh, javascript...\n    this.w++\n  }\n\n  toString() :string {\n    return (\n      this.buf === null ? this.s.substr(0,this.w) :\n      this.buf.substr(0, this.w)\n    )\n  }\n}\n\n\n// clean\n//\nexport function clean(path :string) :string {\n  // The code in this function has been ported from Go and the following\n  // license applies:\n  //   Copyright 2009 The Go Authors. All rights reserved.\n  //   Use of this source code is governed by a BSD-style\n  //   license that can be found in the LICENSE file.\n  //   https://golang.org/LICENSE\n\n  if (path == \"\") {\n    return \".\"\n  }\n\n  const rooted = path.charCodeAt(0) == SL\n  const n = path.length\n\n  // Invariants:\n  //  reading from path; r is index of next byte to process.\n  //  writing to buf; w is index of next byte to write.\n  //  dotdot is index in buf where .. must stop, either because\n  //    it is the leading slash or it is a leading ../../.. prefix.\n  let out = new lazybuf(path)\n  let r = 0, dotdot = 0\n\n  if (rooted) {\n    out.append(SL)\n    r = 1\n    dotdot = 1\n  }\n\n  while (r < n) {\n    const c0 = path.charCodeAt(r)\n    if (c0 == SL) {\n      // empty path element\n      r++\n    } else if (c0 == DOT && (r+1 == n || path.charCodeAt(r+1) == SL)) {\n      // . element\n      r++\n    } else if (\n      c0 == DOT &&\n      path.charCodeAt(r+1) == DOT &&\n      (r+2 == n || path.charCodeAt(r+2) == SL)\n    ) {\n      // .. element: remove to last /\n      r += 2\n      if (out.w > dotdot) {\n        // can backtrack\n        out.w--\n        while (out.w > dotdot && out.index(out.w) != SL) {\n          out.w--\n        }\n      } else if (!rooted) {\n        // cannot backtrack, but not rooted, so append .. element.\n        if (out.w > 0) {\n          out.append(SL)\n        }\n        out.append(DOT)\n        out.append(DOT)\n        dotdot = out.w\n      }\n    } else {\n      // real path element.\n      // add slash if needed\n      if (rooted && out.w != 1 || !rooted && out.w != 0) {\n        out.append(SL)\n      }\n      // copy element\n      // for (; r < n && path.charCodeAt(r) != SL; r++) {\n      //   out.append(path.charCodeAt(r))\n      // }\n      let c :int\n      for (; r < n; r++) {\n        c = path.charCodeAt(r)\n        if (c == SL) {\n          break\n        }\n        out.append(c)\n      }\n    }\n  }\n\n  // Turn empty string into \".\"\n  if (out.w == 0) {\n    return \".\"\n  }\n\n  return out.toString()\n}\n\nTEST(\"path.clean\", () => {\n  function t(input :string, expect :string) {\n    const result = clean(input)\n    assert(result == expect,\n      `expected ${JSON.stringify(input)} => ${JSON.stringify(expect)}` +\n      ` but instead got ${JSON.stringify(result)}`)\n  }\n  t(\"a/c\", \"a/c\")\n  t(\"a/c/\", \"a/c\")\n  t(\"/a/c\", \"/a/c\")\n  t(\"a//c\", \"a/c\")\n  t(\"a/c/.\", \"a/c\")\n  t(\"a/c/b/..\", \"a/c\")\n  t(\"/../a/c\", \"/a/c\")\n  t(\"/../a/b/../././/c\", \"/a/c\")\n  t(\"\", \".\")\n  t(\"/\", \"/\")\n})\n\n\n// isAbs returns true if the path is absolute\n//\nexport function isAbs(path :string) :bool {\n  return path.charCodeAt(0) == SL\n}\n\nTEST(\"path.isAbs\", () => {\n  assert(isAbs(\"/foo/bar\") === true)\n  assert(isAbs(\"foo/bar\") === false)\n})\n\n\n// join glues paths together\n//\nexport function join(...paths :string[]) :string {\n  let s = ''\n  for (let i = 0; i < paths.length; i++) {\n    if (paths[i] != '') {\n      return clean((i == 0 ? paths : paths.slice(i)).join('/'))\n    }\n  }\n  return s\n}\n\nTEST(\"path.join\", () => {\n  function t(inputs :string[], expect :string) {\n    const result = join.apply(null, inputs)\n    assert(result == expect,\n      `expected ${JSON.stringify(inputs)} => ${JSON.stringify(expect)}` +\n      ` but instead got ${JSON.stringify(result)}`)\n  }\n  t([\"a\", \"b\", \"c\"], \"a/b/c\")\n  t([\"a\", \"b/c\"], \"a/b/c\")\n  t([\"a/b/\", \"c\"], \"a/b/c\")\n  t([\"a/b//\", \"//c\"], \"a/b/c\")\n  t([\"/a/b//\", \"//c\"], \"/a/b/c\")\n  t([\"/a/b//\", \"//c/\"], \"/a/b/c\")\n  t([\"\", \"\"], \"\")\n  t([\"a\", \"\"], \"a\")\n  t([\"\", \"a\"], \"a\")\n})\n","import { AppendBuffer, bufcmp, asciibuf } from './util'\nimport { Pos, Position, SrcFile } from './pos'\nimport * as utf8 from './utf8'\nimport * as unicode from './unicode'\nimport { ErrorCode, ErrorReporter, ErrorHandler } from './error'\nimport { token, lookupKeyword, prec } from './token'\nimport * as path from './path'\n\n\nexport enum Mode {\n  None = 0,\n\n  ScanComments = 1, // do not skip comments; produce token.COMMENT\n\n  CopySource = 2,\n    // copy slices of source data for tokens with literal values instead of\n    // referencing the source buffer. This means slightly lower speed but\n    // less memory usage since when scanning is done, the source code memory\n    // can be reclaimed. If you plan to keep the source code around after\n    // scanning (common case) you should leave this disabled.\n}\n\nconst linePrefix = asciibuf('//!line ')\n\nenum istrOne { OFF, WAIT, CONT }\n\n// A Scanner holds the scanner's internal state while processing a given text.\n// It must be initialized via init before use or resue.\n//\nexport class Scanner extends ErrorReporter {\n  // immutable state (only changed by init())\n  // Note: `undefined as any as X` is a workaround for a TypeScript issue\n  // where members are otherwise not initialized at construction which causes\n  // duplicate struct definitions in v8.\n  public sfile :SrcFile = undefined as any as SrcFile // source file handle\n  public sdata :Uint8Array = undefined as any as Uint8Array // source data\n  public dir   :string = ''   // directory portion of file.name\n  public mode  :Mode = 0         // scanning mode\n\n  // scanning state\n  private ch         :int = -1 // current character (unicode; -1=EOF)\n  private offset     :int = 0  // character offset\n  private rdOffset   :int = 0  // reading offset (position after current char)\n  private lineOffset :int = 0  // current line offset\n  private insertSemi :bool = false // insert a semicolon before next newline\n  private parenL     :int = 0  // parenthesis level, for string interpolation\n  private interpStrL :int = 0  // string interpolation level\n  private istrOne    :istrOne = istrOne.OFF // string interpolation\n  private byteval    :Uint8Array|null = null // value for some string tokens\n\n  // public scanning state (read-only)\n  public pos       :Pos = 0  // token start position\n  public startoffs :int = 0  // token start offset\n  public endoffs   :int = 0  // token end offset\n  public tok       :token = token.EOF\n  public prec      :prec = prec.LOWEST\n  public intval    :int = 0 // value for some tokens\n  public hash      :int = 0 // hash value for current token (if NAME*)\n\n  // sparse buffer state (not reset by s.init)\n  private appendbuf  :AppendBuffer|null = null // for string literals\n\n  // public state - ok to modify\n  public errorCount :int = 0 // number of errors encountered\n\n  constructor() {\n    super('E_SYNTAX')\n  }\n\n  // Init prepares the scanner s to tokenize the text sdata by setting the\n  // scanner at the beginning of sdata. The scanner uses the file set file\n  // for position information and it adds line information for each line.\n  // It is ok to re-use the same file when re-scanning the same file as\n  // line information which is already present is ignored. Init causes a\n  // panic if the file size does not match the sdata size.\n  //\n  // Calls to Scan will invoke the error handler errh if they encounter a\n  // syntax error and errh is not nil. Also, for each error encountered,\n  // the Scanner field ErrorCount is incremented by one. The mode parameter\n  // determines how comments are handled.\n  //\n  // Note that Init may call errh if there is an error in the first character\n  // of the file.\n  //\n  init(\n    sfile :SrcFile,\n    sdata :Uint8Array,\n    errh? :ErrorHandler|null,\n    mode  :Mode =Mode.None,\n  ) {\n    const s = this\n    // Explicitly initialize all fields since a scanner may be reused\n    if (sfile.size != sdata.length) {\n      panic(\n        `file size (${sfile.size}) `+\n        `does not match source size (${sdata.length})`\n      )\n    }\n    s.sfile = sfile\n    s.dir = path.dir(sfile.name)\n    s.sdata = sdata\n    s.errh = errh || null\n    s.mode = mode\n  \n    s.ch = 0x20 /*' '*/\n    s.tok = token.EOF\n    s.offset = 0\n    s.rdOffset = 0\n    s.lineOffset = 0\n    s.insertSemi = false\n    s.errorCount = 0\n  \n    s.readchar()\n  }\n\n  private _r :utf8.DecodeResult = {c:0,w:0}\n\n  // Read the next Unicode char into s.ch.\n  // s.ch < 0 means end-of-file.\n  private readchar() {\n    const s = this\n\n    if (s.rdOffset < s.sdata.length) {\n      s.offset = s.rdOffset\n      \n      if (s.ch == 0xA /*\\n*/ ) {\n        s.lineOffset = s.offset\n        s.sfile.addLine(s.offset)\n      }\n\n      s._r.w = 1\n      s._r.c = s.sdata[s.rdOffset]\n\n      if (s._r.c >= 0x80) {\n        // uncommon case: non-ASCII character\n        if (!utf8.decode(s.sdata, s.rdOffset, s._r)) {\n          s.errorAtOffs('invalid UTF-8 encoding', s.offset)\n        } else if (s._r.c == 0) {\n          s.errorAtOffs('illegal NUL byte in input', s.offset)\n        }\n      }\n\n      s.rdOffset += s._r.w\n      s.ch = s._r.c\n    } else {\n      s.offset = s.sdata.length\n      if (s.ch == 0xA /*\\n*/) {\n        s.lineOffset = s.offset\n        s.sfile.addLine(s.offset)\n      }\n      s.ch = -1 // eof\n    }\n  }\n\n  // undobyte \"puts back\" the last-read byte.\n  // note that this does NOT fully update scanner state -- after calling this\n  // function, you should either call readchar() to update s.ch and s.offset\n  // or call next().\n  //\n  private undobyte() {\n    const s = this\n    assert(s.ch < 0x80)\n    s.rdOffset -= 1\n    s.offset -= 1\n    s.endoffs = s.offset\n  }\n\n  // gotchar reads the next character and returns true if s.ch == ch\n  private gotchar(ch :int) :bool {\n    const s = this\n    if (s.ch == ch) {\n      s.readchar()\n      return true\n    }\n    return false\n  }\n\n  currentPosition() :Position {\n    const s = this\n    return s.sfile.position(s.sfile.pos(s.offset))\n  }\n\n  // byteValue returns a byte buffer representing the literal value of the\n  // current token.\n  // Note that this method returns a byte buffer that is potentially referenced\n  // internally and which value might change next time s.scan is called. If you\n  // plan to keep referencing the byte buffer, use s.takeByteValue instead.\n  //\n  byteValue() :Uint8Array {\n    const s = this\n    const end = s.endoffs == -1 ? s.offset : s.endoffs\n    return s.byteval || s.sdata.subarray(s.startoffs, end)\n  }\n\n  // takeByteValue returns a new byte buffer that is not referenced by\n  // the scanner. The buffer is still immutable.\n  //\n  takeByteValue() :Uint8Array {\n    const s = this\n    const b = s.byteValue()\n    s.byteval = null\n    return (this.mode & Mode.CopySource) ? b.slice() : b\n  }\n\n  // Increment errorCount and call any error handler\n  //\n  error(msg :string, pos :Pos = this.pos, code? :ErrorCode) {\n    const s = this\n    s.errorAt(msg, s.sfile.position(pos), code)\n  }\n\n  errorAtOffs(msg :string, offs :int, code? :ErrorCode) {\n    const s = this\n    s.errorAt(msg, s.sfile.position(s.sfile.pos(offs)), code)\n  }\n\n  // Scan the next token\n  //\n  next() {\n  while (true) {\n    const s = this\n\n    if (s.istrOne == istrOne.OFF) {\n      // skip whitespace\n      while (\n        s.ch == 0x20 ||\n        s.ch == 0x9 ||\n        (s.ch == 0xA && !s.insertSemi) ||\n        s.ch == 0xD\n      ) {\n        s.readchar()\n      }\n    }\n\n    // current token start\n    s.pos = s.sfile.pos(s.offset)\n    s.startoffs = s.offset\n    s.endoffs = -1\n    s.byteval = null\n\n    if (s.istrOne == istrOne.CONT) {\n      // continue interpolated string\n      s.istrOne = istrOne.OFF\n      s.startoffs-- // b/c scanString increments it, assuming it's skipping `\"`\n      s.tok = s.scanString()\n      s.insertSemi = s.tok != token.STRING_PIECE\n      return\n    } else if (s.istrOne == istrOne.WAIT) {\n      // we are about to scan a single token following $ in a string template\n      s.istrOne = istrOne.CONT\n    }\n\n    // make progress\n    const ch = s.ch\n    s.readchar()\n\n    let insertSemi = false\n\n    switch (ch) {\n\n      case -1: {\n        s.tok = s.insertSemi ? token.SEMICOLON : token.EOF\n        break\n      }\n\n      case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:\n      case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:\n        // 0..9\n        s.scanNumber(ch)\n        insertSemi = true\n        break\n\n      case 0xA: { // \\n\n        // we only reach here if s.insertSemi was set in the first place\n        // and exited early from skipping whitespace.\n        // newline consumed\n        s.tok = token.SEMICOLON\n        break\n      }\n\n      case 0x22: // \"\n        s.tok = s.scanString()\n        insertSemi = s.tok != token.STRING_PIECE\n        break\n\n      case 0x27: // '\n        s.scanChar()\n        insertSemi = true\n        break\n\n      case 0x3a: // :\n        if (s.gotchar(0x3D)) {\n          s.tok = token.SET_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.COLON\n        }\n        break\n\n      case 0x2e: { // .\n        if (isDigit(s.ch)) {\n          s.scanFloatNumber(/*seenDecimal*/true)\n          insertSemi = true\n        } else {\n          if (s.gotchar(0x2e)) { // ..\n            if (s.gotchar(0x2e)) { // ...\n              s.tok = token.ELLIPSIS\n            } else {\n              s.tok = token.PERIODS\n            }\n          } else {\n            s.tok = token.DOT\n          }\n        }\n        break\n      }\n\n      case 0x40: { // @\n        s.startoffs++ // skip @\n        let c = s.ch\n        if (c < utf8.UniSelf && (asciiFeats[c] & langIdentStart)) {\n          s.readchar()\n          s.scanIdentifier(c)\n        } else if (c >= utf8.UniSelf && isUniIdentStart(c)) {\n          s.readchar()\n          s.scanIdentifierU(c, this.startoffs)\n        }\n        s.tok = token.NAMEAT\n        insertSemi = true\n        break\n      }\n\n      case 0x2c: // ,\n        s.tok = token.COMMA\n        break\n      case 0x3b: // ;\n        s.tok = token.SEMICOLON\n        break\n\n      case 0x28: // (\n        if (s.interpStrL) {\n          s.parenL++\n        }\n        s.tok = token.LPAREN\n        break\n      case 0x29: // )\n        s.tok = token.RPAREN\n        insertSemi = true\n        if (s.interpStrL) {\n          if (s.parenL == 0) {\n            // continue interpolated string\n            s.interpStrL--\n            s.tok = s.scanString()\n            insertSemi = s.tok != token.STRING_PIECE\n          } else {\n            s.parenL--\n          }\n        }\n        break\n\n      case 0x5b: // [\n        s.tok = token.LBRACK\n        break\n      case 0x5d: // ]\n        s.tok = token.RBRACK\n        insertSemi = true\n        break\n\n      case 0x7b: // {\n        s.tok = token.LBRACE\n        break\n      case 0x7d: // }\n        s.tok = token.RBRACE\n        insertSemi = true\n        break\n\n      case 0x2B: { // +\n        s.prec = prec.LOWEST\n        if (s.gotchar(0x3D)) { // +=\n          s.tok = token.ADD_ASSIGN\n        } else if (s.gotchar(ch)) { // ++\n          s.tok = token.INC\n          insertSemi = true\n        } else {\n          s.tok = token.ADD\n          s.prec = prec.ADD\n        }\n        break\n      }\n\n      case 0x2D: { // -\n        s.prec = prec.LOWEST\n        if (s.gotchar(0x3e)) { // ->\n          s.tok = token.ARROWR\n        } else {\n          if (s.gotchar(0x3D)) { // -=\n            s.tok = token.SUB_ASSIGN\n          } else if (s.gotchar(ch)) { // --\n            s.tok = token.DEC\n            insertSemi = true\n          } else {\n            s.tok = token.SUB\n            s.prec = prec.ADD\n          }\n        }\n        break\n      }\n\n      case 0x2a: // *\n        if (s.gotchar(0x3D)) { // *=\n          s.tok = token.MUL_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.MUL\n          s.prec = prec.MUL\n        }\n        break\n\n      case 0x2f: { // /\n        if (s.ch == 0x2f) { // //\n          s.scanLineComment()\n          if (!(s.mode & Mode.ScanComments)) {\n            continue\n          }\n          insertSemi = s.insertSemi // persist s.insertSemi\n        } else if (s.ch == 0x2a) { // /*\n          const CRcount = s.scanGeneralComment()\n          if (s.mode & Mode.ScanComments) {\n            s.tok = token.COMMENT\n            if (CRcount) {\n              // strip CR characters from comment\n              const v = s.sdata.subarray(\n                s.startoffs,\n                s.endoffs == -1 ? s.offset : s.endoffs\n              )\n              s.byteval = stripByte(v, 0xD, CRcount) // copy; no mutation\n            }\n          } else {\n            continue\n          }\n          insertSemi = s.insertSemi // persist s.insertSemi\n        } else {\n          if (s.gotchar(0x3D)) { // /=\n            s.tok = token.QUO_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.QUO\n            s.prec = prec.MUL\n          }\n        }\n        break\n      }\n\n      case 0x25: // %\n        if (s.gotchar(0x3D)) { // %=\n          s.tok = token.REM_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.REM\n          s.prec = prec.MUL\n        }\n        break\n\n      case 0x5e: // ^\n        if (s.gotchar(0x3D)) { // ^=\n          s.tok = token.XOR_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.XOR\n          s.prec = prec.ADD\n        }\n        break\n\n      case 0x3c: { // <\n        if (s.gotchar(0x2D)) { // <-\n          s.tok = token.ARROWL\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(0x3D)) { // <=\n          s.tok = token.LEQ\n          s.prec = prec.CMP\n        } else if (s.gotchar(ch)) { // <<\n          if (s.gotchar(0x3D)) { // <<=\n            s.tok = token.SHL_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.SHL\n            s.prec = prec.MUL\n          }\n        } else {\n          s.tok = token.LSS\n          s.prec = prec.CMP\n        }\n        break\n      }\n\n      case 0x3E: // >\n        if (s.gotchar(0x3D)) { // >=\n          s.tok = token.GEQ\n          s.prec = prec.CMP\n        } else if (s.gotchar(ch)) { // >>\n          if (s.gotchar(0x3D)) { // >>=\n            s.tok = token.SHR_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.SHR\n            s.prec = prec.MUL\n          }\n        } else {\n          s.tok = token.GTR\n          s.prec = prec.CMP\n        }\n        break\n      \n      case 0x3D: // =\n        if (s.gotchar(0x3D)) { // ==\n          s.tok = token.EQL\n          s.prec = prec.CMP\n        } else {\n          s.tok = token.ASSIGN\n          s.prec = prec.LOWEST\n        }\n        break\n\n      case 0x21: // !\n        if (s.gotchar(0x3D)) { // !=\n          s.tok = token.NEQ\n          s.prec = prec.CMP\n        } else {\n          s.tok = token.NOT\n          s.prec = prec.LOWEST\n        }\n        break\n\n      case 0x26: { // &\n        if (s.gotchar(0x5E)) { // &^\n          if (s.gotchar(0x3D)) { // &^=\n            s.tok = token.AND_NOT_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.AND_NOT\n            s.prec = prec.MUL\n          }\n        } else if (s.gotchar(0x3D)) { // &=\n          s.tok = token.AND_ASSIGN\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(ch)) { // &&\n          s.tok = token.LAND\n          s.prec = prec.AND\n        } else {\n          s.tok = token.AND\n          s.prec = prec.MUL\n        }\n        break\n      }\n\n      case 0x7c: // |\n        if (s.gotchar(0x3D)) { // |=\n          s.tok = token.OR_ASSIGN\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(ch)) { // ||\n          s.tok = token.LOR\n          s.prec = prec.OR\n        } else {\n          s.tok = token.OR\n          s.prec = prec.ADD\n        }\n        break\n\n      default: {\n        if (\n          (ch < utf8.UniSelf && (asciiFeats[ch] & langIdentStart)) ||\n          (ch >= utf8.UniSelf && isUniIdentStart(ch))\n        ) {\n          if (ch < utf8.UniSelf) {\n            s.scanIdentifier(ch)\n          } else {\n            s.scanIdentifierU(ch, this.startoffs)\n          }\n\n          if (s.offset - s.startoffs > 1) {\n            // shortest keyword is 2\n            switch (s.tok = lookupKeyword(s.byteValue())) {\n              case token.NAME:\n              case token.BREAK:\n              case token.CONTINUE:\n              case token.FALLTHROUGH:\n              case token.RETURN:\n                insertSemi = true\n                break\n            }\n          } else {\n            s.tok = token.NAME\n            insertSemi = true\n          }\n        } else {\n          s.error(`unexpected character ${unicode.repr(ch)} in input`)\n          s.tok = token.ILLEGAL\n        }\n        break\n      }\n\n    } // switch (ch)\n\n    if (s.endoffs == -1) {\n      s.endoffs = s.offset\n    }\n\n    s.insertSemi = insertSemi\n\n    // console.log(\n    //   `-> ${tokstr(s.tok)} \"${utf8.decodeToString(s.byteValue())}\"`)\n    return\n\n    } // while(true)\n  }\n\n\n  scanIdentifierU(c :int, hashOffs :int, hash :int = 0x811c9dc5) {\n    // Scan identifier with non-ASCII characters.\n    // c is already verified to be a valid indentifier character.\n    // Hash is calculated as a second pass at the end.\n    const s = this\n    const ZeroWidthJoiner = 0x200D\n    let lastCp = c\n    c = s.ch\n\n    while (\n      isUniIdentCont(c) ||\n      unicode.isEmojiModifier(c) ||\n      unicode.isEmojiModifierBase(c) ||\n      c == ZeroWidthJoiner\n    ) {\n      if (lastCp == 0x2D && c == 0x2D) { // --\n        s.undobyte() // \"put back\" the \"-\" byte\n        break\n      }\n      lastCp = c\n      s.readchar()\n      c = s.ch\n    }\n\n    if (lastCp == ZeroWidthJoiner) {\n      s.error(`illegal zero width-joiner character at end of identifer`)\n      s.tok = token.ILLEGAL\n      return\n    }\n\n    // computing rest of hash\n    for (let i = hashOffs; i < s.offset; ++i) {\n      hash = (hash ^ s.sdata[i]) * 0x1000193 // fnv1a\n    }\n    s.hash = hash >>> 0\n  }\n\n  scanIdentifier(c :int) {\n    // enters past first char; c = 1st char, s.ch = 2nd char\n    // c is already verified to be a valid indentifier character.\n    // The hash function used here must exactly match what's in bytestr.\n    const s = this\n    let hash = (0x811c9dc5 ^ c) * 0x1000193 // fnv1a\n\n    c = s.ch\n    while (\n      isLetter(c) ||\n      isDigit(c) ||\n      c == 0x2D || // -\n      c == 0x5F || // _\n      c == 0x24    // $\n    ) {\n      s.readchar()\n      if (c == 0x2D && s.ch == 0x2D) { // --\n        s.undobyte() // \"put back\" the \"-\" byte\n        break\n      }\n      hash = (hash ^ c) * 0x1000193 // fnv1a\n      c = s.ch\n    }\n\n    if (c >= utf8.UniSelf && isUniIdentCont(c)) {\n      return s.scanIdentifierU(c, s.offset, hash)\n    }\n\n    s.hash = hash >>> 0\n  }\n\n  scanChar() {\n    const s = this\n    let cp = -1\n    s.tok = token.CHAR\n\n    switch (s.ch) {\n      case -1: case 0xA: { // EOF | \\n\n        s.error(\"unterminated character literal\")\n        s.tok = token.ILLEGAL\n        return\n      }\n      case 0x27: { // '\n        s.error(\"empty character literal or unescaped ' in character literal\")\n        s.readchar()\n        s.intval = unicode.InvalidChar\n        return\n      }\n      case 0x5c: { // \\\n        s.readchar()\n        cp = s.scanEscape(0x27) // '\n        // note: cp is -1 for illegal escape sequences\n        break\n      }\n      default: {\n        cp = s.ch\n        s.readchar()\n        break\n      }\n    }\n\n\n    if (s.ch == 0x27) { // '\n      s.readchar()\n      s.intval = cp\n    } else {\n      // failed -- read until EOF or '\n      while (true) {\n        if (s.ch == -1) {\n          break\n        }\n        if (s.ch == 0x27) { // '\n          s.readchar() // consume '\n          break\n        }\n        s.readchar()\n      }\n      s.intval = unicode.InvalidChar\n      s.error(\"invalid character literal\")\n    }\n  }\n\n  resetAppendBuf() :AppendBuffer {\n    const s = this\n    if (s.appendbuf) {\n      s.appendbuf.reset()\n    } else {\n      // we need to buffer the value since it's not a 1:1 literal\n      s.appendbuf = new AppendBuffer(64)\n    }\n    return s.appendbuf\n  }\n\n  scanString() :token {\n    // opening char already consumed\n    const s = this\n    let buf :AppendBuffer|null = null\n    s.startoffs++ // skip initial \"\n    let chunkStart = s.startoffs\n    let tok = token.STRING\n\n    loop1:\n    while (true) {\n      switch (s.ch) {\n        case -1:\n          s.error(\"string literal not terminated\")\n          if (buf) {\n            buf = null\n          }\n          break loop1\n\n        case 0x22: // \"\n          if (buf) {\n            buf.appendRange(s.sdata, chunkStart, s.offset)\n          }\n          s.readchar()\n          break loop1\n\n        case 0x5c: { // \\\n          // we need to buffer the value since it's not a 1:1 literal\n          if (!buf) {\n            buf = s.resetAppendBuf()\n          }\n\n          if (chunkStart != s.offset) {\n            buf.appendRange(s.sdata, chunkStart, s.offset)\n          }\n\n          s.readchar()\n          const ch = s.ch as int // e.g. \"u\", \"x\", etc\n          const n = s.scanEscape(0x22) // \"\n\n          // we continue even if there was an error\n          if (n >= 0) {\n            if (n >= utf8.UniSelf && (ch == 0x75 || ch == 0x55)) { // u | U\n              // Write unicode code point as UTF8 to value buffer\n              if (0xD800 <= n && n <= 0xE000) {\n                s.error(\"illegal: surrogate half in string literal\")\n              } else if (n > unicode.MaxRune) {\n                s.error(\"escape sequence is invalid Unicode code point\")\n              }\n              buf.reserve(utf8.UTFMax)\n              buf.length += utf8.encode(buf.buffer, buf.length, n)\n            } else {\n              buf.append(n)\n            }\n          }\n\n          chunkStart = s.offset\n          break\n        }\n\n        case 0x24: { // $\n          s.readchar()\n          // start interpolated string\n\n          if (buf) {\n            s.byteval = buf.subarray()\n          }\n\n          if (s.gotchar(0x28)) { // (\n            // don't close until we see a balanced closing ')'\n            s.interpStrL++\n            s.endoffs = s.offset - 2 // exclude `$(`\n          } else if (s.ch as int == 0x22) { // \"\n            // \"foo $\"bar\"\" is invalid -- hard to read, hard to parse.\n            // (\"foo $(\"bar\")\" _is_ valid however.)\n            s.error(\n              \"invalid \\\" in string template â€” string literals inside string \" +\n              \"templates need to be enclosed in parenthesis\"\n            )\n            break // consume\n          } else {\n            // expect a single token to follow\n            s.endoffs = s.offset - 1 // exclude `$`\n            s.istrOne = istrOne.WAIT\n          }\n          return token.STRING_PIECE\n        }\n\n        case 0xA: // \\n\n          tok = token.STRING_MULTI\n          s.readchar()\n          break\n\n        default:\n          s.readchar()\n      }\n    }\n\n    if (buf) {\n      s.byteval = buf.subarray()\n    } else {\n      s.endoffs = s.offset - 1\n    }\n\n    return tok\n  }\n\n  // scanEscape parses an escape sequence where `quote` is the accepted\n  // escaped character. In case of a syntax error, it stops at the offending\n  // character (without consuming it) and returns -1.\n  // Otherwise it returns the unicode codepoint for \\u and \\U, and returns a\n  // byte value for all other escape sequences.\n  //\n  scanEscape(quote :int) :int {\n    const s = this\n\n    let n :int = 0\n    let base :int = 0\n\n    switch (s.ch) {\n      case quote: s.readchar(); return quote\n      case 0x30:  s.readchar(); return 0    // 0 - null\n      case 0x61:  s.readchar(); return 0x7  // a - alert or bell\n      case 0x62:  s.readchar(); return 0x8  // b - backspace\n      case 0x66:  s.readchar(); return 0xC  // f - form feed\n      case 0x6e:  s.readchar(); return 0xA  // n - line feed or newline\n      case 0x72:  s.readchar(); return 0xD  // r - carriage return\n      case 0x74:  s.readchar(); return 0x9  // t - horizontal tab\n      case 0x76:  s.readchar(); return 0xb  // v - vertical tab\n      case 0x5c:  s.readchar(); return 0x5c // \\\n      case 0x24:  s.readchar(); return 0x24 // $\n      case 0x78:  s.readchar(); n = 2; base = 16; break // x\n      case 0x75:  s.readchar(); n = 4; base = 16; break // u\n      case 0x55:  s.readchar(); n = 8; base = 16; break // U\n      default: {\n        let msg = \"unknown escape sequence\"\n        if (s.ch < 0) {\n          msg = \"escape sequence not terminated\"\n        }\n        s.error(msg)\n        return -1\n      }\n    }\n\n    let cp :int = 0\n    while (n > 0) {\n      let d = digitVal(s.ch) // returns a large value for non-digit chars\n      if (d >= base) {\n        let msg = (\n          (s.ch == quote) ? \"escape sequence incomplete\" :\n          (s.ch < 0) ? \"escape sequence not terminated\" :\n            `illegal character ${unicode.repr(s.ch)} in escape sequence`\n        )\n        s.errorAtOffs(msg, s.offset)\n        return -1\n      }\n      cp = cp * base + d\n      s.readchar()\n      n--\n    }\n\n    return cp\n  }\n\n  scanNumber(c :int) {\n    let s = this\n\n    if (c == 0x30) { // 0\n      switch (s.ch) {\n\n        case 0x78: case 0x58: { // x, X\n          s.tok = token.INT_HEX\n          s.readchar()\n          while (isHexDigit(s.ch)) {\n            s.readchar()\n          }\n          if (s.offset - s.startoffs <= 2 || unicode.isLetter(s.ch)) {\n            // only scanned \"0x\" or \"0X\" OR e.g. 0xfg\n            while (unicode.isLetter(s.ch) || unicode.isDigit(s.ch)) {\n              s.readchar() // consume invalid letters & digits\n            }\n            s.error(\"invalid hex number\")\n          }\n          return\n        }\n\n        case 0x6F: case 0x4F: // o, O\n          s.tok = token.INT_OCT\n          return s.scanRadixInt8(8)\n\n        case 0x62: case 0x42: // b, B\n          s.tok = token.INT_BIN\n          return s.scanRadixInt8(2)\n\n        case 0x2e: case 0x65: case 0x45:  // . e E\n          return s.scanFloatNumber(/*seenDecimal*/false)\n\n        case 0x2f:  // /\n          if (s.scanRatioNumber()) {\n            // i.e. 0/N\n            s.error(\"invalid zero ratio\")\n            return\n          }\n          break\n      }\n    }\n\n    while (unicode.isDigit(s.ch)) {\n      s.readchar()\n    }\n    s.tok = token.INT\n\n    switch (s.ch) {\n      case 0x2e: case 0x65: case 0x45:  // . e E\n        s.scanFloatNumber(/*seenDecimal*/false)\n        break\n\n      case 0x2f:  // /\n        s.scanRatioNumber()\n        break\n    }\n  }\n\n  scanRadixInt8(base :int) {\n    // invariant: base = 8 | 2\n    const s = this\n    s.readchar()\n    let isInvalid = false\n    while (unicode.isDigit(s.ch)) {\n      if (s.ch - 0x30 >= base) {\n        // e.g. 0o678\n        isInvalid = true\n      }\n      s.readchar()\n    }\n    if (isInvalid || s.offset - s.startoffs <= 2) {\n      // isInvalid OR only scanned \"0x\"\n      s.error(`invalid ${base == 8 ? \"octal\" : \"binary\"} number`)\n    }\n  }\n\n  scanRatioNumber() :bool {\n    // ratio_lit = decimals \"/\" decimals\n    const s = this\n    const startoffs = s.offset\n    s.readchar() // consume /\n    while (unicode.isDigit(s.ch)) {\n      s.readchar()\n    }\n    if (startoffs+1 == s.offset) {\n      // e.g. 43/* 43/= etc -- restore state\n      s.ch = 0x2f // /\n      s.offset = startoffs\n      s.rdOffset = s.offset + 1\n      return false\n    }\n    if (s.ch == 0x2e) { // .\n      s.error(\"invalid ratio\")\n    }\n    s.tok = token.RATIO\n    return true\n  }\n\n  scanFloatNumber(seenDecimal :bool) {\n    // float_lit = decimals \".\" [ decimals ] [ exponent ] |\n    //             decimals exponent |\n    //             \".\" decimals [ exponent ] .\n    // decimals  = decimal_digit { decimal_digit } .\n    // exponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals .\n    const s = this\n\n    if (seenDecimal || s.ch == 0x2e) { // .\n      s.readchar()\n      while (unicode.isDigit(s.ch)) {\n        s.readchar()\n      }\n    }\n\n    if (s.ch == 0x65 || s.ch == 0x45) { // e E\n      s.readchar()\n      if ((s.ch as int) == 0x2D || (s.ch as int) == 0x2B) { // - +\n        s.readchar()\n      }\n      let valid = false\n      while (unicode.isDigit(s.ch)) {\n        valid = true\n        s.readchar()\n      }\n      if (!valid) {\n        s.error(\"invalid floating-point exponent\")\n      }\n    }\n\n    s.tok = token.FLOAT\n  }\n\n  scanLineComment() {\n    const s = this\n    // initial '/' already consumed; s.ch == '/'\n    do { s.readchar() } while (s.ch != 0xA && s.ch >= 0)\n\n    if (s.sdata[s.offset-1] == 0xD) { // \\r\n      // don't include \\r in comment\n      s.endoffs = s.offset - 1\n    }\n\n    if (s.startoffs == s.lineOffset && s.sdata[s.startoffs + 2] == 0x21) { // !\n      // comment pragma, e.g. //!foo\n      s.interpretCommentPragma()\n    }\n\n    s.startoffs += 2 // skip //\n    s.tok = token.COMMENT\n  }\n\n  scanGeneralComment() :int /* CR count */ {\n    // initial '/' already consumed; s.ch == '*'\n    const s = this\n    let CR_count = 0\n\n    while (true) {\n      s.readchar()\n      switch (s.ch) {\n        case -1: // EOF\n          s.error(\"comment not terminated\")\n          return CR_count\n        case 0x2f: // /\n          if (s.sdata[s.offset-1] == 0x2a) { // *\n            s.readchar()\n            s.startoffs += 2\n            s.endoffs = s.offset - 2\n            return CR_count\n          }\n          break\n        case 0xD: // \\r\n          ++CR_count\n          break\n        default:\n          break\n      }\n    }\n  }\n\n  findCommentLineEnd() :bool {\n    // initial '/' already consumed; s.ch == '*'\n    const s = this\n    \n    // save state\n    const enterOffset = s.offset\n\n    while (true) {\n      const ch = s.ch\n      s.readchar()\n      switch (ch) {\n        case -1: // EOF\n        case 0xA: // \\n\n          return true\n        case 0x2a: // *\n          if (s.ch == 0x2f) { // /\n            // restore state\n            s.ch = 0x2a\n            s.offset = enterOffset\n            s.rdOffset = s.offset + 1\n            return false\n          }\n          break\n        default:\n          break\n      }\n    }\n  }\n  \n  interpretCommentPragma() {\n    const s = this\n    const offs = s.startoffs\n    if ( s.offset - offs > linePrefix.length &&\n         bufcmp(s.sdata, linePrefix, offs, offs + linePrefix.length) == 0\n    ) {\n      // get filename and line number, if any\n      // e.g. \"//!line file name:line\"\n      let text = utf8.decodeToString(\n        s.sdata.subarray(offs + linePrefix.length, s.offset)\n      )\n      /// --- here--- the above doesnt work on uintarray.\n      // we need to decode sdata to a js string\n      let i = text.lastIndexOf(':')\n      if (i > 0) {\n        let line = parseInt(text.substr(i+1))\n        if (!isNaN(line) && line > 0) {\n          // valid //!line filename:line comment\n          let filename = text.substr(0, i).trim()\n          if (filename) {\n            filename = path.clean(filename)\n            if (!path.isAbs(filename)) {\n              // make filename relative to current directory\n              filename = path.join(s.dir, filename)\n            }\n          }\n          // update scanner position\n          s.sfile.addLineInfo(s.offset + 1, filename, line)\n            // +1 since comment applies to next line\n        }\n      }\n    }\n  }\n\n  findLineEnd() :bool {\n    // initial '/' already consumed; enters with s.ch == '*'\n    const s = this\n  \n    // read ahead until a newline, EOF, or non-comment token is found\n    while (s.ch == 0x2f || s.ch == 0x2a) { // / *\n      if (s.ch == 0x2f) { // /\n        //-style comment always contains a newline\n        return true\n      }\n\n      /*-style comment: look for newline */\n      s.readchar()\n      while (s.ch >= 0) {\n        const ch = s.ch as int\n        if (ch == 0xA) { // \\n\n          return true\n        }\n        s.readchar()\n        if (ch == 0x2a && s.ch as int == 0x2f) { // */\n          s.readchar()\n          break\n        }\n      }\n\n      // skip whitespace\n      while (\n        s.ch as int == 0x20 || // ' '\n        s.ch as int == 0x9 || // \\t\n        (s.ch as int == 0xA && !s.insertSemi) || // \\n\n        s.ch as int == 0xD) // \\r\n      {\n        s.readchar()\n      }\n\n      if (s.ch < 0 || s.ch as int == 0xA) { // \\n\n        return true\n      }\n\n      if (s.ch as int != 0x2f) { // /\n        // non-comment token\n        return false\n      }\n\n      s.readchar() // consume '/'\n    }\n  \n    return false\n  }\n\n}\n\n\nfunction digitVal(ch :int) :int {\n  return (\n    0x30 <= ch && ch <= 0x39 ? ch - 0x30 :      // 0..9\n    0x61 <= ch && ch <= 0x66 ? ch - 0x61 + 10 : // a..f\n    0x41 <= ch && ch <= 0x46 ? ch - 0x41 + 10 : // A..F\n    16 // larger than any legal digit val\n  )\n}\n\n\nfunction stripByte(v :Uint8Array, b :byte, countHint :int = 0) :Uint8Array {\n  const c = new Uint8Array(v.length - countHint)\n  let i = 0\n  for (let x = 0, L = v.length; x < L; ++x) {\n    const _b = v[x]\n    if (_b != b) { // \\r\n      c[i++] = _b\n    }\n  }\n  return i < c.length ? c.subarray(0, i) : c\n}\n\nfunction isLetter(c :int) :bool {\n  return (\n    (0x41 <= c && c <= 0x5A) || // A..Z\n    (0x61 <= c && c <= 0x7A)  // a..z\n  )\n}\n\nfunction isDigit(c :int) :bool {\n  return 0x30 <= c && c <= 0x39 // 0..9\n}\n\nfunction isHexDigit(c :int) :bool {\n  return (\n    (0x30 <= c && c <= 0x39) || // 0..9\n    (0x41 <= c && c <= 0x46) || // A..F\n    (0x61 <= c && c <= 0x66)    // a..f\n  )\n}\n\nfunction isUniIdentStart(c :int) :bool {\n  return (\n    unicode.isLetter(c) ||\n    c == 0x5F || // _\n    c == 0x24 || // $\n    unicode.isEmojiPresentation(c) ||\n    unicode.isEmojiModifierBase(c)\n  )\n}\n\nfunction isUniIdentCont(c :int) :bool {\n  return (\n    unicode.isLetter(c) ||\n    unicode.isDigit(c) ||\n    c == 0x2D || // -\n    c == 0x5F || // _\n    c == 0x24 || // $\n    unicode.isEmojiPresentation(c) ||\n    unicode.isEmojiModifierBase(c)\n  )\n}\n\nconst\n  langIdent = 1<< 1 -1,\n  langIdentStart = 1<< 2 -1\n\n// must smaller than utf8.UniSelf\nconst asciiFeats = new Uint8Array([\n  /* 0    0  NUL */ 0,\n  /* 1    1  SOH */ 0,\n  /* 2    2  STX */ 0,\n  /* 3    3  ETX */ 0,\n  /* 4    4  EOT */ 0,\n  /* 5    5  ENQ */ 0,\n  /* 6    6  ACK */ 0,\n  /* 7    7  BEL */ 0,\n  /* 8    8  BS  */ 0,\n  /* 9    9  TAB */ 0,\n  /* 10   A  LF  */ 0,\n  /* 11   B  VT  */ 0,\n  /* 12   C  FF  */ 0,\n  /* 13   D  CR  */ 0,\n  /* 14   E  SO  */ 0,\n  /* 15   F  SI  */ 0,\n  /* 16  10  DLE */ 0,\n  /* 17  11  DC1 */ 0,\n  /* 18  12  DC2 */ 0,\n  /* 19  13  DC3 */ 0,\n  /* 20  14  DC4 */ 0,\n  /* 21  15  NAK */ 0,\n  /* 22  16  SYN */ 0,\n  /* 23  17  ETB */ 0,\n  /* 24  18  CAN */ 0,\n  /* 25  19  EM  */ 0,\n  /* 26  1A  SUB */ 0,\n  /* 27  1B  ESC */ 0,\n  /* 28  1C  FS  */ 0,\n  /* 29  1D  GS  */ 0,\n  /* 30  1E  RS  */ 0,\n  /* 31  1F  US  */ 0,\n  /* 32  20  SP  */ 0,\n  /* 33  21  !   */ 0,\n  /* 34  22  \"   */ 0,\n  /* 35  23  #   */ 0,\n  /* 36  24  $   */ langIdent | langIdentStart,\n  /* 37  25  %   */ 0,\n  /* 38  26  &   */ 0,\n  /* 39  27  '   */ 0,\n  /* 40  28  (   */ 0,\n  /* 41  29  )   */ 0,\n  /* 42  2A  *   */ 0,\n  /* 43  2B  +   */ 0,\n  /* 44  2C  ,   */ 0,\n  /* 45  2D  -   */ 0,\n  /* 46  2E  .   */ 0,\n  /* 47  2F  /   */ 0,\n  /* 48  30  0   */ langIdent,\n  /* 49  31  1   */ langIdent,\n  /* 50  32  2   */ langIdent,\n  /* 51  33  3   */ langIdent,\n  /* 52  34  4   */ langIdent,\n  /* 53  35  5   */ langIdent,\n  /* 54  36  6   */ langIdent,\n  /* 55  37  7   */ langIdent,\n  /* 56  38  8   */ langIdent,\n  /* 57  39  9   */ langIdent,\n  /* 58  3A  :   */ 0,\n  /* 59  3B  ;   */ 0,\n  /* 60  3C  <   */ 0,\n  /* 61  3D  =   */ 0,\n  /* 62  3E  >   */ 0,\n  /* 63  3F  ?   */ 0,\n  /* 64  40  @   */ 0,\n  /* 65  41  A   */ langIdent | langIdentStart,\n  /* 66  42  B   */ langIdent | langIdentStart,\n  /* 67  43  C   */ langIdent | langIdentStart,\n  /* 68  44  D   */ langIdent | langIdentStart,\n  /* 69  45  E   */ langIdent | langIdentStart,\n  /* 70  46  F   */ langIdent | langIdentStart,\n  /* 71  47  G   */ langIdent | langIdentStart,\n  /* 72  48  H   */ langIdent | langIdentStart,\n  /* 73  49  I   */ langIdent | langIdentStart,\n  /* 74  4A  J   */ langIdent | langIdentStart,\n  /* 75  4B  K   */ langIdent | langIdentStart,\n  /* 76  4C  L   */ langIdent | langIdentStart,\n  /* 77  4D  M   */ langIdent | langIdentStart,\n  /* 78  4E  N   */ langIdent | langIdentStart,\n  /* 79  4F  O   */ langIdent | langIdentStart,\n  /* 80  50  P   */ langIdent | langIdentStart,\n  /* 81  51  Q   */ langIdent | langIdentStart,\n  /* 82  52  R   */ langIdent | langIdentStart,\n  /* 83  53  S   */ langIdent | langIdentStart,\n  /* 84  54  T   */ langIdent | langIdentStart,\n  /* 85  55  U   */ langIdent | langIdentStart,\n  /* 86  56  V   */ langIdent | langIdentStart,\n  /* 87  57  W   */ langIdent | langIdentStart,\n  /* 88  58  X   */ langIdent | langIdentStart,\n  /* 89  59  Y   */ langIdent | langIdentStart,\n  /* 90  5A  Z   */ langIdent | langIdentStart,\n  /* 91  5B  [   */ 0,\n  /* 92  5C  \\   */ 0,\n  /* 93  5D  ]   */ 0,\n  /* 94  5E  ^   */ 0,\n  /* 95  5F  _   */ langIdent | langIdentStart,\n  /* 96  60  `   */ 0,\n  /* 97  61  a   */ langIdent | langIdentStart,\n  /* 98  62  b   */ langIdent | langIdentStart,\n  /* 99  63  c   */ langIdent | langIdentStart,\n  /* 100 64  d   */ langIdent | langIdentStart,\n  /* 101 65  e   */ langIdent | langIdentStart,\n  /* 102 66  f   */ langIdent | langIdentStart,\n  /* 103 67  g   */ langIdent | langIdentStart,\n  /* 104 68  h   */ langIdent | langIdentStart,\n  /* 105 69  i   */ langIdent | langIdentStart,\n  /* 106 6A  j   */ langIdent | langIdentStart,\n  /* 107 6B  k   */ langIdent | langIdentStart,\n  /* 108 6C  l   */ langIdent | langIdentStart,\n  /* 109 6D  m   */ langIdent | langIdentStart,\n  /* 110 6E  n   */ langIdent | langIdentStart,\n  /* 111 6F  o   */ langIdent | langIdentStart,\n  /* 112 70  p   */ langIdent | langIdentStart,\n  /* 113 71  q   */ langIdent | langIdentStart,\n  /* 114 72  r   */ langIdent | langIdentStart,\n  /* 115 73  s   */ langIdent | langIdentStart,\n  /* 116 74  t   */ langIdent | langIdentStart,\n  /* 117 75  u   */ langIdent | langIdentStart,\n  /* 118 76  v   */ langIdent | langIdentStart,\n  /* 119 77  w   */ langIdent | langIdentStart,\n  /* 120 78  x   */ langIdent | langIdentStart,\n  /* 121 79  y   */ langIdent | langIdentStart,\n  /* 122 7A  z   */ langIdent | langIdentStart,\n  /* 123 7B  {   */ 0,\n  /* 124 7C  |   */ 0,\n  /* 125 7D  }   */ 0,\n  /* 126 7E  ~   */ 0,\n  /* 127 7F  DEL */ 0,\n])\n\n","import { Pos, SrcFile } from './pos'\nimport { ByteStr } from './bytestr'\nimport { token } from './token'\nimport * as utf8 from './utf8'\n\nlet nextgid = 0; export class Group { id = nextgid++ } // DEBUG\n// export class Group {}\n\nexport class Comment {\n  constructor(\n    public pos   :Pos,\n    public value :Uint8Array,\n  ) {}\n}\n\nexport class Node {\n  constructor(\n    public pos   :Pos,\n    public scope :Scope,\n    // public comments? :Comment[],\n  ) {}\n\n  toString() :string {\n    return this.constructor.name\n  }\n}\n\n// Ident Type\n//       Type\nexport class Field extends Node {\n  constructor(pos :Pos, scope :Scope,\n  public type  :Expr,\n  public ident :Ident|null,\n    // nil means anonymous field/parameter (structs/parameters),\n    // or embedded interface (interfaces)\n  ) {\n    super(pos, scope)\n  }\n}\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Scope\n\n// An Ent describes a named language entity such as a package,\n// constant, type, variable, function (incl. methods), or label.\n//\n// VARIABLES\n//\n//   decl\n//    | value\n//    â†“   â†“\n//    x = 0 ; xÂ¹ = 3 ; print(xÂ²)\n//            â†‘              â†‘\n//         writes++       reads.add(xÂ²)\n//\n//\n// FUNCTIONS\n//\n//    fun a() { ... };  aÂ¹()\n//    ~~~~~~~~~~~~~~~   â†‘\n//           â†‘       reads.add(xÂ²)\n//      decl==value\n//\n//\nexport class Ent {\n  writes :int = 0          // Tracks stores. None == constant\n  reads = new Set<Ident>() // Tracks references to this ent. None == unused\n    // writes and reads does NOT include the definition/declaration itself.\n\n  constructor(\n    public name  :ByteStr,\n    public decl  :Node,\n    public value :Expr|null,\n    public data  :any = null,\n  ) {}\n\n  get isConstant() :bool {\n    return this.writes == 0\n  }\n\n  get scope() :Scope {\n    return this.decl.scope\n  }\n}\n\nexport class Scope {\n  fun :FunDecl | null = null // when set, scope if function scope\n\n  constructor(\n  public outer :Scope | null,\n  public decls :Map<ByteStr,Ent> | null = null,\n  public isFunScope :bool = false, // if the scope is that of a function\n  ) {}\n\n  // lookup a declaration in this scope and any outer scopes\n  //\n  lookup(s :ByteStr) :Ent | null {\n    const d = this.decls && this.decls.get(s)\n    return d ? d : this.outer ? this.outer.lookup(s) : null\n  }\n\n  // lookupImm looks up a declaration only in this scope\n  //\n  lookupImm(s :ByteStr) :Ent | null {\n    const d = this.decls && this.decls.get(s)\n    return d || null\n  }\n\n  // declare registers a name in this scope.\n  // If the name is already registered, null is returned.\n  //\n  declare(name: ByteStr, decl :Node, x: Expr|null) :Ent|null {\n    const ent = new Ent(name, decl, x)\n    return this.declareEnt(ent) ? ent : null\n  }\n\n  // declareEnt returns true if ent was declared, and false it's already\n  // declared.\n  //\n  declareEnt(ent :Ent) :bool {\n    // Note: name is interned by value in the same space as all other names in\n    // this scope, meaning we can safely use the object identity of name.\n    if (!this.decls) {\n      this.decls = new Map<ByteStr,Ent>([[ent.name, ent]])\n      return true\n    }\n    if (this.decls.has(ent.name)) {\n      return false\n    }\n    this.decls.set(ent.name, ent)\n    return true\n  }\n\n  // redeclareEnt returns the previously declared entity, if any.\n  //\n  redeclareEnt(ent :Ent) :Ent|null {\n    // Note: name is interned by value in the same space as all other names in\n    // this scope, meaning we can safely use the entity identity of name.\n    if (!this.decls) {\n      this.decls = new Map<ByteStr,Ent>([[ent.name, ent]])\n      return null\n    }\n    const prevent = this.decls.get(ent.name)\n    if (prevent === ent) {\n      return null\n    }\n    this.decls.set(ent.name, ent)\n    return prevent || null\n  }\n\n  // get closest function scope (could be this scope)\n  funScope() :Scope|null {\n    let s :Scope|null = this\n    while (s) {\n      if (s.fun) {\n        return s\n      }\n      s = s.outer\n    }\n    return null\n  }\n\n  level() {\n    let level = 0, s :Scope|null = this\n    while ((s = s.outer)) {\n      level++\n    }\n    return level\n  }\n\n  toString() {\n    const names = this.decls ? Array.from(this.decls.keys()) : []\n    return `Scope(level: ${this.level()}, names: (${names.join(', ')}))`\n  }\n}\n\n// used by intrinsics\nconst nilScope = new Scope(null)\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Declarations\n\nexport class Decl extends Node {}\n\nexport class ImportDecl extends Decl {\n  constructor(pos :Pos, scope :Scope,\n  public path       :StringLit,\n  public localIdent :Ident|null,\n  ) {\n    super(pos, scope)\n  }\n}\n\n// export class ConstDecl extends Decl {\n//   constructor(pos :Pos, scope :Scope,\n//   public idents  :Ident[],\n//   public type    :Expr|null,\n//     // null means auto type (values might have mixed types)\n//   public values  :Expr[],\n//   ) {\n//     super(pos, scope)\n//   }\n// }\n\nexport class VarDecl extends Decl {\n  constructor(pos :Pos, scope :Scope,\n  public idents  :Ident[],\n  public group   :Group|null,         // null means not part of a group\n  public type    :Expr|null = null,   // null means no type\n  public values  :Expr[]|null = null, // null means no values\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class TypeDecl extends Decl {\n  // Ident Type\n  constructor(pos :Pos, scope :Scope,\n  public ident  :Ident,\n  public alias  :bool,\n  public type   :Expr,\n  public group  :Group|null, // nil = not part of a group\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// ----------------------------------------------------------------------------\n// Statements\n\nexport class Stmt extends Node {}\n\nexport class BlockStmt extends Stmt {\n  constructor(pos :Pos, scope :Scope,\n  public list  :Stmt[],\n  ) {\n    super(pos, scope)\n  }\n}\n\n// An instance of SimpleStmt represents noop (no operation)\nexport class SimpleStmt extends Stmt {}\n\nexport class ExprStmt extends SimpleStmt {\n  constructor(pos :Pos, scope :Scope,\n  public expr :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class ReturnStmt extends Stmt {\n  constructor(pos :Pos, scope :Scope,\n  public result :Expr|null, // null means no explicit return values\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class AssignStmt extends SimpleStmt {\n  constructor(pos :Pos, scope :Scope,\n  public op  :token, // ILLEGAL means no operation\n  public lhs :Expr[],\n    // Rhs == ImplicitOne means Lhs++ (Op == Add) or Lhs-- (Op == Sub)\n  public rhs :Expr[],\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class DeclStmt extends SimpleStmt {\n  constructor(pos :Pos, scope :Scope,\n  public decls :Decl[],\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Expressions\n\nexport class Expr extends Node {\n  type :Type|null = null\n}\n\n// Placeholder for an expression that failed to parse\n// correctly and where we can't provide a better node.\nexport class BadExpr extends Expr {}\n\nexport class TupleExpr extends Expr {\n  // TupleExpr = \"(\" Expr (\",\" Expr)+ \")\"\n  constructor(pos :Pos, scope :Scope,\n  public exprs :Expr[],\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `(${this.exprs.map(x => x.toString()).join(', ')})`\n  }\n}\n\nexport class SelectorExpr extends Expr {\n  // Selector = Expr \".\" ( Ident | Selector )\n  constructor(pos :Pos, scope :Scope,\n    public lhs :Expr,\n    public rhs :Expr, // Ident or SelectorExpr\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `${this.lhs}.${this.rhs}`\n  }\n}\n\nexport class Ident extends Expr {\n  ent :Ent|null = null // what this name references\n  constructor(pos :Pos, scope :Scope,\n    public value  :ByteStr, // interned in ByteStrSet\n  ) {\n    super(pos, scope)\n  }\n\n  toString() { return String(this.value) }\n\n  // ref registers a reference to this ent from an identifier\n  //\n  refEnt(ent :Ent) {\n    assert(this !== ent.decl, \"ref declaration\")\n    ent.reads.add(this)\n    this.ent = ent\n  }\n\n  // ref unregisters a reference to this ent from an identifier\n  //\n  unrefEnt() {\n    assert(this.ent, \"null ent\")\n    const ent = this.ent as Ent\n    const _ok = ent.reads.delete(this)\n    assert(_ok, \"ent not referenced\")\n    this.ent = null\n  }\n}\n\nexport class RestExpr extends Expr {\n  // ...expr\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class LiteralExpr extends Expr {}\n\nexport class BasicLit extends LiteralExpr {\n  constructor(pos :Pos, scope :Scope,\n    public tok   :token,\n    public value :Uint8Array,\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return utf8.decodeToString(this.value)\n  }\n}\n\nexport class StringLit extends LiteralExpr {\n  constructor(pos :Pos, scope :Scope,\n    public value :Uint8Array\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return JSON.stringify(utf8.decodeToString(this.value))\n  }\n}\n\nexport class Operation extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public op :token,\n  public x  :Expr,\n  public y  :Expr|null = null, // nil means unary expression\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class CallExpr extends Expr {\n  // Fun(ArgList[0], ArgList[1], ...)\n  constructor(pos :Pos, scope :Scope,\n  public fun     :Expr,\n  public args    :Expr[],\n  public hasDots :bool,  // last argument is followed by ...\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class ParenExpr extends Expr {\n  // (X)\n  constructor(pos :Pos, scope :Scope,\n  public x :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class FunDecl extends Expr {\n  // func Ident? Signature { Body }\n  // func Ident? Signature\n\n  body :Stmt|null = null // nil = forward declaration\n  nlocali32 :int = 0\n  nlocali64 :int = 0\n  nlocalf32 :int = 0\n  nlocalf64 :int = 0\n\n  constructor(pos :Pos, scope :Scope,\n    public name   :Ident|null, // nil = anonymous func expression\n    public sig    :FunSig,\n    public isInit :bool = false, // true for special \"init\" funs at file level\n  ) {\n    super(pos, scope)\n    scope.fun = this  // Mark the scope as being a \"function scope\"\n  }\n}\n\nexport class FunSig extends Node {\n  constructor(pos :Pos, scope :Scope,\n  public params  :Field[],\n  public result  :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class IntrinsicVal extends Expr {\n  constructor(\n    public name :string,\n    public type :Type,\n  ) {\n    super(0, nilScope)\n  }\n}\n\n\nexport class TypeConvExpr extends Expr {\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n    public type :Type,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Types\n\nexport class Type extends Expr {\n  ent :Ent|null = null\n\n  constructor(pos :Pos, scope :Scope) {\n    super(pos, scope)\n    this.type = this\n  }\n\n  equals(other :Type) :bool {\n    return this === other\n  }\n}\n\nexport class UnresolvedType extends Type {\n  refs :Expr[]|null = null  // things that references this type\n\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n  ) {\n    super(pos, scope)\n  }\n\n  addRef(x :Expr) {\n    if (!this.refs) {\n      this.refs = [x]\n    } else {\n      this.refs.push(x)\n    }\n  }\n\n  toString() {\n    return this.expr.toString()\n  }\n}\n\nexport class IntrinsicType extends Type {\n  constructor(\n    public bitsize :int,\n    public name    :string, // only used for debugging and printing\n  ) {\n    super(0, nilScope)\n  }\n\n  toString() :string {\n    return this.name\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      (other instanceof ConstStringType && this.name == 'string')\n    )\n  }\n}\n\nexport class ConstStringType extends IntrinsicType {\n  constructor(\n    public bitsize :int,\n    public length :int,\n  ) {\n    super(bitsize, 'str')\n  }\n\n  toString() :string {\n    return `str[${this.length}]`\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof ConstStringType &&\n        this.bitsize == other.bitsize &&\n        this.length == other.length\n      ) ||\n      ( other instanceof IntrinsicType &&\n        other.name == 'string'\n      )\n    )\n  }\n}\n\nexport class RestType extends Type {\n  // ...type\n  constructor(pos :Pos, scope :Scope,\n    public type :Type,\n  ) {\n    super(pos, scope)\n    this.type = type\n  }\n\n  toString() :string {\n    return `...${this.type}`\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      other instanceof RestType && this.type.equals(other.type)\n    )\n  }\n}\n\nexport class TupleType extends Type {\n  // TupleType = \"(\" Type (\",\" Type)+ \")\"\n  constructor(pos :Pos, scope :Scope,\n  public types :Type[],\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return '(' + this.types.map(t => t.toString()).join(', ') + ')'\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof TupleType &&\n        this.types.length == other.types.length &&\n        this.types.every((t, i) => t.equals(other.types[i]))\n      )\n    )\n  }\n}\n\nexport class FunType extends Type {\n  // FunType = ( Type | TupleType ) \"->\" Type\n  constructor(pos :Pos, scope :Scope,\n  public inputs :Type[],\n  public output :Type,\n  ) {\n    super(pos, scope)\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof FunType &&\n        this.output.equals(other.output) &&\n        this.inputs.length == other.inputs.length &&\n        this.inputs.every((t, i) => t.equals(other.inputs[i]))\n      )\n    )\n  }\n}\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// File\n\n// A File corresponds to a source file\n//\nexport class File {\n  constructor(\n    public sfile      :SrcFile,\n    public scope      :Scope,\n    public imports    :ImportDecl[] | null,  // imports in this file\n    public decls      :Decl[],               // top-level declarations\n    public unresolved :Set<Ident> | null,    // unresolved references\n  ) {}\n}\n\nexport class Package {\n  files :File[] = []\n\n  constructor(\n    public name :string,\n    public scope :Scope,\n    // public imports\n    // public exports\n  ) {}\n\n  toString() {\n    return `Package(${this.name})`\n  }\n}\n","import { ByteStr, ByteStrSet } from './bytestr'\nimport { asciibuf, buf8str, bufcmp } from './util'\nimport { token, tokstr } from './token'\nimport { Pos } from './pos'\nimport { TypeSet } from './typeset'\nimport {\n  Scope,\n  Ent,\n  BasicLit,\n  Type,\n  IntrinsicVal,\n  IntrinsicType,\n} from './ast'\n\nexport const universeTypes = new Map<string,IntrinsicType>()\nexport const universeValues = new Map<string,IntrinsicVal>()\n\nfunction ityp(bitsize :int, name :string) :IntrinsicType {\n  const x = new IntrinsicType(bitsize, name)\n  assert(!universeTypes.has(name))\n  universeTypes.set(name, x)\n  return x\n}\n\nfunction ival(name :string, typ :IntrinsicType) :IntrinsicVal {\n  const x = new IntrinsicVal(name, typ)\n  assert(!universeValues.has(name))\n  universeValues.set(name, x)\n  return x\n}\n\nconst uintz :number = 32 // TODO: target-dependant\n\n// basic types\nexport const\n  u_t_void  = new IntrinsicType(0, 'void') // note: unnamed\n, u_t_auto  = new IntrinsicType(0, 'auto') // note: unnamed\n, u_t_nil   = new IntrinsicType(0, '?') // note: unnamed, special type for nil\n\n, u_t_bool  = ityp(1,  'bool')\n\n, u_t_uint = ityp(uintz, 'uint')\n, u_t_int  = ityp(uintz-1, 'int')\n\n, u_t_i8  = ityp(7,  'i8')\n, u_t_i16 = ityp(15, 'i16')\n, u_t_i32 = ityp(31, 'i32')\n, u_t_i64 = ityp(63, 'i64')\n\n, u_t_u8  = ityp(8,  'u8')\n, u_t_u16 = ityp(16, 'u16')\n, u_t_u32 = ityp(32, 'u32')\n, u_t_u64 = ityp(64, 'u64')\n\n, u_t_f32 = ityp(32, 'f32')\n, u_t_f64 = ityp(64, 'f64')\n\n, u_t_string = ityp(uintz, 'string')\n\nexport const universeTypeAliases = new Map<string,string>([\n  ['byte', 'u8'],\n  ['char', 'u32'],\n])\n\n\n// type compatibility\nexport enum TypeCompat {\n  NO = 0,   // not compatible\n  LOSSY,    // can be converted at a loss\n  LOSSLESS, // can be converted safely without loss\n}\n\n// maps destination type to receiver types and their compatbility type\nconst typeCompatMap = new Map<IntrinsicType,Map<IntrinsicType,TypeCompat>>([\n\n  [u_t_u64, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSLESS],\n    [u_t_int,  TypeCompat.LOSSLESS],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSLESS],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSLESS],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i64, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, uintz <= 63 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSLESS],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSLESS],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_u32, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i32, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_uint, new Map<IntrinsicType,TypeCompat>([\n    [u_t_int, TypeCompat.LOSSLESS],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, uintz >= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_u64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_int, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, uintz >= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_u16, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i16, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSY],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_u8, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSY],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u16, TypeCompat.LOSSY],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i8, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i16, TypeCompat.LOSSY],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSY],\n    [u_t_u16, TypeCompat.LOSSY],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_f32, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_f64, new Map<IntrinsicType,TypeCompat>([\n    [u_t_uint, uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSLESS],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSLESS],\n  ])],\n])\n\nexport function basicTypeCompat(\n  dst :IntrinsicType,\n  src :IntrinsicType,\n) :TypeCompat {\n  assert(dst !== src, \"same type is always compatible\")\n  let s = typeCompatMap.get(dst)\n  return s && s.get(src) || TypeCompat.NO\n}\n\nTEST(\"basicTypeCompat\", () => {\n  function assertTypeCompat(\n    dst :IntrinsicType,\n    src :IntrinsicType,\n    expect :TypeCompat,\n    cons :Function,\n  ) {\n    const r = basicTypeCompat(dst, src)\n    assert(\n      r === expect,\n      `${dst}(${src}) == ${TypeCompat[r]} (expected ${TypeCompat[expect]})`,\n      cons\n    )\n  }\n\n  function assert_LOSSLESS(dst :IntrinsicType, src :IntrinsicType) {\n    assertTypeCompat(dst, src, TypeCompat.LOSSLESS, assert_LOSSLESS)\n  }\n\n  function assert_LOSSY(dst :IntrinsicType, src :IntrinsicType) {\n    assertTypeCompat(dst, src, TypeCompat.LOSSY, assert_LOSSY)\n  }\n\n  // u64\n  assert_LOSSLESS(u_t_u64, u_t_uint)\n  assert_LOSSLESS(u_t_u64, u_t_int)\n  assert_LOSSLESS(u_t_u64, u_t_i64)\n  assert_LOSSLESS(u_t_u64, u_t_u32)\n  assert_LOSSLESS(u_t_u64, u_t_i32)\n  assert_LOSSLESS(u_t_u64, u_t_u16)\n  assert_LOSSLESS(u_t_u64, u_t_i16)\n  assert_LOSSLESS(u_t_u64, u_t_u8)\n  assert_LOSSLESS(u_t_u64, u_t_i8)\n  assert_LOSSY   (u_t_u64, u_t_f32)\n  assert_LOSSY   (u_t_u64, u_t_f64)\n\n  // i64\n  assert_LOSSLESS(u_t_i64, u_t_uint)\n  if (uintz == 64) {\n    assert_LOSSY(u_t_i64, u_t_int)\n  } else {\n    assert_LOSSLESS(u_t_i64, u_t_int)\n  }\n  assert_LOSSY   (u_t_i64, u_t_u64)\n  assert_LOSSLESS(u_t_i64, u_t_u32)\n  assert_LOSSLESS(u_t_i64, u_t_i32)\n  assert_LOSSLESS(u_t_i64, u_t_u16)\n  assert_LOSSLESS(u_t_i64, u_t_i16)\n  assert_LOSSLESS(u_t_i64, u_t_u8)\n  assert_LOSSLESS(u_t_i64, u_t_i8)\n  assert_LOSSY   (u_t_i64, u_t_f32)\n  assert_LOSSY   (u_t_i64, u_t_f64)\n\n  // u32\n  if (uintz == 64) {\n    assert_LOSSY(u_t_u32, u_t_uint)\n    assert_LOSSY(u_t_u32, u_t_int)\n  } else {\n    assert_LOSSLESS(u_t_u32, u_t_uint)\n    assert_LOSSLESS(u_t_u32, u_t_int)\n  }\n  assert_LOSSY   (u_t_u32, u_t_u64)\n  assert_LOSSY   (u_t_u32, u_t_i64)\n  assert_LOSSLESS(u_t_u32, u_t_i32)\n  assert_LOSSLESS(u_t_u32, u_t_u16)\n  assert_LOSSLESS(u_t_u32, u_t_i16)\n  assert_LOSSLESS(u_t_u32, u_t_u8)\n  assert_LOSSLESS(u_t_u32, u_t_i8)\n  assert_LOSSY   (u_t_u32, u_t_f32)\n  assert_LOSSY   (u_t_u32, u_t_f64)\n\n  // i32\n  assert_LOSSY   (u_t_i32, u_t_uint)\n  if (uintz == 64) {\n    assert_LOSSY(u_t_i32, u_t_int)\n  } else {\n    assert_LOSSLESS(u_t_i32, u_t_int)\n  }\n  assert_LOSSY   (u_t_i32, u_t_u64)\n  assert_LOSSY   (u_t_i32, u_t_i64)\n  assert_LOSSY   (u_t_i32, u_t_u32)\n  assert_LOSSLESS(u_t_i32, u_t_u16)\n  assert_LOSSLESS(u_t_i32, u_t_i16)\n  assert_LOSSLESS(u_t_i32, u_t_u8)\n  assert_LOSSLESS(u_t_i32, u_t_i8)\n  assert_LOSSY   (u_t_i32, u_t_f32)\n  assert_LOSSY   (u_t_i32, u_t_f64)\n\n  // u16\n  assert_LOSSY   (u_t_u16, u_t_uint)\n  assert_LOSSY   (u_t_u16, u_t_int)\n  assert_LOSSY   (u_t_u16, u_t_u64)\n  assert_LOSSY   (u_t_u16, u_t_i64)\n  assert_LOSSY   (u_t_u16, u_t_u32)\n  assert_LOSSY   (u_t_u16, u_t_i32)\n  assert_LOSSLESS(u_t_u16, u_t_i16)\n  assert_LOSSLESS(u_t_u16, u_t_u8)\n  assert_LOSSLESS(u_t_u16, u_t_i8)\n  assert_LOSSY   (u_t_u16, u_t_f32)\n  assert_LOSSY   (u_t_u16, u_t_f64)\n\n  // i16\n  assert_LOSSY   (u_t_i16, u_t_uint)\n  assert_LOSSY   (u_t_i16, u_t_int)\n  assert_LOSSY   (u_t_i16, u_t_u64)\n  assert_LOSSY   (u_t_i16, u_t_i64)\n  assert_LOSSY   (u_t_i16, u_t_u32)\n  assert_LOSSY   (u_t_i16, u_t_i32)\n  assert_LOSSY   (u_t_i16, u_t_u16)\n  assert_LOSSLESS(u_t_i16, u_t_u8)\n  assert_LOSSLESS(u_t_i16, u_t_i8)\n  assert_LOSSY   (u_t_i16, u_t_f32)\n  assert_LOSSY   (u_t_i16, u_t_f64)\n\n  // u8\n  assert_LOSSY   (u_t_u8, u_t_uint)\n  assert_LOSSY   (u_t_u8, u_t_int)\n  assert_LOSSY   (u_t_u8, u_t_u64)\n  assert_LOSSY   (u_t_u8, u_t_i64)\n  assert_LOSSY   (u_t_u8, u_t_u32)\n  assert_LOSSY   (u_t_u8, u_t_i32)\n  assert_LOSSY   (u_t_u8, u_t_u16)\n  assert_LOSSY   (u_t_u8, u_t_i16)\n  assert_LOSSLESS(u_t_u8, u_t_i8)\n  assert_LOSSY   (u_t_u8, u_t_f32)\n  assert_LOSSY   (u_t_u8, u_t_f64)\n\n  // i8\n  assert_LOSSY   (u_t_i8, u_t_uint)\n  assert_LOSSY   (u_t_i8, u_t_int)\n  assert_LOSSY   (u_t_i8, u_t_u64)\n  assert_LOSSY   (u_t_i8, u_t_i64)\n  assert_LOSSY   (u_t_i8, u_t_u32)\n  assert_LOSSY   (u_t_i8, u_t_i32)\n  assert_LOSSY   (u_t_i8, u_t_u16)\n  assert_LOSSY   (u_t_i8, u_t_i16)\n  assert_LOSSY   (u_t_i8, u_t_u8)\n  assert_LOSSY   (u_t_i8, u_t_f32)\n  assert_LOSSY   (u_t_i8, u_t_f64)\n\n  // f64\n  if (uintz <= 32) {\n    assert_LOSSLESS(u_t_f64, u_t_uint)\n    assert_LOSSLESS(u_t_f64, u_t_int)\n  } else {\n    assert_LOSSY   (u_t_f64, u_t_uint)\n    assert_LOSSY   (u_t_f64, u_t_int)\n  }\n  assert_LOSSY   (u_t_f64, u_t_u64)\n  assert_LOSSY   (u_t_f64, u_t_i64)\n  assert_LOSSLESS(u_t_f64, u_t_u32)\n  assert_LOSSLESS(u_t_f64, u_t_i32)\n  assert_LOSSLESS(u_t_f64, u_t_u16)\n  assert_LOSSLESS(u_t_f64, u_t_i16)\n  assert_LOSSLESS(u_t_f64, u_t_u8)\n  assert_LOSSLESS(u_t_f64, u_t_i8)\n  assert_LOSSLESS(u_t_f64, u_t_f32)\n\n  // f32\n  assert_LOSSY   (u_t_f32, u_t_uint)\n  assert_LOSSY   (u_t_f32, u_t_int)\n  assert_LOSSY   (u_t_f32, u_t_u64)\n  assert_LOSSY   (u_t_f32, u_t_i64)\n  assert_LOSSY   (u_t_f32, u_t_u32)\n  assert_LOSSY   (u_t_f32, u_t_i32)\n  assert_LOSSLESS(u_t_f32, u_t_u16)\n  assert_LOSSLESS(u_t_f32, u_t_i16)\n  assert_LOSSLESS(u_t_f32, u_t_u8)\n  assert_LOSSLESS(u_t_f32, u_t_i8)\n  assert_LOSSY   (u_t_f32, u_t_f64)\n})\n\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// literal types\n\nfunction intBinBits(v :Uint8Array) :number {\n  let start = 2 // skip 0b or 0B\n  while (v[start] == 0x30) { start++ } // skip leading zeroes\n  let n = v.length - start\n  return n > 64 ? 0 : n || 1\n}\n\nTEST(\"intBinBits\", () => {\n  for (let v of [\n    [\"0b0\",         1], // 0x0\n    [\"0b1111111\",   7], // 0x7F\n    [\"0b10000000\",  8], // 0x80\n    [\"0b11111111\",  8], // 0xFF\n    \n    [\"0b100000000\", 9],          // 0x100\n    [\"0b111111111111111\",   15], // 0x7FFF\n    [\"0b1000000000000000\",  16], // 0x8000\n    [\"0b1111111111111111\",  16], // 0xFFFF\n    \n    [\"0b10000000000000000\", 17],                 // 0x10000\n    [\"0b1111111111111111111111111111111\",   31], // 0x7FFFFFFF\n    [\"0b10000000000000000000000000000000\",  32], // 0x80000000\n    [\"0b11111111111111111111111111111111\",  32], // 0xFFFFFFFF\n\n    [\"0b100000000000000000000000000000000\", 33], // 0x100000000\n    [\"0b11111111111111111111111111111111111111111111111111111\", 53],\n      // 0x1FFFFFFFFFFFFF (js MAX_SAFE_INTEGER)\n    [\"0b111111111111111111111111111111111111111111111111111111111111111\", 63],\n      // 0x7FFFFFFFFFFFFFFF\n    [\"0b1000000000000000000000000000000000000000000000000000000000000000\", 64],\n      // 0x8000000000000000\n    [\"0b1111111111111111111111111111111111111111111111111111111111111111\", 64],\n      // 0xFFFFFFFFFFFFFFFF\n    [\"0b10000000000000000000000000000000000000000000000000000000000000000\", 0],\n      // 0x10000000000000000 too large\n  ]) {\n    let input = v[0] as string\n    let expected = v[1]\n    let actual = intBinBits(asciibuf(input))\n    assert(\n      actual == expected,\n      `${JSON.stringify(input)} => ${actual}; expected ${expected}`\n    )\n  }\n})\n\n\nfunction intOctBits(b :Uint8Array) :number {\n  let start = 2 // skip 0o or 0O\n  while (b[start] == 0x30) { start++ } // skip leading zeroes\n  let z = b.length - start\n  //\n  //         bits   hexadecimal             octal\n  // ------  ---  ---------------  -----------------------\n  // i8max    7   7F                177\n  // u8max    8   FF                377\n  // i16max  15   7FFF              77777\n  // u16max  16   FFFF              177777\n  // i32max  31   7FFFFFFF          17777777777\n  // u32max  32   FFFFFFFF          37777777777\n  // i64max  63   7FFFFFFFFFFFFFFF  777777777777777777777\n  // u64max  64   FFFFFFFFFFFFFFFF  1777777777777777777777\n  //\n  return (\n    z < 3 ? 7 :\n    z == 3 ? (\n      b[start] < 0x32 ? 7 : // <= 177 0x7F\n      b[start] < 0x34 ? 8 : // <= 377 0xFF\n      15 // > 377 0xFF\n    ) :\n    z < 6 ? 15 : // <= 77777 0x7FFF\n    z == 6 && b[start] < 0x32 ? 16 : // <= 177777 0xFFFF\n    z < 11 ? 31 : // > 177777 0xFFFF && < 10000000000 0x40000000\n    z == 11 ? (\n      b[start] < 0x32 ? 31 : // <= 17777777777 0x7FFFFFFF\n      b[start] < 0x34 ? 32 : // <= 37777777777 0xFFFFFFFF\n      63\n    ) :\n    z < 22 ? 63 : // <= 777777777777777777777 0x7FFFFFFFFFFFFFFF\n    z == 22 && b[start] < 0x32 ? 64 : // <= 1777777777777777777777\n    0\n  )\n}\n\nTEST(\"intOctBits\", () => {\n  for (let v of [\n    [\"0o0\",   7], // 0x0\n    [\"0o177\", 7], // 0x7F\n    [\"0o200\", 8], // 0x80\n    [\"0o377\", 8], // 0xFF\n    \n    [\"0o400\", 15],    // 0x100\n    [\"0o77777\",  15], // 0x7FFF\n    [\"0o100000\", 16], // 0x8000\n    [\"0o177777\", 16], // 0xFFFF\n    \n    [\"0o200000\", 31],      // 0x10000\n    [\"0o17777777777\", 31], // 0x7FFFFFFF\n    [\"0o20000000000\", 32], // 0x80000000\n    [\"0o37777777777\", 32], // 0xFFFFFFFF\n\n    [\"0o40000000000\", 63],            // 0x100000000\n    [\"0o377777777777777777\", 63],     // 0x1FFFFFFFFFFFFF (js MAX_SAFE_INTEGER)\n    [\"0o777777777777777777777\", 63],  // 0x7FFFFFFFFFFFFFFF\n    [\"0o1000000000000000000000\", 64], // 0x8000000000000000\n    [\"0o1777777777777777777777\", 64], // 0xFFFFFFFFFFFFFFFF\n    [\"0o2000000000000000000000\", 0],  // 0x10000000000000000 too large\n  ]) {\n    let input = v[0] as string\n    let expected = v[1]\n    let actual = intOctBits(asciibuf(input))\n    assert(\n      actual === expected,\n      `${JSON.stringify(input)} => ${actual}; expected ${expected}`\n    )\n  }\n})\n\n\nconst i64maxDecBuf = new Uint8Array([ // \"9223372036854775807\"\n  57,50,50,51,51,55,50,48,51,54,56,53,52,55,55,53,56,48,55\n])\n\nconst u64maxDecBuf = new Uint8Array([ // \"18446744073709551615\"\n  49,56,52,52,54,55,52,52,48,55,51,55,48,57,53,53,49,54,49,53\n])\n\n\nfunction intDecBits(b :Uint8Array) :number {\n  let v = 0, z = b.length\n  for (let i = 0; i < z; i++) {\n    v = v * 10 + (b[i] - 0x30)\n  }\n  if (v < 0x1FFFFFFFFFFFFF) {\n    return v < 0x80 ? 7 : Math.floor(Math.log2(v)) + 1\n  }\n  // Beyond js integer precision. We have to look at the bytes.\n  let start = 0\n  while (b[start] == 0x30) { start++ } // skip leading zeroes\n  z = b.length - start\n  return  (\n    z < 19 ? 63 :\n    z == 19 ? bufcmp(b, i64maxDecBuf, start) <= 0 ? 63 : 64 :\n    z == 20 && bufcmp(b, u64maxDecBuf, start) <= 0 ? 64 :\n    0\n  )\n}\n\nTEST(\"intDecBits\", () => {\n  for (let v of [\n    [\"0\",   7],  // 0x0\n    [\"127\", 7],  // 0x7F\n    [\"128\", 8],  // 0x80\n    [\"255\", 8],  // 0xFF\n    \n    [\"256\", 9],     // 0x100\n    [\"32767\", 15],  // 0x7FFF\n    [\"32768\", 16],  // 0x8000\n    [\"65535\", 16],  // 0xFFFF\n    \n    [\"65536\", 17],      // 0x10000\n    [\"2147483647\", 31], // 0x7FFFFFFF\n    [\"2147483648\", 32], // 0x80000000\n    [\"4294967295\", 32], // 0xFFFFFFFF\n\n    [\"4294967296\", 33],           // 0x100000000\n    [\"9007199254740991\", 63],     // 0x1FFFFFFFFFFFFF (js MAX_SAFE_INTEGER)\n    [\"9223372036854775807\", 63],  // 0x7FFFFFFFFFFFFFFF\n    [\"9223372036854775808\", 64],  // 0x8000000000000000\n    [\"18446744073709551615\", 64], // 0xFFFFFFFFFFFFFFFF\n    [\"18446744073709551616\", 0],  // 0x10000000000000000 too large\n  ]) {\n    let input = v[0] as string\n    let expected = v[1]\n    let actual = intDecBits(asciibuf(input))\n    assert(\n      actual == expected,\n      `${JSON.stringify(input)} => ${actual}; expected ${expected}`\n    )\n  }\n})\n\n\nfunction intHexBits(b :Uint8Array) :number {\n  let v = 0, z = b.length\n  for (let n = 0, i = 2; i < z; i++) {\n    n = b[i]\n    n = (\n      n >= 0x30 && n <= 0x39 ? n - 0x30 :  // 0..9\n      n >= 0x41 && n <= 0x46 ? n - 0x41 + 10 :  // A..F\n      n - 0x61 + 10  // a..f -- scanner guarantees 0-9A-Fa-f\n    )\n    v = v * 16 + n\n  }\n  if (v < 0x1FFFFFFFFFFFFF) {\n    return v < 0x80 ? 7 : Math.floor(Math.log2(v)) + 1\n  }\n  // Beyond js integer precision. We have to look at the bytes.\n  let start = 2 // skip 0x or 0X\n  while (b[start] == 0x30) { start++ } // skip leading zeroes\n  z = b.length - start\n  return (\n    z < 16 || (z == 16 && b[start] <= 0x37) ? 63 :\n    z == 16 ? 64 :\n    0\n  )\n}\n\nTEST(\"intHexBits\", () => {\n  for (let v of [\n    [\"0x0\",  7],\n    [\"0x7F\", 7],\n    [\"0x80\", 8],\n    [\"0xFF\", 8],\n    \n    [\"0x100\", 9],\n    [\"0x7FFF\", 15],\n    [\"0x8000\", 16],\n    [\"0xFFFF\", 16],\n    \n    [\"0x10000\", 17],\n    [\"0x7FFFFFFF\", 31],\n    [\"0x80000000\", 32],\n    [\"0xFFFFFFFF\", 32],\n\n    [\"0x100000000\", 33],\n    [\"0x1FFFFFFFFFFFFF\", 63],   // (js MAX_SAFE_INTEGER)\n    [\"0x7FFFFFFFFFFFFFFF\", 63],\n    [\"0x8000000000000000\", 64],\n    [\"0xFFFFFFFFFFFFFFFF\", 64],\n    [\"0x10000000000000000\", 0], // too large\n  ]) {\n    let input = v[0] as string\n    let expected = v[1]\n    let actual = intHexBits(asciibuf(input))\n    assert(\n      actual == expected,\n      `${JSON.stringify(input)} => ${actual}; expected ${expected}`\n    )\n  }\n})\n\n\nexport type ErrorHandler = (msg :string, pos :Pos) => any\n\n// basicLitTypeStorageMap maps storage types to all possible values types that\n// can be stored (in the storage type) losslessly.\n//\n// const basicLitTypeStorageMap = new Map<IntrinsicType,Set<IntrinsicType>>([\n//   // storageType => valueTypes[]\n//   [u_t_i64, new Set([\n//     u_t_char,\n//     u_t_i8, u_t_i16, u_t_i32, u_t_i64,\n//     u_t_u8, u_t_u16, u_t_u32\n//   ])],\n// ])\n\n// basicLitTypeFitter is a function that produces the most fitting type\n// for a basic literal. It may receive a \"requested type\", in which case the\n// reqt should be reutned if the literal can safely be represented as reqt.\n//\ntype basicLitTypeFitter =\n  (x :BasicLit, reqt :Type|null, errh? :ErrorHandler) => IntrinsicType\n\nfunction intLitTypeFitter(x :BasicLit, reqt :Type|null, errh? :ErrorHandler\n) :IntrinsicType {\n  // debuglog(`${tokstr(x.tok)} ${JSON.stringify(buf8str(x.value))}`)\n\n  let bits = 0\n\n  // calculate minimum bit length\n  switch (x.tok) {\n    case token.INT_BIN: bits = intBinBits(x.value); break\n    case token.INT_OCT: bits = intOctBits(x.value); break\n    case token.INT:     bits = intDecBits(x.value); break\n    case token.INT_HEX: bits = intHexBits(x.value); break\n  }\n\n  if (bits == 0) {  // literal is too large\n    // TODO: support bigint transparently\n    if (errh) {\n      let t = reqt instanceof IntrinsicType ? reqt : u_t_u64\n      errh(`constant ${buf8str(x.value)} overflows ${t.name}`, x.pos)\n      bits = 64\n    }\n  } else if (reqt instanceof IntrinsicType) {\n    if (reqt.bitsize >= bits) {\n      // yay! requested type is large enough for the literal\n      return reqt\n    }\n    if (errh) {\n      errh(`constant ${buf8str(x.value)} overflows ${reqt.name}`, x.pos)\n      bits = 64\n    }\n  }\n\n  // pick type that matches the bit length\n  return (\n    bits <= 31 ? u_t_int :\n    bits <= 63 ? u_t_i64 :\n    u_t_u64\n  )\n}\n\nfunction floatLitTypeFitter(x :BasicLit, reqt :Type|null, errh? :ErrorHandler\n) :IntrinsicType {\n  // TODO\n  return u_t_f64\n}\n\nfunction charLitTypeFitter(x :BasicLit, reqt :Type|null, errh? :ErrorHandler\n) :IntrinsicType {\n  // TODO reqt\n  return u_t_u32\n}\n\nconst basicLitTypesFitters = new Map<token,basicLitTypeFitter>([\n  [token.CHAR, charLitTypeFitter],\n  \n  [token.INT,     intLitTypeFitter],\n  [token.INT_BIN, intLitTypeFitter],\n  [token.INT_OCT, intLitTypeFitter],\n  [token.INT_HEX, intLitTypeFitter],\n\n  [token.FLOAT, floatLitTypeFitter],\n])\n\n\n// universe values\nexport const\n  u_v_true  = ival('true', u_t_bool)\n, u_v_false = ival('false', u_t_bool)\n, u_v_nil   = ival('nil', u_t_nil)\n\n\nexport class Universe {\n  readonly strSet  :ByteStrSet\n  readonly typeSet :TypeSet\n  readonly scope   :Scope\n\n  constructor(strSet :ByteStrSet, typeSet :TypeSet) {\n    this.strSet = strSet\n    this.typeSet = typeSet\n\n    // build scope\n    const unidecls = new Map<ByteStr,Ent>()\n\n    for (let [name, t] of universeTypes) {\n      // console.log(`DEF UNIVERSE TYPE \"${name}\"`)\n      let n = strSet.emplace(asciibuf(name))\n      unidecls.set(n, new Ent(n, t, t))\n    }\n\n    for (let [aliasName, canonName] of universeTypeAliases) {\n      // console.log(`DEF UNIVERSE TYPE ALIAS \"${aliasName}\" for \"${canonName}\"`)\n      let aliasNameBuf = strSet.emplace(asciibuf(aliasName))\n      let canonNameBuf = strSet.emplace(asciibuf(canonName))\n      const obj = unidecls.get(canonNameBuf)\n      assert(obj)\n      unidecls.set(aliasNameBuf, obj as Ent)\n    }\n\n    for (let [name, x] of universeValues) {\n      // console.log(`DEF UNIVERSE VAL \"${name}\"`)\n      let n = strSet.emplace(asciibuf(name))\n      unidecls.set(n, new Ent(n, x, x))\n    }\n\n    this.scope = new Scope(null, unidecls)\n  }\n\n  // basicLitType returns the most suitable type for a literal.\n  //\n  // If reqType is provided, this function will attempt to fit the literal\n  // into the reqType. If that fails, the most suitable type for the literal\n  // alone is returned, and an error message is produces if errh is provided\n  // You can thus check if contextual type fitting succeeded by comparing\n  // reqType with the result.\n  //\n  basicLitType(x :BasicLit, reqType? :Type|null, errh? :ErrorHandler) :Type {\n    let f = basicLitTypesFitters.get(x.tok) as basicLitTypeFitter\n    assert(f, `missing type fitter for ${tokstr(x.tok)}`)\n    return f(x, reqType || null, errh)\n  }\n\n  // internType potentially returns an equivalent type (t1.equals(t2) == true)\n  // if previously seen. Otherwise it registers t for future calls to this\n  // function and returns t as-is. Populates typeSet.\n  //\n  // The trade-offs are as follows:\n  //\n  //  [-] slower to parse files with many different types because of\n  //      intern-miss overhead.\n  //\n  //  [+] faster to parse files with few types that are used many times\n  //      (common case), since type equality testing is cheap for correct code.\n  //\n  //  [+] uses less memory (fewer resident Type instances).\n  //\n  internType(t :Type) :Type {\n    return this.typeSet.intern(t)\n  }\n\n}\n","import { SrcFile, Position, Pos } from './pos'\nimport { token, tokstr, prec } from './token'\nimport * as scanner from './scanner'\nimport { ErrorHandler, ErrorCode } from './error'\nimport { TypeResolver } from './resolve'\nimport { ByteStr, ByteStrSet } from './bytestr'\nimport {\n  Universe,\n  u_t_void,\n  u_t_auto,\n  u_t_uint,\n} from './universe'\nimport { debuglog } from './util'\nimport {\n  File,\n  Scope,\n  Ent,\n  Node,\n  Group,\n  Comment,\n  Ident,\n  RestExpr,\n  Field,\n  Decl,\n  ImportDecl,\n  VarDecl,\n  TypeDecl,\n  FunDecl,\n  FunSig,\n  Expr,\n  BasicLit,\n  StringLit,\n  Stmt,\n  BlockStmt,\n  ExprStmt,\n  SimpleStmt,\n  ReturnStmt,\n  AssignStmt,\n  DeclStmt,\n  Operation,\n  CallExpr,\n  ParenExpr,\n  TupleExpr,\n  BadExpr,\n  SelectorExpr,\n  Type,\n  FunType,\n  ConstStringType,\n  UnresolvedType,\n} from './ast'\n\n// type of diagnostic\nexport enum DiagKind {\n  INFO,\n  WARN,\n  ERROR, // Note: for config only; never reported to a DiagHandler\n}\n\n// A DiagHandler may be provided to Parser.init. If a diagnostic message is\n// produces and a handler was installed, the handler is called with a\n// position, kind of diagnostic and a message.\n// The position points to the beginning of the related source code.\n//\nexport type DiagHandler = (p :Position, msg :string, k :DiagKind) => void\n\nconst kEmptyByteArray = new Uint8Array(0)\nconst kBytes__ = new Uint8Array([0x5f]) // '_'\nconst kBytes_dot = new Uint8Array([0x2e]) // '.'\nconst kBytes_init = new Uint8Array([0x69, 0x6e, 0x69, 0x74]) // 'init'\n\nconst emptyExprList :Expr[] = []\n\ntype exprCtx = AssignStmt|VarDecl|null\n\n\n// Parser scans source code and produces AST.\n// It must be initialized via init before use or resue.\n//\nexport class Parser extends scanner.Scanner {\n  fnest      :int = 0   // function nesting level (for error handling)\n  universe   :Universe\n  strSet     :ByteStrSet\n  comments   :Comment[]|null\n  scope      :Scope\n  filescope  :Scope\n  pkgscope   :Scope\n  diagh      :DiagHandler|null = null\n  initfnest  :int = 0  // tracks if we're inside an init function\n  unresolved :Set<Ident>|null   // unresolved identifiers\n  funstack   :FunDecl[]  // function stack for type checking\n  types      :TypeResolver\n\n  _id__      :ByteStr\n  _id_dot    :ByteStr\n  _id_init   :ByteStr\n\n  initParser(\n    sfile    :SrcFile,\n    sdata    :Uint8Array,\n    universe :Universe,\n    pkgscope :Scope|null,\n    typeres  :TypeResolver,\n    errh     :ErrorHandler|null = null,\n    diagh    :DiagHandler|null = null,\n    smode    :scanner.Mode = scanner.Mode.None\n  ) {\n    const p = this\n    super.init(sfile, sdata, errh, smode)\n    p.scope = new Scope(pkgscope)\n    p.filescope = p.scope\n    p.pkgscope = pkgscope || p.filescope\n    \n    p.fnest = 0\n    p.universe = universe\n    p.strSet = universe.strSet\n    p.comments = null\n    p.diagh = diagh\n    p.initfnest = 0\n    p.unresolved = null\n    p.funstack = []\n    p.types = typeres\n\n    p._id__ = p.strSet.emplace(kBytes__)\n    p._id_dot = p.strSet.emplace(kBytes_dot)\n    p._id_init = p.strSet.emplace(kBytes_init)\n\n    if (smode & scanner.Mode.ScanComments) {\n      p.next = p.next_comments\n    }\n\n    p.next()\n  }\n\n  next_comments() {\n    const p = this\n    super.next()\n    while (p.tok == token.COMMENT) {\n      if (!p.comments) {\n        p.comments = []\n      }\n      p.comments.push(new Comment(p.pos, p.takeByteValue()))\n      super.next()\n    }\n    // TODO: Figure out a way to attach comments to nodes\n  }\n\n  got(tok :token) :bool {\n    const p = this\n    if (p.tok == tok) {\n      p.next()\n      return true\n    }\n    return false\n  }\n  \n  want(tok :token) {\n    const p = this\n    if (!p.got(tok)) {\n      p.syntaxError(`expecting ${tokstr(tok)}`)\n      p.next()\n    }\n  }\n\n  inFun() :FunDecl|null {\n    return this.funstack[0] || null\n  }\n\n  currFun() :FunDecl {\n    assert(this.funstack.length > 0, 'access current function at file level')\n    return this.funstack[0]\n  }\n\n  pushFun(f :FunDecl) {\n    this.funstack.push(f)\n  }\n\n  popFun() :FunDecl {\n    assert(this.funstack.length > 0, 'popFun with empty funstack')\n    return (this.funstack as any).pop() as FunDecl\n  }\n\n  pushScope(scope :Scope | null = null) {\n    const p = this\n    if (scope) {\n      assert(scope.outer != null, 'pushing scope without outer scope')\n    }\n    p.scope = scope || new Scope(p.scope)\n    // debuglog(`${(p as any).scope.outer.level()} -> ${p.scope.level()}`)\n  }\n\n  popScope() :Scope { // returns old (\"popped\") scope\n    const p = this\n    const s = p.scope\n    \n    assert(s !== p.filescope, \"pop file scope\")\n    assert(s !== p.pkgscope, \"pop file scope\")\n    assert(p.scope.outer != null, 'pop scope at base scope')\n\n    // debuglog(` ${(p as any).scope.outer.level()} <- ${p.scope.level()}`)\n\n    p.scope = p.scope.outer as Scope\n\n    // check for unused declarations\n    if (s.decls) for (let [name, ent] of s.decls) {\n      if (ent.reads.size == 0) {\n        if (ent.decl instanceof Field) {\n          p.diag(DiagKind.WARN, `${name} not used`, ent.decl.pos, (\n            ent.decl.scope.isFunScope ? 'E_UNUSED_PARAM' :\n            'E_UNUSED_FIELD'\n          ))\n        } else {\n          p.diag(\n            DiagKind.WARN,\n            `${name} declared and not used`,\n            ent.decl.pos,\n            'E_UNUSED_VAR'\n          )\n        }\n      }\n    }\n\n    return s\n  }\n\n  declare(scope :Scope, ident: Ident, decl :Node, x: Expr|null) {\n    const p = this\n\n    if (ident.value === p._id__) {\n      // \"_\" is never declared\n      return\n    }\n\n    const ent = new Ent(ident.value, decl, x)\n    if (scope.declareEnt(ent)) {\n      const f = p.inFun()\n      if (f) {\n        // TODO: change locals counting by using a watermark method or stack or\n        // something, so that:\n        //\n        // fun main {\n        //   a = 0\n        //   { c = 0; }\n        //   { d = 0; }\n        // }\n        //\n        // only needs two i32 locals since c and d can use the same slot.\n        //\n        f.nlocali32++\n        debuglog(\n          `${ident} in scope#${scope.level()}; ` +\n          `nlocali32: ${f.nlocali32}`\n        )\n      }\n    } else {\n      p.syntaxError(`${ident} redeclared`, ident.pos)\n    }\n  }\n\n  declarev(scope :Scope, idents: Ident[], decl :Node, xs: Expr[]|null) {\n    const p = this\n    for (let i = 0; i < idents.length; ++i) {\n      p.declare(scope, idents[i], decl, xs && xs[i] || null)\n    }\n  }\n\n  // If x is an identifier, resolve attempts to resolve x by looking up\n  // the entity it denotes. If no entity is found and collectUnresolved is\n  // set, x is marked as unresolved and collected in the list of unresolved\n  // identifiers.\n  // Returns the input expression\n  //\n  resolve<N extends Expr>(x :N, collectUnresolved :bool = true) :N {\n    const p = this\n\n    // nothing to do if x is not an identifier or the blank identifier\n    if (!(x instanceof Ident) || x.value === p._id__) {\n      return x\n    }\n\n    assert(x.ent == null, \"identifier already declared or resolved\")\n    if (x.value === p._id__) {\n      return x\n    }\n\n    // try to resolve the identifier\n    let s :Scope|null = x.scope\n    while (s) {\n      const ent = s.lookupImm(x.value)\n      if (ent) {\n        // debuglog(`${x} found in scope#${s.level()}`)\n        x.refEnt(ent) // reference ent\n        return x\n      }\n      s = s.outer\n    }\n    // debuglog(`${x} not found`)\n    if (collectUnresolved) {\n      // all local scopes are known, so any unresolved identifier\n      // must be found either in the file scope, package scope\n      // (perhaps in another file), or universe scope --- collect\n      // them so that they can be resolved later\n      if (!p.unresolved) {\n        p.unresolved = new Set<Ident>([x])\n      } else {\n        p.unresolved.add(x)\n      }\n    }\n\n    return x\n  }\n\n  // ctxType returns the type of the context, or null if the type is not known\n  // or if the type can't be reliably inferred, in which case it should be\n  // resolved later on.\n  //\n  ctxType(ctx :exprCtx) :Type|null {\n    const p = this\n    if (ctx) {\n      if (ctx instanceof VarDecl) {\n        return ctx.type && p.types.maybeResolve(ctx.type) || null\n      }\n      if (ctx instanceof AssignStmt) {\n        // common case: single assignment\n        // we handle multi assignments later, in p.assignment()\n        return (\n          ctx.lhs && ctx.lhs.length == 1 ? p.types.maybeResolve(ctx.lhs[0]) :\n          null\n        )\n      }\n    }\n    return null\n  }\n\n  parseFile() :File {\n    const p = this\n    const imports = p.parseImports()\n    const decls = p.parseFileBody()\n\n    return new File(\n      p.sfile,\n      p.scope,\n      imports,\n      decls,\n      p.unresolved,\n    )\n  }\n\n  parseImports() :ImportDecl[] {\n    const p = this\n    //\n    // Imports     = ImportDecl? | ImportDecl (\";\" ImportDecl)*\n    // ImportDecl  = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" )\n    // ImportSpec  = [ \".\" | PackageName ] ImportPath\n    // ImportPath  = string_lit\n    //\n    let imports = [] as ImportDecl[]\n    while (p.got(token.IMPORT)) {\n      p.appendGroup(imports, p.importDecl)\n      p.want(token.SEMICOLON)\n    }\n    return imports\n  }\n\n  importDecl = (group :Group|null) :ImportDecl => {\n    const p = this\n    let localIdent :Ident|null = null\n    let hasLocalIdent = false\n  \n    switch (p.tok) {\n      case token.NAME:\n        localIdent = p.ident()\n        hasLocalIdent = true\n        break\n\n      case token.DOT:\n        const s = p._id_dot\n        localIdent = new Ident(p.pos, p.scope, s)\n        p.next()\n        break\n    }\n\n    let path :StringLit\n    if (p.tok == token.STRING) {\n      path = p.strlit()\n    } else {\n      p.syntaxError(\"missing import path; expecting quoted string\")\n      path = new StringLit(p.pos, p.scope, kEmptyByteArray)\n      p.advanceUntil(token.SEMICOLON, token.RPAREN)\n    }\n\n    const d = new ImportDecl(p.pos, p.scope, path, localIdent)\n    // d.Group = group\n\n    if (hasLocalIdent && localIdent) {\n      p.declare(p.filescope, localIdent, d, null)\n    }\n    \n    return d\n  }\n\n  parseFileBody() :Decl[] {\n    const p = this\n    const decls = [] as Decl[]\n\n    // { TopLevelDecl \";\" }\n    while (p.tok != token.EOF) {\n      switch (p.tok) {\n\n        case token.TYPE:\n          p.next() // consume \"type\"\n          p.appendGroup(decls, p.typeDecl)\n          break\n\n        case token.NAME:\n          const pos = p.pos\n          const idents = p.identList(p.ident())\n          decls.push(p.varDecl(pos, idents))\n          break\n\n        case token.FUN:\n          decls.push(p.funDecl())\n          break\n\n        // TODO: token.TYPE\n\n        default: {\n          if (\n            p.tok == token.LBRACE &&\n            decls.length > 0 &&\n            isEmptyFunDecl(decls[decls.length-1])\n          ) {\n            // opening { of function declaration on next line\n            p.syntaxError(\"unexpected semicolon or newline before {\")\n          } else {\n            p.syntaxError(\"non-declaration statement outside function body\")\n          }\n\n          p.error(`TODO file-level token \\`${tokstr(p.tok)}\\``); p.next()\n\n          p.advanceUntil(/*token.CONST, */token.TYPE, token.FUN)\n          continue\n        }\n      }\n\n      if ((p.tok as token) != token.EOF && !p.got(token.SEMICOLON)) {\n        p.syntaxError(\"after top level declaration\")\n        p.advanceUntil(/*token.CONST, */token.TYPE, token.FUN)\n      }\n    }\n\n    return decls\n  }\n\n  // checkDeclLen verifies that idents.length == nvalues, and if not,\n  // reports a syntax error.\n  // Returns true if lengths matches.\n  //\n  checkDeclLen(idents :Ident[], nvalues: number, kind :string) :bool {\n    const p = this\n    if (nvalues != idents.length) {\n      p.syntaxError(\n        `cannot assign ${nvalues} values to ${idents.length} ${kind}`,\n        idents[0].pos\n      )\n      return false\n    }\n    return true\n  }\n\n  typeDecl = (group :Group|null, nth :int) :TypeDecl => {\n    // TypeSpec = \"type\" identifier [ \"=\" ] Type\n    const p = this\n    const pos = p.pos\n    const ident = p.ident()\n    const alias = p.got(token.ASSIGN)\n\n    let t = p.maybeType()\n    if (!t) {\n      t = p.bad()\n      p.syntaxError(\"in type declaration\")\n      p.advanceUntil(token.SEMICOLON, token.RPAREN)\n    }\n\n    const d = new TypeDecl(pos, p.scope, ident, alias, t, group)\n    // TODO: declare in scope\n    return d\n  }\n\n  varDecl(pos :Pos, idents :Ident[]) :VarDecl {\n    // VarDecl = IdentifierList\n    //           ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList )\n    const p = this\n    const typ = p.maybeType()\n    let isError = false\n\n    // vars at the file level are declared in the package scope\n    const scope = p.scope === p.filescope ? p.pkgscope : p.scope\n\n    const d = new VarDecl(pos, scope, idents, null, typ, null)\n\n    if (p.got(token.ASSIGN)) {\n      // e.g. x, y = 1, 2\n      d.values = p.exprList(/*ctx=*/d)\n      isError = !p.checkDeclLen(idents, d.values.length, 'constants')\n    } else if (!typ) {\n      // e.g. `x` -- missing type or values\n      p.syntaxError(\"unexpected identifier\", pos)\n      isError = true\n      d.values = [p.bad()]\n      p.advanceUntil(token.SEMICOLON)\n    }\n\n    if (isError) {\n      return d\n    }\n\n    if (d.type) {\n      // e.g. \"var x, y int = 1, 0x3\"\n      const t = p.types.resolve(d.type)\n      d.type = t\n      d.idents.forEach(ident => { ident.type = t })\n    } else {\n      assert(d.values, \"no type and no vals\")\n      let vals = d.values as Expr[]\n      // e.g. \"var x, y = 1, 0x3\"\n      \n      for (let x of vals) {\n        p.types.resolve(x)\n      }\n\n      // copy types of values to names\n      vals.forEach((v, i) => {\n        let ident = d.idents[i] as Ident // we have checked len already\n        ident.type = v.type\n      })\n    }\n\n    p.declarev(d.scope, idents, d, d.values)\n\n    return d\n  }\n\n  funDecl() :FunDecl {\n    // FunDecl  = \"fun\" FunName Signature? FunBody?\n    // FunName  = identifier\n    // FunBody  = ( Block | \"->\" Stmt )\n    const p = this\n    const pos = p.pos\n    p.want(token.FUN)\n    const name = p.ident()\n\n    // functions called \"init\" at the file level are special\n    const isInitFun = p.scope === p.filescope && name.value.equals(p._id_init)\n\n    // vars at the file level are declared in the package scope\n    const scope = p.scope === p.filescope ? p.pkgscope : p.scope\n\n    // new scope for parameters, signature and body\n    p.pushScope(new Scope(p.scope, null, /*isFunScope*/true))\n\n    const d = new FunDecl(pos, p.scope, name, p.funSig(u_t_void), isInitFun)\n\n    if (isInitFun) {\n      // check initfun signature (should be empty)\n      if (d.sig.params.length > 0) {\n        p.syntaxError(`init function with parameters`, d.sig.pos)\n      }\n      if (d.sig.result !== u_t_void) {\n        p.syntaxError(`init function with result`, d.sig.pos)\n      }\n    } else {\n      // The function itself is declared in its outer scope, so that its body\n      // can refer to the function, but also so that \"funname = x\" declares a\n      // new variable rather than replacing the function.\n      p.declare(scope, name, d, d)\n    }\n\n    // parse body\n    if (isInitFun || p.tok != token.SEMICOLON) {\n      if (isInitFun) { p.initfnest++ }\n      p.pushFun(d)\n      d.body = p.funBody(name)\n      p.popFun()\n      if (isInitFun) { p.initfnest-- }\n    }\n\n    p.popScope()\n\n    if (d.sig.result === u_t_void) {\n      // no result type specified\n      // - if the body is a single expression, result is that expression\n      // - otherwise void (no result)\n      d.sig.result = d.body instanceof ExprStmt ? d.body.expr : u_t_void\n    }\n\n    const funtype = p.types.resolve(d)\n    \n    if (!isInitFun) {\n      // since we declared the name of the function, the name now represents\n      // the function and thus its type.\n      name.type = funtype\n    }\n\n    return d\n  }\n\n  // TODO: maybeFunExpr() :Expr -- FunDecl or some other expr\n\n  funStmt(ctx :exprCtx) :FunDecl {\n    // FunStmt = \"fun\" FunName? Signature FunBody\n    // FunBody  = ( Block | \"->\" Stmt )\n\n    // FunExpr = \"fun\" FunName? Signature FunBody\n    // FunName = identifier\n    // FunBody  = ( Block | \"->\" Stmt )\n    const p = this\n    const pos = p.pos\n\n    p.want(token.FUN)\n\n    // \"fun foo(...) { ... }\"\n    // \"fun foo(...) -> ...\"\n    // \"fun (...) { ... }\"\n    // \"fun (...) -> ...\"\n    // \"fun -> ...\"\n    const name = p.maybeIdent()\n\n    const scope = p.scope\n\n    // new scope for parameters, signature and body\n    p.pushScope(new Scope(scope, null, /*isFunScope*/true))\n\n    // declare in outer scope, before we parse the body, so that the body can\n    // refer to the function's name\n    const d = new FunDecl(pos, scope, name, p.funSig(u_t_void))\n    if (name && !ctx) {\n      // declare the function's name when it's not on the right-hand side of an\n      // assignment.\n      // e.g. \"fun foo ...\"\n      p.declare(name.scope, name, d, d)\n    }\n\n    p.pushFun(d)\n    d.body = p.funBody(name)\n    p.popFun()\n\n    p.popScope()\n\n    if (d.sig.result === u_t_void) {\n      // no result type specified\n      // - if the body is a single expression, result is that expression\n      // - otherwise void (no result)\n      d.sig.result = d.body instanceof ExprStmt ? d.body.expr : u_t_void\n    }\n\n    const funtype = p.types.resolve(d)\n    \n    if (name) {\n      // since we declared the name of the function, the name now represents\n      // the function and thus its type.\n      name.type = funtype\n    }\n\n    return d\n  }\n\n  funSig(defaultType :Type): FunSig {\n    // Signature = ( Parameters Result? | Type )?\n    const p = this\n    const pos = p.pos\n    const params = p.tok == token.LPAREN ? p.parameters() : []\n    const result = p.maybeType() || defaultType\n    return new FunSig(pos, p.scope, params, result)\n  }\n\n  parameters() :Field[] {\n    // Parameters    = \"(\" [ ParameterList [ \",\" ] ] \")\"\n    // ParameterList = ParameterDecl (\",\" ParameterDecl)*\n    // ParameterDecl = Ident [ [ \"...\" ] Type ]\n    //\n    const p = this\n    p.want(token.LPAREN)\n\n    const fields = [] as Field[]\n    let seenRestExpr = false\n\n    while (p.tok != token.RPAREN) {\n      let f = new Field(p.pos, p.scope, u_t_auto, null)\n\n      f.ident = p.ident()\n      p.declare(f.ident.scope, f.ident, f, null) // in function scope\n\n      if (p.tok == token.ELLIPSIS) {\n        // e.g. \"fun foo(ident ... type)\"\n        f.type = p.restExpr(u_t_auto)\n        if (seenRestExpr) {\n          p.syntaxError(\"can only use ... with final parameter in list\")\n          continue  // skip this field\n        } else {\n          seenRestExpr = true\n        }\n      } else if (\n        p.tok != token.COMMA &&\n        p.tok != token.SEMICOLON &&\n        p.tok as token != token.RPAREN)\n      {\n        // e.g. \"fun foo(ident type)\"\n        f.type = p.type()\n      }\n\n      f.ident.type = p.types.resolve(f.type)\n\n      if (!p.ocomma(token.RPAREN)) {\n        // error: unexpected ;, expecting comma, or )\n        // e.g. \"fun foo(a, b<LF>)\" fix -> \"fun foo(a, b,<LF>)\"\n        //                                              ^\n        break\n      }\n\n      fields.push(f)\n    }\n\n    p.want(token.RPAREN)\n\n    return fields\n  }\n\n  funBody(funcname :Ident|null) :Stmt {\n    // FunBody  = ( \"->\" Stmt | Block )\n    const p = this\n    if (p.tok == token.LBRACE) {\n      // Block\n      return p.block()\n    }\n    const pos = p.pos\n    if (p.got(token.ARROWR)) {\n      // \"->\" Stmt\n      const s = p.maybeStmt()\n      if (s) {\n        return s\n      }\n    }\n    // error\n    if (funcname) {\n      p.syntaxError(`${funcname} is missing function body`, pos)\n    } else {\n      p.syntaxError(\"missing function body\", pos)\n    }\n    return new SimpleStmt(pos, p.scope)\n  }\n\n  block() :BlockStmt {\n    // Block = \"{\" StatementList \"}\"\n    const p = this\n    const pos = p.pos\n    p.want(token.LBRACE)\n    const list = p.stmtList()\n    p.want(token.RBRACE)\n    return new BlockStmt(pos, p.scope, list)\n  }\n\n  declStmt<D extends Decl>(f :(g:Group|null, i:int)=>D) :DeclStmt {\n    const p = this\n    const pos = p.pos\n    p.next() // e.g. TYPE\n    const decls :Decl[] = []\n    p.appendGroup(decls, f)\n    return new DeclStmt(pos, p.scope, decls)\n  }\n\n  stmtList() :Stmt[] {\n    // StatementList = { Statement \";\" }\n    const p = this\n    const list = [] as Stmt[]\n\n    while (p.tok != token.EOF &&\n           p.tok != token.RBRACE &&\n           // p.tok != token.CASE &&\n           p.tok != token.DEFAULT)\n    {\n      const s = p.maybeStmt()\n      if (!s) {\n        break\n      }\n      list.push(s)\n      // customized version of osemi:\n      // ';' is optional before a closing ')' or '}'\n      if (p.tok == token.RPAREN || p.tok as token == token.RBRACE) {\n        continue\n      }\n      if (!p.got(token.SEMICOLON)) {\n        p.syntaxError(\"at end of statement\")\n        p.advanceUntil(token.SEMICOLON, token.RBRACE)\n      }\n    }\n\n    return list\n  }\n\n  // shouldStoreToEnt returns true if entis within atScope in such a way\n  // that \"ent = value\" means \"store value to ent\".\n  //\n  shouldStoreToEnt(ent :Ent, atScope :Scope) :bool {\n    const p = this\n    return (\n      ent.scope === atScope  // same scope\n      ||\n      ( ent.scope !== p.filescope &&\n        ( ( ent.scope === p.pkgscope &&\n            atScope.fun && atScope.fun.isInit )\n          ||\n          ent.scope.funScope() === atScope.funScope()\n        )\n      )\n    )\n  }\n\n  assignment(lhs :Expr[]) :AssignStmt {\n    // Assignment = ExprList \"=\" ExprList\n    const p = this\n    p.want(token.ASSIGN) // \"=\"\n\n    const s = new AssignStmt(lhs[0].pos, p.scope, token.ASSIGN, lhs, [])\n\n    // parse right-hand side in context of the function\n    s.rhs = p.exprList(/*ctx=*/s)\n\n    // Check each left-hand identifier against scope and unresolved.\n    // Note that exprList already has called p.resolve on all ids.\n    //\n    // If an id has an ent (i.e. was resolved to something), then we simply\n    // register the assignment with it so that we can later bind.\n    //\n    // If an id is unresolved (doesn't have an ent), the semantics are:\n    // - assume it's a constant definition and declare it as such\n    // - register the assignment so that if we later find a var in the outer\n    //   scope, we can convert the declaration to an assignment.\n    //\n    for (let i = 0; i < lhs.length; ++i) {\n      const id = lhs[i]\n      if (id instanceof Ident) {\n        assert(s.rhs[i])\n\n        // Decide declare a new ent, or store to existing one\n        if (id.ent && p.shouldStoreToEnt(id.ent, id.scope)) {\n          id.ent.writes++  // increment Nth write counter\n          \n          if (id.ent.value && id.ent.value.type) {\n            // check & resolve type, converting RHS if needed\n            id.type = id.ent.value.type\n\n            const val = s.rhs[i]\n            const typ = id.ent.value.type\n            const convertedVal = p.types.convert(typ, val)\n\n            if (!convertedVal) {\n              p.error(\n                (val.type instanceof UnresolvedType ?\n                  `cannot convert \"${val}\" to type ${typ}` :\n                  `cannot convert \"${val}\" (type ${val.type}) to type ${typ}`\n                ),\n                val.pos\n              )\n            } else if (convertedVal !== val) {\n              // no error and conversion is needed.\n              // replace original expression with conversion expression\n              s.rhs[i] = convertedVal\n            }\n\n          }\n        } else {\n          // since we are about to redeclare, clear any \"unresolved\" mark for\n          // this identifier expression.\n          if (p.unresolved) { p.unresolved.delete(id) } // may be noop\n          p.declare(id.scope, id, s, s.rhs[i])\n          id.type = p.types.resolve(s.rhs[i])\n          if (id.type instanceof UnresolvedType) {\n            id.type.addRef(id)\n          }\n        }\n      }\n    }\n\n    return s\n  }\n\n  // SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt\n  //            | Assignment | ShortVarDecl .\n  simpleStmt(lhs :Expr[]) :SimpleStmt {\n    const p = this\n\n    // Note: token.SET_ASSIGN \":=\" is currently unused\n    // we could use it to allow shadowing in same scope, e.g.\n    //   \"b = 4; b := true\" where \"b :=\" redeclares b.\n\n    if (p.tok == token.ASSIGN) {\n      // e.g.  \"a = 1\"  \"a, b = 1, 2\"  \"a[1], b.f = 1, 2\"  etc\n      return p.assignment(lhs)\n    }\n\n    const pos = lhs[0].pos\n\n    if (lhs.length != 1) {\n      p.syntaxError(\"expecting := or = or comma\")\n      p.advanceUntil(token.SEMICOLON, token.RBRACE)\n      return new ExprStmt(lhs[0].pos, p.scope, lhs[0])\n    }\n\n    // single expression\n\n    p.types.resolve(lhs[0])\n\n    if (token.assignop_beg < p.tok && p.tok < token.assignop_end) {\n      // lhs op= rhs;  e.g. \"x += 2\"\n      const op = p.tok\n      p.next() // consume operator\n      const s = new AssignStmt(pos, p.scope, op, lhs, [])\n      s.rhs = p.exprList(/*ctx=*/s)\n      return s\n    }\n\n    if (p.tok == token.INC || p.tok == token.DEC) {\n      // lhs++ or lhs--\n      const op = p.tok\n      p.next() // consume operator\n      // check operand type\n      const operand = lhs[0]\n      if (operand instanceof Ident &&\n          operand.ent &&\n          !(operand.ent.decl instanceof VarDecl)\n      ) {\n        p.syntaxError(`cannot mutate ${operand}`, operand.pos)\n      }\n      return new AssignStmt(pos, p.scope, op, lhs, emptyExprList)\n    }\n\n    if (p.tok == token.ARROWL) {\n      // lhs <- rhs\n      p.syntaxError(\"TODO simpleStmt ARROWL\")\n    }\n\n    if (p.tok == token.ARROWR) {\n      // params -> result\n      p.syntaxError(\"TODO simpleStmt ARROWR\")\n    }\n\n    // else: expr\n    return new ExprStmt(lhs[0].pos, p.scope, lhs[0])\n  }\n\n\n  maybeStmt() :Stmt|null {\n    // Statement =\n    //   Declaration | LabeledStmt | SimpleStmt |\n    //   GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n    //   FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n    //   DeferStmt .\n    const p = this\n\n    switch (p.tok) {\n      // Most statements (assignments) start with an identifier;\n      // look for it first before doing anything more expensive.\n      case token.NAME:\n      case token.NAMEAT:\n        return p.simpleStmt(p.exprList(/*ctx=*/null))\n\n      case token.LBRACE:\n        p.pushScope()\n        const s = p.block()\n        p.popScope()\n        return s\n\n      case token.TYPE:\n        return p.declStmt(p.typeDecl)\n\n      case token.ADD:\n      case token.SUB:\n      case token.MUL:\n      case token.AND:\n      case token.NOT:\n      case token.XOR: // unary operators\n      case token.FUN:\n      case token.LPAREN: // operands\n      case token.LBRACK:\n      // case token.STRUCT:\n      // case token.CHAN:\n      case token.INTERFACE: // composite types\n      // case token.ARROW: // receive operator\n        return p.simpleStmt(p.exprList(/*ctx=*/null))\n\n      // case _For:\n      //   return p.forStmt()\n\n      // case _Switch:\n      //   return p.switchStmt()\n\n      // case _Select:\n      //   return p.selectStmt()\n\n      // case _If:\n      //   return p.ifStmt()\n\n      // case _Fallthrough:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   p.next()\n      //   s.Tok = _Fallthrough\n      //   return s\n\n      // case _Break, _Continue:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   s.Tok = p.tok\n      //   p.next()\n      //   if p.tok == _Name {\n      //     s.Label = p.name()\n      //   }\n      //   return s\n\n      // case _Go, _Defer:\n      //   return p.callStmt()\n\n      // case _Goto:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   s.Tok = _Goto\n      //   p.next()\n      //   s.Label = p.name()\n      //   return s\n\n      case token.RETURN:\n        return p.returnStmt()\n\n      // case _Semi:\n      //   s := new(EmptyStmt)\n      //   s.pos = p.pos()\n      //   return s\n\n      default:\n        if (token.literal_beg < p.tok && p.tok < token.literal_end) {\n          return p.simpleStmt(p.exprList(/*ctx=*/null))\n        }\n    }\n\n    return null\n  }\n\n  returnStmt() :ReturnStmt {\n    const p = this\n    const pos = p.pos\n\n    p.want(token.RETURN)\n\n    const n = new ReturnStmt(pos, p.scope, null)\n\n    // resolve current function's result type\n    const ftype = p.types.resolve(p.currFun()) as FunType\n    assert(ftype instanceof FunType) // ftype always resolves\n    const frtype = ftype.output\n    \n    if (p.tok == token.SEMICOLON || p.tok == token.RBRACE) {\n      // no result\n      if (frtype !== u_t_void) {\n        p.syntaxError(\"missing return value\", pos)\n        return n\n      }\n      return n\n    }\n\n    // expecting one or more results to follow\n    \n    const xs = p.exprList(/*ctx=*/null) // ?: maybe pass TupleExpr?\n    \n    let rval = (\n      xs.length == 1 ? xs[0] :\n        // e.g. \"return 1\", \"return (1, 2)\"\n\n      new TupleExpr(xs[0].pos, xs[0].scope, xs)\n        // Support paren-less tuple return\n        // e.g. \"return 1, 2\" == \"return (1, 2)\"\n    )\n\n    if (frtype === u_t_void) {\n      p.syntaxError(\"function does not return a value\", rval.pos)\n      return n\n    }\n\n    const rtype = p.types.resolve(rval)\n\n    if (!frtype.equals(rtype)) {\n      const convres = p.types.convert(frtype, rval)\n      if (convres) {\n        rval = convres\n      } else {\n        p.syntaxError(\n          (rval.type instanceof UnresolvedType ?\n            `cannot use \"${rval}\" as return type ${frtype}` :\n            `cannot use \"${rval}\" (type ${rval.type}) as return type ${frtype}`\n          ),\n          rval.pos\n        )\n      }\n    }\n\n    n.result = rval\n\n    return n\n  }\n\n  exprList(ctx :exprCtx) :Expr[] {\n    // ExpressionList = Expression ( \",\" Expression )*\n    const p = this\n    const list = [p.expr(ctx)]\n    while (p.got(token.COMMA)) {\n      list.push(p.expr(ctx))\n    }\n    return list\n  }\n\n  expr(ctx :exprCtx) :Expr {\n    const p = this\n    return p.binaryExpr(prec.LOWEST, ctx)\n  }\n\n  binaryExpr(pr :prec, ctx :exprCtx) :Expr {\n    // Expression = UnaryExpr | Expression binary_op Expression\n    const p = this\n    let x = p.unaryExpr(ctx)\n    while (\n      (token.operator_beg < p.tok && p.tok < token.operator_end) &&\n      p.prec > pr)\n    {\n      const pos = p.pos\n      const tprec = p.prec\n      const op = p.tok\n      p.next()\n      x = new Operation(pos, p.scope, op, x, p.binaryExpr(tprec, ctx))\n    }\n    return x\n  }\n\n  unaryExpr(ctx :exprCtx) :Expr {\n    // UnaryExpr = PrimaryExpr | unary_op UnaryExpr\n    const p = this\n    const t = p.tok\n    const pos = p.pos\n\n    switch (t) {\n      case token.MUL:\n      case token.ADD:\n      case token.SUB:\n      case token.NOT:\n      case token.XOR: {\n        p.next()\n        return new Operation(pos, p.scope, t, p.unaryExpr(ctx))\n      }\n\n      case token.AND: {\n        p.next()\n        // unaryExpr may have returned a parenthesized composite literal\n        // (see comment in operand) - remove parentheses if any\n        return new Operation(pos, p.scope, t, unparen(p.unaryExpr(ctx)))\n      }\n\n      // TODO: case token.ARROWL; `<-x`, `<-chan E`\n    }\n\n    return p.primExpr(/*keepParens*/true, ctx)\n  }\n\n\n  primExpr(keepParens :bool, ctx :exprCtx) :Expr {\n    // PrimaryExpr =\n    //   Operand |\n    //   Conversion |\n    //   PrimaryExpr Selector |\n    //   PrimaryExpr Index |\n    //   PrimaryExpr Slice |\n    //   PrimaryExpr TypeAssertion |\n    //   PrimaryExpr Arguments .\n    //\n    // Selector       = \".\" identifier .\n    // Index          = \"[\" Expression \"]\" .\n    // Slice          = \"[\" ( [ Expression ] \":\" [ Expression ] ) |\n    //                      ( [ Expression ] \":\" Expression \":\" Expression )\n    //                  \"]\" .\n    // TypeAssertion  = \".\" \"(\" Type \")\" .\n    // Arguments      = \"(\"\n    //   [ (  ExpressionList | Type [ \",\" ExpressionList ] ) [ \"...\" ] [ \",\" ]]\n    //   \")\" .\n    const p = this\n    let x = p.operand(keepParens, ctx)\n\n    // TODO: what follows an operand, if any\n\n    loop:\n    while (true) {\n      // const pos = p.pos\n      switch (p.tok) {\n        case token.LPAREN:\n          x = p.call(x, ctx)\n          break\n        default:\n          break loop\n      }\n    }\n\n    return x\n  }\n\n\n  call(fun :Expr, ctx :exprCtx) :CallExpr {\n    // Arguments = \"(\" [\n    //     ( ExpressionList | Type [ \",\" ExpressionList ] )\n    //     [ \"...\" ] [ \",\" ]\n    //   ] \")\"\n    const p = this\n\n    // call or conversion\n    // convtype '(' expr ocomma ')'\n    const pos = p.pos\n    const args = [] as Expr[]\n    let hasDots = false\n\n    p.want(token.LPAREN)\n    // p.xnest++\n\n    while (p.tok != token.EOF && p.tok != token.RPAREN) {\n      args.push(p.expr(ctx))\n      hasDots = p.got(token.ELLIPSIS)\n      if (!p.ocomma(token.RPAREN) || hasDots) {\n        break\n      }\n    }\n\n    // p.xnest--\n    p.want(token.RPAREN)\n\n    return new CallExpr(pos, p.scope, fun, args, hasDots)\n  }\n\n\n  operand(keepParens :bool, ctx :exprCtx) :Expr {\n    // Operand   = Literal | OperandName | MethodExpr | \"(\" Expression \")\" .\n    // Literal   = BasicLit | CompositeLit | FunctionLit .\n    // BasicLit  = int_lit | float_lit | imaginary_lit | rune_lit | string_lit\n    // OperandName = identifier | QualifiedIdent.\n    const p = this\n\n    switch (p.tok) {\n      case token.NAME:\n      case token.NAMEAT:\n        return p.dotident(p.resolve(p.ident()))\n\n      case token.LPAREN:\n        return p.parenOrTupleExpr(keepParens, ctx)\n\n      case token.FUN:\n        return p.funStmt(ctx)\n\n      // case _Lbrack, _Chan, _Map, _Struct, _Interface:\n      //   return p.type_() // othertype\n\n      case token.STRING:\n        return p.strlit()\n\n      default: {\n        if (token.literal_beg < p.tok && p.tok < token.literal_end) {\n          const x = new BasicLit(p.pos, p.scope, p.tok, p.takeByteValue())\n          x.type = p.universe.basicLitType(x, p.ctxType(ctx), p.basicLitErrH)\n          p.next() // consume literal\n          return x\n        }\n\n        const x = p.bad()\n        p.syntaxError(\"expecting expression\")\n        p.next()\n        return x\n      }\n    }\n  }\n\n\n  basicLitErrH = (msg :string, pos :Pos) => {\n    this.syntaxError(msg, pos)\n  }\n\n\n  strlit() :StringLit {\n    const p = this\n    assert(p.tok == token.STRING)\n    const n = new StringLit(p.pos, p.scope, p.takeByteValue())\n    n.type = new ConstStringType(u_t_uint.bitsize, n.value.length)\n    p.next()\n    return n\n  }\n\n\n  parenOrTupleExpr(keepParens :bool, ctx :exprCtx) :Expr {\n    // TupleExpr = \"(\" Expr (\",\" Expr)+ \",\"? \")\"\n    // ParenExpr = \"(\" Expr \",\"? \")\"\n    const p = this\n    const pos = p.pos\n    p.want(token.LPAREN)\n\n    const l = []\n    while (true) {\n      l.push(p.expr(ctx))\n      if (!p.ocomma(token.RPAREN)) {\n        break  // error: unexpected ;, expecting comma, or )\n      }\n      if (p.tok == token.RPAREN) {\n        break\n      }\n    }\n    p.want(token.RPAREN)\n\n    return (\n      l.length == 1 ? (\n        keepParens ? new ParenExpr(pos, p.scope, l[0]) :\n        l[0]\n      ) :\n      new TupleExpr(pos, p.scope, l)\n    )\n  }\n\n\n  bad(pos? :Pos) :BadExpr {\n    const p = this\n    return new BadExpr(pos === undefined ? p.pos : pos, p.scope)\n  }\n\n\n  // maybeType is like type but it returns null if there was no type\n  // instead of reporting an error.\n  //\n  // Type     = TypeName | TypeLit | \"(\" Type \")\" .\n  // TypeName = identifier | QualifiedIdent .\n  // TypeLit  = ArrayType | StructType | PointerType | FunctionType\n  //          | InterfaceType | SliceType | MapType | Channel_Type\n  maybeType() :Expr|null {\n    const p = this\n    let x :Expr|null = null\n\n    switch (p.tok) {\n\n      // TODO: all other types\n\n      case token.NAME:\n        x = p.dotident(p.resolve(p.ident()))\n        break\n\n      case token.LPAREN:\n        const t = p.tupleType()\n        x = (\n          t.exprs.length == 0 ? null :        // \"()\"  => null\n          t.exprs.length == 1 ? t.exprs[0] :  // \"(a)\" => \"a\"\n          t                                   // \"(a, b)\"\n        )\n        break\n\n      default:\n        return null\n    }\n\n    return x && p.types.resolve(x) || null\n  }\n\n  type() :Expr {\n    const p = this\n    let t = p.maybeType()\n    if (!t) {\n      t = p.bad()\n      p.syntaxError(\"expecting type\")\n      p.next()\n    }\n    return t\n  }\n\n  restExpr(defaultType :Type) :RestExpr {\n    // RestExpr = \"...\" Expr?\n    const p = this\n    const pos = p.pos\n    p.want(token.ELLIPSIS)\n    const rt = new RestExpr(pos, p.scope, p.maybeType() || defaultType)\n    p.types.resolve(rt)\n    return rt\n  }\n\n  tupleType() :TupleExpr {\n    // TupleType = \"(\" Type (\",\" Type)+ \",\"? \")\"\n    const p = this\n    p.want(token.LPAREN)\n    const pos = p.pos\n    const l = []\n    while (p.tok != token.RPAREN) {\n      l.push(p.type())\n      if (!p.ocomma(token.RPAREN)) {\n        // error: unexpected ;, expecting comma, or )\n        break\n      }\n    }\n    p.want(token.RPAREN)\n    return new TupleExpr(pos, p.scope, l)\n  }\n\n  // IdentifierList = identifier { \",\" identifier } .\n  // The first identifier must be provided.\n  identList(first :Ident) :Ident[] {\n    const p = this\n    const l = [first]\n    while (p.got(token.COMMA)) {\n      l.push(p.ident())\n    }\n    return l\n  }\n\n  dotident(ident :Ident) :Expr {\n    const p = this\n    if (p.tok == token.DOT) {\n      const pos = p.pos\n      p.next()\n      const rhs = p.dotident(p.ident())\n      return new SelectorExpr(pos, p.scope, ident, rhs)\n    }\n    return ident\n  }\n\n  ident() :Ident {\n    const p = this\n    const pos = p.pos\n    if (p.tok == token.NAME) {\n      const s = p.strSet.emplace(p.takeByteValue(), p.hash)\n      p.next()\n      return new Ident(pos, p.scope, s)\n    }\n    p.syntaxError(\"expecting identifier\", pos)\n    p.advanceUntil()\n    return new Ident(pos, p.scope, p._id__)\n  }\n\n  maybeIdent() :Ident|null {\n    const p = this\n    return (p.tok == token.NAME) ? p.ident() : null\n  }\n\n  fallbackIdent(pos? :Pos) :Ident {\n    const p = this\n    return new Ident(pos === undefined ? p.pos : pos, p.scope, p._id__)\n  }\n\n  // osemi parses an optional semicolon.\n  osemi(follow :token) :bool {\n    const p = this\n\n    switch (p.tok) {\n      case token.SEMICOLON:\n        p.next()\n        return true\n    \n      case token.RPAREN:\n      case token.RBRACE:\n        // semicolon is optional before ) or }\n        return true\n    }\n  \n    p.syntaxError(\"expecting semicolon, newline, or \" + tokstr(follow))\n    p.advanceUntil(follow)\n    return false\n  }\n\n  // ocomma parses an optional comma.\n  ocomma(follow :token) :bool {\n    const p = this\n\n    switch (p.tok) {\n      case token.COMMA:\n        p.next()\n        return true\n\n      case token.RPAREN:\n      case token.RBRACE:\n        // comma is optional before ) or }\n        return true\n    }\n\n    p.syntaxError(\"expecting comma, or \" + tokstr(follow))\n    p.advanceUntil(follow)\n    return false\n  }\n\n  // appendGroup(f) = f | \"(\" { f \";\" } \")\" .\n  appendGroup<D extends Decl>(list :D[], f :(g:Group|null, i:int)=>D) {\n    const p = this\n    let i = 0\n    if (p.got(token.LPAREN)) {\n      const g = new Group()\n      while (p.tok != token.EOF && p.tok != token.RPAREN) {\n        list.push(f(g, i++))\n        if (!p.osemi(token.RPAREN)) {\n          break\n        }\n      }\n      p.want(token.RPAREN)\n    } else {\n      list.push(f(null, i))\n    }\n  }\n\n  // advanceUntil consumes tokens until it finds a token of the followlist.\n  // The stopset is only considered if we are inside a function (p.fnest > 0).\n  // The followlist is the list of valid tokens that can follow a production;\n  // if it is empty, exactly one token is consumed to ensure progress.\n  //\n  // Not speed critical, advance is only called in error situations.\n  //\n  advanceUntil(...followlist :token[]) {\n    const p = this\n\n    if (followlist.length == 0) {\n      p.next()\n      return\n    }\n\n    // TODO: improve performance of this, especially followlist.includes\n\n    if (p.fnest > 0) {\n      // The stopset contains keywords that start a statement.\n      // They are good synchronization points in case of syntax\n      // errors and (usually) shouldn't be skipped over.\n      loop1:\n      while (!followlist.includes(p.tok)) {\n        switch (p.tok) {\n          case token.EOF:\n          case token.BREAK:\n          // case token.CONST:\n          case token.CONTINUE:\n          case token.DEFER:\n          case token.FALLTHROUGH:\n          case token.FOR:\n          case token.FUN:\n          case token.GO:\n          // case token.GOTO:\n          case token.IF:\n          case token.RETURN:\n          case token.SELECT:\n          case token.SWITCH:\n          case token.TYPE:\n            break loop1\n        }\n        p.next()\n      }\n    } else {\n      while (!(p.tok == token.EOF || followlist.includes(p.tok))) {\n        p.next()\n      }\n    }\n  }\n\n  // syntax_error reports a syntax error at the current line.\n  syntaxError(msg :string, pos :Pos = this.pos) {\n    const p = this\n    const position = p.sfile.position(pos)\n\n    // if (p.tok == token.EOF) {\n    //   return // avoid meaningless follow-up errors\n    // }\n\n    // add punctuation etc. as needed to msg\n    if (msg == \"\") {\n      // nothing to do\n    } else if (\n      msg.startsWith(\"in \") ||\n      msg.startsWith(\"at \") ||\n      msg.startsWith(\"after \"))\n    {\n      msg = \" \" + msg\n    } else if (msg.startsWith(\"expecting \")) {\n      msg = \", \" + msg\n    } else {\n      // plain error - we don't care about current token\n      p.errorAt(msg, position)\n      return\n    }\n\n    p.errorAt(\"unexpected \" + tokstr(p.tok) + msg, position)\n  }\n\n  // diag reports a diagnostic message, or an error if k is ERROR\n  //\n  diag(k :DiagKind, msg :string, pos :Pos = this.pos, code? :ErrorCode) {\n    const p = this\n    // if (code !== undefined) {\n    //   // level overridden?\n    //   k = p.diagConfig[code] || k\n    // }\n    if (k == DiagKind.ERROR) {\n      p.error(msg, pos, code)\n    } else if (p.diagh) {\n      p.diagh(p.sfile.position(pos), msg, k)\n    }\n  }\n\n}\n\n// unparen removes all parentheses around an expression.\nfunction unparen(x :Expr) :Expr {\n  while (x instanceof ParenExpr) {\n    x = x.x\n  }\n  return x\n}\n\nfunction isEmptyFunDecl(d :Decl) :bool {\n  return d instanceof FunDecl && !d.body\n}\n","// import { token } from './token'\nimport { SrcFileSet, Pos } from './pos'\nimport { ErrorCode, ErrorHandler, ErrorReporter } from './error'\nimport * as utf8 from './utf8'\nimport { debuglog } from './util'\nimport { TypeResolver } from './resolve'\nimport { File, Package, Ent, ImportDecl, UnresolvedType } from './ast'\n\n\n// An Importer resolves import paths to package entities.\n// The imports map records the packages already imported,\n// indexed by package id (canonical import path).\n// An Importer must determine the canonical import path and\n// check the map to see if it is already present in the imports map.\n// If so, the Importer can return the map entry. Otherwise, the\n// Importer should load the package data for the given path into\n// a new Ent (pkg), record pkg in the imports map, and then\n// return pkg.\n//\nexport type Importer =\n  (imports :Map<string,Ent>, path :string) => Promise<Ent>\n\n\n// pkgBinder resolves a ast.Package and its ast.File s\n//\nclass pkgBinder extends ErrorReporter {\n  errorCount = 0\n  // package-global mapping of imported package ids to package entities\n  imports = new Map<string,Ent>()\n\n  constructor(\n    public pkg      :Package,\n    public fset     :SrcFileSet,\n    public importer :Importer|null,\n    public types    :TypeResolver,\n    errh            :ErrorHandler|null,\n  ) {\n    super('E_RESOLVE', errh)\n  }\n\n  bind() :Promise<void> {\n    const b = this\n    //\n    // binding happens in three steps:\n    //\n    // 1. imports are resolved\n    // 2. identifiers are resolved in all files (and across the package)\n    // 3. types are resolved across the package\n    //\n\n    // step 1: complete file scopes with imports\n    return Promise.all(\n      b.pkg.files.map(f => this._bind1(f))\n    ).then(() => {\n      if (b.errorCount > 0) {\n        return  // stop when imports failed\n      }\n\n      // step 2: resolve identifiers\n      for (let f of b.pkg.files) {\n        b._bind2(f)\n      }\n\n      // step 3: resolve types\n      b._bind3()\n    })\n  }\n\n  _bind1(f :File) :Promise<void> {\n    // step 1: complete file scopes with imports\n    const b = this\n\n    if (!f.imports || f.imports.length == 0) {\n      return Promise.resolve()\n    }\n\n    const pv :Promise<void>[] = []\n\n    for (let decl of f.imports) {\n      if (!b.importer) {\n        b.error(`unresolvable import ${decl.path}`, decl.path.pos)\n        break\n      }\n      const path = utf8.decodeToString(decl.path.value)\n      pv.push(b.importer(b.imports, path)\n        .then((pkg :Ent) => { b.integrateImport(f, decl, pkg) })\n        .catch(err => {\n          b.error(\n            `could not import ${path} (${err.message || err})`,\n            decl.path.pos\n          )\n        })\n      )\n    }\n    return Promise.all(pv).then(() => {})\n  }\n\n  integrateImport(f :File, imp :ImportDecl, pkg :Ent) {\n    // local name overrides imported package name\n    let name = imp.localIdent ? imp.localIdent.value : pkg.name\n\n    if (name.toString() == \".\") { // TODO: fix efficiency\n      // TODO: merge imported scope with file scope\n      // for _, obj := range pkg.Data.(*Scope).Objects {\n      //   p.declare(fileScope, pkgScope, obj)\n      // }\n    } else if (name.toString() != \"_\") { // TODO: fix efficiency\n      // declare imported package entities in file scope\n      // (do not re-use pkg in the file scope but create\n      // a new ent instead; the Decl field is different\n      // for different files)\n      f.scope.declareEnt(new Ent(name, imp, null, pkg.data))\n    }\n  }\n\n  _bind2(f :File) {\n    // step 2: resolve identifiers\n    const b = this\n\n    if (f.unresolved) for (let id of f.unresolved) {\n      // see if the name was declared after it was referenced in the file, or\n      // declared in another file in the same package\n      let ent = f.scope.lookup(id.value)\n\n      if (!ent) { // truly undefined\n        b.error(`${id} undefined`, id.pos)\n        continue\n      }\n\n      debuglog(`${id}`, ent.value && ent.value.constructor.name)\n\n      id.refEnt(ent) // reference ent\n\n      let t = id.type\n      if (t instanceof UnresolvedType && ent.value) {\n        id.type = b.types.resolve(ent.value)\n        assert(!(id.type instanceof UnresolvedType), 'TODO still unresolved')\n        \n        // delegate type to any expressions that reference this type\n        if (t.refs) for (let ref of t.refs) {\n          ref.type = id.type\n        }\n      }\n    }\n  }\n\n  _bind3() {\n    // step 3: resolve types\n    const b = this\n\n    for (let ut of b.types.unresolved) {\n      const t = ut.expr.type\n\n      if (!(t instanceof UnresolvedType)) {\n        // was probably resolved during step 2\n        continue\n      }\n  \n      // attempt to resolve the type now that we can see the entire package\n      const restyp = b.types.resolve(ut.expr)\n      if (restyp instanceof UnresolvedType) {\n        b.error(`undefined type ${ut.expr}`, ut.expr.pos)\n      } else {\n        // succeeded in resolving the type.\n        // delegate type to any expressions that reference this type.\n        if (t.refs) for (let ref of t.refs) {\n          console.log(`ref[1] ${ref}`) // TODO: test this scenario\n          ref.type = restyp\n        }\n      }\n    }\n  }\n\n  error(msg :string, pos :Pos, c? :ErrorCode) {\n    const b = this\n    b.errorAt(msg, b.fset.position(pos), c)\n  }\n}\n\n\n// bindpkg resolves any undefined names (usually across source files) and,\n// unless there are errors, all identifiers in the package will have Ident.ent\n// set, pointing to whatever entity a name references.\n//\n// Returns false if there were errors\n//\nexport function bindpkg(\n  pkg      :Package,\n  fset     :SrcFileSet,\n  importer :Importer|null,\n  typeres  :TypeResolver,\n  errh     :ErrorHandler,\n) :Promise<bool> {\n  const b = new pkgBinder(pkg, fset, importer, typeres, errh)\n  return b.bind().then(() => b.errorCount != 0)\n}\n","import * as util from './util'\n\n// Pos is a compact encoding of a source position within a file set.\n// It can be converted into a Position for a more convenient, but much\n// larger, representation.\n//\n// The Pos value for a given file is a number in the range [base, base+size],\n// where base and size are specified when adding the file to the file set via\n// addFile.\n//\n// To create the Pos value for a specific source offset (measured in bytes),\n// first add the respective file to the current file set using\n// SrcFileSet.addFile and then call File.Pos(offset) for that file.\n// Given a Pos value p for a specific file set fset, the corresponding Position\n// value is obtained by calling fset.Position(p).\n//\n// Pos values can be compared directly with the usual comparison operators:\n// If two Pos values p and q are in the same file, comparing p and q is\n// equivalent to comparing the respective source file offsets. If p and q\n// are in different files, p < q is true if the file implied by p was added\n// to the respective file set before the file implied by q.\n//\nexport type Pos = int\n\n// The zero value for Pos is NoPos; there is no file and line information\n// associated with it, and NoPos().IsValid() is false. NoPos is always\n// smaller than any other Pos value. The corresponding Position value\n// for NoPos is the zero value for Position.\n//\nexport const NoPos :Pos = 0\n\n// IsValid reports whether the position is valid.\nexport function PosIsValid(p :Pos) :bool {\n  return p != NoPos\n}\n\n// Position describes an arbitrary source position\n// including the file, line, and column location.\n// A Position is valid if the line number is > 0.\nexport class Position { constructor(\n  public readonly filename :string = '', // filename, if any\n  public readonly offset   :int = 0,    // offset, starting at 0\n  public readonly line     :int = 0,    // line number, starting at 1\n  public readonly column   :int = 0,    // column number, starting at 1 (byte count)\n  ) {}\n\n  // IsValid reports whether the position is valid.\n  isValid() :bool {\n    return this.line > 0\n  }\n\n  // toString returns a string in one of several forms:\n  //\n  //  file:line:column    valid position with file name\n  //  line:column         valid position without file name\n  //  file                invalid position with file name\n  //  -                   invalid position without file name\n  //\n  toString() :string {\n    let p = this\n    let s = p.filename\n    if (p.isValid()) {\n      if (s) {\n        s += \":\"\n      }\n      s += `${p.line}:${p.column}`\n    }\n    return s || \"-\"\n  }\n}\n\nconst invalidPosition = new Position()\n\n// -----------------------------------------------------------------\n\n// A lineInfo object describes alternative file and line number\n// information (such as provided via a //line comment in a .go\n// file) for a given file offset.\ninterface lineInfo {\n  offset   :int\n  filename :string\n  line     :int\n}\n\n// A SrcFile is a handle for a file belonging to a FileSet.\n// A SrcFile has a name, size, and line offset table.\nexport class SrcFile {\n  private infos :lineInfo[] = []\n\n  constructor(\n  public name  :string,  // file name as provided to addFile\n  public base  :int,     // Pos value range for this file is [base...base+size]\n  public size  :int,     // file size as provided to addFile\n  public lines :int[],\n  ) {}\n\n  // Number of lines in file\n  get lineCount() :int {\n    return this.lines.length\n  }\n\n  // addLine adds the line offset for a new line.\n  // The line offset must be larger than the offset for the previous line\n  // and smaller than the file size; otherwise the line offset is ignored.\n  //\n  addLine(offset :int) {\n    const f = this\n    const i = f.lines.length\n    if ((i === 0 || f.lines[i-1] < offset) && offset < f.size) {\n      f.lines.push(offset)\n    }\n  }\n\n  // AddLineInfo adds alternative file and line number information for\n  // a given file offset. The offset must be larger than the offset for\n  // the previously added alternative line info and smaller than the\n  // file size; otherwise the information is ignored.\n  //\n  // AddLineInfo is typically used to register alternative position\n  // information for //line filename:line comments in source files.\n  //\n  addLineInfo(offset :int, filename :string, line :int) {\n    const f = this\n    const i = f.infos.length\n    if (i == 0 || f.infos[i-1].offset < offset && offset < f.size) {\n      f.infos.push({offset, filename, line})\n    }\n  }\n\n  // Pos returns the Pos value for the given file offset;\n  // the offset must be <= f.size.\n  // f.pos(f.offset(p)) == p.\n  //\n  pos(offset :int) :Pos {\n    const f = this\n    if (offset > f.size) {\n      panic(\"illegal file offset\")\n    }\n    return f.base + offset\n  }\n\n  // Offset returns the offset for the given file position p;\n  // p must be a valid Pos value in that file.\n  // f.offset(f.pos(offset)) == offset.\n  //\n  offset(p :Pos) :int {\n    const f = this\n    if (p < f.base || p > f.base + f.size) {\n      panic(\"illegal Pos value\")\n    }\n    return p - f.base\n  }\n\n  // position returns the Position value for the given file position p.\n  // If adjusted is set, the position may be adjusted by position-altering\n  // //!line comments; otherwise those comments are ignored.\n  // p must be a Pos value in f or NoPos.\n  //\n  position(p :Pos, adjusted :bool = true) :Position {\n    const f = this\n    if (p == NoPos) {\n      return invalidPosition\n    }\n    if (p < f.base || p > f.base + f.size) {\n      panic(\"illegal Pos value\")\n    }\n    return f._position(p, adjusted)\n  }\n\n  // If adjusted is set, will return the filename and line information possibly\n  // adjusted by //line comments; otherwise those comments are ignored.\n  //\n  private _position(p :Pos, adjusted :bool) :Position {\n    const f = this\n    const offset = p - f.base\n\n    let filename = f.name\n    let line = 0, column = 0\n    \n    let i = searchInts(f.lines, offset)\n\n    if (i >= 0) {\n      line = i + 1\n      column = offset - f.lines[i] + 1\n    }\n\n    if (adjusted && f.infos.length > 0) {\n      // file has extra line infos\n      let i = searchLineInfos(f.infos, offset)\n      if (i >= 0) {\n        const alt = f.infos[i]\n        filename = alt.filename\n        i = searchInts(f.lines, alt.offset)\n        if (i >= 0) {\n          line += alt.line - i - 1\n        }\n      }\n    }\n\n    return new Position(filename, offset, line, column)\n  }\n\n}\n\nfunction searchLineInfos(a :lineInfo[], x :int) :int {\n  return util.search(a.length, (i :int) => a[i].offset > x) - 1\n}\n\n// -----------------------------------------------------------------\n\n// A SrcFileSet represents a set of source files\nexport class SrcFileSet { constructor(\n  public base:  int = 1,      // base offset for the next file. 0 == NoPos\n    // Base is the minimum base offset that must be provided to\n    // addFile when adding the next file.\n\n  public files: SrcFile[] = [],  // list of files in the order added to the set\n  public last:  SrcFile|null = null,  // cache of last file looked up\n  ) {}\n\n  // addFile adds a new file with a given filename, base offset, and file size\n  // to the file set s and returns the file. Multiple files may have the same\n  // name. The base offset must not be smaller than the SrcFileSet's Base(), and\n  // size must not be negative. As a special case, if a negative base is\n  // provided, the current value of the SrcFileSet's base() is used instead.\n  //\n  // Adding the file will set the file set's Base() value to base + size + 1\n  // as the minimum base value for the next file. The following relationship\n  // exists between a Pos value p for a given file offset offs:\n  //\n  //  int(p) = base + offs\n  //\n  // with offs in the range [0, size] and thus p in the range [base, base+size].\n  // For convenience, SrcFile.pos may be used to create file-specific position\n  // values from a file offset.\n  //\n  addFile(filename :string, size :int, base :int = -1) :SrcFile {\n    const s = this\n    if (base < 0) {\n      base = s.base\n    }\n    if (base < s.base || size < 0) {\n      panic(\"illegal base or size\")\n    }\n    // base >= s.base && size >= 0\n    const f = new SrcFile(filename, base, size, [0])\n    base += size + 1 // +1 because EOF also has a position\n    if (base < 0) {\n      panic(\"Pos offset overflow (too much source code in file set)\")\n    }\n    // add the file to the file set\n    s.base = base\n    s.files.push(f)\n    s.last = f\n    return f\n  }\n\n  // findFile returns the file that contains the position p.\n  // If no such file is found (for instance for p == NoPos),\n  // the result is null.\n  //\n  findFile(p :Pos) :SrcFile|null {\n    if (p == NoPos) {\n      return null\n    }\n    const s = this\n    // common case: p is in last file\n    let f = s.last\n    if (f && f.base <= p && p <= f.base + f.size) {\n      return f\n    }\n    // p is not in last file - search all files\n    let i = searchFiles(s.files, p)\n    if (i >= 0) {\n      f = s.files[i]\n      // f.base <= p  by definition of searchFiles\n      if (p <= f.base + f.size) {\n        s.last = f\n        return f\n      }\n    }\n    return null\n  }\n\n  // position converts a Pos p in the fileset into a Position value.\n  // If adjusted is set, the position may be adjusted by position-altering\n  // //line comments; otherwise those comments are ignored.\n  // p must be a Pos value in s or NoPos.\n  //\n  position(p :Pos, adjusted :bool = true) :Position {\n    const f = this.findFile(p)\n    return f ? f.position(p, adjusted) : invalidPosition\n  }\n}\n\n\nfunction searchFiles(a :SrcFile[], x :int) :int {\n  return util.search(a.length, (i :int) => a[i].base > x ) - 1\n}\n\n\nfunction searchInts(a :ArrayLike<int>, x :int) :int {\n  // Inlined version of\n  //  return util.search(a.length, i => a[i] > x) - 1\n  //\n  let i = 0, j = a.length\n  while (i < j) {\n    const h = i + (((j-i)/2) >> 0) // avoid overflow when computing h\n    // i â‰¤ h < j\n    if (a[h] <= x) {\n      i = h + 1\n    } else {\n      j = h\n    }\n  }\n  return i - 1\n}\n","import { bufcmp } from './util'\nimport * as utf8 from './utf8'\n//\n// Interned byte strings\n//\n\nlet _nextId = 0\n\nexport class ByteStr {\n  readonly _id :int = _nextId++ // only for debugging\n  constructor(\n  readonly hash  :int,\n  readonly bytes :Uint8Array,\n  ){}\n\n  toString() :string {\n    return utf8.decodeToString(this.bytes)\n  }\n\n  equals(other :ByteStr) :bool {\n    return (\n      this.hash == other.hash &&\n      this.bytes.length == other.bytes.length &&\n      bufcmp(this.bytes, other.bytes) == 0\n    )\n  }\n}\n\nexport class ByteStrSet {\n  _m = new Map<int,ByteStr[]>() // naive implementation\n  // TODO: use a rb-tree or something like that\n\n  emplace(value :Uint8Array, hash :int = 0) :ByteStr {\n    if (!hash) {\n      hash = hashBytes(value, 0, value.length)\n    }\n    let v = this._m.get(hash)\n    if (v) {\n      for (let bs of v) {\n        if (bs.bytes.length == value.length && bufcmp(bs.bytes, value) == 0) {\n          return bs\n        }\n      }\n      const bs = new ByteStr(hash, value)\n      v.push(bs)\n      return bs\n    } else {\n      const bs = new ByteStr(hash, value)\n      this._m.set(hash, [bs])\n      return bs\n    }\n  }\n}\n\n// hashBytes returns an unsigned 31 bit integer hash of an array of bytes.\n// It's using the FNV1a algorithm which is very fast and has good distribution\n// for common short names (based on tests on a large corpus of go source code.)\n//\nexport function hashBytes(buf :ArrayLike<byte>, offs :int, length :int) {\n  // This function must exactly match what's in scanner.\n  var h = 0x811c9dc5, i = offs, e = offs + length\n  while (i < e) {\n    h = (h ^ buf[i++]) * 0x1000193\n  }\n  return h >>> 0\n}\n","import { Type } from './ast'\n\n// TypeSet provides interning of types based on equality on a per-constructor\n// basis.\n//\nexport class TypeSet {\n  types = new Map<Object,Set<Type>>() // type constructor => type instance\n\n  intern(t :Type) :Type {\n    let s = this.types.get(t.constructor)\n    if (s) {\n      for (let i of s) {\n        if (i.equals(t)) {\n          return i\n        }\n      }\n      s.add(t)\n    } else {\n      this.types.set(t.constructor, new Set<Type>([t]))\n    }\n    return t\n  }\n}\n","// provides styling via shell color codes\n//\n// A Style object provides a number of functions named after their effect,\n// like \"boldRed\". A style function takes a single argument which is interpreted\n// as a string, and returns a string with the appropriate style codes\n// surrounding the string argument.\n//\n// Additionally, each such function has two properties: open and close, each\n// which are strings containing the starting (or ending) code(s) for the\n// appropriate style.\n//\n// Examples:\n//\n//   style.boldRed(\"hello\")    // => \"\\x1b[1;31mhello\\x1b[0;39m\"\n//   stdoutStyle.cyan(\"hello\") // => \"\\x1b[36mhello\\x1b[39m\"\n//\n\n// progressively support nodejs\ninterface has_isTTY { isTTY? :bool }\ndeclare var process :undefined | {\n  env :{[k:string]:string},\n  stdout: has_isTTY,\n  stderr: has_isTTY,\n}\nconst TERM = typeof process != 'undefined' && process.env.TERM || ''\n\nexport type StyleFun = (s: string) => string\n\nfunction sfn(open :string, close :string) :StyleFun {\n  open = '\\x1b[' + open + 'm'\n  close = '\\x1b[' + close + 'm'\n  return (s :string) => open + s + close\n}\n\n// number of colors that the terminal probably supports\nexport const termColorSupport :number = (\n  TERM && ['xterm','screen','vt100'].some(s => TERM.indexOf(s) != -1) ? (\n    TERM.indexOf('256color') != -1 ? 256 :\n    16\n  ) : 0\n)\n\nconst passThrough = ((s :string) => s) as StyleFun\n\nexport interface Style {\n  'clear'         :string\n\n  'bold'          :StyleFun\n  'italic'        :StyleFun\n  'underline'     :StyleFun\n  'inverse'       :StyleFun\n\n  'white'         :StyleFun\n  'grey'          :StyleFun\n  'black'         :StyleFun\n\n  'blue'          :StyleFun\n  'cyan'          :StyleFun\n  'green'         :StyleFun\n  'magenta'       :StyleFun\n  'purple'        :StyleFun\n  'pink'          :StyleFun\n  'red'           :StyleFun\n  'yellow'        :StyleFun\n  'lightyellow'   :StyleFun\n  'orange'        :StyleFun\n}\n\nexport const noStyle :Style = {\n  // no colors\n  'clear'         : \"\",\n\n  'bold'          : passThrough,\n  'italic'        : passThrough,\n  'underline'     : passThrough,\n  'inverse'       : passThrough,\n\n  'white'         : passThrough,\n  'grey'          : passThrough,\n  'black'         : passThrough,\n  'blue'          : passThrough,\n  'cyan'          : passThrough,\n  'green'         : passThrough,\n  'magenta'       : passThrough,\n  'purple'        : passThrough,\n  'pink'          : passThrough,\n  'red'           : passThrough,\n  'yellow'        : passThrough,\n  'lightyellow'   : passThrough,\n  'orange'        : passThrough,\n}\n\nexport const style :Style = (\n  termColorSupport == 0 ? noStyle :\n  termColorSupport < 256 ? {\n    // 16 colors\n    'clear'         : \"\\e[0m\",\n\n    'bold'          : sfn('1', '22'),\n    'italic'        : sfn('3', '23'),\n    'underline'     : sfn('4', '24'),\n    'inverse'       : sfn('7', '27'),\n\n    'white'         : sfn('37', '39'),\n    'grey'          : sfn('90', '39'),\n    'black'         : sfn('30', '39'),\n    'blue'          : sfn('34', '39'),\n    'cyan'          : sfn('36', '39'),\n    'green'         : sfn('32', '39'),\n    'magenta'       : sfn('35', '39'),\n    'purple'        : sfn('35', '39'),\n    'pink'          : sfn('35', '39'),\n    'red'           : sfn('31', '39'),\n    'yellow'        : sfn('33', '39'),\n    'lightyellow'   : sfn('93', '39'),\n    'orange'        : sfn('33', '39'),\n  } : {\n    // 256 colors\n    'clear'         : \"\\e[0m\",\n\n    'bold'          : sfn('1', '22'),\n    'italic'        : sfn('3', '23'),\n    'underline'     : sfn('4', '24'),\n    'inverse'       : sfn('7', '27'),\n\n    'white'         : sfn('38;5;255', '39'),\n    'grey'          : sfn('38;5;244', '39'),\n    'black'         : sfn('38;5;16',  '39'),\n    'blue'          : sfn('38;5;75',  '39'), // '38;2;120;160;255'\n    'cyan'          : sfn('38;5;87',  '39'),\n    'green'         : sfn('38;5;84',  '39'),\n    'magenta'       : sfn('38;5;213', '39'),\n    'purple'        : sfn('38;5;141', '39'),\n    'pink'          : sfn('38;5;211', '39'),\n    'red'           : sfn('38;2;255;110;80', '39'),\n    'yellow'        : sfn('38;5;227', '39'),\n    'lightyellow'   : sfn('38;5;229', '39'),\n    'orange'        : sfn('38;5;215', '39'),\n  }\n)\n\n// demo\n// for (let k in style) {\n//   if (k != 'clear') {\n//     console.log((style as any)[k](k))\n//   }\n// }\n// for (let mod of ['bold','italic','underline','inverse']) {\n//   for (let col of [\n//     'white','grey','black','blue','cyan','green','magenta','red','yellow'\n//   ]) {\n//     console.log(\n//       (style as any)[col](\n//         (style as any)[mod](mod + ' ' + col)\n//       )\n//     )\n//   }\n// }\n// ;(process as any).exit(0)\n\n\n// streamStyle returns the most appropriate Style object for `w`\nexport function streamStyle(w :has_isTTY) {\n  return termColorSupport && w.isTTY && style || noStyle\n}\n\nexport const stdoutStyle = (\n  typeof process != 'undefined' && streamStyle(process.stdout) || noStyle\n)\n\nexport const stderrStyle = (\n  typeof process != 'undefined' && streamStyle(process.stderr) || noStyle\n)\n\nexport const stdoutSupportsStyle = stdoutStyle !== noStyle\nexport const stderrSupportsStyle = stderrStyle !== noStyle\n","//\n// Produces a human-readable format of an AST, meant for debugging.\n//\nimport * as utf8 from './utf8'\nimport { tokstr, token } from './token'\nimport { termColorSupport, style, noStyle } from './termstyle'\nimport {\n  Node,\n  Group,\n  Ident,\n  RestExpr,\n  Field,\n  BasicLit,\n  StringLit,\n  ImportDecl,\n  // ConstDecl,\n  VarDecl,\n  TypeDecl,\n  FunDecl,\n  FunSig,\n  SimpleStmt,\n  BlockStmt,\n  ReturnStmt,\n  ExprStmt,\n  AssignStmt,\n  DeclStmt,\n  Operation,\n  Expr,\n  CallExpr,\n  ParenExpr,\n  TupleExpr,\n  BadExpr,\n  SelectorExpr,\n  TypeConvExpr,\n  Type,\n  UnresolvedType,\n  RestType,\n  IntrinsicType,\n  ConstStringType,\n  TupleType,\n  FunType,\n} from './ast'\n\n\nclass ReprCtx {\n  // This is a hack for creating printable group identifiers\n  groupIds = new Map<Group,int>()\n  nextGroupId = 0\n  ind :string = '  '\n  typedepth = 0\n  style = termColorSupport ? style : noStyle\n\n  groupId(g :Group) :string {\n    let gid = (g as any).id || this.groupIds.get(g)\n    if (gid === undefined) {\n      gid = this.nextGroupId++\n      this.groupIds.set(g, gid)\n    }\n    return gid.toString(36)\n  }\n}\n\n\nexport interface ReprOptions {\n  colors?: bool\n}\n\n\nexport function astRepr(n :Node, options? :ReprOptions) :string {\n  let ctx = defaultCtx\n  if (options) {\n    ctx = new ReprCtx()\n    if (options.colors !== undefined) {\n      ctx.style = options.colors ? style : noStyle\n    }\n  }\n  return repr1(n, '\\n', ctx).trim()\n}\n\n\nconst defaultCtx = new ReprCtx()\n\n\nfunction _reprt(t :Type, nl :string, c :ReprCtx) :string {\n  if (t instanceof ConstStringType) {\n    return `${t.name}[${t.length}]`\n  }\n  if (t instanceof IntrinsicType) {\n    return c.style.bold(t.name)\n  }\n  if (t instanceof TupleType) {\n    return '(' + t.types.map(t => _reprt(t, nl, c)).join(', ') + ')'\n  }\n  if (t instanceof RestType) {\n    return '...' + _reprt(t.type, nl, c)\n  }\n  if (t instanceof FunType) {\n    return (\n      '(' + t.inputs.map(it => _reprt(it, nl, c)).join(', ') + ')' +\n      '->' + _reprt(t.output, nl, c)\n    )\n  }\n  if (t instanceof UnresolvedType) {\n    return '~'\n  }\n  return `???${t.constructor.name}`\n}\n\n\nfunction reprt0(tx :Expr|null, nl :string, c :ReprCtx) :string {\n  if (!tx) {\n    return '?'\n  }\n\n  let t :Type|null = (\n    tx instanceof Type ? tx :\n    tx.type && tx.type !== tx && tx.type instanceof Type ? tx.type :\n    null\n  )\n\n  if (t) {\n    c.typedepth++\n    const v = _reprt(t, nl, c)\n    c.typedepth--\n    return v\n  }\n\n  // unresolved\n  return '~' + repr1(tx, nl, c)\n}\n\nfunction reprt(tx :Expr|null, newline :string, c :ReprCtx) :string {\n  return c.style.blue(`<${reprt0(tx, newline, c)}>`)\n}\n\n\nfunction reprv(nv :Node[], newline :string, c :ReprCtx, delims :string='()') :string {\n  return (\n    (delims[0] || '') +\n    nv.map(n => repr1(n, newline, c)).join(' ') +\n    (delims[1] || '')\n  )\n}\n\n\nfunction reprid(id :Ident, c :ReprCtx) :string {\n  // return c.style.yellow(utf8.decodeToString(id.value.bytes))\n  return utf8.decodeToString(id.value.bytes)\n}\n\n\nfunction reprcons(n :Node, c :ReprCtx) :string {\n  return c.style.grey(n.constructor.name)\n  // return n.constructor.name\n}\n\n\nfunction repr1(n :Node, newline :string, c :ReprCtx) :string {\n  if (n instanceof IntrinsicType) {\n    return c.style.purple(c.style.bold(n.name))\n  }\n\n  if (n instanceof BasicLit || n instanceof StringLit) {\n    let s = JSON.stringify(utf8.decodeToString(n.value))\n    if (!(n instanceof StringLit)) {\n      // trim \"\n      s = s.substr(1, s.length-2)\n    }\n    return reprt(n.type, newline, c) + c.style.green(s)\n  }\n\n  if (n instanceof Ident) {\n    return (c.typedepth ? '' : reprt(n.type, newline, c)) + reprid(n, c)\n  }\n\n  if (n instanceof RestExpr) {\n    return '...' + repr1(n.expr, newline, c)\n  }\n\n  if (n instanceof BadExpr) {\n    return 'BAD'\n  }\n\n  const nl2 = newline + c.ind\n\n  if (n instanceof Field) {\n    let s = repr1(n.type, nl2, c)\n    if (n.ident) {\n      s = '(' + repr1(n.ident, nl2, c) + ' ' + s + ')'\n    }\n    return s\n  }\n\n  if (n instanceof BlockStmt) {\n    return (\n      n.list.length ?\n        newline + '{' + reprv(n.list, nl2, c, '') + newline + '}' :\n        '{}'\n    )\n  }\n\n  if (n instanceof ReturnStmt) {\n    if (n.result) {\n      return newline + `(${reprcons(n, c)} ${repr1(n.result, nl2, c)})`\n    }\n    return newline + reprcons(n, c)\n  }\n\n  if (n instanceof ExprStmt) {\n    return newline + `(${reprcons(n, c)} ${repr1(n.expr, nl2, c)})`\n  }\n\n  if (n instanceof FunSig) {\n    return reprv(n.params, nl2, c) + ' -> ' + reprt(n.result, nl2, c)\n  }\n\n  if (n instanceof AssignStmt) {\n    let s = newline + `(${reprcons(n, c)} `\n    s += reprv(n.lhs, nl2, c)\n    if (n.op == token.ILLEGAL) {\n      s += ' = '\n    } else {\n      s += ' ' + tokstr(n.op) + ' '\n    }\n    s += reprv(n.rhs, nl2, c)\n    return s + ')'\n  }\n\n  if (n instanceof DeclStmt) {\n    return newline + `(${reprcons(n, c)}` + ' ' + reprv(n.decls, nl2, c, '') + ')'\n  }\n\n  // if (n instanceof UnresolvedType) {\n  //   return '<~>'\n  // }\n\n  if (n instanceof SelectorExpr) {\n    return (\n      '(SEL ' +\n      repr1(n.lhs, newline, c) + '.' +\n      repr1(n.rhs, newline, c) + ')'\n    )\n  }\n\n\n  // --------\n\n\n  let s = '('\n  if (n instanceof Expr && !c.typedepth) {\n    s += reprt(n.type, newline, c)\n  }\n  s += reprcons(n, c)\n\n  if (n instanceof ImportDecl) {\n    s += ' path: ' + repr1(n.path, nl2, c)\n    if (n.localIdent) {\n      s += newline +\n        c.ind + 'localIdent: ' + repr1(n.localIdent, nl2, c)\n    }\n    return s + ' )'\n  }\n\n  if (n instanceof VarDecl) {\n    if (n.group) {\n      s += ' [#' + c.groupId(n.group) + ']'\n    }\n    if (n.type) {\n      s += reprt(n.type, newline, c) + ' ' + reprv(n.idents, nl2, c)\n    } else {\n      s += ' (' + n.idents.map(id =>\n        reprt(id, newline, c) + reprid(id, c)\n      ).join(' ') + ')'\n    }\n    if (n.values) {\n      s += ' ' + reprv(n.values, nl2, c)\n    }\n    return s + ' )'\n  }\n\n  if (n instanceof TypeDecl) {\n    if (n.group) {\n      s += ' [#' + c.groupId(n.group) + ']'\n    }\n    s += ' ' + repr1(n.ident, nl2, c)\n    if (n.alias) {\n      s += ' ='\n    }\n    return s + ' ' + repr1(n.type, nl2, c) + ')'\n  }\n\n  if (n instanceof Operation) {\n    s += ' ' + tokstr(n.op) + ' ' + repr1(n.x, nl2, c)\n    if (n.y) {\n      s += ' ' + repr1(n.y, nl2, c)\n    }\n    return s + ')'\n  }\n\n  if (n instanceof CallExpr) {\n    s += ' ' + repr1(n.fun, newline, c) + ' ('\n    s += reprv(n.args, nl2, c, '')\n    if (n.hasDots) {\n      s += '...'\n    }\n    return s + '))'\n  }\n\n  if (n instanceof ParenExpr) {\n    return s + ' ' + repr1(n.x, newline, c) + ')'\n  }\n\n  if (n instanceof TypeConvExpr) {\n    return s + ' ' + repr1(n.expr, newline, c) + ')'\n  }\n\n  if (n instanceof FunDecl) {\n    s += ' '\n    if (n.isInit) {\n      s += 'init '\n    } else if (n.name) {\n      s += repr1(n.name, newline, c) + ' '\n    }\n    s += repr1(n.sig, newline, c)\n    if (n.body) {\n      s += ' ' + repr1(n.body, nl2, c)\n    }\n    return s + ')'\n  }\n\n  if (n instanceof TupleExpr) {\n    return s + ' ' + reprv(n.exprs, nl2, c, '') + ')'\n  }\n\n  if (n.constructor === SimpleStmt) {\n    return 'noop'\n  }\n\n  return '(???'+ reprcons(n, c) + ' ' + repr(n) + ')'\n}\n","import { SrcFileSet, Pos, NoPos } from './pos'\nimport { u_t_auto, TypeCompat, basicTypeCompat, Universe } from './universe'\nimport { ErrorCode, ErrorReporter, ErrorHandler } from './error'\nimport { debuglog } from './util'\nimport {\n  Ident,\n  RestExpr,\n  FunDecl,\n  Expr,\n  LiteralExpr,\n  TupleExpr,\n  SelectorExpr,\n  TypeConvExpr,\n  CallExpr,\n  Type,\n  IntrinsicType,\n  UnresolvedType,\n  RestType,\n  TupleType,\n  FunType,\n} from './ast'\n\n\nexport class TypeResolver extends ErrorReporter {\n  fset       :SrcFileSet\n  universe   :Universe\n  unresolved :Set<UnresolvedType>\n\n  constructor() {\n    super('E_RESOLVE')\n  }\n\n  init(fset :SrcFileSet, universe :Universe, errh :ErrorHandler|null) {\n    // note: normally initialized per package (not per file)\n    const r = this\n    r.errh = errh\n    r.fset = fset\n    r.universe = universe\n    r.unresolved = new Set<UnresolvedType>()\n  }\n\n  error(msg :string, pos :Pos = NoPos, typ? :ErrorCode) {\n    const r = this\n    r.errorAt(msg, r.fset.position(pos), typ)\n  }\n\n  // resolve attempts to resolve or infer the type of n.\n  // Returns UnresolvedType if the type refers to an undefined identifier.\n  // May mutate n.type, and may call ErrorHandler for undefined fields.\n  //\n  resolve(n :Expr) :Type {\n    if (n instanceof Type) {\n      return n\n    }\n\n    if (n.type instanceof Type && n.type.constructor !== UnresolvedType) {\n      return n.type\n    }\n\n    const r = this\n    let t = r.maybeResolve(n)\n\n    if (!t) {\n      if (n.type) {\n        return n.type\n      }\n\n      t = r.markUnresolved(n)\n\n      // error failing to resolve field of known type\n      if (\n        n instanceof SelectorExpr &&\n        n.lhs instanceof Ident &&\n        n.lhs.ent\n      ) {\n        // Partially resolved selector, e.g.\n        // \"a.B undefined (type <typeof(a)> has no field or method B)\"\n        r.error(`${n} undefined`, n.pos)\n      }\n    }\n\n    n.type = t\n\n    return t\n  }\n\n  // maybeResolve attempts to resolve or infer the type of n.\n  // Returns null if the type can't be resolved or inferred.\n  // May mutate n.type and may call ErrorHandler.\n  //\n  maybeResolve(n :Expr) :Type|null {\n    const r = this\n\n    if (n instanceof Type) {\n      return n\n    }\n\n    if (n.type && n.type.constructor !== UnresolvedType) {\n      return r.resolve(n.type)\n    }\n\n    if (n instanceof Ident) {\n      if (n.ent) {\n        if (n.ent.value) {\n          return r.maybeResolve(n.ent.value)\n        }\n        if (n.ent.decl instanceof Expr) {\n          return r.maybeResolve(n.ent.decl)\n        }\n      }\n      // else: unresolved -- unknown type\n      return null\n    }\n\n    if (n instanceof FunDecl) {\n      const s = n.sig\n      return r.universe.internType(new FunType(\n        s.pos,\n        s.scope,\n        s.params.map(field => r.resolve(field.type)),\n        r.resolve(s.result),\n      ))\n    }\n\n    if (n instanceof TupleExpr) {\n      let types :Type[] = []\n      for (const x1 of n.exprs) {\n        const t = r.resolve(x1)\n        if (!t) {\n          return null\n        }\n        types.push(t)\n      }\n      return r.universe.internType(new TupleType(n.pos, n.scope, types))\n    }\n\n    if (n instanceof RestExpr) {\n      let t = n.expr && r.resolve(n.expr) || u_t_auto\n      return r.universe.internType(new RestType(n.pos, n.scope, t))\n    }\n\n    if (n instanceof CallExpr) {\n      const funtype = r.resolve(n.fun)\n      for (let arg of n.args) {\n        r.resolve(arg)\n      }\n      if (funtype instanceof FunType) {\n        return funtype.output\n      }\n      return null  // unknown\n    }\n\n    debuglog(`TODO handle ${n.constructor.name}`)\n    return null  // unknown type\n  }\n\n  // registerUnresolved registers expr as having an unresolved type.\n  // Does NOT set expr.type but instead returns an UnresolvedType object.\n  //\n  markUnresolved(expr :Expr) :UnresolvedType {\n    const t = new UnresolvedType(expr.pos, expr.scope, expr)\n    debuglog(`expr ${expr}`)\n    this.unresolved.add(t)\n    return t\n  }\n\n  // isConstant returns true if the expression is a compile-time constant\n  //\n  isConstant(x :Expr) :bool {\n    return (\n      x instanceof LiteralExpr ||\n      (x instanceof Ident && x.ent != null && x.ent.isConstant)\n    )\n    // TODO: expand\n  }\n\n  // convertType attempts to convert expression x to type t.\n  // If x is already of type t, x is returned unchanged.\n  // If conversion is needed, a TypeConvExpr is returned,\n  // encapsulating x.\n  // If conversion is impossible, null is returned to indicate error.\n  //\n  convert(t :Type, x :Expr) :Expr|null {\n    const xt = this.resolve(x)\n\n    if (xt.equals(t)) {\n      return x\n    }\n\n    if (\n      this.isConstant(x) &&\n      t instanceof IntrinsicType &&\n      xt instanceof IntrinsicType\n    ) {\n      // constant expression with basic types\n      switch (basicTypeCompat(t, xt)) { // TypeCompat\n        case TypeCompat.NO: break\n        case TypeCompat.LOSSY: {\n          this.error(`constant ${x} truncated to ${t}`, x.pos, 'E_CONV')\n          // TODO: ^ use diag instead with DiagKind.ERROR as the default, so\n          // that user code can override this error into a warning instead, as\n          // it's still valid to perform a lossy conversion.\n          return new TypeConvExpr(x.pos, x.scope, x, t)\n        }\n        case TypeCompat.LOSSLESS: {\n          return new TypeConvExpr(x.pos, x.scope, x, t)\n        }\n      }\n    }\n\n    // TODO: figure out a scalable type conversion system\n    // TODO: conversion of other types\n\n    return null\n  }\n\n}\n","import { Parser, DiagKind } from './parser'\nimport { bindpkg } from './bind'\nimport * as scanner from './scanner'\nimport { Position, SrcFileSet } from './pos'\nimport * as fs from 'fs'\nimport { ByteStrSet } from './bytestr'\nimport { TypeSet } from './typeset'\nimport { astRepr } from './ast-repr'\nimport { Package, Scope, Ent } from './ast'\nimport { Universe } from './universe'\nimport { TypeResolver } from './resolve'\nimport { stdoutStyle, stdoutSupportsStyle } from './termstyle'\n\n\nconst reprOptions = {colors:stdoutSupportsStyle}\n\n\ninterface ParseResults {\n  pkg     :Package\n  success :bool\n}\n\nfunction parsePkg(\n  name     :string,\n  sources  :string[],\n  universe :Universe,\n  parser   :Parser,\n  typeres  :TypeResolver,\n) :Promise<ParseResults> {\n\n  const pkg = new Package(name, new Scope(universe.scope))\n  const sfileSet = new SrcFileSet()\n\n  const errh = (p :Position, msg :string, typ :string) => {\n    console.error(stdoutStyle.red(`${p}: ${msg} (${typ})`))\n  }\n\n  const diagh = (p :Position, msg :string, k :DiagKind) => {\n    const m = `[diag] ${p}: ${msg} (${DiagKind[k]})`\n    console.log(k == DiagKind.INFO ? stdoutStyle.cyan(m) : stdoutStyle.lightyellow(m))\n  }\n\n  typeres.init(sfileSet, universe, errh)\n\n  for (let filename of sources) {\n    console.log(\n      '\\n--------------------------------------------------------\\n' + \n      `parse ${filename}`\n    )\n    const sdata = fs.readFileSync(filename, {flag:'r'}) as Uint8Array\n    const sfile = sfileSet.addFile(filename, sdata.length)\n\n    parser.initParser(\n      sfile,\n      sdata,\n      universe,\n      pkg.scope,\n      typeres,\n      errh,\n      diagh,\n      scanner.Mode.ScanComments\n    )\n\n    const file = parser.parseFile()\n    pkg.files.push(file)\n\n    if (file.imports) {\n      console.log(`${file.imports.length} imports`)\n      for (let imp of file.imports) {\n        console.log(astRepr(imp, reprOptions))\n      }\n    }\n\n    if (file.unresolved) {\n      console.log(`${file.unresolved.size} unresolved references`)\n      for (let ident of file.unresolved) {\n        console.log(' - ' + astRepr(ident, reprOptions))\n      }\n    }\n\n    console.log(`${file.decls.length} declarations`)\n    for (let decl of file.decls) {\n      console.log(astRepr(decl, reprOptions))\n    }\n  }\n\n  if (parser.errorCount != 0) {\n    return Promise.resolve({ pkg, success: false })\n  }\n\n  // bind and assemble package\n  console.log(\n    '\\n--------------------------------------------------------\\n' + \n    `bind & assemble ${pkg}`\n  )\n  function importer(_imports :Map<string,Ent>, _path :string) :Promise<Ent> {\n    return Promise.reject(new Error(`not found`))\n  }\n\n  return bindpkg(pkg, sfileSet, importer, typeres, errh)\n    .then(hasErrors => ( { pkg, success: !hasErrors } ))\n}\n\n\nfunction main() {\n  const strSet = new ByteStrSet()\n  const typeSet = new TypeSet()\n  const universe = new Universe(strSet, typeSet)\n  const typeres = new TypeResolver()\n  const parser = new Parser()\n\n  parsePkg(\"example\", ['example/scope4.xl'], universe, parser, typeres).then(r => {\n    if (!r.success) {\n      return\n    }\n\n    // print AST\n    for (const file of r.pkg.files) {\n      console.log('\\n========================================================')\n      console.log(\n        `${r.pkg} ${file.sfile.name} ${file.decls.length} declarations`)\n      console.log('--------------------------------------------------------')\n      for (let decl of file.decls) {\n        console.log(astRepr(decl, reprOptions))\n      }\n    }\n\n  })\n}\n\n\nmain()\n"],"names":["utf8.decodeToString","utf8.encodeAsString","path.dir","utf8.decode","utf8.UniSelf","unicode.repr","unicode.isEmojiModifier","unicode.isEmojiModifierBase","unicode.InvalidChar","unicode.MaxRune","utf8.UTFMax","utf8.encode","unicode.isLetter","unicode.isDigit","bufcmp","path.clean","path.isAbs","path.join","unicode.isEmojiPresentation","scanner.Scanner","scanner.Mode","util.search","fs.readFileSync"],"mappings":"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,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,CAC/B,EAAC;CACH;AAED,mBAAwB,CAAM;IAC5B,QACE,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,KACzB,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;SACtB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,OAAO,IAAI,CAAC,IAAI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AAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAA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"}