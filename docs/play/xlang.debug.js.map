{"version":3,"file":"xlang.debug.js","sources":["../src/btree.ts","../src/token.ts","../src/util.ts","../src/utf8.ts","../src/unicode.ts","../src/termstyle.ts","../src/error.ts","../src/path.ts","../src/scanner.ts","../src/strtou.ts","../src/ast.ts","../src/parser.ts","../src/bind.ts","../src/pos.ts","../src/bytestr.ts","../src/typeset.ts","../src/ast-repr.ts","../src/universe.ts","../src/resolve.ts","../src/ir.ts","../src/ir-repr.ts","../src/main.ts"],"sourcesContent":["export interface BTreeNode<T> {\n  k  :ArrayLike<byte>\n  v  :T\n  L? :BTreeNode<T>\n  R? :BTreeNode<T>\n}\n\nexport class BTree<T> {\n  readonly root :BTreeNode<T>\n  constructor(root :BTreeNode<T>) {\n    this.root = root\n  }\n\n  get(key :ArrayLike<byte>) :T|null {\n    return lookup(key, this.root)\n  }\n}\n\n// function lookup<T>(key :ArrayLike<byte>, n :BTreeNode<T>) :T|null {\n//   let c = bufcmp(key, n.k)\n//   return (\n//     (c == -1) ? n.L ? lookup(key, n.L) : null :\n//     (c == 1) ? n.R ? lookup(key, n.R) : null :\n//     (key.length == n.k.length) ? n.v :\n//     null\n//   )\n// }\n\nfunction lookup<T>(key :ArrayLike<byte>, n :BTreeNode<T>) :T|null {\n  while (n) {\n    const c = bufcmp(key, n.k)\n    if (c == -1) {\n      n = n.L as BTreeNode<T>\n    } else if (c == 1) {\n      n = n.R as BTreeNode<T>\n    } else if (key.length == n.k.length) {\n      return n.v\n    } else {\n      break\n    }\n  }\n  return null\n}\n\nfunction bufcmp(a :ArrayLike<byte>, b :ArrayLike<byte>) :int {\n  const aL = a.length, bL = b.length, L = (aL < bL ? aL : bL)\n  for (let i = 0; i != L; ++i) {\n    if (a[i] < b[i]) { return -1 }\n    if (b[i] < a[i]) { return 1 }\n  }\n  return (\n    aL < bL ? -1 :\n    bL < aL ? 1 :\n    0\n  )\n}\n","import { BTree } from './btree'\n\nexport function tokIsKeyword(t :token) :bool {\n  return token.keyword_beg < t && t < token.keyword_end\n}\n\nexport function hasIntValue(t :token) :bool {\n  return t == token.CHAR\n}\n\nexport function hasByteValue(t :token) :bool {\n  return (\n    (token.literal_beg < t && t < token.literal_end) ||\n    t == token.COMMENT\n  )\n}\n\nexport function tokstr(t :token) :string {\n  return tokenStrings.get(t) || token[t].toLowerCase()\n}\n\n// Operator precedences\nexport enum prec {\n  LOWEST, // = := ! <- ->\n  OROR,     // ||\n  ANDAND,    // &&\n  CMP,    // == != < <= > >=\n  ADD,    // + - | ^\n  MUL,    // * / % & &^ << >>\n}\n\nexport enum token {\n  // Special tokens\n  ILLEGAL = 0,\n  EOF,\n  COMMENT,\n\n  literal_beg,\n  // Identifiers and basic type literals\n  // (these tokens stand for classes of literals)\n  NAME,    // main\n  NAMEAT,  // @foo, @\n  literal_int_beg,\n  INT,     // 12345\n  INT_BIN, // 0b1010\n  INT_OCT, // 0o6737\n  INT_HEX, // 0xBE3f\n  literal_int_end,\n  FLOAT,   // 123.45\n  RATIO,   // 22/7\n  CHAR,    // 'a'\n  STRING,  // \"abc\"\n  STRING_MULTI, // \"ab\\nc\" — multi-line\n  STRING_PIECE, // \"a ${...} b\" -- the \"a \" part (\" b\" is STRING)\n  literal_end,\n\n  // Delimiters\n  delim_beg,\n  LPAREN,    // (\n  LBRACKET,  // [\n  LBRACE,    // {\n  COMMA,     // ,\n  DOT,       // .\n  PERIODS,   // ..\n  ELLIPSIS,  // ...\n  RPAREN,    // )\n  RBRACKET,  // ]\n  RBRACE,    // }\n  SEMICOLON, // ;\n  COLON,     // :\n  delim_end,\n\n  // Operators\n  operator_beg,\n\n  // prec.LOWEST\n  ASSIGN,         // =\n  assignop_beg,\n  ADD_ASSIGN,     // +=\n  SUB_ASSIGN,     // -=\n  MUL_ASSIGN,     // *=\n  QUO_ASSIGN,     // /=\n  REM_ASSIGN,     // %=\n  AND_ASSIGN,     // &=\n  OR_ASSIGN,      // |=\n  XOR_ASSIGN,     // ^=\n  SHL_ASSIGN,     // <<=\n  SHR_ASSIGN,     // >>=\n  AND_NOT_ASSIGN, // &^=\n  assignop_end,\n  INC,            // ++\n  DEC,            // --\n  SET_ASSIGN,     // :=\n  NOT,            // !\n  ARROWL,         // <-\n  ARROWR,         // ->\n\n  cmpop_beg,\n  // prec.OR\n  OROR, // ||\n  \n  // prec.AND\n  ANDAND, // &&\n\n  // prec.CMP\n  EQL, // ==\n  NEQ, // !=\n  LSS, // <\n  LEQ, // <=\n  GTR, // >\n  GEQ, // >=\n  cmpop_end,\n\n  // prec.ADD\n  ADD, // +\n  SUB, // -\n  OR,  // |\n  XOR, // ^\n  \n  // prec.MUL\n  MUL,     // *\n  QUO,     // /\n  REM,     // %\n  AND,     // &\n  AND_NOT, // &^\n  SHL,     // <<\n  SHR,     // >>  (arithmetic when signed, logical when unsigned)\n\n  operator_end,\n\n  // Keywords\n  keyword_beg,\n  BREAK,\n  //CASE,\n  //CHAN,\n  //CONST,\n  CONTINUE,\n  DEFAULT,\n  DEFER,\n  ELSE,\n  ENUM,\n  FALLTHROUGH,\n  FOR,\n  FUN,\n  GO,\n  //GOTO,\n  IF,\n  IMPORT,\n  INTERFACE,\n  IN,\n  //MAP,\n  //PACKAGE,\n  //RANGE,\n  RETURN,\n  SELECT,\n  //STRUCT,\n  SWITCH,\n  SYMBOL,\n  TYPE,\n  // VAR,\n  WHILE,\n  keyword_end,\n} // enum T\n\n\n// Keywords\n// When you add, change or remove a keyword, make sure to run gen-btree.js\n// with the changes and update the code below.\n// Keyword token names should be the UPPER-CASE version of the actual keyword\n// name. This convention is used to populate tokenStrings.\n\n\nconst tokenStrings = new Map<token, string>([\n  [token.NAMEAT, \"@\"],\n\n  [token.ADD, \"+\"],\n  [token.SUB, \"-\"],\n  [token.MUL, \"*\"],\n  [token.QUO, \"/\"],\n  [token.REM, \"%\"],\n\n  [token.AND,     \"&\"],\n  [token.OR,      \"|\"],\n  [token.XOR,     \"^\"],\n  [token.SHL,     \"<<\"],\n  [token.SHR,     \">>\"],\n  [token.AND_NOT, \"&^\"],\n\n  [token.ADD_ASSIGN, \"+=\"],\n  [token.SUB_ASSIGN, \"-=\"],\n  [token.MUL_ASSIGN, \"*=\"],\n  [token.QUO_ASSIGN, \"/=\"],\n  [token.REM_ASSIGN, \"%=\"],\n\n  [token.AND_ASSIGN,     \"&=\"],\n  [token.OR_ASSIGN,      \"|=\"],\n  [token.XOR_ASSIGN,     \"^=\"],\n  [token.SHL_ASSIGN,     \"<<=\"],\n  [token.SHR_ASSIGN,     \">>=\"],\n  [token.AND_NOT_ASSIGN, \"&^=\"],\n\n  [token.ANDAND, \"&&\"],\n  [token.OROR,   \"||\"],\n  [token.ARROWL, \"<-\"],\n  [token.ARROWR, \"->\"],\n  [token.INC,    \"++\"],\n  [token.DEC,    \"--\"],\n\n  [token.EQL,    \"==\"],\n  [token.LSS,    \"<\"],\n  [token.GTR,    \">\"],\n  [token.ASSIGN, \"=\"],\n  [token.NOT,    \"!\"],\n\n  [token.NEQ,        \"!=\"],\n  [token.LEQ,        \"<=\"],\n  [token.GEQ,        \">=\"],\n  [token.SET_ASSIGN, \":=\"],\n  [token.ELLIPSIS,   \"...\"],\n  [token.PERIODS,    \"..\"],\n\n  [token.LPAREN,   \"(\"],\n  [token.LBRACKET, \"[\"],\n  [token.LBRACE,   \"{\"],\n  [token.COMMA,    \",\"],\n  [token.DOT,      \".\"],\n\n  [token.RPAREN,    \")\"],\n  [token.RBRACKET,  \"]\"],\n  [token.RBRACE,    \"}\"],\n  [token.SEMICOLON, \";\"],\n  [token.COLON,     \":\"],\n]) // tokenStrings\n\nfor (let i = token.keyword_beg+1; i < token.keyword_end; ++i) {\n  const t = token[i] as string\n  tokenStrings.set((token as any)[t] as token, t.toLowerCase())\n}\n\n// BEGIN generated by gen-keywords.js\nconst cdat = new Uint8Array([\n  103,111,100,101,102,101,114,98,114,101,97,107,99,111,110,116,105,110,117,101\n  ,100,101,102,97,117,108,116,101,110,117,109,101,108,115,101,102,97,108,108\n  ,116,104,114,111,117,103,104,102,111,114,102,117,110,114,101,116,117,114,110\n  ,105,109,112,111,114,116,105,102,105,110,105,110,116,101,114,102,97,99,101\n  ,115,119,105,116,99,104,115,101,108,101,99,116,115,121,109,98,111,108,116\n  ,121,112,101,119,104,105,108,101]);\nconst keywords = new BTree<token>(\n  { k: cdat.subarray(0,2) /*go*/, v: token.GO,\n    L:{ k: cdat.subarray(2,7) /*defer*/, v: token.DEFER,\n      L:{ k: cdat.subarray(7,12) /*break*/, v: token.BREAK,\n        R:{ k: cdat.subarray(12,20) /*continue*/, v: token.CONTINUE,\n          R:{ k: cdat.subarray(20,27) /*default*/, v: token.DEFAULT}}},\n      R:{ k: cdat.subarray(27,31) /*enum*/, v: token.ENUM,\n        L:{ k: cdat.subarray(31,35) /*else*/, v: token.ELSE},\n        R:{ k: cdat.subarray(35,46) /*fallthrough*/, v: token.FALLTHROUGH,\n          R:{ k: cdat.subarray(46,49) /*for*/, v: token.FOR,\n            R:{ k: cdat.subarray(49,52) /*fun*/, v: token.FUN}}}}},\n    R:{ k: cdat.subarray(52,58) /*return*/, v: token.RETURN,\n      L:{ k: cdat.subarray(58,64) /*import*/, v: token.IMPORT,\n        L:{ k: cdat.subarray(64,66) /*if*/, v: token.IF},\n        R:{ k: cdat.subarray(66,68) /*in*/, v: token.IN,\n          R:{ k: cdat.subarray(68,77) /*interface*/, v: token.INTERFACE}}},\n      R:{ k: cdat.subarray(77,83) /*switch*/, v: token.SWITCH,\n        L:{ k: cdat.subarray(83,89) /*select*/, v: token.SELECT},\n        R:{ k: cdat.subarray(89,95) /*symbol*/, v: token.SYMBOL,\n          R:{ k: cdat.subarray(95,99) /*type*/, v: token.TYPE,\n            R:{ k: cdat.subarray(99,104) /*while*/, v: token.WHILE}}}}}}\n)\n// END generated by gen-keywords.js\n\n// lookupKeyword maps an identifier to its keyword token or NAME\n// (if not a keyword).\n//\nexport function lookupKeyword(ident :ArrayLike<byte>) :token {\n  return keywords.get(ident) || token.NAME\n}\n","// export function SplitFileExt(path :string) :[string, string] {\n//   let p = path.lastIndexOf('/')\n//   p = path.lastIndexOf('.', p == -1 ? 0 : p)\n//   return p == -1 ? [path, ''] : [path.substr(0, p), path.substr(p)]\n// }\n\n// export function SplitPath(path :string) :[string, string] {\n//   const p = path.lastIndexOf('/')\n//   return p == -1 ? ['.', path] : [path.substr(0, p), path.substr(p+1)]\n// }\n\nexport function search(n :number, f :(n:number)=>bool) :int {\n  // Define f(-1) == false and f(n) == true.\n  // Invariant: f(i-1) == false, f(j) == true.\n  let i = 0, j = n\n  while (i < j) {\n    const mid = i + (((j-i)/2) >> 0) // avoid overflow and truncate to int\n    // i ≤ h < j\n    if (!f(mid)) {\n      i = mid + 1 // preserves f(i-1) == false\n    } else {\n      j = mid // preserves f(j) == true\n    }\n  }\n  // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n  return i\n}\n\n// bufcopy creates a new buffer containing bytes with some additional space.\n//\nfunction bufcopy(bytes :ArrayLike<byte>, addlSize :int) {\n  const size = bytes.length + addlSize\n  const b2 = new Uint8Array(size)\n  b2.set(bytes, 0)\n  // const b = Buffer.allocUnsafe(size)\n  // this.buffer.copy(b)\n  return b2\n}\n\n\n// asciibuf creates a byte array from a string of ASCII characters.\n// The string must only contain character values in the range [0-127].\n//\nexport function asciibuf(s :string) :Uint8Array {\n  return Uint8Array.from(\n    s as any as ArrayLike<number>,\n    (v: number, k: number) => s.charCodeAt(k)\n  )\n}\n\n\n// asciistr creates a string from bytes representing ASCII characters.\n// The byte array must only contain values in the range [0-127].\n//\nexport function asciistr(b :ArrayLike<byte>) :string {\n  return String.fromCharCode.apply(null, b)\n}\n\n\n// bufcmp compares two arrays of bytes\n//\nexport function bufcmp(\n  a       :ArrayLike<byte>,\n  b       :ArrayLike<byte>,\n  aStart  :int = 0,\n  aEnd    :int = a.length,\n  bStart  :int = 0,\n  bEnd    :int = b.length,\n) :int {\n  if (a === b) {\n    return 0\n  }\n  var ai = aStart, bi = bStart\n  for (; ai != aEnd && bi != bEnd; ++ai, ++bi) {\n    if (a[ai] < b[bi]) { return -1 }\n    if (b[bi] < a[ai]) { return 1 }\n  }\n  var aL = aEnd - aStart, bL = bEnd - bStart\n  return (\n    aL < bL ? -1 :\n    bL < aL ? 1 :\n    0\n  )\n}\n\n\n// asbuf returns a byte buffer for a\n// \nexport let asbuf :(a :ArrayLike<byte>) => Uint8Array\n\n\nif (typeof Buffer != 'undefined') {\n\n  asbuf = (a :ArrayLike<byte>) => {\n    if (a instanceof Buffer || a instanceof Uint8Array) {\n      return a as Uint8Array\n    }\n\n    if (\n      (a as any).buffer &&\n      (a as any).byteOffset !== undefined &&\n      (a as any).byteLength !== undefined\n    ) {\n      return Buffer.from(\n        (a as any).buffer as ArrayBuffer,\n        (a as any).byteOffset as int,\n        (a as any).byteLength as int\n      ) as Uint8Array\n    }\n\n    const buf = Buffer.allocUnsafe(a.length)\n    for (let i = 0; i < a.length; ++i) {\n      buf[i] = a[i]\n    }\n    return buf as Uint8Array\n  }\n\n  // function asnodebuf(a :ArrayLike<byte>) :Buffer {\n  //   return (a instanceof Buffer) ? a : new Buffer(asbuf(a))\n  // }\n\n  // bufcmp1 = (a, b, aStart, aEnd, bStart, bEnd) => {\n  //   if (a === b) {\n  //     return 0\n  //   }\n\n  //   // Note: although TS type decarations may say that Buffer.compare\n  //   // only accepts a Buffer, in fact it also accepts a Uint8Array.\n  //   if (a instanceof Buffer &&\n  //       (b instanceof Buffer || b instanceof Uint8Array))\n  //   {\n  //     return a.compare(b as Buffer, bStart, bEnd, aStart, aEnd)\n  //   }\n\n  //   if (b instanceof Buffer &&\n  //       (a instanceof Buffer || a instanceof Uint8Array))\n  //   {\n  //     return b.compare(a as Buffer, aStart, aEnd, bStart, bEnd)\n  //   }\n\n  //   const abuf = asnodebuf(a)\n  //   const bbuf = asbuf(b) as Buffer\n\n  //   return abuf.compare(bbuf, bStart, bEnd, aStart, aEnd)\n  // }\n}\n\n\nexport class AppendBuffer {\n  buffer :Uint8Array\n  length :int // current offset\n\n  constructor(size :int) {\n    this.length = 0\n    this.buffer = new Uint8Array(size)\n  }\n\n  reset() {\n    this.length = 0\n  }\n\n  // Make sure there's space for at least `size` additional bytes\n  reserve(addlSize :int) {\n    if (this.length + addlSize >= this.buffer.length) {\n      this._grow(addlSize)\n    }\n  }\n\n  subarray() :Uint8Array {\n    return this.buffer.subarray(0, this.length)\n  }\n\n  // slice() :Uint8Array {\n  //   return this.buffer.slice(0, this.length)\n  // }\n  // slice(start :int = 0, end? :int) :Uint8Array {\n  //   const _end = end === undefined ? this.length : Math.min(this.length, end)\n  //   if (this.buffer.length - (_end - start) < 128) {\n  //     // trade memory usage for speed by avoiding allocation & copy\n  //     return this.buffer.subarray(start, _end)\n  //   }\n  //   return this.buffer.slice(start, _end)\n  // }\n\n  append(b :int) :void {\n    if (this.length >= this.buffer.length) {\n      this._grow()\n    }\n    this.buffer[this.length++] = b\n  }\n\n  appendRange(src :Uint8Array, srcStart :int, srcEnd? :int) :void {\n    const end = (srcEnd === undefined) ? src.length : srcEnd\n    const size = end - srcStart\n    if (this.length + size >= this.buffer.length) {\n      this._grow(size)\n    }\n    this.buffer.set(src.subarray(srcStart, srcEnd), this.length)\n    this.length += size\n  }\n\n  private _grow(minAddlSize :int = 8) {\n    this.buffer = bufcopy(\n      this.buffer,\n      Math.min(minAddlSize, this.buffer.length)\n    )\n  }\n}\n\n// debug function\nexport const debuglog = DEBUG ? function(...v :any[]) {\n  let e = new Error()\n  let prefix = ''\n\n  if (e.stack) {\n    // let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)/.exec(e.stack.split(/\\n/, 3)[2])\n    let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)\\s+\\(.+\\/src\\/(.+)\\)/.exec(\n      e.stack.split(/\\n/, 3)[2]\n    )\n    if (m) {\n      const fun = m[1]\n      const origin = m[2]\n      if (origin) {\n        const filename = origin.split('.ts:', 1)[0]\n        const trmsg = String(v[0])\n        if (trmsg.indexOf('TODO:') == 0 || trmsg.indexOf('TODO ') == 0) {\n          // message start with \"TODO\"\n          prefix = 'TODO src/' + origin + ' ' + fun + '>'\n          v[0] = trmsg.substr(5).replace(/^\\s*/, '')\n        } else {\n          prefix = filename + '/' + fun + '>'\n        }\n      } else {\n        prefix = fun + '>'\n      }\n    } else {\n      prefix = 'DEBUG>'\n    }\n  }\n\n  v.splice(0, 0, prefix)\n  console.log.apply(console, v)\n} : function(...v :any[]){}\n\n","// UTF-8\n//\n// codepoint -> UTF-8 bytes\n//   encode         (dst WArrayLike<byte>, offset int, codepoint) -> nwrite int\n//   encodeString   (src string) -> Uint8Array\n//   encodeAsString (codepoint) -> string\n//\n// UTF-8 bytes -> codepoint\n//   decode         (src ArrayLike<byte>, offset int, DecodeResult) -> ok bool\n//   decodeToString (src ArrayLike<byte>) -> string\n//\n// misc\n//   byteSize(codepoint) -> size int\n//\n\nexport const\n  UniError = 0xFFFD,   // the \"error\" Rune or \"Unicode replacement character\"\n  UniSelf  = 0x80,     // characters below UniSelf are represented as\n                       // themselves in a single byte.\n  UTFMax   = 4         // Maximum number of bytes of a UTF8-encoded char\n\nconst\n  maxCp        = 0x10FFFF, // Maximum valid Unicode code point.\n  // Code points in the surrogate range are not valid for UTF-8.\n  surrogateMin = 0xD800,\n  surrogateMax = 0xDFFF,\n  // rune1Max = 1<<8 - 1  // 0x80\n  rune2Max = 1<<11 - 1 // 0x400\n  // rune3Max = 1<<16 - 1  // 0x8000\n\nexport interface DecodeResult {\n  c :int // codepoint -- UniError on error\n  w :int // width in bytes -- may be 0 on error\n}\n\nexport function decode(\n  src    :ArrayLike<byte>,\n  offset :int,\n  r      :DecodeResult\n) :bool {\n  const b = src[offset]\n\n  if (b < UniSelf) {\n    r.c = isNaN(b) ? UniError : b\n    r.w = 1\n  } else {\n    const end = src.length\n\n    if ((b >> 5) == 0x6) {\n      r.c = offset + 2 > end ? UniError :\n            ((b << 6) & 0x7ff) +\n            ((src[++offset]) & 0x3f),\n      r.w = 2\n    } else if ((b >> 4) == 0xe) {\n      r.c = offset + 3 > end ? UniError :\n            ((b << 12) & 0xffff) +\n            ((src[++offset] << 6) & 0xfff) +\n            ((src[++offset]) & 0x3f),\n      r.w = 3\n    } else if ((b >> 3) == 0x1e) {\n      r.c=  offset + 4 > end ? UniError :\n            ((b << 18) & 0x1fffff) +\n            ((src[++offset] << 12) & 0x3ffff) +\n            ((src[++offset] << 6) & 0xfff) +\n             (src[++offset] & 0x3f),\n      r.w = 4\n    } else {\n      return false\n    }\n  }\n\n  return true\n}\n\ninterface TextDecoderOptions {\n  fatal?: boolean\n  ignoreBOM?: boolean\n}\ninterface TextDecodeOptions {\n  stream?: boolean\n}\n\ndeclare class TextDecoder {\n  constructor(utfLabel?: string, options?: TextDecoderOptions)\n  encoding: string\n  fatal: boolean\n  ignoreBOM: boolean\n  decode(input?: ArrayBufferView, options?: TextDecodeOptions): string\n}\n\n\nexport let decodeToString :(src :ArrayLike<byte>) => string\n\nif (typeof TextDecoder != 'undefined') {\n  const dec = new TextDecoder('utf-8')\n  decodeToString = (src :ArrayLike<byte>) => dec.decode(\n    (src as any).buffer != undefined ? src as Uint8Array :\n    new Uint8Array(src)\n  )\n} else if (typeof Buffer != 'undefined') {\n  // nodejs\n  decodeToString = (src :ArrayLike<byte>) => {\n    let buf :Buffer\n    if (src instanceof Buffer) {\n      buf = src\n    } else if (\n      (src as any).buffer &&\n      (src as any).byteOffset !== undefined &&\n      (src as any).byteLength !== undefined\n    ) {\n      buf = Buffer.from(\n        (src as any).buffer as ArrayBuffer,\n        (src as any).byteOffset as int,\n        (src as any).byteLength as int\n      )\n    } else {\n      buf = Buffer.allocUnsafe(src.length)\n      for (let i = 0; i < src.length; ++i) {\n        buf[i] = src[i]\n      }\n    }\n    return buf.toString('utf8')\n  }\n} else {\n  // todo: fallback implementation\n  panic('missing TextDecoder')\n}\n\n\ndeclare class TextEncoder  {\n  constructor(utfLabel?: string)\n    // utfLabel ignored since Firefox >=48 and Chrome >=53 (always utf-8)\n  encoding :string // always \"utf-8\"\n  encode(input? :string, options? :TextEncodeOptions) :Uint8Array\n}\n\ninterface TextEncodeOptions {\n  stream?: boolean\n}\n\nexport let encodeString :(src :string) => Uint8Array\n\nif (typeof TextEncoder != 'undefined') {\n  const enc = new TextEncoder('utf-8')\n  encodeString = (s :string) => enc.encode(s)\n} else if (typeof Buffer != 'undefined') {\n  encodeString = (s :string) => Buffer.from(s, 'utf8') as Uint8Array\n} else {\n  // todo: fallback implementation\n  panic('missing TextEncoder')\n}\n\n\n// encode writes into b (which must be large enough) the UTF-8 encoding\n// of the character. Never writes more than UTFMax bytes.\n// Returns the number of bytes written.\n//\nexport function encode(b :WArrayLike<byte>, offs :int, cp :int) :int {\n  if (cp < UniSelf) {\n    b[offs] = cp\n    return 1\n  }\n  if (cp < 0x800) {\n    b[offs]   = (cp >> 6)   | 0xc0\n    b[++offs] = (cp & 0x3f) | 0x80\n    return 2\n  }\n  if (cp > maxCp || (surrogateMin <= cp && cp <= surrogateMax)) {\n    // invalid codepoint\n    cp = UniError\n  }\n  if (cp < 0x10000) {\n    b[offs]   = (cp >> 12)         | 0xe0\n    b[++offs] = ((cp >> 6) & 0x3f) | 0x80\n    b[++offs] = (cp & 0x3f)        | 0x80\n    return 3\n  }\n  b[offs]   = (cp >> 18)         | 0xf0\n  b[++offs] = ((cp >> 12) & 0x3f)| 0x80\n  b[++offs] = ((cp >> 6) & 0x3f) | 0x80\n  b[++offs] = (cp & 0x3f)        | 0x80\n  return 4\n}\n\nexport function byteSize(cp :int) :int {\n  return (\n    (cp < 0x80) ? 1 :\n    (cp < 0x800) ? 2 :\n    (cp < 0x10000) ? 3 :\n    4\n  )\n}\n\nexport function encodeAsString(cp :int) :string {\n  if (cp < 0 || cp > maxCp) {\n    panic(`invalid unicode code point ${cp}`)\n  }\n  if (cp < 0x10000) {\n    return String.fromCharCode(cp)\n  }\n  cp -= 0x10000\n  return String.fromCharCode(\n    (cp >> 10) + surrogateMin,\n    (cp % rune2Max) + 0xDC00\n  )\n}\n","import * as utf8 from './utf8'\n\nexport const\n  MaxRune     = 0x10FFFF, // Maximum valid Unicode code point.\n  MaxASCII    = 0x007F,   // maximum ASCII value.\n  MaxLatin1   = 0x00FF,   // maximum Latin-1 value.\n  InvalidChar = 0xFFFD    // Represents invalid code points.\n\n\nconst fmt4 = '0000'\n\nexport function repr(cp :int) :string {\n  let s = cp.toString(16)\n  if (cp <= 0xFFFF) {\n    s = fmt4.substr(0, fmt4.length - s.length) + s\n  }\n  let str = JSON.stringify(utf8.encodeAsString(cp))\n  str = str.substr(1, str.length-2)\n  return `U+${s} '${str}'`\n}\n\nexport function isValid(c :int) :bool {\n  return c <= MaxRune && (c < 0xD800 || 0xE000 < c)\n  // D800..E000 surrogate range\n}\n\n// the rest of this file was generated by misc/gen-unicode-data.js\n\nexport function isLetter(c :int) :bool {\n  return (\n    0x41 <= c && c <= 0x1E943 && ( // LATIN CAPITAL LETTER A..ADLAM SMALL LETTER SHA\n    (0x41 <= c && c <= 0x5A) || // LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z\n    (0x61 <= c && c <= 0x7A) || // LATIN SMALL LETTER A..LATIN SMALL LETTER Z\n    c == 0xB5 || // MICRO SIGN\n    (0xC0 <= c && c <= 0xD6) || // LATIN CAPITAL LETTER A WITH GRAVE..LATIN CAPITAL LETTER O WITH DIAERESIS\n    (0xD8 <= c && c <= 0xF6) || // LATIN CAPITAL LETTER O WITH STROKE..LATIN SMALL LETTER O WITH DIAERESIS\n    (0xF8 <= c && c <= 0x1BA) || // LATIN SMALL LETTER O WITH STROKE..LATIN SMALL LETTER EZH WITH TAIL\n    (0x1BC <= c && c <= 0x1BF) || // LATIN CAPITAL LETTER TONE FIVE..LATIN LETTER WYNN\n    c == 0x1C4 || // LATIN CAPITAL LETTER DZ WITH CARON\n    (0x1C6 <= c && c <= 0x1C7) || // LATIN SMALL LETTER DZ WITH CARON..LATIN CAPITAL LETTER LJ\n    (0x1C9 <= c && c <= 0x1CA) || // LATIN SMALL LETTER LJ..LATIN CAPITAL LETTER NJ\n    (0x1CC <= c && c <= 0x1F1) || // LATIN SMALL LETTER NJ..LATIN CAPITAL LETTER DZ\n    (0x1F3 <= c && c <= 0x293) || // LATIN SMALL LETTER DZ..LATIN SMALL LETTER EZH WITH CURL\n    (0x295 <= c && c <= 0x2AF) || // LATIN LETTER PHARYNGEAL VOICED FRICATIVE..LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL\n    (0x370 <= c && c <= 0x373) || // GREEK CAPITAL LETTER HETA..GREEK SMALL LETTER ARCHAIC SAMPI\n    (0x376 <= c && c <= 0x377) || // GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA..GREEK SMALL LETTER PAMPHYLIAN DIGAMMA\n    (0x37B <= c && c <= 0x37D) || // GREEK SMALL REVERSED LUNATE SIGMA SYMBOL..GREEK SMALL REVERSED DOTTED LUNATE SIGMA SYMBOL\n    c == 0x37F || // GREEK CAPITAL LETTER YOT\n    c == 0x386 || // GREEK CAPITAL LETTER ALPHA WITH TONOS\n    (0x388 <= c && c <= 0x38A) || // GREEK CAPITAL LETTER EPSILON WITH TONOS..GREEK CAPITAL LETTER IOTA WITH TONOS\n    c == 0x38C || // GREEK CAPITAL LETTER OMICRON WITH TONOS\n    (0x38E <= c && c <= 0x3A1) || // GREEK CAPITAL LETTER UPSILON WITH TONOS..GREEK CAPITAL LETTER RHO\n    (0x3A3 <= c && c <= 0x3F5) || // GREEK CAPITAL LETTER SIGMA..GREEK LUNATE EPSILON SYMBOL\n    (0x3F7 <= c && c <= 0x481) || // GREEK CAPITAL LETTER SHO..CYRILLIC SMALL LETTER KOPPA\n    (0x48A <= c && c <= 0x52F) || // CYRILLIC CAPITAL LETTER SHORT I WITH TAIL..CYRILLIC SMALL LETTER EL WITH DESCENDER\n    (0x531 <= c && c <= 0x556) || // ARMENIAN CAPITAL LETTER AYB..ARMENIAN CAPITAL LETTER FEH\n    (0x561 <= c && c <= 0x587) || // ARMENIAN SMALL LETTER AYB..ARMENIAN SMALL LIGATURE ECH YIWN\n    (0x10A0 <= c && c <= 0x10C5) || // GEORGIAN CAPITAL LETTER AN..GEORGIAN CAPITAL LETTER HOE\n    c == 0x10C7 || // GEORGIAN CAPITAL LETTER YN\n    c == 0x10CD || // GEORGIAN CAPITAL LETTER AEN\n    (0x13A0 <= c && c <= 0x13F5) || // CHEROKEE LETTER A..CHEROKEE LETTER MV\n    (0x13F8 <= c && c <= 0x13FD) || // CHEROKEE SMALL LETTER YE..CHEROKEE SMALL LETTER MV\n    (0x1C80 <= c && c <= 0x1C88) || // CYRILLIC SMALL LETTER ROUNDED VE..CYRILLIC SMALL LETTER UNBLENDED UK\n    (0x1D00 <= c && c <= 0x1D2B) || // LATIN LETTER SMALL CAPITAL A..CYRILLIC LETTER SMALL CAPITAL EL\n    (0x1D6B <= c && c <= 0x1D77) || // LATIN SMALL LETTER UE..LATIN SMALL LETTER TURNED G\n    (0x1D79 <= c && c <= 0x1D9A) || // LATIN SMALL LETTER INSULAR G..LATIN SMALL LETTER EZH WITH RETROFLEX HOOK\n    (0x1E00 <= c && c <= 0x1F15) || // LATIN CAPITAL LETTER A WITH RING BELOW..GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA\n    (0x1F18 <= c && c <= 0x1F1D) || // GREEK CAPITAL LETTER EPSILON WITH PSILI..GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA\n    (0x1F20 <= c && c <= 0x1F45) || // GREEK SMALL LETTER ETA WITH PSILI..GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA\n    (0x1F48 <= c && c <= 0x1F4D) || // GREEK CAPITAL LETTER OMICRON WITH PSILI..GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA\n    (0x1F50 <= c && c <= 0x1F57) || // GREEK SMALL LETTER UPSILON WITH PSILI..GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI\n    c == 0x1F59 || // GREEK CAPITAL LETTER UPSILON WITH DASIA\n    c == 0x1F5B || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA\n    c == 0x1F5D || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA\n    (0x1F5F <= c && c <= 0x1F7D) || // GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI..GREEK SMALL LETTER OMEGA WITH OXIA\n    (0x1F80 <= c && c <= 0x1F87) || // GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1F90 <= c && c <= 0x1F97) || // GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1FA0 <= c && c <= 0x1FA7) || // GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI..GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI\n    (0x1FB0 <= c && c <= 0x1FB4) || // GREEK SMALL LETTER ALPHA WITH VRACHY..GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FB6 <= c && c <= 0x1FBB) || // GREEK SMALL LETTER ALPHA WITH PERISPOMENI..GREEK CAPITAL LETTER ALPHA WITH OXIA\n    c == 0x1FBE || // GREEK PROSGEGRAMMENI\n    (0x1FC2 <= c && c <= 0x1FC4) || // GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI..GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FC6 <= c && c <= 0x1FCB) || // GREEK SMALL LETTER ETA WITH PERISPOMENI..GREEK CAPITAL LETTER ETA WITH OXIA\n    (0x1FD0 <= c && c <= 0x1FD3) || // GREEK SMALL LETTER IOTA WITH VRACHY..GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA\n    (0x1FD6 <= c && c <= 0x1FDB) || // GREEK SMALL LETTER IOTA WITH PERISPOMENI..GREEK CAPITAL LETTER IOTA WITH OXIA\n    (0x1FE0 <= c && c <= 0x1FEC) || // GREEK SMALL LETTER UPSILON WITH VRACHY..GREEK CAPITAL LETTER RHO WITH DASIA\n    (0x1FF2 <= c && c <= 0x1FF4) || // GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI..GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI\n    (0x1FF6 <= c && c <= 0x1FFB) || // GREEK SMALL LETTER OMEGA WITH PERISPOMENI..GREEK CAPITAL LETTER OMEGA WITH OXIA\n    c == 0x2102 || // DOUBLE-STRUCK CAPITAL C\n    c == 0x2107 || // EULER CONSTANT\n    (0x210A <= c && c <= 0x2113) || // SCRIPT SMALL G..SCRIPT SMALL L\n    c == 0x2115 || // DOUBLE-STRUCK CAPITAL N\n    (0x2119 <= c && c <= 0x211D) || // DOUBLE-STRUCK CAPITAL P..DOUBLE-STRUCK CAPITAL R\n    c == 0x2124 || // DOUBLE-STRUCK CAPITAL Z\n    c == 0x2126 || // OHM SIGN\n    c == 0x2128 || // BLACK-LETTER CAPITAL Z\n    (0x212A <= c && c <= 0x212D) || // KELVIN SIGN..BLACK-LETTER CAPITAL C\n    (0x212F <= c && c <= 0x2134) || // SCRIPT SMALL E..SCRIPT SMALL O\n    c == 0x2139 || // INFORMATION SOURCE\n    (0x213C <= c && c <= 0x213F) || // DOUBLE-STRUCK SMALL PI..DOUBLE-STRUCK CAPITAL PI\n    (0x2145 <= c && c <= 0x2149) || // DOUBLE-STRUCK ITALIC CAPITAL D..DOUBLE-STRUCK ITALIC SMALL J\n    c == 0x214E || // TURNED SMALL F\n    (0x2183 <= c && c <= 0x2184) || // ROMAN NUMERAL REVERSED ONE HUNDRED..LATIN SMALL LETTER REVERSED C\n    (0x2C00 <= c && c <= 0x2C2E) || // GLAGOLITIC CAPITAL LETTER AZU..GLAGOLITIC CAPITAL LETTER LATINATE MYSLITE\n    (0x2C30 <= c && c <= 0x2C5E) || // GLAGOLITIC SMALL LETTER AZU..GLAGOLITIC SMALL LETTER LATINATE MYSLITE\n    (0x2C60 <= c && c <= 0x2C7B) || // LATIN CAPITAL LETTER L WITH DOUBLE BAR..LATIN LETTER SMALL CAPITAL TURNED E\n    (0x2C7E <= c && c <= 0x2CE4) || // LATIN CAPITAL LETTER S WITH SWASH TAIL..COPTIC SYMBOL KAI\n    (0x2CEB <= c && c <= 0x2CEE) || // COPTIC CAPITAL LETTER CRYPTOGRAMMIC SHEI..COPTIC SMALL LETTER CRYPTOGRAMMIC GANGIA\n    (0x2CF2 <= c && c <= 0x2CF3) || // COPTIC CAPITAL LETTER BOHAIRIC KHEI..COPTIC SMALL LETTER BOHAIRIC KHEI\n    (0x2D00 <= c && c <= 0x2D25) || // GEORGIAN SMALL LETTER AN..GEORGIAN SMALL LETTER HOE\n    c == 0x2D27 || // GEORGIAN SMALL LETTER YN\n    c == 0x2D2D || // GEORGIAN SMALL LETTER AEN\n    (0xA640 <= c && c <= 0xA66D) || // CYRILLIC CAPITAL LETTER ZEMLYA..CYRILLIC SMALL LETTER DOUBLE MONOCULAR O\n    (0xA680 <= c && c <= 0xA69B) || // CYRILLIC CAPITAL LETTER DWE..CYRILLIC SMALL LETTER CROSSED O\n    (0xA722 <= c && c <= 0xA76F) || // LATIN CAPITAL LETTER EGYPTOLOGICAL ALEF..LATIN SMALL LETTER CON\n    (0xA771 <= c && c <= 0xA787) || // LATIN SMALL LETTER DUM..LATIN SMALL LETTER INSULAR T\n    (0xA78B <= c && c <= 0xA78E) || // LATIN CAPITAL LETTER SALTILLO..LATIN SMALL LETTER L WITH RETROFLEX HOOK AND BELT\n    (0xA790 <= c && c <= 0xA7AE) || // LATIN CAPITAL LETTER N WITH DESCENDER..LATIN CAPITAL LETTER SMALL CAPITAL I\n    (0xA7B0 <= c && c <= 0xA7B7) || // LATIN CAPITAL LETTER TURNED K..LATIN SMALL LETTER OMEGA\n    c == 0xA7FA || // LATIN LETTER SMALL CAPITAL TURNED M\n    (0xAB30 <= c && c <= 0xAB5A) || // LATIN SMALL LETTER BARRED ALPHA..LATIN SMALL LETTER Y WITH SHORT RIGHT LEG\n    (0xAB60 <= c && c <= 0xAB65) || // LATIN SMALL LETTER SAKHA YAT..GREEK LETTER SMALL CAPITAL OMEGA\n    (0xAB70 <= c && c <= 0xABBF) || // CHEROKEE SMALL LETTER A..CHEROKEE SMALL LETTER YA\n    (0xFB00 <= c && c <= 0xFB06) || // LATIN SMALL LIGATURE FF..LATIN SMALL LIGATURE ST\n    (0xFB13 <= c && c <= 0xFB17) || // ARMENIAN SMALL LIGATURE MEN NOW..ARMENIAN SMALL LIGATURE MEN XEH\n    (0xFF21 <= c && c <= 0xFF3A) || // FULLWIDTH LATIN CAPITAL LETTER A..FULLWIDTH LATIN CAPITAL LETTER Z\n    (0xFF41 <= c && c <= 0xFF5A) || // FULLWIDTH LATIN SMALL LETTER A..FULLWIDTH LATIN SMALL LETTER Z\n    (0x10400 <= c && c <= 0x1044F) || // DESERET CAPITAL LETTER LONG I..DESERET SMALL LETTER EW\n    (0x104B0 <= c && c <= 0x104D3) || // OSAGE CAPITAL LETTER A..OSAGE CAPITAL LETTER ZHA\n    (0x104D8 <= c && c <= 0x104FB) || // OSAGE SMALL LETTER A..OSAGE SMALL LETTER ZHA\n    (0x10C80 <= c && c <= 0x10CB2) || // OLD HUNGARIAN CAPITAL LETTER A..OLD HUNGARIAN CAPITAL LETTER US\n    (0x10CC0 <= c && c <= 0x10CF2) || // OLD HUNGARIAN SMALL LETTER A..OLD HUNGARIAN SMALL LETTER US\n    (0x118A0 <= c && c <= 0x118DF) || // WARANG CITI CAPITAL LETTER NGAA..WARANG CITI SMALL LETTER VIYO\n    (0x1D400 <= c && c <= 0x1D454) || // MATHEMATICAL BOLD CAPITAL A..MATHEMATICAL ITALIC SMALL G\n    (0x1D456 <= c && c <= 0x1D49C) || // MATHEMATICAL ITALIC SMALL I..MATHEMATICAL SCRIPT CAPITAL A\n    (0x1D49E <= c && c <= 0x1D49F) || // MATHEMATICAL SCRIPT CAPITAL C..MATHEMATICAL SCRIPT CAPITAL D\n    c == 0x1D4A2 || // MATHEMATICAL SCRIPT CAPITAL G\n    (0x1D4A5 <= c && c <= 0x1D4A6) || // MATHEMATICAL SCRIPT CAPITAL J..MATHEMATICAL SCRIPT CAPITAL K\n    (0x1D4A9 <= c && c <= 0x1D4AC) || // MATHEMATICAL SCRIPT CAPITAL N..MATHEMATICAL SCRIPT CAPITAL Q\n    (0x1D4AE <= c && c <= 0x1D4B9) || // MATHEMATICAL SCRIPT CAPITAL S..MATHEMATICAL SCRIPT SMALL D\n    c == 0x1D4BB || // MATHEMATICAL SCRIPT SMALL F\n    (0x1D4BD <= c && c <= 0x1D4C3) || // MATHEMATICAL SCRIPT SMALL H..MATHEMATICAL SCRIPT SMALL N\n    (0x1D4C5 <= c && c <= 0x1D505) || // MATHEMATICAL SCRIPT SMALL P..MATHEMATICAL FRAKTUR CAPITAL B\n    (0x1D507 <= c && c <= 0x1D50A) || // MATHEMATICAL FRAKTUR CAPITAL D..MATHEMATICAL FRAKTUR CAPITAL G\n    (0x1D50D <= c && c <= 0x1D514) || // MATHEMATICAL FRAKTUR CAPITAL J..MATHEMATICAL FRAKTUR CAPITAL Q\n    (0x1D516 <= c && c <= 0x1D51C) || // MATHEMATICAL FRAKTUR CAPITAL S..MATHEMATICAL FRAKTUR CAPITAL Y\n    (0x1D51E <= c && c <= 0x1D539) || // MATHEMATICAL FRAKTUR SMALL A..MATHEMATICAL DOUBLE-STRUCK CAPITAL B\n    (0x1D53B <= c && c <= 0x1D53E) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL D..MATHEMATICAL DOUBLE-STRUCK CAPITAL G\n    (0x1D540 <= c && c <= 0x1D544) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL I..MATHEMATICAL DOUBLE-STRUCK CAPITAL M\n    c == 0x1D546 || // MATHEMATICAL DOUBLE-STRUCK CAPITAL O\n    (0x1D54A <= c && c <= 0x1D550) || // MATHEMATICAL DOUBLE-STRUCK CAPITAL S..MATHEMATICAL DOUBLE-STRUCK CAPITAL Y\n    (0x1D552 <= c && c <= 0x1D6A5) || // MATHEMATICAL DOUBLE-STRUCK SMALL A..MATHEMATICAL ITALIC SMALL DOTLESS J\n    (0x1D6A8 <= c && c <= 0x1D6C0) || // MATHEMATICAL BOLD CAPITAL ALPHA..MATHEMATICAL BOLD CAPITAL OMEGA\n    (0x1D6C2 <= c && c <= 0x1D6DA) || // MATHEMATICAL BOLD SMALL ALPHA..MATHEMATICAL BOLD SMALL OMEGA\n    (0x1D6DC <= c && c <= 0x1D6FA) || // MATHEMATICAL BOLD EPSILON SYMBOL..MATHEMATICAL ITALIC CAPITAL OMEGA\n    (0x1D6FC <= c && c <= 0x1D714) || // MATHEMATICAL ITALIC SMALL ALPHA..MATHEMATICAL ITALIC SMALL OMEGA\n    (0x1D716 <= c && c <= 0x1D734) || // MATHEMATICAL ITALIC EPSILON SYMBOL..MATHEMATICAL BOLD ITALIC CAPITAL OMEGA\n    (0x1D736 <= c && c <= 0x1D74E) || // MATHEMATICAL BOLD ITALIC SMALL ALPHA..MATHEMATICAL BOLD ITALIC SMALL OMEGA\n    (0x1D750 <= c && c <= 0x1D76E) || // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL..MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA\n    (0x1D770 <= c && c <= 0x1D788) || // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA..MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA\n    (0x1D78A <= c && c <= 0x1D7A8) || // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL..MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA\n    (0x1D7AA <= c && c <= 0x1D7C2) || // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA..MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA\n    (0x1D7C4 <= c && c <= 0x1D7CB) || // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL..MATHEMATICAL BOLD SMALL DIGAMMA\n    (0x1E900 <= c && c <= 0x1E943) // ADLAM CAPITAL LETTER ALIF..ADLAM SMALL LETTER SHA\n  ))\n}\n\nexport function isDigit(c :int) :bool {\n  return (\n    0x30 <= c && c <= 0x1E959 && ( // DIGIT ZERO..ADLAM DIGIT NINE\n    (0x30 <= c && c <= 0x39) || // DIGIT ZERO..DIGIT NINE\n    (0x660 <= c && c <= 0x669) || // ARABIC-INDIC DIGIT ZERO..ARABIC-INDIC DIGIT NINE\n    (0x6F0 <= c && c <= 0x6F9) || // EXTENDED ARABIC-INDIC DIGIT ZERO..EXTENDED ARABIC-INDIC DIGIT NINE\n    (0x7C0 <= c && c <= 0x7C9) || // NKO DIGIT ZERO..NKO DIGIT NINE\n    (0x966 <= c && c <= 0x96F) || // DEVANAGARI DIGIT ZERO..DEVANAGARI DIGIT NINE\n    (0x9E6 <= c && c <= 0x9EF) || // BENGALI DIGIT ZERO..BENGALI DIGIT NINE\n    (0xA66 <= c && c <= 0xA6F) || // GURMUKHI DIGIT ZERO..GURMUKHI DIGIT NINE\n    (0xAE6 <= c && c <= 0xAEF) || // GUJARATI DIGIT ZERO..GUJARATI DIGIT NINE\n    (0xB66 <= c && c <= 0xB6F) || // ORIYA DIGIT ZERO..ORIYA DIGIT NINE\n    (0xBE6 <= c && c <= 0xBEF) || // TAMIL DIGIT ZERO..TAMIL DIGIT NINE\n    (0xC66 <= c && c <= 0xC6F) || // TELUGU DIGIT ZERO..TELUGU DIGIT NINE\n    (0xCE6 <= c && c <= 0xCEF) || // KANNADA DIGIT ZERO..KANNADA DIGIT NINE\n    (0xD66 <= c && c <= 0xD6F) || // MALAYALAM DIGIT ZERO..MALAYALAM DIGIT NINE\n    (0xDE6 <= c && c <= 0xDEF) || // SINHALA LITH DIGIT ZERO..SINHALA LITH DIGIT NINE\n    (0xE50 <= c && c <= 0xE59) || // THAI DIGIT ZERO..THAI DIGIT NINE\n    (0xED0 <= c && c <= 0xED9) || // LAO DIGIT ZERO..LAO DIGIT NINE\n    (0xF20 <= c && c <= 0xF29) || // TIBETAN DIGIT ZERO..TIBETAN DIGIT NINE\n    (0x1040 <= c && c <= 0x1049) || // MYANMAR DIGIT ZERO..MYANMAR DIGIT NINE\n    (0x1090 <= c && c <= 0x1099) || // MYANMAR SHAN DIGIT ZERO..MYANMAR SHAN DIGIT NINE\n    (0x17E0 <= c && c <= 0x17E9) || // KHMER DIGIT ZERO..KHMER DIGIT NINE\n    (0x1810 <= c && c <= 0x1819) || // MONGOLIAN DIGIT ZERO..MONGOLIAN DIGIT NINE\n    (0x1946 <= c && c <= 0x194F) || // LIMBU DIGIT ZERO..LIMBU DIGIT NINE\n    (0x19D0 <= c && c <= 0x19D9) || // NEW TAI LUE DIGIT ZERO..NEW TAI LUE DIGIT NINE\n    (0x1A80 <= c && c <= 0x1A89) || // TAI THAM HORA DIGIT ZERO..TAI THAM HORA DIGIT NINE\n    (0x1A90 <= c && c <= 0x1A99) || // TAI THAM THAM DIGIT ZERO..TAI THAM THAM DIGIT NINE\n    (0x1B50 <= c && c <= 0x1B59) || // BALINESE DIGIT ZERO..BALINESE DIGIT NINE\n    (0x1BB0 <= c && c <= 0x1BB9) || // SUNDANESE DIGIT ZERO..SUNDANESE DIGIT NINE\n    (0x1C40 <= c && c <= 0x1C49) || // LEPCHA DIGIT ZERO..LEPCHA DIGIT NINE\n    (0x1C50 <= c && c <= 0x1C59) || // OL CHIKI DIGIT ZERO..OL CHIKI DIGIT NINE\n    (0xA620 <= c && c <= 0xA629) || // VAI DIGIT ZERO..VAI DIGIT NINE\n    (0xA8D0 <= c && c <= 0xA8D9) || // SAURASHTRA DIGIT ZERO..SAURASHTRA DIGIT NINE\n    (0xA900 <= c && c <= 0xA909) || // KAYAH LI DIGIT ZERO..KAYAH LI DIGIT NINE\n    (0xA9D0 <= c && c <= 0xA9D9) || // JAVANESE DIGIT ZERO..JAVANESE DIGIT NINE\n    (0xA9F0 <= c && c <= 0xA9F9) || // MYANMAR TAI LAING DIGIT ZERO..MYANMAR TAI LAING DIGIT NINE\n    (0xAA50 <= c && c <= 0xAA59) || // CHAM DIGIT ZERO..CHAM DIGIT NINE\n    (0xABF0 <= c && c <= 0xABF9) || // MEETEI MAYEK DIGIT ZERO..MEETEI MAYEK DIGIT NINE\n    (0xFF10 <= c && c <= 0xFF19) || // FULLWIDTH DIGIT ZERO..FULLWIDTH DIGIT NINE\n    (0x104A0 <= c && c <= 0x104A9) || // OSMANYA DIGIT ZERO..OSMANYA DIGIT NINE\n    (0x11066 <= c && c <= 0x1106F) || // BRAHMI DIGIT ZERO..BRAHMI DIGIT NINE\n    (0x110F0 <= c && c <= 0x110F9) || // SORA SOMPENG DIGIT ZERO..SORA SOMPENG DIGIT NINE\n    (0x11136 <= c && c <= 0x1113F) || // CHAKMA DIGIT ZERO..CHAKMA DIGIT NINE\n    (0x111D0 <= c && c <= 0x111D9) || // SHARADA DIGIT ZERO..SHARADA DIGIT NINE\n    (0x112F0 <= c && c <= 0x112F9) || // KHUDAWADI DIGIT ZERO..KHUDAWADI DIGIT NINE\n    (0x11450 <= c && c <= 0x11459) || // NEWA DIGIT ZERO..NEWA DIGIT NINE\n    (0x114D0 <= c && c <= 0x114D9) || // TIRHUTA DIGIT ZERO..TIRHUTA DIGIT NINE\n    (0x11650 <= c && c <= 0x11659) || // MODI DIGIT ZERO..MODI DIGIT NINE\n    (0x116C0 <= c && c <= 0x116C9) || // TAKRI DIGIT ZERO..TAKRI DIGIT NINE\n    (0x11730 <= c && c <= 0x11739) || // AHOM DIGIT ZERO..AHOM DIGIT NINE\n    (0x118E0 <= c && c <= 0x118E9) || // WARANG CITI DIGIT ZERO..WARANG CITI DIGIT NINE\n    (0x11C50 <= c && c <= 0x11C59) || // BHAIKSUKI DIGIT ZERO..BHAIKSUKI DIGIT NINE\n    (0x11D50 <= c && c <= 0x11D59) || // MASARAM GONDI DIGIT ZERO..MASARAM GONDI DIGIT NINE\n    (0x16A60 <= c && c <= 0x16A69) || // MRO DIGIT ZERO..MRO DIGIT NINE\n    (0x16B50 <= c && c <= 0x16B59) || // PAHAWH HMONG DIGIT ZERO..PAHAWH HMONG DIGIT NINE\n    (0x1D7CE <= c && c <= 0x1D7FF) || // MATHEMATICAL BOLD DIGIT ZERO..MATHEMATICAL MONOSPACE DIGIT NINE\n    (0x1E950 <= c && c <= 0x1E959) // ADLAM DIGIT ZERO..ADLAM DIGIT NINE\n  ))\n}\n\nexport function isWhitespace(c :int) :bool {\n  return (\n    0x0 <= c && c <= 0x3000 && ( // <control>..IDEOGRAPHIC SPACE\n    (0x0 <= c && c <= 0x20) || // <control>..SPACE\n    (0x7F <= c && c <= 0xA0) || // <control>..NO-BREAK SPACE\n    c == 0x1680 || // OGHAM SPACE MARK\n    (0x2000 <= c && c <= 0x200A) || // EN QUAD..HAIR SPACE\n    (0x2028 <= c && c <= 0x2029) || // LINE SEPARATOR..PARAGRAPH SEPARATOR\n    c == 0x202F || // NARROW NO-BREAK SPACE\n    c == 0x205F || // MEDIUM MATHEMATICAL SPACE\n    c == 0x3000 // IDEOGRAPHIC SPACE\n  ))\n}\n\n\nexport function isEmojiPresentation(c :int) :bool {\n  return (\n    0x231A <= c && c <= 0x1F9E6 && ( // WATCH..SOCKS\n    (0x231A <= c && c <= 0x231B) || // WATCH..HOURGLASS\n    (0x23E9 <= c && c <= 0x23EC) || // BLACK RIGHT-POINTING DOUBLE TRIANGLE..BLACK DOWN-POINTING DOUBLE TRIANGLE\n    c == 0x23F0 || // <unknown>\n    c == 0x23F3 || // <unknown>\n    (0x25FD <= c && c <= 0x25FE) || // WHITE MEDIUM SMALL SQUARE..BLACK MEDIUM SMALL SQUARE\n    (0x2614 <= c && c <= 0x2615) || // UMBRELLA WITH RAIN DROPS..HOT BEVERAGE\n    (0x2648 <= c && c <= 0x2653) || // ARIES..PISCES\n    c == 0x267F || // <unknown>\n    c == 0x2693 || // <unknown>\n    c == 0x26A1 || // <unknown>\n    (0x26AA <= c && c <= 0x26AB) || // MEDIUM WHITE CIRCLE..MEDIUM BLACK CIRCLE\n    (0x26BD <= c && c <= 0x26BE) || // SOCCER BALL..BASEBALL\n    (0x26C4 <= c && c <= 0x26C5) || // SNOWMAN WITHOUT SNOW..SUN BEHIND CLOUD\n    c == 0x26CE || // <unknown>\n    c == 0x26D4 || // <unknown>\n    c == 0x26EA || // <unknown>\n    (0x26F2 <= c && c <= 0x26F3) || // FOUNTAIN..FLAG IN HOLE\n    c == 0x26F5 || // <unknown>\n    c == 0x26FA || // <unknown>\n    c == 0x26FD || // <unknown>\n    c == 0x2705 || // <unknown>\n    (0x270A <= c && c <= 0x270B) || // RAISED FIST..RAISED HAND\n    c == 0x2728 || // <unknown>\n    c == 0x274C || // <unknown>\n    c == 0x274E || // <unknown>\n    (0x2753 <= c && c <= 0x2755) || // BLACK QUESTION MARK ORNAMENT..WHITE EXCLAMATION MARK ORNAMENT\n    c == 0x2757 || // <unknown>\n    (0x2795 <= c && c <= 0x2797) || // HEAVY PLUS SIGN..HEAVY DIVISION SIGN\n    c == 0x27B0 || // <unknown>\n    c == 0x27BF || // <unknown>\n    (0x2B1B <= c && c <= 0x2B1C) || // BLACK LARGE SQUARE..WHITE LARGE SQUARE\n    c == 0x2B50 || // <unknown>\n    c == 0x2B55 || // <unknown>\n    c == 0x1F004 || // <unknown>\n    c == 0x1F0CF || // <unknown>\n    c == 0x1F18E || // <unknown>\n    (0x1F191 <= c && c <= 0x1F19A) || // SQUARED CL..SQUARED VS\n    (0x1F1E6 <= c && c <= 0x1F1FF) || // REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z\n    c == 0x1F201 || // <unknown>\n    c == 0x1F21A || // <unknown>\n    c == 0x1F22F || // <unknown>\n    (0x1F232 <= c && c <= 0x1F236) || // SQUARED CJK UNIFIED IDEOGRAPH-7981..SQUARED CJK UNIFIED IDEOGRAPH-6709\n    (0x1F238 <= c && c <= 0x1F23A) || // SQUARED CJK UNIFIED IDEOGRAPH-7533..SQUARED CJK UNIFIED IDEOGRAPH-55B6\n    (0x1F250 <= c && c <= 0x1F251) || // CIRCLED IDEOGRAPH ADVANTAGE..CIRCLED IDEOGRAPH ACCEPT\n    (0x1F300 <= c && c <= 0x1F320) || // CYCLONE..SHOOTING STAR\n    (0x1F32D <= c && c <= 0x1F335) || // HOT DOG..CACTUS\n    (0x1F337 <= c && c <= 0x1F37C) || // TULIP..BABY BOTTLE\n    (0x1F37E <= c && c <= 0x1F393) || // BOTTLE WITH POPPING CORK..GRADUATION CAP\n    (0x1F3A0 <= c && c <= 0x1F3C4) || // CAROUSEL HORSE..SURFER\n    c == 0x1F3C5 || // <unknown>\n    (0x1F3C6 <= c && c <= 0x1F3CA) || // TROPHY..SWIMMER\n    (0x1F3CF <= c && c <= 0x1F3D3) || // CRICKET BAT AND BALL..TABLE TENNIS PADDLE AND BALL\n    (0x1F3E0 <= c && c <= 0x1F3F0) || // HOUSE BUILDING..EUROPEAN CASTLE\n    c == 0x1F3F4 || // <unknown>\n    (0x1F3F8 <= c && c <= 0x1F43E) || // BADMINTON RACQUET AND SHUTTLECOCK..PAW PRINTS\n    c == 0x1F440 || // <unknown>\n    (0x1F442 <= c && c <= 0x1F4F7) || // EAR..CAMERA\n    c == 0x1F4F8 || // <unknown>\n    (0x1F4F9 <= c && c <= 0x1F4FC) || // VIDEO CAMERA..VIDEOCASSETTE\n    c == 0x1F4FF || // <unknown>\n    (0x1F500 <= c && c <= 0x1F53D) || // TWISTED RIGHTWARDS ARROWS..DOWN-POINTING SMALL RED TRIANGLE\n    (0x1F54B <= c && c <= 0x1F54E) || // KAABA..MENORAH WITH NINE BRANCHES\n    (0x1F550 <= c && c <= 0x1F567) || // CLOCK FACE ONE OCLOCK..CLOCK FACE TWELVE-THIRTY\n    c == 0x1F57A || // <unknown>\n    (0x1F595 <= c && c <= 0x1F596) || // REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS\n    c == 0x1F5A4 || // <unknown>\n    (0x1F5FB <= c && c <= 0x1F5FF) || // MOUNT FUJI..MOYAI\n    c == 0x1F600 || // <unknown>\n    (0x1F601 <= c && c <= 0x1F610) || // GRINNING FACE WITH SMILING EYES..NEUTRAL FACE\n    c == 0x1F611 || // <unknown>\n    (0x1F612 <= c && c <= 0x1F614) || // UNAMUSED FACE..PENSIVE FACE\n    c == 0x1F615 || // <unknown>\n    c == 0x1F616 || // <unknown>\n    c == 0x1F617 || // <unknown>\n    c == 0x1F618 || // <unknown>\n    c == 0x1F619 || // <unknown>\n    c == 0x1F61A || // <unknown>\n    c == 0x1F61B || // <unknown>\n    (0x1F61C <= c && c <= 0x1F61E) || // FACE WITH STUCK-OUT TONGUE AND WINKING EYE..DISAPPOINTED FACE\n    c == 0x1F61F || // <unknown>\n    (0x1F620 <= c && c <= 0x1F62B) || // ANGRY FACE..TIRED FACE\n    c == 0x1F62C || // <unknown>\n    c == 0x1F62D || // <unknown>\n    (0x1F62E <= c && c <= 0x1F633) || // FACE WITH OPEN MOUTH..FLUSHED FACE\n    c == 0x1F634 || // <unknown>\n    (0x1F635 <= c && c <= 0x1F64F) || // DIZZY FACE..PERSON WITH FOLDED HANDS\n    (0x1F680 <= c && c <= 0x1F6C5) || // ROCKET..LEFT LUGGAGE\n    c == 0x1F6CC || // <unknown>\n    c == 0x1F6D0 || // <unknown>\n    (0x1F6D1 <= c && c <= 0x1F6D2) || // OCTAGONAL SIGN..SHOPPING TROLLEY\n    (0x1F6EB <= c && c <= 0x1F6EC) || // AIRPLANE DEPARTURE..AIRPLANE ARRIVING\n    (0x1F6F4 <= c && c <= 0x1F6F8) || // SCOOTER..FLYING SAUCER\n    (0x1F910 <= c && c <= 0x1F91E) || // ZIPPER-MOUTH FACE..HAND WITH INDEX AND MIDDLE FINGERS CROSSED\n    c == 0x1F91F || // <unknown>\n    (0x1F920 <= c && c <= 0x1F92F) || // FACE WITH COWBOY HAT..SHOCKED FACE WITH EXPLODING HEAD\n    c == 0x1F930 || // <unknown>\n    (0x1F931 <= c && c <= 0x1F93A) || // BREAST-FEEDING..FENCER\n    (0x1F93C <= c && c <= 0x1F93E) || // WRESTLERS..HANDBALL\n    (0x1F940 <= c && c <= 0x1F945) || // WILTED FLOWER..GOAL NET\n    (0x1F947 <= c && c <= 0x1F94B) || // FIRST PLACE MEDAL..MARTIAL ARTS UNIFORM\n    c == 0x1F94C || // <unknown>\n    (0x1F950 <= c && c <= 0x1F96B) || // CROISSANT..CANNED FOOD\n    (0x1F980 <= c && c <= 0x1F997) || // CRAB..CRICKET\n    c == 0x1F9C0 || // <unknown>\n    (0x1F9D0 <= c && c <= 0x1F9E6) // FACE WITH MONOCLE..SOCKS\n  ))\n}\n\nexport function isEmojiModifierBase(c :int) :bool {\n  return (\n    0x261D <= c && c <= 0x1F9DD && ( // <unknown>..ELF\n    c == 0x261D || // <unknown>\n    c == 0x26F9 || // <unknown>\n    (0x270A <= c && c <= 0x270D) || // RAISED FIST..WRITING HAND\n    c == 0x1F385 || // <unknown>\n    (0x1F3C2 <= c && c <= 0x1F3C4) || // SNOWBOARDER..SURFER\n    c == 0x1F3C7 || // <unknown>\n    c == 0x1F3CA || // <unknown>\n    (0x1F3CB <= c && c <= 0x1F3CC) || // WEIGHT LIFTER..GOLFER\n    (0x1F442 <= c && c <= 0x1F443) || // EAR..NOSE\n    (0x1F446 <= c && c <= 0x1F450) || // WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN\n    (0x1F466 <= c && c <= 0x1F469) || // BOY..WOMAN\n    c == 0x1F46E || // <unknown>\n    (0x1F470 <= c && c <= 0x1F478) || // BRIDE WITH VEIL..PRINCESS\n    c == 0x1F47C || // <unknown>\n    (0x1F481 <= c && c <= 0x1F483) || // INFORMATION DESK PERSON..DANCER\n    (0x1F485 <= c && c <= 0x1F487) || // NAIL POLISH..HAIRCUT\n    c == 0x1F4AA || // <unknown>\n    (0x1F574 <= c && c <= 0x1F575) || // MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY\n    c == 0x1F57A || // <unknown>\n    c == 0x1F590 || // <unknown>\n    (0x1F595 <= c && c <= 0x1F596) || // REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS\n    (0x1F645 <= c && c <= 0x1F647) || // FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY\n    (0x1F64B <= c && c <= 0x1F64F) || // HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS\n    c == 0x1F6A3 || // <unknown>\n    (0x1F6B4 <= c && c <= 0x1F6B6) || // BICYCLIST..PEDESTRIAN\n    c == 0x1F6C0 || // <unknown>\n    c == 0x1F6CC || // <unknown>\n    c == 0x1F918 || // <unknown>\n    (0x1F919 <= c && c <= 0x1F91C) || // CALL ME HAND..RIGHT-FACING FIST\n    c == 0x1F91E || // <unknown>\n    c == 0x1F91F || // <unknown>\n    c == 0x1F926 || // <unknown>\n    c == 0x1F930 || // <unknown>\n    (0x1F931 <= c && c <= 0x1F939) || // BREAST-FEEDING..JUGGLING\n    (0x1F93D <= c && c <= 0x1F93E) || // WATER POLO..HANDBALL\n    (0x1F9D1 <= c && c <= 0x1F9DD) // ADULT..ELF\n  ))\n}\n\nexport function isEmojiModifier(c :int) :bool {\n  return (\n    (0x1F3FB <= c && c <= 0x1F3FF) // EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6\n  )\n}\n","// provides styling via shell color codes\n//\n// A Style object provides a number of functions named after their effect,\n// like \"boldRed\". A style function takes a single argument which is interpreted\n// as a string, and returns a string with the appropriate style codes\n// surrounding the string argument.\n//\n// Additionally, each such function has two properties: open and close, each\n// which are strings containing the starting (or ending) code(s) for the\n// appropriate style.\n//\n// Examples:\n//\n//   style.boldRed(\"hello\")    // => \"\\x1b[1;31mhello\\x1b[0;39m\"\n//   stdoutStyle.cyan(\"hello\") // => \"\\x1b[36mhello\\x1b[39m\"\n//\n\n// progressively support nodejs\ninterface has_isTTY { isTTY? :bool }\ndeclare var process :undefined | {\n  env :{[k:string]:string},\n  stdout: has_isTTY,\n  stderr: has_isTTY,\n}\nconst TERM = typeof process != 'undefined' && process.env.TERM || ''\n\nexport type StyleFun = (s: string) => string\n\nfunction sfn(open :string, close :string) :StyleFun {\n  open = '\\x1b[' + open + 'm'\n  close = '\\x1b[' + close + 'm'\n  return (s :string) => open + s + close\n}\n\n// number of colors that the terminal probably supports\nexport const termColorSupport :number = (\n  TERM && ['xterm','screen','vt100'].some(s => TERM.indexOf(s) != -1) ? (\n    TERM.indexOf('256color') != -1 ? 256 :\n    16\n  ) : 0\n)\n\nconst passThrough = ((s :string) => s) as StyleFun\n\nexport interface Style {\n  'clear'         :string\n\n  'bold'          :StyleFun\n  'italic'        :StyleFun\n  'underline'     :StyleFun\n  'inverse'       :StyleFun\n\n  'white'         :StyleFun\n  'grey'          :StyleFun\n  'black'         :StyleFun\n\n  'blue'          :StyleFun\n  'cyan'          :StyleFun\n  'green'         :StyleFun\n  'magenta'       :StyleFun\n  'purple'        :StyleFun\n  'pink'          :StyleFun\n  'red'           :StyleFun\n  'yellow'        :StyleFun\n  'lightyellow'   :StyleFun\n  'orange'        :StyleFun\n}\n\nexport const noStyle :Style = {\n  // no colors\n  'clear'         : \"\",\n\n  'bold'          : passThrough,\n  'italic'        : passThrough,\n  'underline'     : passThrough,\n  'inverse'       : passThrough,\n\n  'white'         : passThrough,\n  'grey'          : passThrough,\n  'black'         : passThrough,\n  'blue'          : passThrough,\n  'cyan'          : passThrough,\n  'green'         : passThrough,\n  'magenta'       : passThrough,\n  'purple'        : passThrough,\n  'pink'          : passThrough,\n  'red'           : passThrough,\n  'yellow'        : passThrough,\n  'lightyellow'   : passThrough,\n  'orange'        : passThrough,\n}\n\nexport const style :Style = (\n  termColorSupport == 0 ? noStyle :\n  termColorSupport < 256 ? {\n    // 16 colors\n    'clear'         : \"\\e[0m\",\n\n    'bold'          : sfn('1', '22'),\n    'italic'        : sfn('3', '23'),\n    'underline'     : sfn('4', '24'),\n    'inverse'       : sfn('7', '27'),\n\n    'white'         : sfn('37', '39'),\n    'grey'          : sfn('90', '39'),\n    'black'         : sfn('30', '39'),\n    'blue'          : sfn('34', '39'),\n    'cyan'          : sfn('36', '39'),\n    'green'         : sfn('32', '39'),\n    'magenta'       : sfn('35', '39'),\n    'purple'        : sfn('35', '39'),\n    'pink'          : sfn('35', '39'),\n    'red'           : sfn('31', '39'),\n    'yellow'        : sfn('33', '39'),\n    'lightyellow'   : sfn('93', '39'),\n    'orange'        : sfn('33', '39'),\n  } : {\n    // 256 colors\n    'clear'         : \"\\e[0m\",\n\n    'bold'          : sfn('1', '22'),\n    'italic'        : sfn('3', '23'),\n    'underline'     : sfn('4', '24'),\n    'inverse'       : sfn('7', '27'),\n\n    'white'         : sfn('38;2;255;255;255', '39'),\n    'grey'          : sfn('38;5;244', '39'),\n    'black'         : sfn('38;5;16',  '39'),\n    'blue'          : sfn('38;5;75',  '39'), // '38;2;120;160;255'\n    'cyan'          : sfn('38;5;87',  '39'),\n    'green'         : sfn('38;5;84',  '39'),\n    'magenta'       : sfn('38;5;213', '39'),\n    'purple'        : sfn('38;5;141', '39'),\n    'pink'          : sfn('38;5;211', '39'),\n    'red'           : sfn('38;2;255;110;80', '39'),\n    'yellow'        : sfn('38;5;227', '39'),\n    'lightyellow'   : sfn('38;5;229', '39'),\n    'orange'        : sfn('38;5;215', '39'),\n  }\n)\n\n// demo\n// for (let k in style) {\n//   if (k != 'clear') {\n//     console.log((style as any)[k](k))\n//   }\n// }\n// for (let mod of ['bold','italic','underline','inverse']) {\n//   for (let col of [\n//     'white','grey','black','blue','cyan','green','magenta','red','yellow'\n//   ]) {\n//     console.log(\n//       (style as any)[col](\n//         (style as any)[mod](mod + ' ' + col)\n//       )\n//     )\n//   }\n// }\n// ;(process as any).exit(0)\n\n// streamStyle returns the most appropriate Style object for `w`\nexport function streamStyle(w :has_isTTY) {\n  return termColorSupport && w.isTTY ? style : noStyle\n}\n\nexport const stdoutStyle = (\n  typeof process != 'undefined' && streamStyle(process.stdout) || noStyle\n)\n\nexport const stderrStyle = (\n  typeof process != 'undefined' && streamStyle(process.stderr) || noStyle\n)\n\nexport const stdoutSupportsStyle = stdoutStyle !== noStyle\nexport const stderrSupportsStyle = stderrStyle !== noStyle\n","import { Position } from './pos'\nimport { termColorSupport, style, noStyle } from './termstyle'\n\n// error codes\nclass _errors {\n  E_SYNTAX  = 'syntax'\n  E_CONV    = 'type or value conversion'\n  E_RESOLVE = 'reference resolution'\n  E_UNUSED_VAR   = 'declared and not used'\n  E_UNUSED_PARAM = 'unused parameter'\n  E_UNUSED_FIELD = 'unused field'\n}\nexport const errors = new _errors()\n\n// error code type\nexport type ErrorCode = keyof(_errors)\n\n// An ErrorHandler may be provided to Scanner.init. If a syntax error is\n// encountered and a handler was installed, the handler is called with a\n// position and an error message. The position points to the beginning of\n// the offending token.\n//\nexport type ErrorHandler = (pos :Position, msg :string, c :ErrorCode) => void\n\n// ErrorReporter serves as a base for other types that report source errors.\n//\nexport class ErrorReporter {\n  errorCount :number = 0\n\n  constructor(\n    public defaultErrCode :ErrorCode,\n    public errh :ErrorHandler|null = null,\n  ) {}\n\n  errorAt(msg :string, position :Position, code? :ErrorCode) {\n    if (this.errh) {\n      this.errh(position, msg, code || this.defaultErrCode)\n    }\n    this.errorCount++\n\n    // when compiling in debug mode, also show stack trace when reporting error\n    if (DEBUG) {\n      let e = new Error()\n      let maxlen = 0, SP = '                              '\n      const S = termColorSupport ? style : noStyle\n      let v = (e.stack||'').split('\\n').slice(2).map(s => {\n        let m = /\\s+at\\s+([^\\s]+)\\s+\\((.+)\\)/.exec(s)\n        if (!m) { return [s, null] }\n        let p = m[2].lastIndexOf('/src/')\n        if (p != -1) {\n          m[2] = m[2].substr(p+1)\n        }\n        maxlen = Math.max(m[1].length, maxlen)\n        return [m[1], m[2]]\n      })\n      console.error(\n        v.map(s => {\n          if (!s[1]) { return S.italic(String(s[0])) }\n          let f = s[0] as string\n          return S.grey(\n            '  ' + f + SP.substr(0,maxlen - f.length) + '  ' + s[1]\n          )\n        }).join('\\n')\n      )\n    }\n  }\n}\n","// TODO: to support good old windows...\n// const iswin32 = typeof process != 'undefined' && process.platform == 'win32'\n// and check for \\ in paths.\n\n\nconst SL = 0x2F  // '/'\n    , DOT = 0x2E // .'\n\n\n// dir returns the directory part of a path, or \".\" if no directory part.\n//\nexport function dir(path :string) :string {\n  if (path.indexOf('/') == -1) {\n    return '.'\n  }\n  path = clean(path)\n  let p = path.lastIndexOf('/')\n  return (\n    p == -1 ? '.' :\n    p == path.length - 1 ? path : // \"/\"\n    path.substr(0, p)\n  )\n}\n\nTEST(\"path.dir\", () => {\n  assert(dir(\"/a/b/c\") == \"/a/b\")\n  assert(dir(\"a/b/c\") == \"a/b\")\n  assert(dir(\"a/b\") == \"a\")\n  assert(dir(\"/\") == \"/\")\n  assert(dir(\"a\") == \".\")\n  assert(dir(\"\") == \".\")\n})\n\n\nclass lazybuf {\n  // The code in this class has been ported from Go and the following\n  // license applies:\n  //   Copyright 2009 The Go Authors. All rights reserved.\n  //   Use of this source code is governed by a BSD-style\n  //   license that can be found in the LICENSE file.\n  //   https://golang.org/LICENSE\n\n  buf :string|null = null\n  w   :int = 0\n\n  constructor(\n    public s :string,\n  ) {}\n\n  index(i :int) :int {\n    return this.buf !== null ? this.buf.charCodeAt(i) : this.s.charCodeAt(i)\n  }\n\n  append(c :int) {\n    if (this.buf === null) {\n      if (this.w < this.s.length && this.s.charCodeAt(this.w) == c) {\n        this.w++\n        return\n      }\n      this.buf = this.s.substr(0, this.w)\n    }\n    if (this.w < this.buf.length-1) {\n      // w was reverted\n      this.buf = this.buf.substr(0, this.w)\n    }\n    this.buf += String.fromCharCode(c) // ugh, javascript...\n    this.w++\n  }\n\n  toString() :string {\n    return (\n      this.buf === null ? this.s.substr(0,this.w) :\n      this.buf.substr(0, this.w)\n    )\n  }\n}\n\n\n// clean\n//\nexport function clean(path :string) :string {\n  // The code in this function has been ported from Go and the following\n  // license applies:\n  //   Copyright 2009 The Go Authors. All rights reserved.\n  //   Use of this source code is governed by a BSD-style\n  //   license that can be found in the LICENSE file.\n  //   https://golang.org/LICENSE\n\n  if (path == \"\") {\n    return \".\"\n  }\n\n  const rooted = path.charCodeAt(0) == SL\n  const n = path.length\n\n  // Invariants:\n  //  reading from path; r is index of next byte to process.\n  //  writing to buf; w is index of next byte to write.\n  //  dotdot is index in buf where .. must stop, either because\n  //    it is the leading slash or it is a leading ../../.. prefix.\n  let out = new lazybuf(path)\n  let r = 0, dotdot = 0\n\n  if (rooted) {\n    out.append(SL)\n    r = 1\n    dotdot = 1\n  }\n\n  while (r < n) {\n    const c0 = path.charCodeAt(r)\n    if (c0 == SL) {\n      // empty path element\n      r++\n    } else if (c0 == DOT && (r+1 == n || path.charCodeAt(r+1) == SL)) {\n      // . element\n      r++\n    } else if (\n      c0 == DOT &&\n      path.charCodeAt(r+1) == DOT &&\n      (r+2 == n || path.charCodeAt(r+2) == SL)\n    ) {\n      // .. element: remove to last /\n      r += 2\n      if (out.w > dotdot) {\n        // can backtrack\n        out.w--\n        while (out.w > dotdot && out.index(out.w) != SL) {\n          out.w--\n        }\n      } else if (!rooted) {\n        // cannot backtrack, but not rooted, so append .. element.\n        if (out.w > 0) {\n          out.append(SL)\n        }\n        out.append(DOT)\n        out.append(DOT)\n        dotdot = out.w\n      }\n    } else {\n      // real path element.\n      // add slash if needed\n      if (rooted && out.w != 1 || !rooted && out.w != 0) {\n        out.append(SL)\n      }\n      // copy element\n      // for (; r < n && path.charCodeAt(r) != SL; r++) {\n      //   out.append(path.charCodeAt(r))\n      // }\n      let c :int\n      for (; r < n; r++) {\n        c = path.charCodeAt(r)\n        if (c == SL) {\n          break\n        }\n        out.append(c)\n      }\n    }\n  }\n\n  // Turn empty string into \".\"\n  if (out.w == 0) {\n    return \".\"\n  }\n\n  return out.toString()\n}\n\nTEST(\"path.clean\", () => {\n  function t(input :string, expect :string) {\n    const result = clean(input)\n    assert(result == expect,\n      `expected ${JSON.stringify(input)} => ${JSON.stringify(expect)}` +\n      ` but instead got ${JSON.stringify(result)}`)\n  }\n  t(\"a/c\", \"a/c\")\n  t(\"a/c/\", \"a/c\")\n  t(\"/a/c\", \"/a/c\")\n  t(\"a//c\", \"a/c\")\n  t(\"a/c/.\", \"a/c\")\n  t(\"a/c/b/..\", \"a/c\")\n  t(\"/../a/c\", \"/a/c\")\n  t(\"/../a/b/../././/c\", \"/a/c\")\n  t(\"\", \".\")\n  t(\"/\", \"/\")\n})\n\n\n// isAbs returns true if the path is absolute\n//\nexport function isAbs(path :string) :bool {\n  return path.charCodeAt(0) == SL\n}\n\nTEST(\"path.isAbs\", () => {\n  assert(isAbs(\"/foo/bar\") === true)\n  assert(isAbs(\"foo/bar\") === false)\n})\n\n\n// join glues paths together\n//\nexport function join(...paths :string[]) :string {\n  let s = ''\n  for (let i = 0; i < paths.length; i++) {\n    if (paths[i] != '') {\n      return clean((i == 0 ? paths : paths.slice(i)).join('/'))\n    }\n  }\n  return s\n}\n\nTEST(\"path.join\", () => {\n  function t(inputs :string[], expect :string) {\n    const result = join.apply(null, inputs)\n    assert(result == expect,\n      `expected ${JSON.stringify(inputs)} => ${JSON.stringify(expect)}` +\n      ` but instead got ${JSON.stringify(result)}`)\n  }\n  t([\"a\", \"b\", \"c\"], \"a/b/c\")\n  t([\"a\", \"b/c\"], \"a/b/c\")\n  t([\"a/b/\", \"c\"], \"a/b/c\")\n  t([\"a/b//\", \"//c\"], \"a/b/c\")\n  t([\"/a/b//\", \"//c\"], \"/a/b/c\")\n  t([\"/a/b//\", \"//c/\"], \"/a/b/c\")\n  t([\"\", \"\"], \"\")\n  t([\"a\", \"\"], \"a\")\n  t([\"\", \"a\"], \"a\")\n})\n","import { AppendBuffer, bufcmp, asciibuf } from './util'\nimport { Pos, Position, SrcFile } from './pos'\nimport * as utf8 from './utf8'\nimport * as unicode from './unicode'\nimport { ErrorCode, ErrorReporter, ErrorHandler } from './error'\nimport { token, lookupKeyword, prec } from './token'\nimport * as path from './path'\n\n\nexport enum Mode {\n  None = 0,\n\n  ScanComments = 1, // do not skip comments; produce token.COMMENT\n\n  CopySource = 2,\n    // copy slices of source data for tokens with literal values instead of\n    // referencing the source buffer. This means slightly lower speed but\n    // less memory usage since when scanning is done, the source code memory\n    // can be reclaimed. If you plan to keep the source code around after\n    // scanning (common case) you should leave this disabled.\n}\n\nconst linePrefix = asciibuf('//!line ')\n\nenum istrOne { OFF, WAIT, CONT }\n\n// A Scanner holds the scanner's internal state while processing a given text.\n// It must be initialized via init before use or resue.\n//\nexport class Scanner extends ErrorReporter {\n  // immutable state (only changed by init())\n  // Note: `undefined as any as X` is a workaround for a TypeScript issue\n  // where members are otherwise not initialized at construction which causes\n  // duplicate struct definitions in v8.\n  public sfile :SrcFile = undefined as any as SrcFile // source file handle\n  public sdata :Uint8Array = undefined as any as Uint8Array // source data\n  public dir   :string = ''   // directory portion of file.name\n  public mode  :Mode = 0         // scanning mode\n\n  // scanning state\n  private ch         :int = -1 // current character (unicode; -1=EOF)\n  protected offset   :int = 0  // character offset\n  private rdOffset   :int = 0  // reading offset (position after current char)\n  private lineOffset :int = 0  // current line offset\n  private insertSemi :bool = false // insert a semicolon before next newline\n  private parenL     :int = 0  // parenthesis level, for string interpolation\n  private interpStrL :int = 0  // string interpolation level\n  private istrOne    :istrOne = istrOne.OFF // string interpolation\n  private byteval    :Uint8Array|null = null // value for some string tokens\n\n  // public scanning state (read-only)\n  public pos       :Pos = 0  // token start position\n  public startoffs :int = 0  // token start offset\n  public endoffs   :int = 0  // token end offset\n  public tok       :token = token.EOF\n  public prec      :prec = prec.LOWEST\n  public intval    :int = 0 // value for some tokens\n  public hash      :int = 0 // hash value for current token (if NAME*)\n\n  // sparse buffer state (not reset by s.init)\n  private appendbuf  :AppendBuffer|null = null // for string literals\n\n  // public state - ok to modify\n  public errorCount :int = 0 // number of errors encountered\n\n  constructor() {\n    super('E_SYNTAX')\n  }\n\n  // Init prepares the scanner s to tokenize the text sdata by setting the\n  // scanner at the beginning of sdata. The scanner uses the file set file\n  // for position information and it adds line information for each line.\n  // It is ok to re-use the same file when re-scanning the same file as\n  // line information which is already present is ignored. Init causes a\n  // panic if the file size does not match the sdata size.\n  //\n  // Calls to Scan will invoke the error handler errh if they encounter a\n  // syntax error and errh is not nil. Also, for each error encountered,\n  // the Scanner field ErrorCount is incremented by one. The mode parameter\n  // determines how comments are handled.\n  //\n  // Note that Init may call errh if there is an error in the first character\n  // of the file.\n  //\n  init(\n    sfile :SrcFile,\n    sdata :Uint8Array,\n    errh? :ErrorHandler|null,\n    mode  :Mode =Mode.None,\n  ) {\n    const s = this\n    // Explicitly initialize all fields since a scanner may be reused\n    if (sfile.size != sdata.length) {\n      panic(\n        `file size (${sfile.size}) `+\n        `does not match source size (${sdata.length})`\n      )\n    }\n    s.sfile = sfile\n    s.dir = path.dir(sfile.name)\n    s.sdata = sdata\n    s.errh = errh || null\n    s.mode = mode\n  \n    s.ch = 0x20 /*' '*/\n    s.tok = token.EOF\n    s.offset = 0\n    s.rdOffset = 0\n    s.lineOffset = 0\n    s.insertSemi = false\n    s.errorCount = 0\n    s.parenL = 0\n    s.interpStrL = 0\n    s.byteval = null\n  \n    s.readchar()\n  }\n\n  // setOffset sets the read offset.\n  // it's only safe to call this outside of next() and readchar()\n  //\n  setOffset(offs :int) {\n    const s = this\n    s.offset = s.rdOffset = offs\n  }\n\n  private _r :utf8.DecodeResult = {c:0,w:0}\n\n  // Read the next Unicode char into s.ch.\n  // s.ch < 0 means end-of-file.\n  private readchar() {\n    const s = this\n\n    if (s.rdOffset < s.sdata.length) {\n      s.offset = s.rdOffset\n      \n      if (s.ch == 0xA /*\\n*/ ) {\n        s.lineOffset = s.offset\n        s.sfile.addLine(s.offset)\n      }\n\n      s._r.w = 1\n      s._r.c = s.sdata[s.rdOffset]\n\n      if (s._r.c >= 0x80) {\n        // uncommon case: non-ASCII character\n        if (!utf8.decode(s.sdata, s.rdOffset, s._r)) {\n          s.errorAtOffs('invalid UTF-8 encoding', s.offset)\n        } else if (s._r.c == 0) {\n          s.errorAtOffs('illegal NUL byte in input', s.offset)\n        }\n      }\n\n      s.rdOffset += s._r.w\n      s.ch = s._r.c\n    } else {\n      s.offset = s.sdata.length\n      if (s.ch == 0xA /*\\n*/) {\n        s.lineOffset = s.offset\n        s.sfile.addLine(s.offset)\n      }\n      s.ch = -1 // eof\n    }\n  }\n\n  // undobyte \"puts back\" the last-read byte.\n  // note that this does NOT fully update scanner state -- after calling this\n  // function, you should either call readchar() to update s.ch and s.offset\n  // or call next().\n  //\n  private undobyte() {\n    const s = this\n    assert(s.ch < 0x80)\n    s.rdOffset -= 1\n    s.offset -= 1\n    s.endoffs = s.offset\n  }\n\n  // gotchar reads the next character and returns true if s.ch == ch\n  private gotchar(ch :int) :bool {\n    const s = this\n    if (s.ch == ch) {\n      s.readchar()\n      return true\n    }\n    return false\n  }\n\n  currentPosition() :Position {\n    const s = this\n    return s.sfile.position(s.sfile.pos(s.offset))\n  }\n\n  // byteValue returns a byte buffer representing the literal value of the\n  // current token.\n  // Note that this method returns a byte buffer that is potentially referenced\n  // internally and which value might change next time s.scan is called. If you\n  // plan to keep referencing the byte buffer, use s.takeByteValue instead.\n  //\n  byteValue() :Uint8Array {\n    const s = this\n    const end = s.endoffs == -1 ? s.offset : s.endoffs\n    return s.byteval || s.sdata.subarray(s.startoffs, end)\n  }\n\n  // takeByteValue returns a new byte buffer that is not referenced by\n  // the scanner. The buffer is still immutable.\n  //\n  takeByteValue() :Uint8Array {\n    const s = this\n    const b = s.byteValue()\n    s.byteval = null\n    return (this.mode & Mode.CopySource) ? b.slice() : b\n  }\n\n  // Increment errorCount and call any error handler\n  //\n  error(msg :string, pos :Pos = this.pos, code? :ErrorCode) {\n    const s = this\n    s.errorAt(msg, s.sfile.position(pos), code)\n  }\n\n  errorAtOffs(msg :string, offs :int, code? :ErrorCode) {\n    const s = this\n    s.errorAt(msg, s.sfile.position(s.sfile.pos(offs)), code)\n  }\n\n  // Scan the next token\n  //\n  next() {\n  while (true) {\n    const s = this\n\n    if (s.istrOne == istrOne.OFF) {\n      // skip whitespace\n      while (\n        s.ch == 0x20 ||\n        s.ch == 0x9 ||\n        (s.ch == 0xA && !s.insertSemi) ||\n        s.ch == 0xD\n      ) {\n        s.readchar()\n      }\n    }\n\n    // current token start\n    s.pos = s.sfile.pos(s.offset)\n    s.startoffs = s.offset\n    s.endoffs = -1\n    s.byteval = null\n\n    if (s.istrOne == istrOne.CONT) {\n      // continue interpolated string\n      s.istrOne = istrOne.OFF\n      s.startoffs-- // b/c scanString increments it, assuming it's skipping `\"`\n      s.tok = s.scanString()\n      s.insertSemi = s.tok != token.STRING_PIECE\n      return\n    } else if (s.istrOne == istrOne.WAIT) {\n      // we are about to scan a single token following $ in a string template\n      s.istrOne = istrOne.CONT\n    }\n\n    // make progress\n    const ch = s.ch\n    s.readchar()\n\n    let insertSemi = false\n\n    switch (ch) {\n\n      case -1: {\n        s.tok = s.insertSemi ? token.SEMICOLON : token.EOF\n        break\n      }\n\n      case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:\n      case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:\n        // 0..9\n        s.scanNumber(ch)\n        insertSemi = true\n        break\n\n      case 0xA: { // \\n\n        // we only reach here if s.insertSemi was set in the first place\n        // and exited early from skipping whitespace.\n        // newline consumed\n        s.tok = token.SEMICOLON\n        break\n      }\n\n      case 0x22: // \"\n        s.tok = s.scanString()\n        insertSemi = s.tok != token.STRING_PIECE\n        break\n\n      case 0x27: // '\n        s.scanChar()\n        insertSemi = true\n        break\n\n      case 0x3a: // :\n        if (s.gotchar(0x3D)) {\n          s.tok = token.SET_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.COLON\n        }\n        break\n\n      case 0x2e: { // .\n        if (\n          isDigit(s.ch) &&\n          s.tok != token.NAME &&\n          s.tok != token.RPAREN &&\n          s.tok != token.RBRACKET\n        ) {\n          // Note: We check for NAME so that:\n          //   x.1 => (selector (name x) (int 1))\n          //   ).1 => (selector (name x) (int 1))\n          //   ].1 => (selector (name x) (int 1))\n          //   .1  => (float 0.1)\n          s.scanFloatNumber(/*seenDecimal*/true)\n          insertSemi = true\n        } else {\n          if (s.gotchar(0x2e)) { // ..\n            if (s.gotchar(0x2e)) { // ...\n              s.tok = token.ELLIPSIS\n            } else {\n              s.tok = token.PERIODS\n            }\n          } else {\n            s.tok = token.DOT\n          }\n        }\n        break\n      }\n\n      case 0x40: { // @\n        s.startoffs++ // skip @\n        let c = s.ch\n        if (c < utf8.UniSelf && (asciiFeats[c] & langIdentStart)) {\n          s.readchar()\n          s.scanIdentifier(c)\n        } else if (c >= utf8.UniSelf && isUniIdentStart(c)) {\n          s.readchar()\n          s.scanIdentifierU(c, this.startoffs)\n        }\n        s.tok = token.NAMEAT\n        insertSemi = true\n        break\n      }\n\n      case 0x2c: // ,\n        s.tok = token.COMMA\n        break\n      case 0x3b: // ;\n        s.tok = token.SEMICOLON\n        break\n\n      case 0x28: // (\n        if (s.interpStrL) {\n          s.parenL++\n        }\n        s.tok = token.LPAREN\n        break\n      case 0x29: // )\n        s.tok = token.RPAREN\n        insertSemi = true\n        if (s.interpStrL) {\n          if (s.parenL == 0) {\n            // continue interpolated string\n            s.interpStrL--\n            s.tok = s.scanString()\n            insertSemi = s.tok != token.STRING_PIECE\n          } else {\n            s.parenL--\n          }\n        }\n        break\n\n      case 0x5b: // [\n        s.tok = token.LBRACKET\n        break\n      case 0x5d: // ]\n        s.tok = token.RBRACKET\n        insertSemi = true\n        break\n\n      case 0x7b: // {\n        s.tok = token.LBRACE\n        break\n      case 0x7d: // }\n        s.tok = token.RBRACE\n        insertSemi = true\n        break\n\n      case 0x2B: { // +\n        s.prec = prec.LOWEST\n        if (s.gotchar(0x3D)) { // +=\n          s.tok = token.ADD_ASSIGN\n        } else if (s.gotchar(ch)) { // ++\n          s.tok = token.INC\n          insertSemi = true\n        } else {\n          s.tok = token.ADD\n          s.prec = prec.ADD\n        }\n        break\n      }\n\n      case 0x2D: { // -\n        s.prec = prec.LOWEST\n        if (s.gotchar(0x3e)) { // ->\n          s.tok = token.ARROWR\n        } else {\n          if (s.gotchar(0x3D)) { // -=\n            s.tok = token.SUB_ASSIGN\n          } else if (s.gotchar(ch)) { // --\n            s.tok = token.DEC\n            insertSemi = true\n          } else {\n            s.tok = token.SUB\n            s.prec = prec.ADD\n          }\n        }\n        break\n      }\n\n      case 0x2a: // *\n        if (s.gotchar(0x3D)) { // *=\n          s.tok = token.MUL_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.MUL\n          s.prec = prec.MUL\n        }\n        break\n\n      case 0x2f: { // /\n        if (s.ch == 0x2f) { // //\n          s.scanLineComment()\n          if (!(s.mode & Mode.ScanComments)) {\n            continue\n          }\n          insertSemi = s.insertSemi // persist s.insertSemi\n        } else if (s.ch == 0x2a) { // /*\n          const CRcount = s.scanGeneralComment()\n          if (s.mode & Mode.ScanComments) {\n            s.tok = token.COMMENT\n            if (CRcount) {\n              // strip CR characters from comment\n              const v = s.sdata.subarray(\n                s.startoffs,\n                s.endoffs == -1 ? s.offset : s.endoffs\n              )\n              s.byteval = stripByte(v, 0xD, CRcount) // copy; no mutation\n            }\n          } else {\n            continue\n          }\n          insertSemi = s.insertSemi // persist s.insertSemi\n        } else {\n          if (s.gotchar(0x3D)) { // /=\n            s.tok = token.QUO_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.QUO\n            s.prec = prec.MUL\n          }\n        }\n        break\n      }\n\n      case 0x25: // %\n        if (s.gotchar(0x3D)) { // %=\n          s.tok = token.REM_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.REM\n          s.prec = prec.MUL\n        }\n        break\n\n      case 0x5e: // ^\n        if (s.gotchar(0x3D)) { // ^=\n          s.tok = token.XOR_ASSIGN\n          s.prec = prec.LOWEST\n        } else {\n          s.tok = token.XOR\n          s.prec = prec.ADD\n        }\n        break\n\n      case 0x3c: { // <\n        if (s.gotchar(0x2D)) { // <-\n          s.tok = token.ARROWL\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(0x3D)) { // <=\n          s.tok = token.LEQ\n          s.prec = prec.CMP\n        } else if (s.gotchar(ch)) { // <<\n          if (s.gotchar(0x3D)) { // <<=\n            s.tok = token.SHL_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.SHL\n            s.prec = prec.MUL\n          }\n        } else {\n          s.tok = token.LSS\n          s.prec = prec.CMP\n        }\n        break\n      }\n\n      case 0x3E: // >\n        if (s.gotchar(0x3D)) { // >=\n          s.tok = token.GEQ\n          s.prec = prec.CMP\n        } else if (s.gotchar(ch)) { // >>\n          if (s.gotchar(0x3D)) { // >>=\n            s.tok = token.SHR_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.SHR\n            s.prec = prec.MUL\n          }\n        } else {\n          s.tok = token.GTR\n          s.prec = prec.CMP\n        }\n        break\n      \n      case 0x3D: // =\n        if (s.gotchar(0x3D)) { // ==\n          s.tok = token.EQL\n          s.prec = prec.CMP\n        } else {\n          s.tok = token.ASSIGN\n          s.prec = prec.LOWEST\n        }\n        break\n\n      case 0x21: // !\n        if (s.gotchar(0x3D)) { // !=\n          s.tok = token.NEQ\n          s.prec = prec.CMP\n        } else {\n          s.tok = token.NOT\n          s.prec = prec.LOWEST\n        }\n        break\n\n      case 0x26: { // &\n        if (s.gotchar(0x5E)) { // &^\n          if (s.gotchar(0x3D)) { // &^=\n            s.tok = token.AND_NOT_ASSIGN\n            s.prec = prec.LOWEST\n          } else {\n            s.tok = token.AND_NOT\n            s.prec = prec.MUL\n          }\n        } else if (s.gotchar(0x3D)) { // &=\n          s.tok = token.AND_ASSIGN\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(ch)) { // &&\n          s.tok = token.ANDAND\n          s.prec = prec.ANDAND\n        } else {\n          s.tok = token.AND\n          s.prec = prec.MUL\n        }\n        break\n      }\n\n      case 0x7c: // |\n        if (s.gotchar(0x3D)) { // |=\n          s.tok = token.OR_ASSIGN\n          s.prec = prec.LOWEST\n        } else if (s.gotchar(ch)) { // ||\n          s.tok = token.OROR\n          s.prec = prec.OROR\n        } else {\n          s.tok = token.OR\n          s.prec = prec.ADD\n        }\n        break\n\n      default: {\n        if (\n          (ch < utf8.UniSelf && (asciiFeats[ch] & langIdentStart)) ||\n          (ch >= utf8.UniSelf && isUniIdentStart(ch))\n        ) {\n          if (ch < utf8.UniSelf) {\n            s.scanIdentifier(ch)\n          } else {\n            s.scanIdentifierU(ch, this.startoffs)\n          }\n\n          if (s.offset - s.startoffs > 1) {\n            // shortest keyword is 2\n            switch (s.tok = lookupKeyword(s.byteValue())) {\n              case token.NAME:\n              case token.BREAK:\n              case token.CONTINUE:\n              case token.FALLTHROUGH:\n              case token.RETURN:\n                insertSemi = true\n                break\n            }\n          } else {\n            s.tok = token.NAME\n            insertSemi = true\n          }\n        } else {\n          s.error(`unexpected character ${unicode.repr(ch)} in input`)\n          s.tok = token.ILLEGAL\n        }\n        break\n      }\n\n    } // switch (ch)\n\n    if (s.endoffs == -1) {\n      s.endoffs = s.offset\n    }\n\n    s.insertSemi = insertSemi\n\n    // console.log(\n    //   `-> ${tokstr(s.tok)} \"${utf8.decodeToString(s.byteValue())}\"`)\n    return\n\n    } // while(true)\n  }\n\n\n  scanIdentifierU(c :int, hashOffs :int, hash :int = 0x811c9dc5) {\n    // Scan identifier with non-ASCII characters.\n    // c is already verified to be a valid indentifier character.\n    // Hash is calculated as a second pass at the end.\n    const s = this\n    const ZeroWidthJoiner = 0x200D\n    let lastCp = c\n    c = s.ch\n\n    while (\n      isUniIdentCont(c) ||\n      unicode.isEmojiModifier(c) ||\n      unicode.isEmojiModifierBase(c) ||\n      c == ZeroWidthJoiner\n    ) {\n      if (lastCp == 0x2D && c == 0x2D) { // --\n        s.undobyte() // \"put back\" the \"-\" byte\n        break\n      }\n      lastCp = c\n      s.readchar()\n      c = s.ch\n    }\n\n    if (lastCp == ZeroWidthJoiner) {\n      s.error(`illegal zero width-joiner character at end of identifer`)\n      s.tok = token.ILLEGAL\n      return\n    }\n\n    // computing rest of hash\n    for (let i = hashOffs; i < s.offset; ++i) {\n      hash = (hash ^ s.sdata[i]) * 0x1000193 // fnv1a\n    }\n    s.hash = hash >>> 0\n  }\n\n  scanIdentifier(c :int) {\n    // enters past first char; c = 1st char, s.ch = 2nd char\n    // c is already verified to be a valid indentifier character.\n    // The hash function used here must exactly match what's in bytestr.\n    const s = this\n    let hash = (0x811c9dc5 ^ c) * 0x1000193 // fnv1a\n\n    c = s.ch\n    while (\n      isLetter(c) ||\n      isDigit(c) ||\n      c == 0x2D || // -\n      c == 0x5F || // _\n      c == 0x24    // $\n    ) {\n      s.readchar()\n      if (c == 0x2D && s.ch == 0x2D) { // --\n        s.undobyte() // \"put back\" the \"-\" byte\n        break\n      }\n      hash = (hash ^ c) * 0x1000193 // fnv1a\n      c = s.ch\n    }\n\n    if (c >= utf8.UniSelf && isUniIdentCont(c)) {\n      return s.scanIdentifierU(c, s.offset, hash)\n    }\n\n    s.hash = hash >>> 0\n  }\n\n  scanChar() {\n    const s = this\n    let cp = -1\n    s.tok = token.CHAR\n\n    switch (s.ch) {\n      case -1: case 0xA: { // EOF | \\n\n        s.error(\"unterminated character literal\")\n        s.tok = token.ILLEGAL\n        return\n      }\n      case 0x27: { // '\n        s.error(\"empty character literal or unescaped ' in character literal\")\n        s.readchar()\n        s.intval = unicode.InvalidChar\n        return\n      }\n      case 0x5c: { // \\\n        s.readchar()\n        cp = s.scanEscape(0x27) // '\n        // note: cp is -1 for illegal escape sequences\n        break\n      }\n      default: {\n        cp = s.ch\n        s.readchar()\n        break\n      }\n    }\n\n\n    if (s.ch == 0x27) { // '\n      s.readchar()\n      s.intval = cp\n    } else {\n      // failed -- read until EOF or '\n      while (true) {\n        if (s.ch == -1) {\n          break\n        }\n        if (s.ch == 0x27) { // '\n          s.readchar() // consume '\n          break\n        }\n        s.readchar()\n      }\n      s.intval = unicode.InvalidChar\n      s.error(\"invalid character literal\")\n    }\n  }\n\n  resetAppendBuf() :AppendBuffer {\n    const s = this\n    if (s.appendbuf) {\n      s.appendbuf.reset()\n    } else {\n      // we need to buffer the value since it's not a 1:1 literal\n      s.appendbuf = new AppendBuffer(64)\n    }\n    return s.appendbuf\n  }\n\n  scanString() :token {\n    // opening char already consumed\n    const s = this\n    let buf :AppendBuffer|null = null\n    s.startoffs++ // skip initial \"\n    let chunkStart = s.startoffs\n    let tok = token.STRING\n\n    loop1:\n    while (true) {\n      switch (s.ch) {\n        case -1:\n          s.error(\"string literal not terminated\")\n          if (buf) {\n            buf = null\n          }\n          break loop1\n\n        case 0x22: // \"\n          if (buf) {\n            buf.appendRange(s.sdata, chunkStart, s.offset)\n          }\n          s.readchar()\n          break loop1\n\n        case 0x5c: { // \\\n          // we need to buffer the value since it's not a 1:1 literal\n          if (!buf) {\n            buf = s.resetAppendBuf()\n          }\n\n          if (chunkStart != s.offset) {\n            buf.appendRange(s.sdata, chunkStart, s.offset)\n          }\n\n          s.readchar()\n          const ch = s.ch as int // e.g. \"u\", \"x\", etc\n          const n = s.scanEscape(0x22) // \"\n\n          // we continue even if there was an error\n          if (n >= 0) {\n            if (n >= utf8.UniSelf && (ch == 0x75 || ch == 0x55)) { // u | U\n              // Write unicode code point as UTF8 to value buffer\n              if (0xD800 <= n && n <= 0xE000) {\n                s.error(\"illegal: surrogate half in string literal\")\n              } else if (n > unicode.MaxRune) {\n                s.error(\"escape sequence is invalid Unicode code point\")\n              }\n              buf.reserve(utf8.UTFMax)\n              buf.length += utf8.encode(buf.buffer, buf.length, n)\n            } else {\n              buf.append(n)\n            }\n          }\n\n          chunkStart = s.offset\n          break\n        }\n\n        case 0x24: { // $\n          s.readchar()\n          // start interpolated string\n\n          if (buf) {\n            s.byteval = buf.subarray()\n          }\n\n          if (s.gotchar(0x28)) { // (\n            // don't close until we see a balanced closing ')'\n            s.interpStrL++\n            s.endoffs = s.offset - 2 // exclude `$(`\n          } else if (s.ch as int == 0x22) { // \"\n            // \"foo $\"bar\"\" is invalid -- hard to read, hard to parse.\n            // (\"foo $(\"bar\")\" _is_ valid however.)\n            s.error(\n              \"invalid \\\" in string template — string literals inside string \" +\n              \"templates need to be enclosed in parenthesis\"\n            )\n            break // consume\n          } else {\n            // expect a single token to follow\n            s.endoffs = s.offset - 1 // exclude `$`\n            s.istrOne = istrOne.WAIT\n          }\n          return token.STRING_PIECE\n        }\n\n        case 0xA: // \\n\n          tok = token.STRING_MULTI\n          s.readchar()\n          break\n\n        default:\n          s.readchar()\n      }\n    }\n\n    if (buf) {\n      s.byteval = buf.subarray()\n    } else {\n      s.endoffs = s.offset - 1\n    }\n\n    return tok\n  }\n\n  // scanEscape parses an escape sequence where `quote` is the accepted\n  // escaped character. In case of a syntax error, it stops at the offending\n  // character (without consuming it) and returns -1.\n  // Otherwise it returns the unicode codepoint for \\u and \\U, and returns a\n  // byte value for all other escape sequences.\n  //\n  scanEscape(quote :int) :int {\n    const s = this\n\n    let n :int = 0\n    let base :int = 0\n\n    switch (s.ch) {\n      case quote: s.readchar(); return quote\n      case 0x30:  s.readchar(); return 0    // 0 - null\n      case 0x61:  s.readchar(); return 0x7  // a - alert or bell\n      case 0x62:  s.readchar(); return 0x8  // b - backspace\n      case 0x66:  s.readchar(); return 0xC  // f - form feed\n      case 0x6e:  s.readchar(); return 0xA  // n - line feed or newline\n      case 0x72:  s.readchar(); return 0xD  // r - carriage return\n      case 0x74:  s.readchar(); return 0x9  // t - horizontal tab\n      case 0x76:  s.readchar(); return 0xb  // v - vertical tab\n      case 0x5c:  s.readchar(); return 0x5c // \\\n      case 0x24:  s.readchar(); return 0x24 // $\n      case 0x78:  s.readchar(); n = 2; base = 16; break // x\n      case 0x75:  s.readchar(); n = 4; base = 16; break // u\n      case 0x55:  s.readchar(); n = 8; base = 16; break // U\n      default: {\n        let msg = \"unknown escape sequence\"\n        if (s.ch < 0) {\n          msg = \"escape sequence not terminated\"\n        }\n        s.error(msg)\n        return -1\n      }\n    }\n\n    let cp :int = 0\n    while (n > 0) {\n      let d = digitVal(s.ch) // returns a large value for non-digit chars\n      if (d >= base) {\n        let msg = (\n          (s.ch == quote) ? \"escape sequence incomplete\" :\n          (s.ch < 0) ? \"escape sequence not terminated\" :\n            `illegal character ${unicode.repr(s.ch)} in escape sequence`\n        )\n        s.errorAtOffs(msg, s.offset)\n        return -1\n      }\n      cp = cp * base + d\n      s.readchar()\n      n--\n    }\n\n    return cp\n  }\n\n  scanNumber(c :int) {\n    let s = this\n\n    if (c == 0x30) { // 0\n      switch (s.ch) {\n\n        case 0x78: case 0x58: { // x, X\n          s.tok = token.INT_HEX\n          s.readchar()\n          while (isHexDigit(s.ch)) {\n            s.readchar()\n          }\n          if (s.offset - s.startoffs <= 2 || unicode.isLetter(s.ch)) {\n            // only scanned \"0x\" or \"0X\" OR e.g. 0xfg\n            while (unicode.isLetter(s.ch) || unicode.isDigit(s.ch)) {\n              s.readchar() // consume invalid letters & digits\n            }\n            s.error(\"invalid hex number\")\n          }\n          return\n        }\n\n        case 0x6F: case 0x4F: // o, O\n          s.tok = token.INT_OCT\n          return s.scanRadixInt8(8)\n\n        case 0x62: case 0x42: // b, B\n          s.tok = token.INT_BIN\n          return s.scanRadixInt8(2)\n\n        case 0x2e: case 0x65: case 0x45:  // . e E\n          return s.scanFloatNumber(/*seenDecimal*/false)\n\n        case 0x2f:  // /\n          if (s.scanRatioNumber()) {\n            // i.e. 0/N\n            s.error(\"invalid zero ratio\")\n            return\n          }\n          break\n      }\n    }\n\n    while (unicode.isDigit(s.ch)) {\n      s.readchar()\n    }\n    s.tok = token.INT\n\n    switch (s.ch) {\n      case 0x2e: case 0x65: case 0x45:  // . e E\n        s.scanFloatNumber(/*seenDecimal*/false)\n        break\n\n      case 0x2f:  // /\n        s.scanRatioNumber()\n        break\n    }\n  }\n\n  scanRadixInt8(base :int) {\n    // invariant: base = 8 | 2\n    const s = this\n    s.readchar()\n    let isInvalid = false\n    while (unicode.isDigit(s.ch)) {\n      if (s.ch - 0x30 >= base) {\n        // e.g. 0o678\n        isInvalid = true\n      }\n      s.readchar()\n    }\n    if (isInvalid || s.offset - s.startoffs <= 2) {\n      // isInvalid OR only scanned \"0x\"\n      s.error(`invalid ${base == 8 ? \"octal\" : \"binary\"} number`)\n    }\n  }\n\n  scanRatioNumber() :bool {\n    // ratio_lit = decimals \"/\" decimals\n    const s = this\n    const startoffs = s.offset\n    s.readchar() // consume /\n    while (unicode.isDigit(s.ch)) {\n      s.readchar()\n    }\n    if (startoffs+1 == s.offset) {\n      // e.g. 43/* 43/= etc -- restore state\n      s.ch = 0x2f // /\n      s.offset = startoffs\n      s.rdOffset = s.offset + 1\n      return false\n    }\n    if (s.ch == 0x2e) { // .\n      s.error(\"invalid ratio\")\n    }\n    s.tok = token.RATIO\n    return true\n  }\n\n  scanFloatNumber(seenDecimal :bool) {\n    // float_lit = decimals \".\" [ decimals ] [ exponent ] |\n    //             decimals exponent |\n    //             \".\" decimals [ exponent ] .\n    // decimals  = decimal_digit { decimal_digit } .\n    // exponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals .\n    const s = this\n\n    if (seenDecimal || s.ch == 0x2e) { // .\n      s.readchar()\n      while (unicode.isDigit(s.ch)) {\n        s.readchar()\n      }\n    }\n\n    if (s.ch == 0x65 || s.ch == 0x45) { // e E\n      s.readchar()\n      if ((s.ch as int) == 0x2D || (s.ch as int) == 0x2B) { // - +\n        s.readchar()\n      }\n      let valid = false\n      while (unicode.isDigit(s.ch)) {\n        valid = true\n        s.readchar()\n      }\n      if (!valid) {\n        s.error(\"invalid floating-point exponent\")\n      }\n    }\n\n    s.tok = token.FLOAT\n  }\n\n  scanLineComment() {\n    const s = this\n    // initial '/' already consumed; s.ch == '/'\n    do { s.readchar() } while (s.ch != 0xA && s.ch >= 0)\n\n    if (s.sdata[s.offset-1] == 0xD) { // \\r\n      // don't include \\r in comment\n      s.endoffs = s.offset - 1\n    }\n\n    if (s.startoffs == s.lineOffset && s.sdata[s.startoffs + 2] == 0x21) { // !\n      // comment pragma, e.g. //!foo\n      s.interpretCommentPragma()\n    }\n\n    s.startoffs += 2 // skip //\n    s.tok = token.COMMENT\n  }\n\n  scanGeneralComment() :int /* CR count */ {\n    // initial '/' already consumed; s.ch == '*'\n    const s = this\n    let CR_count = 0\n\n    while (true) {\n      s.readchar()\n      switch (s.ch) {\n        case -1: // EOF\n          s.error(\"comment not terminated\")\n          return CR_count\n        case 0x2f: // /\n          if (s.sdata[s.offset-1] == 0x2a) { // *\n            s.readchar()\n            s.startoffs += 2\n            s.endoffs = s.offset - 2\n            return CR_count\n          }\n          break\n        case 0xD: // \\r\n          ++CR_count\n          break\n        default:\n          break\n      }\n    }\n  }\n\n  findCommentLineEnd() :bool {\n    // initial '/' already consumed; s.ch == '*'\n    const s = this\n    \n    // save state\n    const enterOffset = s.offset\n\n    while (true) {\n      const ch = s.ch\n      s.readchar()\n      switch (ch) {\n        case -1: // EOF\n        case 0xA: // \\n\n          return true\n        case 0x2a: // *\n          if (s.ch == 0x2f) { // /\n            // restore state\n            s.ch = 0x2a\n            s.offset = enterOffset\n            s.rdOffset = s.offset + 1\n            return false\n          }\n          break\n        default:\n          break\n      }\n    }\n  }\n  \n  interpretCommentPragma() {\n    const s = this\n    const offs = s.startoffs\n    if ( s.offset - offs > linePrefix.length &&\n         bufcmp(s.sdata, linePrefix, offs, offs + linePrefix.length) == 0\n    ) {\n      // get filename and line number, if any\n      // e.g. \"//!line file name:line\"\n      let text = utf8.decodeToString(\n        s.sdata.subarray(offs + linePrefix.length, s.offset)\n      )\n      /// --- here--- the above doesnt work on uintarray.\n      // we need to decode sdata to a js string\n      let i = text.lastIndexOf(':')\n      if (i > 0) {\n        let line = parseInt(text.substr(i+1))\n        if (!isNaN(line) && line > 0) {\n          // valid //!line filename:line comment\n          let filename = text.substr(0, i).trim()\n          if (filename) {\n            filename = path.clean(filename)\n            if (!path.isAbs(filename)) {\n              // make filename relative to current directory\n              filename = path.join(s.dir, filename)\n            }\n          }\n          // update scanner position\n          s.sfile.addLineInfo(s.offset + 1, filename, line)\n            // +1 since comment applies to next line\n        }\n      }\n    }\n  }\n\n  findLineEnd() :bool {\n    // initial '/' already consumed; enters with s.ch == '*'\n    const s = this\n  \n    // read ahead until a newline, EOF, or non-comment token is found\n    while (s.ch == 0x2f || s.ch == 0x2a) { // / *\n      if (s.ch == 0x2f) { // /\n        //-style comment always contains a newline\n        return true\n      }\n\n      /*-style comment: look for newline */\n      s.readchar()\n      while (s.ch >= 0) {\n        const ch = s.ch as int\n        if (ch == 0xA) { // \\n\n          return true\n        }\n        s.readchar()\n        if (ch == 0x2a && s.ch as int == 0x2f) { // */\n          s.readchar()\n          break\n        }\n      }\n\n      // skip whitespace\n      while (\n        s.ch as int == 0x20 || // ' '\n        s.ch as int == 0x9 || // \\t\n        (s.ch as int == 0xA && !s.insertSemi) || // \\n\n        s.ch as int == 0xD) // \\r\n      {\n        s.readchar()\n      }\n\n      if (s.ch < 0 || s.ch as int == 0xA) { // \\n\n        return true\n      }\n\n      if (s.ch as int != 0x2f) { // /\n        // non-comment token\n        return false\n      }\n\n      s.readchar() // consume '/'\n    }\n  \n    return false\n  }\n\n}\n\n\nfunction digitVal(ch :int) :int {\n  return (\n    0x30 <= ch && ch <= 0x39 ? ch - 0x30 :      // 0..9\n    0x61 <= ch && ch <= 0x66 ? ch - 0x61 + 10 : // a..f\n    0x41 <= ch && ch <= 0x46 ? ch - 0x41 + 10 : // A..F\n    16 // larger than any legal digit val\n  )\n}\n\n\nfunction stripByte(v :Uint8Array, b :byte, countHint :int = 0) :Uint8Array {\n  const c = new Uint8Array(v.length - countHint)\n  let i = 0\n  for (let x = 0, L = v.length; x < L; ++x) {\n    const _b = v[x]\n    if (_b != b) { // \\r\n      c[i++] = _b\n    }\n  }\n  return i < c.length ? c.subarray(0, i) : c\n}\n\nfunction isLetter(c :int) :bool {\n  return (\n    (0x41 <= c && c <= 0x5A) || // A..Z\n    (0x61 <= c && c <= 0x7A)  // a..z\n  )\n}\n\nfunction isDigit(c :int) :bool {\n  return 0x30 <= c && c <= 0x39 // 0..9\n}\n\nfunction isHexDigit(c :int) :bool {\n  return (\n    (0x30 <= c && c <= 0x39) || // 0..9\n    (0x41 <= c && c <= 0x46) || // A..F\n    (0x61 <= c && c <= 0x66)    // a..f\n  )\n}\n\nfunction isUniIdentStart(c :int) :bool {\n  return (\n    unicode.isLetter(c) ||\n    c == 0x5F || // _\n    c == 0x24 || // $\n    unicode.isEmojiPresentation(c) ||\n    unicode.isEmojiModifierBase(c)\n  )\n}\n\nfunction isUniIdentCont(c :int) :bool {\n  return (\n    unicode.isLetter(c) ||\n    unicode.isDigit(c) ||\n    c == 0x2D || // -\n    c == 0x5F || // _\n    c == 0x24 || // $\n    unicode.isEmojiPresentation(c) ||\n    unicode.isEmojiModifierBase(c)\n  )\n}\n\nconst\n  langIdent = 1<< 1 -1,\n  langIdentStart = 1<< 2 -1\n\n// must smaller than utf8.UniSelf\nconst asciiFeats = new Uint8Array([\n  /* 0    0  NUL */ 0,\n  /* 1    1  SOH */ 0,\n  /* 2    2  STX */ 0,\n  /* 3    3  ETX */ 0,\n  /* 4    4  EOT */ 0,\n  /* 5    5  ENQ */ 0,\n  /* 6    6  ACK */ 0,\n  /* 7    7  BEL */ 0,\n  /* 8    8  BS  */ 0,\n  /* 9    9  TAB */ 0,\n  /* 10   A  LF  */ 0,\n  /* 11   B  VT  */ 0,\n  /* 12   C  FF  */ 0,\n  /* 13   D  CR  */ 0,\n  /* 14   E  SO  */ 0,\n  /* 15   F  SI  */ 0,\n  /* 16  10  DLE */ 0,\n  /* 17  11  DC1 */ 0,\n  /* 18  12  DC2 */ 0,\n  /* 19  13  DC3 */ 0,\n  /* 20  14  DC4 */ 0,\n  /* 21  15  NAK */ 0,\n  /* 22  16  SYN */ 0,\n  /* 23  17  ETB */ 0,\n  /* 24  18  CAN */ 0,\n  /* 25  19  EM  */ 0,\n  /* 26  1A  SUB */ 0,\n  /* 27  1B  ESC */ 0,\n  /* 28  1C  FS  */ 0,\n  /* 29  1D  GS  */ 0,\n  /* 30  1E  RS  */ 0,\n  /* 31  1F  US  */ 0,\n  /* 32  20  SP  */ 0,\n  /* 33  21  !   */ 0,\n  /* 34  22  \"   */ 0,\n  /* 35  23  #   */ 0,\n  /* 36  24  $   */ langIdent | langIdentStart,\n  /* 37  25  %   */ 0,\n  /* 38  26  &   */ 0,\n  /* 39  27  '   */ 0,\n  /* 40  28  (   */ 0,\n  /* 41  29  )   */ 0,\n  /* 42  2A  *   */ 0,\n  /* 43  2B  +   */ 0,\n  /* 44  2C  ,   */ 0,\n  /* 45  2D  -   */ 0,\n  /* 46  2E  .   */ 0,\n  /* 47  2F  /   */ 0,\n  /* 48  30  0   */ langIdent,\n  /* 49  31  1   */ langIdent,\n  /* 50  32  2   */ langIdent,\n  /* 51  33  3   */ langIdent,\n  /* 52  34  4   */ langIdent,\n  /* 53  35  5   */ langIdent,\n  /* 54  36  6   */ langIdent,\n  /* 55  37  7   */ langIdent,\n  /* 56  38  8   */ langIdent,\n  /* 57  39  9   */ langIdent,\n  /* 58  3A  :   */ 0,\n  /* 59  3B  ;   */ 0,\n  /* 60  3C  <   */ 0,\n  /* 61  3D  =   */ 0,\n  /* 62  3E  >   */ 0,\n  /* 63  3F  ?   */ 0,\n  /* 64  40  @   */ 0,\n  /* 65  41  A   */ langIdent | langIdentStart,\n  /* 66  42  B   */ langIdent | langIdentStart,\n  /* 67  43  C   */ langIdent | langIdentStart,\n  /* 68  44  D   */ langIdent | langIdentStart,\n  /* 69  45  E   */ langIdent | langIdentStart,\n  /* 70  46  F   */ langIdent | langIdentStart,\n  /* 71  47  G   */ langIdent | langIdentStart,\n  /* 72  48  H   */ langIdent | langIdentStart,\n  /* 73  49  I   */ langIdent | langIdentStart,\n  /* 74  4A  J   */ langIdent | langIdentStart,\n  /* 75  4B  K   */ langIdent | langIdentStart,\n  /* 76  4C  L   */ langIdent | langIdentStart,\n  /* 77  4D  M   */ langIdent | langIdentStart,\n  /* 78  4E  N   */ langIdent | langIdentStart,\n  /* 79  4F  O   */ langIdent | langIdentStart,\n  /* 80  50  P   */ langIdent | langIdentStart,\n  /* 81  51  Q   */ langIdent | langIdentStart,\n  /* 82  52  R   */ langIdent | langIdentStart,\n  /* 83  53  S   */ langIdent | langIdentStart,\n  /* 84  54  T   */ langIdent | langIdentStart,\n  /* 85  55  U   */ langIdent | langIdentStart,\n  /* 86  56  V   */ langIdent | langIdentStart,\n  /* 87  57  W   */ langIdent | langIdentStart,\n  /* 88  58  X   */ langIdent | langIdentStart,\n  /* 89  59  Y   */ langIdent | langIdentStart,\n  /* 90  5A  Z   */ langIdent | langIdentStart,\n  /* 91  5B  [   */ 0,\n  /* 92  5C  \\   */ 0,\n  /* 93  5D  ]   */ 0,\n  /* 94  5E  ^   */ 0,\n  /* 95  5F  _   */ langIdent | langIdentStart,\n  /* 96  60  `   */ 0,\n  /* 97  61  a   */ langIdent | langIdentStart,\n  /* 98  62  b   */ langIdent | langIdentStart,\n  /* 99  63  c   */ langIdent | langIdentStart,\n  /* 100 64  d   */ langIdent | langIdentStart,\n  /* 101 65  e   */ langIdent | langIdentStart,\n  /* 102 66  f   */ langIdent | langIdentStart,\n  /* 103 67  g   */ langIdent | langIdentStart,\n  /* 104 68  h   */ langIdent | langIdentStart,\n  /* 105 69  i   */ langIdent | langIdentStart,\n  /* 106 6A  j   */ langIdent | langIdentStart,\n  /* 107 6B  k   */ langIdent | langIdentStart,\n  /* 108 6C  l   */ langIdent | langIdentStart,\n  /* 109 6D  m   */ langIdent | langIdentStart,\n  /* 110 6E  n   */ langIdent | langIdentStart,\n  /* 111 6F  o   */ langIdent | langIdentStart,\n  /* 112 70  p   */ langIdent | langIdentStart,\n  /* 113 71  q   */ langIdent | langIdentStart,\n  /* 114 72  r   */ langIdent | langIdentStart,\n  /* 115 73  s   */ langIdent | langIdentStart,\n  /* 116 74  t   */ langIdent | langIdentStart,\n  /* 117 75  u   */ langIdent | langIdentStart,\n  /* 118 76  v   */ langIdent | langIdentStart,\n  /* 119 77  w   */ langIdent | langIdentStart,\n  /* 120 78  x   */ langIdent | langIdentStart,\n  /* 121 79  y   */ langIdent | langIdentStart,\n  /* 122 7A  z   */ langIdent | langIdentStart,\n  /* 123 7B  {   */ 0,\n  /* 124 7C  |   */ 0,\n  /* 125 7D  }   */ 0,\n  /* 126 7E  ~   */ 0,\n  /* 127 7F  DEL */ 0,\n])\n\n","\n// strtou parses an unsigned integer from a byte array.\n// The maximum value this function can produce is Number.MAX_SAFE_INTEGER\n//\n// Note on performance: In benchmarks with nodejs 8.1.3, this is roughly 2.5x\n// faster than parseInt(String.fromCharCode ...)\n//\nexport function strtou(b :ArrayLike<byte>, base :int, offs :int = 0) :int {\n  assert(base >= 2)\n  assert(base <= 36)\n\n  var end = b.length\n  var acc = 0 // accumulator\n  var any = 0\n  var cutoff = Math.floor(Number.MAX_SAFE_INTEGER / base)\n  var cutlim = Number.MAX_SAFE_INTEGER % base\n  var i = offs, c = 0\n\n  while (i < end) {\n    c = b[i]\n    if (c >= 0x30 && c <= 0x39) { // 0..9\n      c -= 0x30\n    } else if (c >= 0x41 && c <= 0x5A) { // A..Z\n      c -= 0x41 - 10\n    } else if (c >= 0x61 && c <= 0x7A) { // a..z\n      c -= 0x61 - 10\n    } else {\n      return -1\n    }\n\n    if (c >= base) {\n      return -1\n    }\n\n    if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {\n      any = -1\n    } else {\n      any = 1\n      acc = (acc * base) + c\n    }\n\n    i++\n  }\n\n  return (\n    ( any < 0 ||  // more digits than what fits in `max`\n      any == 0) ? -1 :\n    acc\n  )\n}\n\n\nTEST(\"strtou\", () => {\n  function t(input :string, base :int, expect :int) {\n    let buf = Uint8Array.from(\n      input as any as ArrayLike<number>,\n      (v: number, k: number) => input.charCodeAt(k)\n    )\n    let output = strtou(buf, base)\n    assert(\n      output === expect,\n      `strtou32(\"${input}\", ${base}) => ${output}; expected ${expect}`\n    )\n  }\n\n  t(\"0\", 10, 0)\n  t(\"000000000000\", 10, 0)\n  t(\"1\", 10, 1)\n  t(\"00000000000000000000000000000000000000000000000001\", 10, 1)\n  t(\"123\", 10, 123)\n  t(\"4294967295\", 10, 4294967295)  // 0xFFFFFFFF\n  t(Number.MAX_SAFE_INTEGER.toString(10), 10, Number.MAX_SAFE_INTEGER)\n  t((Number.MAX_SAFE_INTEGER+1).toString(10), 10, -1)\n\n  t(\"0\", 16, 0x0)\n  t(\"FF\", 16, 0xFF)\n  t(\"DEADBEEF\", 16, 0xDEADBEEF)\n  t(\"deadbeef\", 16, 0xdeadbeef)\n  t(\"dEaDbEef\", 16, 0xdeadbeef)\n  t(\"0000DEADBEEF\", 16, 0xDEADBEEF)\n\n  // invalid chars\n  t(\"x123\", 10, -1)\n  t(\"-123\", 10, -1)\n})\n","import { Pos, SrcFile } from './pos'\nimport { ByteStr } from './bytestr'\nimport { token, tokstr } from './token'\nimport * as utf8 from './utf8'\nimport { strtou } from './strtou'\n\n// ——————————————————————————————————————————————————————————————————\n// AST type hierarchy\n//\n//  Group\n//  Comment\n//  Node\n//    Field\n//    Stmt\n//      NoOpStmt\n//      Decl\n//        MultiDecl\n//        ImportDecl\n//        VarDecl\n//        TypeDecl\n//      ReturnStmt\n//      Expr\n//        Block\n//        Ident\n//        IfExpr\n//        LiteralExpr\n//        FunExpr\n//        Assignment\n//        ...\n//        Type\n//          ...\n//\n\nlet nextgid = 0\nexport class Group { id = nextgid++ } // nextgid only for DEBUG\n\nexport class Comment {\n  constructor(\n    public pos   :Pos,\n    public value :Uint8Array,\n  ) {}\n}\n\nexport class Node {\n  constructor(\n    public pos   :Pos,\n    public scope :Scope,\n    // public comments? :Comment[],\n  ) {}\n\n  toString() :string {\n    return this.constructor.name\n  }\n}\n\n// Ident Type\n//       Type\nexport class Field extends Node {\n  constructor(pos :Pos, scope :Scope,\n  public type :Expr,\n  public name :Ident|null,\n    // nil means anonymous field/parameter (structs/parameters),\n    // or embedded interface (interfaces)\n  ) {\n    super(pos, scope)\n  }\n}\n\n// ——————————————————————————————————————————————————————————————————\n// Scope\n\n// An Ent describes a named language entity such as a package,\n// constant, type, variable, function (incl. methods), or label.\n//\n// VARIABLES\n//\n//   decl\n//    | value\n//    ↓   ↓\n//    x = 0 ; x¹ = 3 ; print(x²)\n//            ↑              ↑\n//         writes++       reads.add(x²)\n//\n//\n// FUNCTIONS\n//\n//    fun a() { ... };  a¹()\n//    ~~~~~~~~~~~~~~~   ↑\n//           ↑       reads.add(a¹)\n//      decl==value\n//\n//\nexport class Ent {\n  writes :int = 0  // Tracks stores (SSA version). None == constant.\n  nreads :int = 0  // Tracks references to this ent. None == unused\n    // writes and reads does NOT include the definition/declaration itself.\n\n  constructor(\n    public name  :ByteStr,\n    public decl  :Node,\n    public value :Expr|null,\n    public data  :any = null,\n    public type  :Type|null = null, // TODO: use this\n  ) {}\n\n  getTypeExpr() :Expr | null {\n    return (\n      ( this.decl && (\n        this.decl instanceof Field ||\n        this.decl instanceof VarDecl\n      ) && this.decl.type) ||\n\n      ( this.value && this.value.type) ||\n\n      this.value\n    )\n  }\n\n  get isConstant() :bool {\n    return this.writes == 0\n  }\n\n  get scope() :Scope {\n    return this.decl.scope\n  }\n}\n\nexport class Scope {\n  fun :FunExpr | null = null // when set, scope if function scope\n\n  constructor(\n  public outer :Scope | null,\n  public decls :Map<ByteStr,Ent> | null = null,\n  public isFunScope :bool = false, // if the scope is that of a function\n  ) {}\n\n  // lookup a declaration in this scope and any outer scopes\n  //\n  lookup(s :ByteStr) :Ent | null {\n    const d = this.decls && this.decls.get(s)\n    return d ? d : this.outer ? this.outer.lookup(s) : null\n  }\n\n  // lookupImm looks up a declaration only in this scope\n  //\n  lookupImm(s :ByteStr) :Ent | null {\n    const d = this.decls && this.decls.get(s)\n    return d || null\n  }\n\n  // declare registers a name in this scope.\n  // If the name is already registered, null is returned.\n  //\n  declare(name: ByteStr, decl :Node, x: Expr|null) :Ent|null {\n    const ent = new Ent(name, decl, x)\n    return this.declareEnt(ent) ? ent : null\n  }\n\n  // declareEnt returns true if ent was declared, and false it's already\n  // declared.\n  //\n  declareEnt(ent :Ent) :bool {\n    // Note: name is interned by value in the same space as all other names in\n    // this scope, meaning we can safely use the object identity of name.\n    if (!this.decls) {\n      this.decls = new Map<ByteStr,Ent>([[ent.name, ent]])\n      return true\n    }\n    if (this.decls.has(ent.name)) {\n      return false\n    }\n    this.decls.set(ent.name, ent)\n    return true\n  }\n\n  // redeclareEnt returns the previously declared entity, if any.\n  //\n  redeclareEnt(ent :Ent) :Ent|null {\n    // Note: name is interned by value in the same space as all other names in\n    // this scope, meaning we can safely use the entity identity of name.\n    if (!this.decls) {\n      this.decls = new Map<ByteStr,Ent>([[ent.name, ent]])\n      return null\n    }\n    const prevent = this.decls.get(ent.name)\n    if (prevent === ent) {\n      return null\n    }\n    this.decls.set(ent.name, ent)\n    return prevent || null\n  }\n\n  // get closest function scope (could be this scope)\n  funScope() :Scope|null {\n    let s :Scope|null = this\n    while (s) {\n      if (s.fun) {\n        return s\n      }\n      s = s.outer\n    }\n    return null\n  }\n\n  level() {\n    let level = 0, s :Scope|null = this\n    while ((s = s.outer)) {\n      level++\n    }\n    return level\n  }\n\n  toString() {\n    const names = this.decls ? Array.from(this.decls.keys()) : []\n    return `Scope(level: ${this.level()}, names: (${names.join(', ')}))`\n  }\n}\n\n// used by intrinsics\nconst nilScope = new Scope(null)\n\n// ——————————————————————————————————————————————————————————————————\n// Statements\n//\n// There are two kinds of statements:\n// - declaration statements and\n// - expression statements.\n//\nexport class Stmt extends Node {}\n\n// no operation / blank / filler\nexport class NoOpStmt extends Stmt {}\n\n\nexport class ReturnStmt extends Stmt {\n  constructor(pos :Pos, scope :Scope,\n  public result :Expr, // u_t_nil means no explicit return values\n  public type :Type,  // effective type. null until resolved.\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class WhileStmt extends Stmt {\n  constructor(pos :Pos, scope :Scope,\n  public cond :Expr, // condition for executing the body\n  public body :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// ——————————————————————————————————————————————————————————————————\n// Declarations\n\nexport class Decl extends Stmt {}\n\nexport class MultiDecl extends Decl {\n  // MultiDecl represents a collection of declarations that were parsed from\n  // a multi-declaration site. E.g. \"type (a int; b f32)\"\n  constructor(pos :Pos, scope :Scope,\n  public decls :Decl[],\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class ImportDecl extends Decl {\n  constructor(pos :Pos, scope :Scope,\n  public path       :StringLit,\n  public localIdent :Ident|null,\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class VarDecl extends Decl {\n  constructor(pos :Pos, scope :Scope,\n  public idents  :Ident[],\n  public group   :Group|null,         // null means not part of a group\n  public type    :Expr|null = null,   // null means no type\n  public values  :Expr[]|null = null, // null means no values\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class TypeDecl extends Decl {\n  // Ident Type\n  constructor(pos :Pos, scope :Scope,\n  public ident  :Ident,\n  public alias  :bool,\n  public type   :Expr,\n  public group  :Group|null, // nil = not part of a group\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// ——————————————————————————————————————————————————————————————————\n// Expressions\n\nexport class Expr extends Stmt {\n  type :Type|null = null  // effective type of expression. null until resolved.\n}\n\n// Placeholder for an expression that failed to parse correctly and\n// where we can't provide a better node.\nexport class BadExpr extends Expr {}\n\n\nexport class Ident extends Expr {\n  ent :Ent|null = null // what this name references\n\n  constructor(pos :Pos, scope :Scope,\n    public value :ByteStr, // interned in ByteStrSet\n    public ver :int = 0,   // SSA version\n  ) {\n    super(pos, scope)\n  }\n\n  toString() { return String(this.value) }\n\n  incrWrite() {\n    assert(this.ent != null)\n    let ent = this.ent as Ent\n    ent.writes++\n    this.ver = ent.writes\n  }\n\n  // ref registers a reference to this ent from an identifier\n  //\n  refEnt(ent :Ent) {\n    assert(this !== ent.decl, \"ref declaration\")\n    ent.nreads++\n    this.ent = ent\n    this.ver = ent.writes\n  }\n\n  // ref unregisters a reference to this ent from an identifier\n  //\n  unrefEnt() {\n    assert(this.ent, \"null ent\")\n    const ent = this.ent as Ent\n    ent.nreads--\n    this.ent = null\n    this.ver = 0\n  }\n}\n\n\nexport class Block extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public list :Stmt[],\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class IfExpr extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public cond :Expr,\n  public then :Expr,\n  public els_ :Expr|null,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class TupleExpr extends Expr {\n  // TupleExpr = \"(\" Expr (\",\" Expr)+ \")\"\n  constructor(pos :Pos, scope :Scope,\n  public exprs :Expr[],\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `(${this.exprs.map(x => x.toString()).join(', ')})`\n  }\n}\n\nexport class SelectorExpr extends Expr {\n  // Selector = Expr \".\" ( Ident | Selector )\n  constructor(pos :Pos, scope :Scope,\n    public lhs :Expr,\n    public rhs :Expr, // Ident or SelectorExpr\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `${this.lhs}.${this.rhs}`\n  }\n}\n\n\nexport class IndexExpr extends Expr {\n  // IndexExpr = Expr \"[\" Expr \"]\"\n\n  indexv :int = -1  // >=0 = resolved, -1 = invalid/unresolved\n\n  constructor(pos :Pos, scope :Scope,\n    public operand :Expr,\n    public index   :Expr,\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return `${this.operand}[${this.index}]`\n  }\n}\n\n\nexport class SliceExpr extends Expr {\n  // SliceExpr = Expr \"[\" Expr? \":\" Expr? \"]\"\n  constructor(pos :Pos, scope :Scope,\n    public operand :Expr,\n    public start   :Expr|null,\n    public end     :Expr|null,\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return `${this.operand}[${this.start || ''}:${this.end || ''}]`\n  }\n}\n\n\nexport class RestExpr extends Expr {\n  // ...expr\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\nexport class LiteralExpr extends Expr {}\n\nexport class BasicLit extends LiteralExpr {\n  type :BasicType\n  constructor(pos :Pos, scope :Scope,\n    public kind  :token, // kind\n    public value :Uint8Array,\n    public op    :token = token.ILLEGAL,\n      // op: potential negation operation, e.g. \"-3\"\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return (\n      (this.op != token.ILLEGAL ? tokstr(this.op) : '') +\n      utf8.decodeToString(this.value)\n    )\n  }\n\n  isInt() :bool {\n    return (\n      token.literal_int_beg < this.kind &&\n      this.kind < token.literal_int_end\n    )\n  }\n\n  isFloat() :bool {\n    return this.kind == token.FLOAT\n  }\n\n  // isSignedInt returns true if the literal int is signed.\n  // if its type has not yet been resolved, true is returned only\n  // if op == token.SUB.\n  //\n  isSignedInt() :bool {\n    assert(this.isInt(), \"called isSignedInt on non-integer\")\n    return (\n      this.type instanceof IntType ? this.type.signed :\n      this.op == token.SUB\n    )\n  }\n\n  // parseInt parses a signed value up to Number.MAX_SAFE_INTEGER\n  // Returns NaN on failure.\n  //\n  parseSInt() :int {\n    let base = 0, b = this.value\n    switch (this.kind) {\n      case token.INT_BIN: base = 2; b = b.subarray(2); break\n      case token.INT_OCT: base = 8; b = b.subarray(2); break\n      case token.INT:     base = 10; break\n      case token.INT_HEX: base = 16; b = b.subarray(2); break\n      default: return -1\n    }\n    var v = parseInt(String.fromCharCode.apply(null, b), base)\n    return (\n      v > Number.MAX_SAFE_INTEGER || v < Number.MIN_SAFE_INTEGER ? NaN :\n      v\n    )\n  }\n\n  // parseUInt parses an unsigned value up to Number.MAX_SAFE_INTEGER\n  // -1 is returned to indicate failure.\n  //\n  parseUInt() :int {\n    assert(this.isInt(), \"calling parseUInt on a non-integer\")\n    if (this.op == token.SUB) {\n      return -1\n    }\n\n    let base = 0, offs = 0\n\n    switch (this.kind) {\n      case token.INT_BIN: base = 2; offs = 2; break\n      case token.INT_OCT: base = 8; offs = 2; break\n      case token.INT:     base = 10; break\n      case token.INT_HEX: base = 16; offs = 2; break\n      default: return -1\n    }\n\n    return strtou(this.value, base, offs)\n  }\n\n  parseFloat() :number {\n    assert(this.isFloat(), \"called parseFloat on non-float\")\n    let str = String.fromCharCode.apply(null, this.value)\n    let c = parseFloat(str)\n    assert(!isNaN(c), `failed to parse \"${str}\"`)\n    if (!isNaN(c) && this.op == token.SUB) {\n      c = -c\n    }\n    return c\n  }\n}\n\n// export const ImplicitOne = new BasicLit(\n//   0,\n//   nilScope,\n//   token.INT,\n//   null as any as Uint8Array,\n// )\n\nexport class StringLit extends LiteralExpr {\n  constructor(pos :Pos, scope :Scope,\n    public value :Uint8Array\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return JSON.stringify(utf8.decodeToString(this.value))\n  }\n}\n\nexport class Assignment extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public op  :token, // ILLEGAL means no operation\n  public lhs :Expr[],\n  public rhs :Expr[], // empty == lhs++ or lhs--\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return `${this.lhs.join(', ')} ${tokstr(this.op)} ${this.rhs.join(', ')}`\n  }\n}\n\nexport class Operation extends Expr {\n  constructor(pos :Pos, scope :Scope,\n  public op :token, // [token.operator_beg .. token.operator_end]\n  public x  :Expr,\n  public y  :Expr|null = null, // nil means unary expression\n  ) {\n    super(pos, scope)\n  }\n\n  toString() {\n    return `(${token[this.op]} ${this.x}${this.y ? ' ' + this.y : ''})`\n  }\n}\n\nexport class CallExpr extends Expr {\n  // Fun(ArgList[0], ArgList[1], ...)\n  constructor(pos :Pos, scope :Scope,\n  public fun     :Expr,\n  public args    :Expr[],\n  public hasDots :bool,  // last argument is followed by ...\n  ) {\n    super(pos, scope)\n  }\n}\n\n// export class ParenExpr extends Expr {\n//   // (X)\n//   constructor(pos :Pos, scope :Scope,\n//   public x :Expr,\n//   ) {\n//     super(pos, scope)\n//   }\n// }\n\nexport class FunExpr extends Expr {\n  body :Expr|null = null // nil = forward declaration\n  // nlocali32 :int = 0\n  // nlocali64 :int = 0\n  // nlocalf32 :int = 0\n  // nlocalf64 :int = 0\n\n  constructor(pos :Pos, scope :Scope,\n    public name   :Ident|null, // nil = anonymous func expression\n    public sig    :FunSig,\n    public isInit :bool = false, // true for special \"init\" funs at file level\n  ) {\n    super(pos, scope)\n    scope.fun = this  // Mark the scope as being a \"function scope\"\n  }\n}\n\nexport class FunSig extends Node {\n  constructor(pos :Pos, scope :Scope,\n  public params :Field[],\n  public result :Expr,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\nexport class IntrinsicVal extends Expr {\n  constructor(\n    public name :string,\n    public type :Type,\n  ) {\n    super(0, nilScope)\n  }\n}\n\n\nexport class TypeConvExpr extends Expr {\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n    public type :Type,\n  ) {\n    super(pos, scope)\n  }\n}\n\n\n// ——————————————————————————————————————————————————————————————————\n// Types\n\nexport class Type extends Expr {\n  ent :Ent|null = null\n\n  constructor(pos :Pos, scope :Scope) {\n    super(pos, scope)\n    this.type = this\n  }\n\n  // accepts returns true if the other type is compatible with this type.\n  // essentially: \"this >= other\"\n  // For instance, if the receiver is the same as `other`\n  // or a superset of `other`, true is returned.\n  //\n  accepts(other :Type) :bool {\n    return this.equals(other)\n  }\n\n  // equals returns true if the receiver is equivalent to `other`\n  //\n  equals(other :Type) :bool {\n    return this === other\n  }\n}\n\nexport class UnresolvedType extends Type {\n  refs :Set<Expr|FunSig>|null = null  // things that references this type\n\n  constructor(pos :Pos, scope :Scope,\n    public expr :Expr,\n  ) {\n    super(pos, scope)\n  }\n\n  addRef(x :Expr|FunSig) {\n    assert(x !== this.expr)\n    // if (x !== this.expr) {\n    if (!this.refs) {\n      this.refs = new Set<Expr|FunSig>([x])\n    } else {\n      this.refs.add(x)\n    }\n    // }\n  }\n\n  toString() {\n    return '~' + this.expr.toString()\n  }\n}\n\n// register storage type needed for a basic type\nexport enum RegType {\n  i32,\n  i64,\n  f32,\n  f64\n}\n\nexport class BasicType extends Type {\n  constructor(\n    public bitsize :int,\n    public regtype :RegType,\n    public name    :string, // only used for debugging and printing\n  ) {\n    super(0, nilScope)\n  }\n\n  toString() :string {\n    return this.name\n  }\n\n  equals(other :Type) :bool {\n    return this === other\n  }\n\n  // TODO: accepts(other :Type) :bool\n}\n\n\nexport class IntType extends BasicType {\n  constructor(bitsize :int, regtype :RegType, name :string,\n    public signed :bool, // true if type is signed\n  ) {\n    super(bitsize, regtype, name)\n  }\n}\n\n// basic type constants\nconst uintz :number = 32 // TODO: target-dependant\nconst uintregtype = uintz <= 32 ? RegType.i32 : RegType.i64\n\nexport const\n  u_t_auto = new BasicType(0, RegType.i32, 'auto')  // special\n, u_t_nil  = new BasicType(0, RegType.i32, 'nil')   // special; aka \"void\"\n, u_t_bool = new BasicType(1, RegType.i32, 'bool')\n, u_t_u8  = new IntType(8,  RegType.i32, 'u8', false)\n, u_t_i8  = new IntType(7,  RegType.i32, 'i8', true)\n, u_t_u16 = new IntType(16, RegType.i32, 'u16', false)\n, u_t_i16 = new IntType(15, RegType.i32, 'i16', true)\n, u_t_u32 = new IntType(32, RegType.i32, 'u32', false)\n, u_t_i32 = new IntType(31, RegType.i32, 'i32', true)\n, u_t_u64 = new IntType(64, RegType.i64, 'u64', false)\n, u_t_i64 = new IntType(63, RegType.i64, 'i64', true)\n, u_t_f32 = new BasicType(32, RegType.f32, 'f32')\n, u_t_f64 = new BasicType(64, RegType.f64, 'f64')\n, u_t_uint = new IntType(uintz,  uintregtype, 'uint', false)\n, u_t_int  = new IntType(uintz-1,uintregtype, 'int', true)\n\n\nexport class StrType extends Type {\n  constructor(\n    public length :int, // -1 == length only known at runtime\n  ) {\n    super(0, nilScope)\n  }\n\n  toString() :string {\n    return this.length > -1 ? `str<${this.length}>` : 'str'\n  }\n\n  equals(other :Type) :bool {\n    // TODO: break this up, partly into accepts(), so its truly \"equals\",\n    // e.g. \"cstr<4> != str\"\n    return (\n      this === other ||\n      ( other instanceof StrType &&\n        this.length == other.length\n      )\n    )\n  }\n}\n\n\nexport const u_t_str = new StrType(-1)  // heap-allocated string\n\n\n\nexport class RestType extends Type {\n  // ...type\n  constructor(pos :Pos, scope :Scope,\n    public type :Type,\n  ) {\n    super(pos, scope)\n    this.type = type\n  }\n\n  toString() :string {\n    return `...${this.type}`\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof RestType &&\n        this.type.equals(other.type)\n      )\n    )\n  }\n}\n\nexport class TupleType extends Type {\n  // TupleType = \"(\" Type (\",\" Type)+ \")\"\n  constructor(pos :Pos, scope :Scope,\n  public types :Type[],\n  ) {\n    super(pos, scope)\n  }\n\n  toString() :string {\n    return '(' + this.types.map(t => t.toString()).join(', ') + ')'\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof TupleType &&\n        this.types.length == other.types.length &&\n        this.types.every((t, i) => t.equals(other.types[i]))\n      )\n    )\n  }\n}\n\nexport class FunType extends Type {\n  // FunType = ( Type | TupleType ) \"->\" Type\n  constructor(pos :Pos, scope :Scope,\n  public inputs :Type[],\n  public result :Type,\n  ) {\n    super(pos, scope)\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof FunType &&\n        this.inputs.length == other.inputs.length &&\n        this.result.equals(other.result) &&\n        this.inputs.every((t, i) => t.equals(other.inputs[i]))\n      )\n    )\n  }\n}\n\nexport class UnionType extends Type {\n  constructor(\n    public types :Set<Type>,\n  ) {\n    super(0, nilScope)\n  }\n\n  add(t :Type) {\n    assert(!(t instanceof UnionType))\n    this.types.add(t)\n  }\n\n  toString() :string {\n    let s = '(U ', first = true\n    for (let t of this.types) {\n      if (first) {\n        first = false\n      } else {\n        s += '|'\n      }\n      s += t.toString()\n    }\n    return s + ')'\n  }\n\n  equals(other :Type) :bool {\n    if (this === other) {\n      return true\n    }\n    if (!(other instanceof UnionType) || other.types.size != this.types.size) {\n      return false\n    }\n    // Note: This relies on type instances being singletons (being interned)\n    for (let t of this.types) {\n      if (!other.types.has(t)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  accepts(other :Type) :bool {\n    if (this === other) {\n      return true\n    }\n    if (!(other instanceof UnionType)) {\n      return false\n    }\n    // Note: This relies on type instances being singletons (being interned)\n    // make sure that we have at least the types of `other`.\n    // e.g.\n    //   (int|f32|bool) accepts (int|f32) => true\n    //   (int|f32) accepts (int|f32|bool) => false\n    for (let t of other.types) {\n      if (!this.types.has(t)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n\nexport class OptionalType extends Type {\n  constructor(\n    public type :Type,\n  ) {\n    super(0, nilScope)\n    assert(!(type instanceof OptionalType))\n    assert(!(type instanceof UnionType))\n    assert(!(type instanceof BasicType))\n  }\n\n  toString() :string {\n    return this.type.toString() + '?'\n  }\n\n  equals(other :Type) :bool {\n    return (\n      this === other ||\n      ( other instanceof OptionalType &&\n        this.type.equals(other.type)\n      )\n    )\n  }\n\n  accepts(other :Type) :bool {\n    return (\n      this.equals(other) ||       // e.g. \"x str?; y str?; x = y\"\n      this.type.equals(other) ||  // e.g. \"x str?; y str; x = y\"\n      other === u_t_nil           // e.g. \"x str?; x = nil\"\n    )\n  }\n}\n\n\nexport const u_t_optstr = new OptionalType(u_t_str)\n\n\n\n// ——————————————————————————————————————————————————————————————————\n// File\n\n// A File corresponds to a source file\n//\nexport class File {\n  constructor(\n    public sfile      :SrcFile,\n    public scope      :Scope,\n    public imports    :ImportDecl[] | null,  // imports in this file\n    public decls      :(Decl|FunExpr)[],     // top-level declarations\n    public unresolved :Set<Ident> | null,    // unresolved references\n  ) {}\n\n  toString() :string {\n    return (\n      `File(\"${this.sfile.name}\"; ${this.decls.length} decls` +\n      ( this.imports ? `; ${this.imports.length} imports)` : '' )\n    )\n  }\n}\n\nexport class Package {\n  files :File[] = []\n\n  constructor(\n    public name :string,\n    public scope :Scope,\n    // public imports\n    // public exports\n  ) {}\n\n  toString() {\n    return `Package(${this.name})`\n  }\n}\n","import { SrcFile, Pos } from './pos'\nimport { token, tokstr, prec } from './token'\nimport * as scanner from './scanner'\nimport { ErrorHandler, ErrorCode } from './error'\nimport { TypeResolver } from './resolve'\nimport { ByteStr, ByteStrSet } from './bytestr'\nimport { Universe } from './universe'\nimport { debuglog } from './util'\nimport { DiagHandler, DiagKind } from './diag'\nimport {\n  File,\n  Scope,\n  Ent,\n  Group,\n  Comment,\n\n  Node,\n\n  Field,\n  Stmt,\n  ReturnStmt,\n  WhileStmt,\n  \n  Decl,\n  ImportDecl,\n  VarDecl,\n  TypeDecl,\n  MultiDecl,\n\n  Expr,\n  Ident,\n  // LiteralExpr,\n  RestExpr,\n  FunExpr,\n  FunSig,\n  BasicLit,\n  StringLit,\n  Block,\n  IfExpr,\n  Assignment,\n  Operation,\n  CallExpr,\n  // ParenExpr,\n  TupleExpr,\n  BadExpr,\n  SelectorExpr,\n  IndexExpr,\n  SliceExpr,\n\n  Type,\n  IntType,\n  FunType,\n  StrType,\n  UnresolvedType,\n  UnionType,\n  // TupleType,\n\n  u_t_nil,\n  u_t_auto,\n  u_t_f32,\n  u_t_f64,\n} from './ast'\n\nconst kEmptyByteArray = new Uint8Array(0)\nconst kBytes__ = new Uint8Array([0x5f]) // '_'\nconst kBytes_dot = new Uint8Array([0x2e]) // '.'\nconst kBytes_init = new Uint8Array([0x69, 0x6e, 0x69, 0x74]) // 'init'\n\nconst emptyExprList :Expr[] = []\n\ntype exprCtx = Assignment|VarDecl|null\n\n\n// funInfo contains information about the current function, used for data\n// that is really only needed during parsing.\nclass funInfo {\n  autort :UnionType|null = null // inferred result types\n\n  constructor(\n  public f :FunExpr, // the respective function node\n  ){}\n\n  addInferredReturnType(t :Type) {\n    if (this.autort == null) {\n      this.autort = new UnionType(new Set<Type>([t]))\n    } else {\n      this.autort.add(t)\n    }\n  }\n}\n\n\n// Parser scans source code and produces AST.\n// It must be initialized via init before use or resue.\n//\nexport class Parser extends scanner.Scanner {\n  fnest      :int = 0   // function nesting level (for error handling)\n  universe   :Universe\n  strSet     :ByteStrSet\n  comments   :Comment[]|null\n  scope      :Scope\n  filescope  :Scope\n  pkgscope   :Scope\n  diagh      :DiagHandler|null = null\n  initfnest  :int = 0  // tracks if we're inside an init function\n  unresolved :Set<Ident>|null   // unresolved identifiers\n  funstack   :funInfo[]  // function stack\n  types      :TypeResolver\n\n  _id__      :ByteStr\n  _id_dot    :ByteStr\n  _id_init   :ByteStr\n\n  initParser(\n    sfile      :SrcFile,\n    sdata      :Uint8Array,\n    universe   :Universe,\n    pkgscope   :Scope|null,\n    typeres    :TypeResolver,\n    errh       :ErrorHandler|null = null,\n    diagh      :DiagHandler|null = null,\n    smode      :scanner.Mode = scanner.Mode.None,\n  ) {\n    const p = this\n    super.init(sfile, sdata, errh, smode)\n    p.scope = new Scope(pkgscope)\n    p.filescope = p.scope\n    p.pkgscope = pkgscope || p.filescope\n    \n    p.fnest = 0\n    p.universe = universe\n    p.strSet = universe.strSet\n    p.comments = null\n    p.diagh = diagh\n    p.initfnest = 0\n    p.unresolved = null\n    p.funstack = []\n    p.types = typeres\n\n    p._id__ = p.strSet.emplace(kBytes__)\n    p._id_dot = p.strSet.emplace(kBytes_dot)\n    p._id_init = p.strSet.emplace(kBytes_init)\n\n    if (smode & scanner.Mode.ScanComments) {\n      p.next = p.next_comments\n    }\n\n    p.next()\n  }\n\n  next_comments() {\n    const p = this\n    super.next()\n    while (p.tok == token.COMMENT) {\n      if (!p.comments) {\n        p.comments = []\n      }\n      p.comments.push(new Comment(p.pos, p.takeByteValue()))\n      super.next()\n    }\n    // TODO: Figure out a way to attach comments to nodes\n  }\n\n  got(tok :token) :bool {\n    const p = this\n    if (p.tok == tok) {\n      p.next()\n      return true\n    }\n    return false\n  }\n  \n  want(tok :token) {\n    const p = this\n    if (!p.got(tok)) {\n      p.syntaxError(`expecting ${tokstr(tok)}`)\n      p.next()\n    }\n  }\n\n  // inFun() :FunExpr|null {\n  //   return this.funstack[0] || null\n  // }\n\n  currFun() :funInfo {\n    assert(this.funstack.length > 0, 'access current function at file level')\n    return this.funstack[0]\n  }\n\n  pushFun(f :FunExpr) {\n    this.funstack.push(new funInfo(f))\n  }\n\n  popFun() {\n    assert(this.funstack.length > 0, 'popFun with empty funstack')\n    this.funstack.pop()\n  }\n\n\n  pushScope(scope :Scope | null = null) {\n    const p = this\n    if (scope) {\n      assert(scope.outer != null, 'pushing scope without outer scope')\n    }\n    p.scope = scope || new Scope(p.scope)\n    // debuglog(`${(p as any).scope.outer.level()} -> ${p.scope.level()}`)\n  }\n\n  popScope() :Scope { // returns old (\"popped\") scope\n    const p = this\n    const s = p.scope\n    \n    assert(s !== p.filescope, \"pop file scope\")\n    assert(s !== p.pkgscope, \"pop file scope\")\n    assert(p.scope.outer != null, 'pop scope at base scope')\n\n    // debuglog(` ${(p as any).scope.outer.level()} <- ${p.scope.level()}`)\n\n    p.scope = p.scope.outer as Scope\n\n    // check for unused declarations\n    if (s.decls) for (let [name, ent] of s.decls) {\n      if (ent.nreads == 0) {\n        if (ent.decl instanceof Field) {\n          p.diag(\"warn\", `${name} not used`, ent.decl.pos, (\n            ent.decl.scope.isFunScope ? 'E_UNUSED_PARAM' :\n            'E_UNUSED_FIELD'\n          ))\n        } else {\n          p.diag(\n            \"warn\",\n            `${name} declared and not used`,\n            ent.decl.pos,\n            'E_UNUSED_VAR'\n          )\n        }\n      }\n    }\n\n    return s\n  }\n\n  declare(scope :Scope, ident: Ident, decl :Node, x: Expr|null) {\n    const p = this\n\n    if (ident.value === p._id__) {\n      // \"_\" is never declared\n      return\n    }\n\n    assert(ident.ent == null, `redeclaration of ${ident}`)\n\n    const ent = new Ent(ident.value, decl, x)\n    if (!scope.declareEnt(ent)) {\n      p.syntaxError(`${ident} redeclared`, ident.pos)\n    }\n\n    ident.ent = ent\n    // TODO: in the else branch, we could count locals/registers needed here.\n    // For instance, \"currFun().local_i32s_needed++\"\n  }\n\n  declarev(scope :Scope, idents: Ident[], decl :Node, xs: Expr[]|null) {\n    const p = this\n    for (let i = 0; i < idents.length; ++i) {\n      p.declare(scope, idents[i], decl, xs && xs[i] || null)\n    }\n  }\n\n  // If x is an identifier, resolve attempts to resolve x by looking up\n  // the entity it denotes. If no entity is found and collectUnresolved is\n  // set, x is marked as unresolved and collected in the list of unresolved\n  // identifiers.\n  // Returns the input expression\n  //\n  resolve<N extends Expr>(x :N, collectUnresolved :bool = true) :N {\n    const p = this\n\n    // nothing to do if x is not an identifier or the blank identifier\n    if (!(x instanceof Ident) || x.value === p._id__) {\n      return x\n    }\n\n    assert(x.ent == null, \"already resolved\")\n\n    if (x.value === p._id__) {\n      return x\n    }\n\n    // try to resolve the identifier\n    let s :Scope|null = x.scope\n    while (s) {\n      const ent = s.lookupImm(x.value)\n      if (ent) {\n        // debuglog(`${x} found in scope#${s.level()}`)\n        x.refEnt(ent) // reference ent\n\n        if (!x.type) {\n          const tx = ent.getTypeExpr()\n          x.type = tx ? p.types.resolve(tx) : null\n          // x.type = (\n          //   ent.value ? p.types.resolve(ent.value) :\n          //   ent.decl instanceof Expr ? p.types.resolve(ent.decl) :\n          //   null\n          // )\n\n          if (!x.type) {\n            x.type = p.types.markUnresolved(x)\n          }\n          if (x.type instanceof UnresolvedType) {\n            // references something that itself is undefined\n            x.type.addRef(x)\n          }\n        }\n\n        return x\n      }\n      s = s.outer\n    }\n\n    // debuglog(`${x} not found`)\n    if (collectUnresolved) {\n      // all local scopes are known, so any unresolved identifier\n      // must be found either in the file scope, package scope\n      // (perhaps in another file), or universe scope --- collect\n      // them so that they can be resolved later\n      if (!p.unresolved) {\n        p.unresolved = new Set<Ident>([x])\n      } else {\n        p.unresolved.add(x)\n      }\n    }\n\n    return x\n  }\n\n  // ctxType returns the type of the context, or null if the type is not known\n  // or if the type can't be reliably inferred, in which case it should be\n  // resolved later on.\n  //\n  ctxType(ctx :exprCtx) :Type|null {\n    const p = this\n    if (ctx) {\n      if (ctx instanceof VarDecl) {\n        return ctx.type && p.types.maybeResolve(ctx.type) || null\n      }\n      if (ctx instanceof Assignment) {\n        // common case: single assignment\n        // we handle multi assignments later, in p.assignment()\n        return (\n          ctx.lhs && ctx.lhs.length == 1 ? p.types.maybeResolve(ctx.lhs[0]) :\n          null\n        )\n      }\n    }\n    return null\n  }\n\n  parseFile() :File {\n    const p = this\n    const imports = p.parseImports()\n    const decls = p.parseFileBody()\n\n    return new File(\n      p.sfile,\n      p.scope,\n      imports,\n      decls,\n      p.unresolved,\n    )\n  }\n\n  parseImports() :ImportDecl[] {\n    const p = this\n    //\n    // Imports     = ImportDecl? | ImportDecl (\";\" ImportDecl)*\n    // ImportDecl  = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" )\n    // ImportSpec  = [ \".\" | PackageName ] ImportPath\n    // ImportPath  = string_lit\n    //\n    let imports = [] as ImportDecl[]\n    while (p.got(token.IMPORT)) {\n      p.appendGroup(imports, p.importDecl)\n      p.want(token.SEMICOLON)\n    }\n    return imports\n  }\n\n  importDecl = (group :Group|null) :ImportDecl => {\n    const p = this\n    let localIdent :Ident|null = null\n    let hasLocalIdent = false\n  \n    switch (p.tok) {\n      case token.NAME:\n        localIdent = p.ident()\n        hasLocalIdent = true\n        break\n\n      case token.DOT:\n        const s = p._id_dot\n        localIdent = new Ident(p.pos, p.scope, s)\n        p.next()\n        break\n    }\n\n    let path :StringLit\n    if (p.tok == token.STRING) {\n      path = p.strlit()\n    } else {\n      p.syntaxError(\"missing import path; expecting quoted string\")\n      path = new StringLit(p.pos, p.scope, kEmptyByteArray)\n      p.advanceUntil(token.SEMICOLON, token.RPAREN)\n    }\n\n    const d = new ImportDecl(p.pos, p.scope, path, localIdent)\n    // d.Group = group\n\n    if (hasLocalIdent && localIdent) {\n      p.declare(p.filescope, localIdent, d, null)\n    }\n    \n    return d\n  }\n\n  parseFileBody() :Decl[] {\n    const p = this\n    const decls = [] as Decl[]\n\n    // { TopLevelDecl \";\" }\n    while (p.tok != token.EOF) {\n      switch (p.tok) {\n\n        case token.TYPE:\n          p.next() // consume \"type\"\n          p.appendGroup(decls, p.typeDecl)\n          break\n\n        case token.NAME:\n          const pos = p.pos\n          const idents = p.identList(p.ident())\n          decls.push(p.varDecl(pos, idents))\n          break\n\n        case token.FUN:\n          decls.push(p.funExpr(null))\n          break\n\n        // TODO: token.TYPE\n\n        default: {\n          if (\n            p.tok == token.LBRACE &&\n            decls.length > 0 &&\n            isEmptyFunExpr(decls[decls.length-1])\n          ) {\n            // opening { of function declaration on next line\n            p.syntaxError(\"unexpected semicolon or newline before {\")\n          } else {\n            p.syntaxError(\"non-declaration statement outside function body\")\n          }\n\n          p.error(`TODO file-level token \\`${tokstr(p.tok)}\\``); p.next()\n\n          p.advanceUntil(/*token.CONST, */token.TYPE, token.FUN)\n          continue\n        }\n      }\n\n      if ((p.tok as token) != token.EOF && !p.got(token.SEMICOLON)) {\n        p.syntaxError(\"after top level declaration\")\n        p.advanceUntil(/*token.CONST, */token.TYPE, token.FUN)\n      }\n    }\n\n    return decls\n  }\n\n  // checkDeclLen verifies that idents.length == nvalues, and if not,\n  // reports a syntax error.\n  // Returns true if lengths matches.\n  //\n  checkDeclLen(idents :Ident[], nvalues: number, kind :string) :bool {\n    const p = this\n    if (nvalues != idents.length) {\n      p.syntaxError(\n        `cannot assign ${nvalues} values to ${idents.length} ${kind}`,\n        idents[0].pos\n      )\n      return false\n    }\n    return true\n  }\n\n  typeDecl = (group :Group|null, nth :int) :TypeDecl => {\n    // TypeSpec = \"type\" identifier [ \"=\" ] Type\n    const p = this\n    const pos = p.pos\n    const ident = p.ident()\n    const alias = p.got(token.ASSIGN)\n\n    let t = p.maybeType()\n    if (!t) {\n      t = p.bad()\n      p.syntaxError(\"in type declaration\")\n      p.advanceUntil(token.SEMICOLON, token.RPAREN)\n    }\n\n    const d = new TypeDecl(pos, p.scope, ident, alias, t, group)\n    // TODO: declare in scope\n    return d\n  }\n\n  varDecl(pos :Pos, idents :Ident[]) :VarDecl|Assignment {\n    // VarDecl = IdentifierList\n    //           ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList )\n    const p = this\n    const typ = p.maybeType()\n    let isError = false\n\n    // vars at the file level are declared in the package scope\n    const scope = p.scope === p.filescope ? p.pkgscope : p.scope\n\n    // if (p.scope !== p.filescope && p.tok == token.ASSIGN) {\n    //   // produce Assignment instead\n    //   return p.assignment(idents, typ ? p.types.resolve(typ) : null)\n    // }\n\n    const d = new VarDecl(pos, scope, idents, null, typ, null)\n\n    if (p.got(token.ASSIGN)) {\n      // e.g. x, y = 1, 2\n      d.values = p.exprList(/*ctx=*/d)\n      isError = !p.checkDeclLen(idents, d.values.length, 'constants')\n    } else if (!typ) {\n      // e.g. `x` -- missing type or values\n      p.syntaxError(\"unexpected identifier\", pos)\n      isError = true\n      d.values = [p.bad()]\n      p.advanceUntil(token.SEMICOLON)\n    }\n\n    if (isError) {\n      return d\n    }\n\n    const reqt = d.type ? p.types.resolve(d.type) : null\n    p.processAssign(d.idents, d.values, d, reqt, /*onlyDef=*/true)\n\n    return d\n  }\n\n  funExpr(ctx :exprCtx) :FunExpr {\n    //\n    // FunExpr  = \"fun\" FunName? Signature? FunBody?\n    // FunName  = identifier\n    // FunBody  = ( Block | \"->\" Stmt )\n    //\n    // Note: FunName is required at file level in \"fun\" declarations\n    //\n    const p = this\n    const pos = p.pos\n    p.want(token.FUN)\n\n    const isTopLevel = p.scope === p.filescope\n\n    let name :Ident|null\n    let isInitFun = false\n\n    if (isTopLevel && !ctx) {\n      // case: statement(!ctx) at top-level\n      name = p.ident()\n      // functions called \"init\" at the file level are special\n      isInitFun = p.scope === p.filescope && name.value.equals(p._id_init)\n    } else {\n      name = p.maybeIdent()\n    }\n\n    // scope in which we will declare the function's name.\n    // declarations at the top-level are declared in the package scope.\n    const scope = isTopLevel ? p.pkgscope : p.scope\n\n    // new scope for parameters, signature and body\n    p.pushScope(new Scope(p.scope, null, /*isFunScope*/true))\n\n    // parse signature.\n    //\n    // Note: we use the default and special type constant \"auto\" for all\n    // functions but initi functions. This allows us to track multiple return\n    // sites and do type checking as we go.\n    //\n    // Additionally, p.funSig may find an explicit return type in which case\n    // it will use that instead. Whenever we encounter a return statement, we\n    // will check the expected return type with the actual return type.\n    //\n    const sig = p.funSig(isInitFun ? u_t_nil/*u_t_void*/ : u_t_auto)\n\n    const f = new FunExpr(pos, p.scope, name, sig, isInitFun)\n\n    if (isInitFun) {\n      // check initfun signature (should be empty)\n      if (sig.params.length > 0) {\n        p.syntaxError(`init function with parameters`, sig.pos)\n      }\n      if (sig.result !== u_t_nil/*u_t_void*/) {\n        p.syntaxError(`init function with result`, sig.pos)\n      }\n    } else {\n      if (sig.result !== u_t_auto) {\n        // an explicit type was provided -- resolve type\n        p.types.resolve(sig.result)\n      }\n\n      if (name && !ctx) {\n        // The function itself is declared in its outer scope, so that its body\n        // can refer to the function, but also so that \"funname = x\" declares a\n        // new variable rather than replacing the function.\n        //\n        // The check for !ctx is to make sure that decorative names in\n        // expressions are not declared in the scope.\n        // E.g. the statement \"x = fun y(){}\" should only declare x in the scope,\n        // but not y.\n        p.declare(scope, name, f, f)\n      }\n    }\n\n    // parse body\n    if (!isTopLevel || isInitFun || ctx || p.tok != token.SEMICOLON) {\n\n      // Note: the following code can be enabled to disallow type-only param\n      // signatures for functions with bodies.\n      // e.g. \"fun foo(int, f32) {}\"\n      // if (sig.params.length > 0 && !sig.params[0].name) {\n      //   p.syntaxError(\n      //     `type-only parameters for function with body`,\n      //     sig.pos\n      //   )\n      // }\n\n      if (isInitFun) { p.initfnest++ }\n      p.pushFun(f)\n\n      f.body = p.funBody(name)\n      const fi = p.currFun()\n\n      p.popFun()\n      if (isInitFun) { p.initfnest-- }\n\n      // pop function body scope before resolving types.\n      // otherwise we would run the risk of resolving a type to something\n      // that's defined in the function body itself which may shadow outer\n      // definitions.\n      p.popScope()\n\n      // handle implicit return\n      if (f.body instanceof Block) {\n        let lastindex = f.body.list.length - 1\n        let result = f.body.list[lastindex]\n        if (result instanceof Expr) {\n          let rettype = p.types.resolve(result)\n          let ret = new ReturnStmt(result.pos, result.scope, result, rettype)\n          f.body.list[lastindex] = ret\n        }\n      }\n      // else if (!(f.body instanceof ReturnExpr)) {\n      //   let ret = new ReturnExpr(f.body.pos, f.body.scope, f.body)\n      //   ret.type = p.types.resolve(f.body)\n      //   f.body = ret\n      // }\n\n      if (sig.result === u_t_auto) {\n        // inferred result type\n        if (fi.autort == null) {\n          // no return statements encountered.\n          // set result type to same as the body\n          sig.result = p.types.resolve(f.body)\n        } else if (fi.autort.types.size == 1) {\n          // single return type (note: may be void if found `return;`)\n          sig.result = fi.autort.types.values().next().value\n        } else {\n          // union type\n          sig.result = fi.autort\n        }\n      }\n    } else {\n      if (sig.result == u_t_auto) {\n        // for functions without a body and that is missing an explicit\n        // result type, nil/void is assumed.\n        sig.result = u_t_nil //u_t_void\n      }\n      p.popScope()\n    }\n\n    if (sig.result instanceof UnresolvedType) {\n      sig.result.addRef(sig)\n    }\n\n    const funtype = p.types.resolve(f) as FunType\n    assert(funtype.constructor === FunType) // funtype always resolves\n\n    if (name && name.value !== p._id__ && !isInitFun) {\n      // since we declared the name of the function, the name now represents\n      // the function and thus its type.\n      name.type = funtype\n    }\n\n    return f\n  }\n\n  // TODO: maybeFunExpr() :Expr -- FunExpr or some other expr\n  // FunExpr = \"fun\" FunName? Signature FunBody\n  // FunName = identifier\n  // FunBody  = ( Block | \"->\" Stmt )\n\n  funSig(defaultType :Type): FunSig {\n    // Signature = ( Parameters Result? | Type )?\n    const p = this\n    const pos = p.pos\n    const params = p.tok == token.LPAREN ? p.parameters() : []\n    const result = p.maybeType() || defaultType\n    return new FunSig(pos, p.scope, params, result)\n  }\n\n  parameters() :Field[] {\n    // Parameters    = \"(\" [ ParameterList [ \",\" ] ] \")\"\n    // ParameterList = ParameterDecl (\",\" ParameterDecl)*\n    // ParameterDecl = [ NameList ] [ \"...\" ] Type\n    //\n    // T\n    // x T\n    // x, y, z T\n    // ... T\n    // x  ... T\n    // x, y, z  ... T\n    // T1, T2, T3\n    // T1, T2, ... T3\n    //\n    const p = this\n    p.want(token.LPAREN)\n\n    let named = 0   // parameters that have an explicit name and type\n    let seenRestExpr = false\n    const paramsPos = p.pos\n    const fields = [] as Field[]\n    const scope = p.scope\n\n    while (p.tok != token.RPAREN) {\n      let pos = p.pos\n      // let f = new Field(p.pos, scope, u_t_auto, p.ident())\n      \n      let typ :Expr = u_t_auto\n      let name :Ident|null = null\n\n      // parse type or name\n      if (p.tok == token.NAME) {\n        typ = p.dotident(null, p.ident())\n      } else {\n        // Note: No need to check for \";\" or \")\" since the \"while\" condition\n        // checks for \")\" and an empty parameter set with linebreaks never\n        // produces a semicolon implicitly. I.e. \"foo(<LF><LF>)\" == \"foo()\"\n        // However, it's a syntax error to write \"foo(;)\"\n        const x = p.maybeType()\n        if (x) {\n          typ = x\n        } else {\n          typ = p.bad()\n          p.syntaxError(\"expecting name or type\")\n          // p.next()\n        }\n      }\n\n      if (p.tok != token.COMMA &&\n          p.tok != token.SEMICOLON &&\n          p.tok as token != token.RPAREN)\n      {\n        // e.g. func(T), func(... T)\n\n        // move typ -> name as we are about to parse the actual type\n        if (typ) {\n          // e.g. func(name T)\n          if (typ instanceof Ident) {\n            name = typ\n            named++\n          } else {\n            // e.g. func(a.b.c T)\n            p.syntaxError(\"illegal parameter name\", pos)\n          }\n        }\n\n        // parse type\n        if (p.got(token.ELLIPSIS)) {\n          const x = p.maybeType()\n          if (x) {\n            typ = new RestExpr(pos, scope, x)\n          } else {\n            typ = p.bad()\n            p.syntaxError(\"expecting type after ...\")\n          }\n          if (seenRestExpr) {\n            p.syntaxError(\"can only use ... with final parameter\")\n            continue  // skip this field\n          } else {\n            seenRestExpr = true\n          }\n        } else {\n          typ = p.type()\n        }\n      }\n\n      // restType() :RestExpr {\n      //   // RestType = \"...\" Expr?\n      //   const p = this\n      //   const pos = p.pos\n      //   p.want(token.ELLIPSIS)\n      //   const rt = new RestExpr(pos, p.scope, p.type())\n      //   p.types.resolve(rt)\n      //   return rt\n      // }\n\n      // parse optional comma, or break on error\n      if (!p.ocomma(token.RPAREN)) {\n        // error: unexpected SOMETHING, expecting comma, or )\n        // e.g. \"fun foo(a, b<LF>)\" fix -> \"fun foo(a, b,<LF>)\"\n        //                                              ^\n        break\n      }\n\n      fields.push(new Field(pos, scope, typ, name))\n    }\n\n    p.want(token.RPAREN)\n\n    // distribute parameter types\n    if (named == 0) {\n      // none named -- types only\n      for (let f of fields) {\n        p.resolve(f.type)\n      }\n    } else {\n\n      if (named < fields.length) {\n        // All named, some has types, e.g. func(a, b B, c ...C)\n        // some named => all must be named\n        let ok = true\n        let typ :Expr|null = null\n        let t :Type = u_t_auto\n\n        for (let i = fields.length - 1; i >= 0; --i) {\n          const f = fields[i]\n\n          if (!f.name) {\n            // is a single-name param (name is actually on .type)\n            if (f.type instanceof Ident) {\n              f.name = f.type\n              if (typ) {\n                f.type = typ\n                f.name.type = t\n              } else {\n                // f.type == nil && typ == null => we only have a f.name\n                ok = false\n                f.type = p.bad(f.type.pos)\n              }\n            } else {\n              p.syntaxError(\"illegal parameter name\", f.type.pos)\n            }\n          } else if (f.type) {\n            p.resolve(f.type)\n            t = p.types.resolve(f.type)\n            typ = f.type\n            if (typ instanceof RestExpr) {\n              typ = typ.expr\n            }\n            if (f.name) {\n              f.name.type = t\n            } else {\n              ok = false\n              f.name = p.fallbackIdent(typ.pos)\n            }\n          }\n\n          if (!ok) {\n            p.syntaxError(\n              \"mixed named and unnamed function parameters\",\n              paramsPos\n            )\n            break\n          }\n\n          // declare name in function scope\n          assert(f.name != null)\n          p.declare(scope, f.name as Ident, f, null)\n        }\n      } else {\n        // All named, all have types\n        // declare names in function scope\n        for (let f of fields) {\n          assert(f.name != null)\n          p.resolve(f.type)\n          ;(f.name as Ident).type = p.types.resolve(f.type)\n          p.declare(scope, f.name as Ident, f, null)\n        }\n      }\n    }\n\n    return fields\n  }\n\n  funBody(funcname :Ident|null) :Expr {\n    // FunBody = ( Block | \"->\" Expr )\n    const p = this\n\n    if (p.tok == token.LBRACE) {\n      // Block\n      return p.block()\n      // let b = p.block()\n      // if (b.list.length > 0) {\n      //   let laststmt = b.list[b.list.length-1]\n      //   if (laststmt instanceof ReturnExpr) {\n      //     // unwrap \"return\" when it is the last statement in a function, since\n      //     // last statement is implicit.\n      //     b.list[b.list.length-1] = laststmt.result\n      //   }\n      // }\n      // return b\n    }\n\n    if (p.got(token.ARROWR)) {\n      // \"->\" Expr\n      return p.expr(/*ctx=*/null)\n      // let x = p.expr(/*ctx=*/null)\n      // if (x instanceof ReturnExpr) {\n      //   // unwrap \"return\" when it is the last statement in a function, since\n      //   // last statement is implicit.\n      //   return x.result\n      // }\n      // return x\n    }\n\n    // error\n    const pos = p.pos\n    if (funcname) {\n      p.syntaxError(`${funcname} is missing function body`, pos)\n    } else {\n      p.syntaxError(\"missing function body\", pos)\n    }\n    return p.bad(pos)\n  }\n\n  // block parses a block expression.\n  // The caller manages scope (push/pop if required)\n  //\n  block() :Block {\n    // Block = \"{\" StatementList \"}\" | Stmt\n    const p = this\n    const pos = p.pos\n    p.want(token.LBRACE)\n    const list = p.stmtList()\n    p.want(token.RBRACE)\n    return new Block(pos, p.scope, list)\n  }\n\n  multiDecl<D extends Decl>(f :(g:Group|null, i:int)=>D) :MultiDecl {\n    const p = this\n    const pos = p.pos\n    p.next() // e.g. TYPE\n    const decls :Decl[] = []\n    p.appendGroup(decls, f)\n    return new MultiDecl(pos, p.scope, decls)\n  }\n\n  stmtList() :Stmt[] {\n    // StatementList = { Statement \";\" }\n    const p = this\n    const list = [] as Stmt[]\n\n    while (p.tok != token.EOF &&\n           p.tok != token.RBRACE &&\n           // p.tok != token.CASE &&\n           p.tok != token.DEFAULT)\n    {\n      const s = p.maybeStmt()\n      if (!s) {\n        break\n      }\n      list.push(s)\n      // customized version of osemi:\n      // ';' is optional before a closing ')' or '}'\n      if (p.tok == token.RPAREN || p.tok as token == token.RBRACE) {\n        continue\n      }\n      if (!p.got(token.SEMICOLON)) {\n        p.syntaxError(\"at end of statement\")\n        p.advanceUntil(token.SEMICOLON, token.RBRACE)\n      }\n    }\n\n    return list\n  }\n\n  // shouldStoreToEnt returns true if ent is within atScope in such a way\n  // that \"ent = value\" means \"store value to ent\".\n  //\n  shouldStoreToEnt(ent :Ent, atScope :Scope) :bool {\n    const p = this\n    return (\n      ent.scope === atScope  // same scope\n      ||\n      ( ent.scope !== p.filescope &&\n        ( ( ent.scope === p.pkgscope &&\n            atScope.fun && atScope.fun.isInit )\n          ||\n          ent.scope.funScope() === atScope.funScope()\n        )\n      )\n    )\n  }\n\n\n  processAssign(\n    lhs :Expr[],\n    rhs :Expr[]|null,\n    decl :Node,\n    reqt :Type|null,\n    onlyDef :bool,\n  ) {\n    const p = this\n\n    // TODO refactor this and move this function (that has a closure)\n    function maybeConvRVal(typ :Type, rval :Expr, index :int) {\n      if (\n        !(rval.type instanceof UnresolvedType) &&\n        !(typ instanceof UnresolvedType)\n      ) {\n        const convx = p.types.convert(typ, rval)\n        if (!convx) {\n          if (rval.type instanceof UnresolvedType) {\n            // unresolved\n            return \n          }\n          p.error(\n            (rval.type instanceof UnresolvedType ?\n              `cannot convert \"${rval}\" to type ${typ}` :\n              `cannot convert \"${rval}\" (type ${rval.type}) to type ${typ}`\n            ),\n            rval.pos\n          )\n        } else if (convx !== rval) {\n          // no error and conversion is needed.\n          // replace original expression with conversion expression\n          assert(rhs != null)\n          ;(rhs as any)[index] = convx\n        }\n      }\n    }\n\n    // Check each left-hand identifier against scope and unresolved.\n    // Note that exprList already has called p.resolve on all ids.\n    //\n    // If an id has an ent (i.e. was resolved to something), then we simply\n    // register the assignment with it so that we can later bind.\n    //\n    // If an id is unresolved (doesn't have an ent), the semantics are:\n    // - assume it's a constant definition and declare it as such\n    // - register the assignment so that if we later find a var in the outer\n    //   scope, we can convert the declaration to an assignment.\n    //\n    for (let i = 0; i < lhs.length; ++i) {\n      const id = lhs[i]\n\n      if (!(id instanceof Ident)) {\n        debuglog(`TODO LHS is not an id (type is ${id.constructor.name})`)\n        continue\n      }\n\n      // Decide to store to an existing ent, or declare a new one\n      if (!onlyDef && rhs && id.ent && p.shouldStoreToEnt(id.ent, id.scope)) {\n        const rval = rhs[i]\n\n        id.incrWrite()\n\n        const typexpr = id.ent.getTypeExpr()\n        assert(typexpr != null)\n        const typ = p.types.resolve(typexpr as Expr)\n\n        // check & resolve type, converting rval if needed\n        id.type = typ\n        maybeConvRVal(typ, rval, i)\n\n        continue\n      }\n\n      id.ent = null\n      \n      // new declaration\n      //\n      // since we are about to redeclare, clear any \"unresolved\" mark for\n      // this identifier expression.\n      const rval = rhs ? rhs[i] : null\n\n      if (reqt) {\n        id.type = reqt\n        if (rval) {\n          // see if we need to convert the rval to fit the destination type\n          maybeConvRVal(reqt, rval, i)\n        }\n      } else {\n        assert(rval, \"processAssign called with no reqt and no rvals\")\n        id.type = p.types.resolve(rval as Expr)\n      }\n      \n      if (p.unresolved) { p.unresolved.delete(id) } // may be noop\n      p.declare(id.scope, id, decl, rval)\n\n      if (id.type instanceof UnresolvedType) {\n        id.type.addRef(id)\n      }\n\n    } // end for loop\n  }\n\n\n  assignment(lhs :Expr[], reqt :Type|null = null) :Assignment {\n    // Assignment = ExprList \"=\" ExprList\n    const p = this\n    p.want(token.ASSIGN) // \"=\"\n\n    const s = new Assignment(lhs[0].pos, p.scope, token.ASSIGN, lhs, [])\n\n    // parse right-hand side in context of the function\n    s.rhs = p.exprList(/*ctx=*/s)\n\n    p.processAssign(s.lhs, s.rhs, s, /*reqt=*/reqt, /*onlyDef=*/false)\n\n    p.types.resolve(s)\n\n    return s\n  }\n\n  // simpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt\n  //            | Assignment | VarDecl\n  simpleStmt(lhs :Expr[]) :Stmt {\n    const p = this\n\n    // Note: token.SET_ASSIGN \":=\" is currently unused\n    // we could use it to allow shadowing in same scope, e.g.\n    //   \"b = 4; b := true\" where \"b :=\" redeclares b.\n\n    if (p.tok == token.ASSIGN) {\n      // e.g.  \"a = 1\"  \"a, b = 1, 2\"  \"a[1], b.f = 1, 2\"  etc\n      return p.assignment(lhs)\n    }\n\n    if (p.tok == token.NAME && lhs.every(x => x instanceof Ident)) {\n      // var definition\n      // e.g. \"a T\", \"a, b, c T\" -- declare var with type T\n\n      // first, revert either bindings or unresolved mark of LHS idents\n      for (let i = 0; i < lhs.length; i++) {\n        let x = lhs[i] as Ident\n        if (x.ent) {\n          x.unrefEnt()\n        } else {\n          assert(p.unresolved != null)\n          ;(p.unresolved as Set<Ident>).delete(x)\n        }\n      }\n\n      // now, form a var declaration (next up may be assignment and values)\n      return p.varDecl(lhs[0].pos, lhs as Ident[])\n    }\n\n    const pos = lhs[0].pos\n\n    if (lhs.length != 1) {\n      p.syntaxError('expecting \"=\" or \",\"')\n      p.advanceUntil(token.SEMICOLON, token.RBRACE)\n      return lhs[0]\n    }\n\n    // single expression\n\n    let t = p.types.resolve(lhs[0])\n\n    if (token.assignop_beg < p.tok && p.tok < token.assignop_end) {\n      // lhs op= rhs;  e.g. \"x += 2\"\n      let op = p.tok\n      p.next() // consume operator\n      p.checkBasicTypeMutation(lhs[0], t)\n\n      // map assign ops to regular ops.\n      // e.g. \"(assign += x 2)\" => \"(assign + x 2)\"\n      switch (op) {\n        case token.ADD_ASSIGN:     op = token.ADD; break  // +\n        case token.SUB_ASSIGN:     op = token.SUB; break  // -\n        case token.MUL_ASSIGN:     op = token.MUL; break  // *\n        case token.QUO_ASSIGN:     op = token.QUO; break  // /\n        case token.REM_ASSIGN:     op = token.REM; break  // %\n        case token.AND_ASSIGN:     op = token.AND; break  // &\n        case token.OR_ASSIGN:      op = token.OR;  break  // |\n        case token.XOR_ASSIGN:     op = token.XOR; break  // ^\n        case token.SHL_ASSIGN:     op = token.SHL; break  // <<\n        case token.SHR_ASSIGN:     op = token.SHR; break  // >>\n        case token.AND_NOT_ASSIGN: op = token.AND_NOT; break // &^\n        default:\n          assert(false, `unexpected operator token ${token[op]}`)\n      }\n\n      const s = new Assignment(pos, p.scope, op, lhs, [])\n      s.rhs = p.exprList(/*ctx=*/s)\n      p.types.resolve(s)\n      return s\n    }\n\n    if (p.tok == token.INC || p.tok == token.DEC) {\n      // lhs++ or lhs--\n      const op = p.tok\n      p.next() // consume operator\n      p.checkBasicTypeMutation(lhs[0], t)\n      let s = new Assignment(pos, p.scope, op, lhs, emptyExprList)\n      p.types.resolve(s)\n      return s\n    }\n\n    if (p.tok == token.ARROWL) {\n      // lhs <- rhs\n      p.syntaxError(\"TODO simpleStmt ARROWL\")\n    }\n\n    if (p.tok == token.ARROWR) {\n      // params -> result\n      p.syntaxError(\"TODO simpleStmt ARROWR\")\n    }\n\n    // else: expr\n    return lhs[0]\n  }\n\n\n  checkBasicTypeMutation(x :Expr, t :Type) {\n    if (!(t instanceof IntType) &&\n      t !== u_t_f32 && t !== u_t_f64 &&\n      !(t instanceof UnresolvedType)\n    ) {\n      // debuglog(`operand type: ${x.constructor.name}`, x)\n      this.syntaxError(`cannot mutate ${x}`, x.pos)\n    }\n  }\n\n\n  maybeStmt() :Stmt|null {\n    // Statement =\n    //   Declaration | LabeledStmt | simpleStmt |\n    //   GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n    //   FallthroughStmt | Block | IfExpr | SwitchStmt | SelectStmt | ForStmt |\n    //   DeferStmt .\n    const p = this\n\n    switch (p.tok) {\n      // Most statements (assignments) start with an identifier;\n      // look for it first before doing anything more expensive.\n      case token.NAME:\n      case token.NAMEAT:\n        return p.simpleStmt(p.exprList(/*ctx=*/null))\n\n      case token.LBRACE:\n        p.pushScope()\n        const s = p.block()\n        p.popScope()\n        return s\n\n      case token.TYPE:\n        return p.multiDecl(p.typeDecl)\n\n      case token.ADD:\n      case token.SUB:\n      case token.MUL:\n      case token.AND:\n      case token.NOT:\n      case token.XOR: // unary operators\n      case token.FUN:\n      case token.LPAREN: // operands\n      case token.LBRACKET:\n      // case token.STRUCT:\n      // case token.CHAN:\n      case token.INTERFACE: // composite types\n      // case token.ARROW: // receive operator\n        return p.simpleStmt(p.exprList(/*ctx=*/null))\n\n      // case token.FOR:\n      //   return p.forStmt()\n\n      // case token.SWITCH:\n      //   return p.switchStmt()\n\n      // case token.SELECT:\n      //   return p.selectStmt()\n\n      case token.WHILE:\n        return p.whileStmt()\n\n      case token.IF:\n        return p.ifExpr(/*ctx=*/null)\n\n      // case token.FALLTHROUGH:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   p.next()\n      //   s.Tok = _Fallthrough\n      //   return s\n\n      // case token.BREAK, token.CONTINUE:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   s.Tok = p.tok\n      //   p.next()\n      //   if p.tok == _Name {\n      //     s.Label = p.name()\n      //   }\n      //   return s\n\n      // case token.GO, token.DEFER:\n      //   return p.callStmt()\n\n      // case token.GOTO:\n      //   s := new(BranchStmt)\n      //   s.pos = p.pos()\n      //   s.Tok = _Goto\n      //   p.next()\n      //   s.Label = p.name()\n      //   return s\n\n      case token.RETURN:\n        return p.returnStmt()\n\n      // case token.SEMI:\n      //   s := new(EmptyStmt)\n      //   s.pos = p.pos()\n      //   return s\n\n      default:\n        if (token.literal_beg < p.tok && p.tok < token.literal_end) {\n          return p.simpleStmt(p.exprList(/*ctx=*/null))\n        }\n    }\n\n    return null\n  }\n\n  whileStmt() :WhileStmt {\n    //\n    // WhileStmt = \"while\" Expression Block\n    //\n    const p = this\n    const pos = p.pos\n    const scope = p.scope\n\n    p.want(token.WHILE)\n\n    const cond = p.expr(/*ctx=*/null)\n    p.types.resolve(cond)\n\n    const body = p.expr(/*ctx=*/null)\n\n    return new WhileStmt(pos, scope, cond, body)\n  }\n\n  ifExpr(ctx :exprCtx) :IfExpr {\n    //\n    // IfExpr = \"if\" Expression Block\n    //          [ \"else\" ( IfExpr | Block ) ]\n    //\n    // e.g. `if x > 1 \"large\" else \"small\"`\n    // e.g. `if x = size() > 1 print(\"large number: $x\")`\n    //\n    const p = this\n\n    // push a scope for conditions to support e.g. capture of x in\n    //   if x = a() > 0 print(\"$x > 0\") else print(\"$x < 0\")\n    //\n    p.pushScope()\n    const s = p.ifExpr2(ctx)\n    p.popScope()\n\n    return s\n  }\n\n  ifExpr2(ctx :exprCtx) :IfExpr {\n    // used by ifExpr\n    const p = this\n    const pos = p.pos\n    const scope = p.scope\n\n    p.want(token.IF)\n\n    const cond = p.expr(ctx)\n    p.types.resolve(cond)\n\n    const then = p.expr(ctx)\n\n    const s = new IfExpr(pos, scope, cond, then, null)\n\n    if (p.got(token.ELSE)) {\n      if (p.tok == token.IF) {\n        s.els_ = p.ifExpr2(ctx)\n      } else {\n        p.pushScope()\n        s.els_ = p.expr(ctx)\n        p.popScope()\n      }\n    }\n\n    return s\n  }\n\n  returnStmt() :ReturnStmt {\n    const p = this\n    const pos = p.pos\n\n    p.want(token.RETURN)\n\n    // expected return type (may be u_t_auto; u_t_nil/u_t_void for init)\n    const fi = p.currFun()\n    const frtype = fi.f.sig.result as Type  // ok; already resolved\n    assert(frtype instanceof Type, \"currFun sig.result type not resolved\")\n\n    const n = new ReturnStmt(pos, p.scope, u_t_nil, frtype)\n\n    if (p.tok == token.SEMICOLON || p.tok == token.RBRACE) {\n      // no result; just \"return\"\n      if (frtype !== u_t_nil/*u_t_void*/) {\n        if (frtype === u_t_auto && fi.autort == null) {\n          // if `fi.autort != null` that means the block returns both\n          // some type and nothing, which is invalid.\n          fi.f.sig.result = u_t_nil //u_t_void\n        } else {\n          p.syntaxError(\n            `missing return value; expecting ${fi.autort || frtype}`\n          )\n        }\n      }\n      return n\n    }\n\n    // expecting one or more results to follow\n    \n    const xs = p.exprList(/*ctx=*/null) // ?: maybe pass TupleExpr?\n    \n    let rval = (\n      xs.length == 1 ? xs[0] :\n        // e.g. \"return 1\", \"return (1, 2)\"\n\n      new TupleExpr(xs[0].pos, xs[0].scope, xs)\n        // Support paren-less tuple return\n        // e.g. \"return 1, 2\" == \"return (1, 2)\"\n    )\n\n    if (frtype === u_t_nil/*u_t_void*/) {\n      p.syntaxError(\"function does not return a value\", rval.pos)\n      return n\n    }\n\n    const rtype = p.types.resolve(rval)\n\n    if (frtype === u_t_auto) {\n      // register inferred result type\n      fi.addInferredReturnType(rtype)\n    } else if (!(rtype instanceof UnresolvedType) && !frtype.equals(rtype)) {\n      // attempt type conversion\n      const convres = p.types.convert(frtype, rval)\n      if (convres) {\n        rval = convres\n      } else {\n        // error: type mismatch\n        p.syntaxError(\n          (rval.type instanceof UnresolvedType ?\n            `cannot use \"${rval}\" as return type ${frtype}` :\n            `cannot use \"${rval}\" (type ${rval.type}) as return type ${frtype}`\n          ),\n          rval.pos\n        )\n      }\n    }\n\n    n.result = rval\n\n    return n\n  }\n\n  exprList(ctx :exprCtx) :Expr[] {\n    // ExpressionList = Expression ( \",\" Expression )*\n    const p = this\n    const list = [p.expr(ctx)]\n    while (p.got(token.COMMA)) {\n      list.push(p.expr(ctx))\n    }\n    return list\n  }\n\n  expr(ctx :exprCtx) :Expr {\n    const p = this\n    return p.binaryExpr(prec.LOWEST, ctx)\n  }\n\n  binaryExpr(pr :prec, ctx :exprCtx) :Expr {\n    // Expression = UnaryExpr | Expression binary_op Expression\n    const p = this\n    let x = p.unaryExpr(ctx)\n\n    while (\n      (token.operator_beg < p.tok && p.tok < token.operator_end) &&\n      p.prec > pr)\n    {\n      const pos = p.pos\n      const tprec = p.prec\n      const op = p.tok\n      p.next()\n      x = new Operation(pos, p.scope, op, x, p.binaryExpr(tprec, ctx))\n    }\n\n    // p.types.resolve(x) // should be resolved when needed\n\n    return x\n  }\n\n  unaryExpr(ctx :exprCtx) :Expr {\n    // UnaryExpr = PrimaryExpr | unary_op UnaryExpr\n    const p = this\n    const t = p.tok\n    const pos = p.pos\n\n    switch (t) {\n      case token.ADD:\n      case token.SUB:\n      case token.NOT:\n      case token.XOR: {\n        // e.g. \"-x\", \"!y\"\n        p.next()\n        if (token.literal_beg < p.tok && p.tok < token.literal_end) {\n          // common case of negated literal, e.g. \"-3\", \"+0.0\"\n          return p.basicLit(ctx, t)\n        }\n        let x = new Operation(pos, p.scope, t, p.unaryExpr(ctx))\n        p.types.resolve(x)\n        return x\n      }\n\n      case token.AND: {\n        p.next()\n        // unaryExpr may have returned a parenthesized composite literal\n        // (see comment in operand)\n        let x = new Operation(pos, p.scope, t, p.unaryExpr(ctx))\n        p.types.resolve(x)\n        return x\n        // legacy: unparen(p.unaryExpr(ctx)) to unwrap ParenExpr.\n      }\n\n      // TODO: case token.ARROWL; `<-x`, `<-chan E`\n    }\n\n    return p.primExpr(ctx)\n  }\n\n\n  primExpr(ctx :exprCtx) :Expr {\n    // PrimaryExpr =\n    //   Operand |\n    //   Conversion |\n    //   PrimaryExpr Selector |\n    //   PrimaryExpr Index |\n    //   PrimaryExpr Slice |\n    //   PrimaryExpr TypeAssertion |\n    //   PrimaryExpr Arguments .\n    //\n    // Selector       = \".\" identifier .\n    // Index          = \"[\" Expression \"]\" .\n    // Slice          = \"[\" ( [ Expression ] \":\" [ Expression ] ) |\n    //                      ( [ Expression ] \":\" Expression \":\" Expression )\n    //                  \"]\" .\n    // TypeAssertion  = \".\" \"(\" Type \")\" .\n    // Arguments      = \"(\"\n    //   [ (  ExpressionList | Type [ \",\" ExpressionList ] ) [ \"...\" ] [ \",\" ]]\n    //   \")\" .\n    const p = this\n    let x = p.operand(ctx)\n\n    loop:\n    while (true) switch (p.tok) {\n\n      case token.LPAREN:\n        x = p.call(x, ctx)\n        break  // may be more calls, e.g. foo()()()\n\n      case token.LBRACKET:\n        x = p.bracketExpr(x, ctx)\n        break\n\n      case token.DOT:\n        x = p.selectorExpr(x, ctx)\n        break\n\n      default:\n        break loop\n    }\n\n    return x\n  }\n\n\n  call(fun :Expr, ctx :exprCtx) :CallExpr {\n    // Arguments = \"(\" [\n    //     ( ExpressionList | Type [ \",\" ExpressionList ] )\n    //     [ \"...\" ] [ \",\" ]\n    //   ] \")\"\n    const p = this\n\n    // call or conversion\n    // convtype '(' expr ocomma ')'\n    const pos = p.pos\n    const args = [] as Expr[]\n    let hasDots = false\n\n    p.want(token.LPAREN)\n    // p.xnest++\n\n    while (p.tok != token.EOF && p.tok != token.RPAREN) {\n      args.push(p.expr(ctx))\n      hasDots = p.got(token.ELLIPSIS)\n      if (!p.ocomma(token.RPAREN) || hasDots) {\n        break\n      }\n    }\n\n    // p.xnest--\n    p.want(token.RPAREN)\n\n    return new CallExpr(pos, p.scope, fun, args, hasDots)\n  }\n\n\n  operand(ctx :exprCtx) :Expr {\n    // Operand   = Literal | OperandName | MethodExpr | \"(\" Expression \")\" .\n    // Literal   = BasicLit | CompositeLit | FunctionLit .\n    // BasicLit  = int_lit | float_lit | imaginary_lit | rune_lit | string_lit\n    // OperandName = identifier | QualifiedIdent.\n    const p = this\n\n    switch (p.tok) {\n      case token.NAME:\n      case token.NAMEAT:\n        return p.dotident(ctx, p.resolve(p.ident()))\n\n      case token.LPAREN:\n        return p.parenExpr(ctx)\n\n      case token.FUN:\n        return p.funExpr(ctx)\n\n      case token.LBRACE:\n        p.pushScope()\n        const b = p.block()\n        p.popScope()\n        return b\n\n      case token.IF:\n        return p.ifExpr(ctx)\n\n      // case _Lbrack, _Chan, _Map, _Struct, _Interface:\n      //   return p.type_() // othertype\n\n      case token.STRING:\n        return p.strlit()\n\n      default: {\n        if (token.literal_beg < p.tok && p.tok < token.literal_end) {\n          return p.basicLit(ctx)\n        }\n\n        const x = p.bad()\n        p.syntaxError(\"expecting expression\")\n        // p.next()\n        return x\n      }\n    }\n  }\n\n\n  basicLit(ctx :exprCtx, op? :token) :BasicLit {\n    const p = this\n    assert(token.literal_beg < p.tok && p.tok < token.literal_end)\n    const x = new BasicLit(p.pos, p.scope, p.tok, p.takeByteValue(), op)\n    const reqt = p.ctxType(ctx)\n    x.type = p.universe.basicLitType(x, reqt, p.basicLitErrH, op)\n    p.next() // consume literal\n    return x\n  }\n\n\n  basicLitErrH = (msg :string, pos :Pos) => {\n    this.syntaxError(msg, pos)\n  }\n\n\n  strlit() :StringLit {\n    const p = this\n    assert(p.tok == token.STRING)\n    const n = new StringLit(p.pos, p.scope, p.takeByteValue())\n    n.type = new StrType(n.value.length)\n    p.next()\n    return n\n  }\n\n\n  selectorExpr(operand :Expr, ctx :exprCtx) :SelectorExpr|IndexExpr {\n    // SelectorExpr = Expr \".\" ( Ident | IntLit )\n    const p = this\n    p.want(token.DOT)\n    const pos = p.pos  // pos is after \".\"\n\n    let rhs :Expr\n    if (p.tok as token == token.NAME) {\n      // e.g. \"a.b\"\n      rhs = p.dotident(ctx, p.ident())\n    } else if (\n      (p.tok as token) > token.literal_int_beg &&\n      (p.tok as token) < token.literal_int_end\n    ) {\n      // e.g. \"a.3\"\n      return p.types.resolveIndex(\n        new IndexExpr(pos, p.scope, operand, p.basicLit(ctx))\n      )\n    } else {\n      p.syntaxError('expecting name or integer after \".\"')\n      rhs = p.bad(pos)\n    }\n\n    return new SelectorExpr(pos, p.scope, operand, rhs)\n  }\n\n\n  dotident(ctx :exprCtx, ident :Ident) :Ident|SelectorExpr|IndexExpr {\n    // dotident = Ident | SelectorExpr\n    const p = this\n    return p.tok == token.DOT ? p.selectorExpr(ident, ctx) : ident\n  }\n\n\n  bracketExpr(operand :Expr, ctx :exprCtx) :IndexExpr|SliceExpr {\n    // bracketExpr = IndexExpr | SliceExpr\n    // IndexExpr   = Expr \"[\" Expr \"]\"\n    // SliceExpr   = Expr \"[\" Expr? \":\" Expr? \"]\"\n    const p = this\n    const pos = p.pos\n    p.want(token.LBRACKET)\n\n    let x1 :Expr|null = null\n    if (p.tok != token.COLON) {\n      x1 = p.expr(ctx)\n    }\n\n    if (p.got(token.COLON)) {\n      // slice with implicit start, e.g. \"operand[:end]\"\n      let end :Expr|null = null\n      if (!p.got(token.RBRACKET)) {\n        end = p.expr(ctx)\n        p.want(token.RBRACKET)\n      } // else: slice with implicit end, e.g. \"operand[:]\"\n      return new SliceExpr(pos, p.scope, operand, x1, end)\n    }\n\n    // index\n    p.want(token.RBRACKET)\n\n    return p.types.resolveIndex(\n      new IndexExpr(pos, p.scope, operand, x1 as Expr)\n    )\n  }\n\n\n  // // resolveIndex attempts to resolve the \n  // // returns ix as a convenience\n  // //\n  // resolveIndex(ix :IndexExpr) :IndexExpr {\n  //   const p = this\n\n  //   // for type inference of the IndexExpr to work, we need to inspect the type\n  //   // of the operand\n  //   let opt = p.types.resolve(ix.operand)\n  //   if (opt instanceof UnresolvedType) {\n  //     // defer to bind stage\n  //     debuglog(`[index type] deferred to bind stage`)\n  //   } else if (opt instanceof TupleType) {\n  //     p.resolveTupleIndex(ix, opt)\n  //   } else {\n  //     debuglog(`TODO [index type] operand is not a tuple; opt = ${opt}`)\n  //   }\n  //   return ix\n  // }\n\n\n  // resolveTupleIndex(ix :IndexExpr, opt :TupleType) {\n  //   const p = this\n\n  //   let it = p.types.resolve(ix.index)\n  //   if (it instanceof UnresolvedType) {\n  //     debuglog(`[index type] deferred to bind stage`)\n  //     ix.type = p.types.markUnresolved(ix)\n  //     return\n  //   }\n\n  //   // index must be constant for tuple access\n  //   let index = p.resolveLitConstant(ix.index)\n  //   if (!index) {\n  //     // TODO: somehow track this and complete the check during bind\n  //     p.syntaxError('non-constant tuple index', ix.index.pos)\n  //     return\n  //   }\n\n  //   // check type to make sure index is an integer\n  //   if (\n  //     index.type && !(index.type instanceof IntType) ||\n  //     !(index instanceof BasicLit) ||\n  //     !index.isInt()\n  //   ) {\n  //     p.syntaxError(`invalid index type ${index.type || index}`, ix.index.pos)\n  //     return\n  //   }\n\n  //   // parse the integer; returns -1 on failure\n  //   ix.indexv = index.parseUInt()\n  //   if (ix.indexv == -1) {\n  //     p.syntaxError(`invalid index ${index}`, ix.index.pos)\n  //     return\n  //   }\n\n  //   if (ix.indexv >= opt.types.length) {\n  //     p.syntaxError(`out-of-bounds tuple index ${index} on type ${opt}`, ix.pos)\n  //     return\n  //   }\n\n  //   // success -- type of IndexExpr found\n  //   ix.type = opt.types[ix.indexv]\n  // }\n\n\n  // // resolveLitConstant attempts to resolve the constant value of x, expected\n  // // to be a LiteralExpr. If x or anything x might refer to is not constant,\n  // // null is returned.\n  // //\n  // resolveLitConstant(x :Expr) :LiteralExpr|null {\n  //   const p = this\n\n  //   if (x instanceof LiteralExpr) {\n  //     return x\n  //   }\n\n  //   if (x instanceof Ident) {\n  //     if (x.ent && x.ent.writes == 0 && x.ent.value) {\n  //       // Note: we check `x.ent.writes == 0` to make sure that x is a constant\n  //       // i.e. that there are no potential conditional branches that might\n  //       // change the value of x.\n  //       return p.resolveLitConstant(x.ent.value)\n  //     }\n  //   } else if (x instanceof IndexExpr) {\n  //     let opt = p.types.resolve(x.operand)\n\n  //     if (opt instanceof TupleType) {\n  //       let tuple :TupleExpr\n  //       if (x.operand instanceof Ident) {\n  //         assert(x.operand.ent != null) // should have been resolved\n  //         const ent = x.operand.ent as Ent\n  //         assert(ent.value instanceof TupleExpr)\n  //         tuple = ent.value as TupleExpr\n  //       } else {\n  //         // TODO: handle selectors to fields\n  //         assert(x.operand instanceof TupleExpr)\n  //         tuple = x.operand as TupleExpr\n  //       }\n\n  //       if (x.indexv >= 0) {\n  //         assert(x.indexv < tuple.exprs.length) // bounds checked when resolved\n  //         return p.resolveLitConstant(tuple.exprs[x.indexv])\n  //       } else {\n  //         debuglog(`x.indexv < 0 for IndexExpr ${x}`)\n  //       }\n  //     } else {\n  //       debuglog(`TODO ${x.constructor.name} operand ${opt}`)\n  //     }\n  //   } else {\n  //     debuglog(`TODO ${x.constructor.name}`)\n  //   }\n\n  //   return null\n  // }\n\n\n  parenExpr(ctx :exprCtx) :Expr {\n    // ParenExpr = \"(\" Expr \",\"? \")\" | TupleExpr | Assignment\n    // TupleExpr = \"(\" Expr (\",\" Expr)+ \",\"? \")\"\n    const p = this\n    const pos = p.pos\n    p.want(token.LPAREN)\n\n    const l = []\n    while (true) {\n      l.push(p.expr(ctx))\n      if (p.tok == token.ASSIGN) {\n        // e.g. \"(a, b = 1, 2)\"\n        const x = p.assignment(l)\n        p.want(token.RPAREN)\n        return x\n      }\n      if (!p.ocomma(token.RPAREN)) {\n        break  // error: unexpected ;, expecting comma, or )\n      }\n      if (p.tok == token.RPAREN) {\n        break\n      }\n    }\n    p.want(token.RPAREN)\n\n    return (\n      // l.length == 1 ? (\n      //   p.keepParens ? new ParenExpr(pos, p.scope, l[0]) :\n      //   l[0]\n      // ) :\n      l.length == 1 ? l[0] :\n      new TupleExpr(pos, p.scope, l)\n    )\n  }\n\n\n  bad(pos? :Pos) :BadExpr {\n    const p = this\n    return new BadExpr(pos === undefined ? p.pos : pos, p.scope)\n  }\n\n\n  // maybeType is like type but it returns null if there was no type\n  // instead of reporting an error.\n  //\n  // Type     = TypeName | TypeLit | \"(\" Type \")\" .\n  // TypeName = identifier | QualifiedIdent .\n  // TypeLit  = ArrayType | StructType | PointerType | FunctionType\n  //          | InterfaceType | SliceType | MapType | Channel_Type\n  maybeType() :Expr|null {\n    const p = this\n    let x :Expr|null = null\n\n    switch (p.tok) {\n\n      // TODO: all other types\n\n      case token.NAME:\n        x = p.dotident(null, p.resolve(p.ident()))\n        break\n\n      case token.LPAREN:\n        const t = p.tupleType()\n        x = (\n          t.exprs.length == 0 ? null :        // \"()\"  => null\n          t.exprs.length == 1 ? t.exprs[0] :  // \"(a)\" => \"a\"\n          t                                   // \"(a, b)\"\n        )\n        break\n\n      default:\n        return null\n    }\n\n    return x && p.types.resolve(x) || null\n  }\n\n  type() :Expr {\n    const p = this\n    let t = p.maybeType()\n    if (!t) {\n      t = p.bad()\n      p.syntaxError(\"expecting type\")\n      p.next()\n    }\n    return t\n  }\n\n  tupleType() :TupleExpr {\n    // TupleType = \"(\" Type (\",\" Type)+ \",\"? \")\"\n    const p = this\n    p.want(token.LPAREN)\n    const pos = p.pos\n    const l = []\n    while (p.tok != token.RPAREN) {\n      l.push(p.type())\n      if (!p.ocomma(token.RPAREN)) {\n        // error: unexpected ;, expecting comma, or )\n        break\n      }\n    }\n    p.want(token.RPAREN)\n    return new TupleExpr(pos, p.scope, l)\n  }\n\n  // IdentifierList = identifier { \",\" identifier } .\n  // The first identifier must be provided.\n  identList(first :Ident) :Ident[] {\n    const p = this\n    const l = [first]\n    while (p.got(token.COMMA)) {\n      l.push(p.ident())\n    }\n    return l\n  }\n\n  ident() :Ident {\n    const p = this\n    const pos = p.pos\n    if (p.tok == token.NAME) {\n      const s = p.strSet.emplace(p.takeByteValue(), p.hash)\n      p.next()\n      return new Ident(pos, p.scope, s)\n    }\n    p.syntaxError(\"expecting identifier\", pos)\n    p.advanceUntil()\n    return new Ident(pos, p.scope, p._id__)\n  }\n\n  maybeIdent() :Ident|null {\n    const p = this\n    return (p.tok == token.NAME) ? p.ident() : null\n  }\n\n  fallbackIdent(pos? :Pos) :Ident {\n    const p = this\n    return new Ident(pos === undefined ? p.pos : pos, p.scope, p._id__)\n  }\n\n  // osemi parses an optional semicolon.\n  osemi(follow :token) :bool {\n    const p = this\n\n    switch (p.tok) {\n      case token.SEMICOLON:\n        p.next()\n        return true\n    \n      case token.RPAREN:\n      case token.RBRACE:\n        // semicolon is optional before ) or }\n        return true\n    }\n  \n    p.syntaxError(\"expecting semicolon, newline, or \" + tokstr(follow))\n    p.advanceUntil(follow)\n    return false\n  }\n\n  // ocomma parses an optional comma.\n  ocomma(follow :token) :bool {\n    const p = this\n\n    switch (p.tok) {\n      case token.COMMA:\n        p.next()\n        return true\n\n      case token.RPAREN:\n      case token.RBRACE:\n        // comma is optional before ) or }\n        return true\n    }\n\n    p.syntaxError(\"expecting comma, or \" + tokstr(follow))\n    p.advanceUntil(follow)\n    return false\n  }\n\n  // appendGroup(f) = f | \"(\" { f \";\" } \")\" .\n  appendGroup<D extends Decl>(list :D[], f :(g:Group|null, i:int)=>D) {\n    const p = this\n    let i = 0\n    if (p.got(token.LPAREN)) {\n      const g = new Group()\n      while (p.tok != token.EOF && p.tok != token.RPAREN) {\n        list.push(f(g, i++))\n        if (!p.osemi(token.RPAREN)) {\n          break\n        }\n      }\n      p.want(token.RPAREN)\n    } else {\n      list.push(f(null, i))\n    }\n  }\n\n  // advanceUntil consumes tokens until it finds a token of the followlist.\n  // The stopset is only considered if we are inside a function (p.fnest > 0).\n  // The followlist is the list of valid tokens that can follow a production;\n  // if it is empty, exactly one token is consumed to ensure progress.\n  //\n  // Not speed critical, advance is only called in error situations.\n  //\n  advanceUntil(...followlist :token[]) {\n    const p = this\n\n    if (followlist.length == 0) {\n      p.next()\n      return\n    }\n\n    // TODO: improve performance of this, especially followlist.includes\n\n    if (p.fnest > 0) {\n      // The stopset contains keywords that start a statement.\n      // They are good synchronization points in case of syntax\n      // errors and (usually) shouldn't be skipped over.\n      loop1:\n      while (!followlist.includes(p.tok)) {\n        switch (p.tok) {\n          case token.EOF:\n          case token.BREAK:\n          // case token.CONST:\n          case token.CONTINUE:\n          case token.DEFER:\n          case token.FALLTHROUGH:\n          case token.FOR:\n          case token.FUN:\n          case token.GO:\n          // case token.GOTO:\n          case token.IF:\n          case token.RETURN:\n          case token.SELECT:\n          case token.SWITCH:\n          case token.TYPE:\n            break loop1\n        }\n        p.next()\n      }\n    } else {\n      while (!(p.tok == token.EOF || followlist.includes(p.tok))) {\n        p.next()\n      }\n    }\n  }\n\n  // syntaxError reports a syntax error\n  //\n  syntaxError(msg :string, pos :Pos = this.pos) {\n    const p = this\n    const position = p.sfile.position(pos)\n\n    // if (p.tok == token.EOF) {\n    //   return // avoid meaningless follow-up errors\n    // }\n\n    // add punctuation etc. as needed to msg\n    if (msg == \"\") {\n      // nothing to do\n    } else if (\n      msg.startsWith(\"in \") ||\n      msg.startsWith(\"at \") ||\n      msg.startsWith(\"after \"))\n    {\n      msg = \" \" + msg\n    } else if (msg.startsWith(\"expecting \")) {\n      msg = \", \" + msg\n    } else {\n      // plain error - we don't care about current token\n      p.errorAt(msg, position)\n      return\n    }\n\n    let cond = (\n      p.tok == token.EOF ? 'unexpected end of input' :\n      `unexpected ${tokstr(p.tok)}`\n    )\n    p.errorAt(cond + msg, position)\n    if (DEBUG) {\n      // print token state when compiled in debug mode\n      console.error(`  p.tok = ${token[p.tok]} ${tokstr(p.tok)}`)\n    }\n  }\n\n  // diag reports a diagnostic message, or an error if k is ERROR\n  //\n  diag(k :DiagKind, msg :string, pos :Pos = this.pos, code? :ErrorCode) {\n    const p = this\n    // if (code !== undefined) {\n    //   // level overridden?\n    //   k = p.diagConfig[code] || k\n    // }\n    if (k == \"error\") {\n      p.error(msg, pos, code)\n    } else if (p.diagh) {\n      p.diagh(p.sfile.position(pos), msg, k)\n    }\n  }\n\n}\n\n// unparen removes all parentheses around an expression.\n// function unparen(x :Expr) :Expr {\n//   while (x instanceof ParenExpr) {\n//     x = x.x\n//   }\n//   return x\n// }\n\nfunction isEmptyFunExpr(d :Decl) :bool {\n  return d instanceof FunExpr && !d.body\n}\n","// import { token } from './token'\nimport { SrcFileSet, Pos } from './pos'\nimport { ErrorCode, ErrorHandler, ErrorReporter } from './error'\nimport * as utf8 from './utf8'\nimport { TypeResolver } from './resolve'\nimport { debuglog as dlog } from './util'\nimport {\n  File,\n  Package,\n  Ent,\n  Ident,\n\n  FunSig,\n  ImportDecl,\n  Expr,\n  UnresolvedType,\n  FunType,\n} from './ast'\n\n\n// An Importer resolves import paths to package entities.\n// The imports map records the packages already imported,\n// indexed by package id (canonical import path).\n// An Importer must determine the canonical import path and\n// check the map to see if it is already present in the imports map.\n// If so, the Importer can return the map entry. Otherwise, the\n// Importer should load the package data for the given path into\n// a new Ent (pkg), record pkg in the imports map, and then\n// return pkg.\n//\nexport type Importer =\n  (imports :Map<string,Ent>, path :string) => Promise<Ent>\n\n\n// pkgBinder resolves a ast.Package and its ast.File s\n//\nclass pkgBinder extends ErrorReporter {\n  errorCount = 0\n  // package-global mapping of imported package ids to package entities\n  imports = new Map<string,Ent>()\n  undef :Set<Ident>|null = null // track undefined so we don't report twice\n\n  constructor(\n    public pkg      :Package,\n    public fset     :SrcFileSet,\n    public importer :Importer|null,\n    public types    :TypeResolver,\n    errh            :ErrorHandler|null,\n  ) {\n    super('E_RESOLVE', errh)\n  }\n\n  bind() :Promise<void> {\n    const b = this\n    //\n    // binding happens in three steps:\n    //\n    // 1. imports are resolved\n    // 2. identifiers are resolved in all files (and across the package)\n    // 3. types are resolved across the package\n    //\n\n    // step 1: complete file scopes with imports\n    return Promise.all(\n      b.pkg.files.map(f => this._resolveImports(f))\n    ).then(() => {\n      if (b.errorCount > 0) {\n        return  // stop when imports failed\n      }\n\n      // step 2: resolve identifiers\n      for (let f of b.pkg.files) {\n        b._resolveIdents(f)\n      }\n\n      // step 3: resolve types\n      b._resolveTypes()\n    })\n  }\n\n  _resolveImports(f :File) :Promise<void> {\n    // step 1: complete file scopes with imports\n    const b = this\n\n    if (!f.imports || f.imports.length == 0) {\n      return Promise.resolve()\n    }\n\n    const pv :Promise<void>[] = []\n\n    for (let decl of f.imports) {\n      if (!b.importer) {\n        b.error(`unresolvable import ${decl.path}`, decl.path.pos)\n        break\n      }\n      const path = utf8.decodeToString(decl.path.value)\n      pv.push(b.importer(b.imports, path)\n        .then((pkg :Ent) => { b.integrateImport(f, decl, pkg) })\n        .catch(err => {\n          b.error(\n            `could not import ${path} (${err.message || err})`,\n            decl.path.pos\n          )\n        })\n      )\n    }\n    return Promise.all(pv).then(() => {})\n  }\n\n  integrateImport(f :File, imp :ImportDecl, pkg :Ent) {\n    // local name overrides imported package name\n    let name = imp.localIdent ? imp.localIdent.value : pkg.name\n\n    if (name.toString() == \".\") { // TODO: fix efficiency\n      // TODO: merge imported scope with file scope\n      // for _, obj := range pkg.Data.(*Scope).Objects {\n      //   p.declare(fileScope, pkgScope, obj)\n      // }\n    } else if (name.toString() != \"_\") { // TODO: fix efficiency\n      // declare imported package entities in file scope\n      // (do not re-use pkg in the file scope but create\n      // a new ent instead; the Decl field is different\n      // for different files)\n      f.scope.declareEnt(new Ent(name, imp, null, pkg.data))\n    }\n  }\n\n  _resolveIdents(f :File) {\n    // step 2: resolve identifiers\n    const b = this\n\n    if (f.unresolved) for (let id of f.unresolved) {\n      // see if the name was declared after it was referenced in the file, or\n      // declared in another file in the same package\n      let ent = f.scope.lookup(id.value)\n\n      if (!ent) { // truly undefined\n        b.error(`${id} undefined`, id.pos)\n        if (!b.undef) {\n          b.undef = new Set<Ident>()\n        }\n        b.undef.add(id)\n        continue\n      }\n\n      // dlog(\n      //   `${id} (${ent.value && ent.value.constructor.name})`+\n      //   ` at ${b.fset.position(id.pos)}`\n      // )\n\n      id.refEnt(ent) // reference ent\n\n      let t = id.type\n      if (t instanceof UnresolvedType) {\n        assert(ent.value != null)\n        id.type = b.types.resolve(ent.value as Expr)\n        assert(!(id.type instanceof UnresolvedType), 'still unresolved')\n        \n        // delegate type to any expressions that reference this type\n        if (t.refs) for (let ref of t.refs) {\n          if (ref instanceof FunSig || ref instanceof FunType) {\n            ref.result = id.type\n          } else {\n            ref.type = id.type\n          }\n        }\n      }\n    }\n  }\n\n  _resolveTypes() {\n    // step 3: resolve types\n    const b = this\n\n    for (let ut of b.types.unresolved) {\n      // console.log('types.unresolved.size = ', b.types.unresolved.size)\n      const t = ut.expr.type\n\n      if (!(t instanceof UnresolvedType)) {\n        // was probably resolved during step 2\n        continue\n      }\n\n      if (b.undef && ut.expr instanceof Ident && b.undef.has(ut.expr)) {\n        continue\n      }\n  \n      // attempt to resolve the type now that we can see the entire package\n      ut.expr.type = null // clear so resolve can progress\n      const restyp = b.types.maybeResolve(ut.expr)\n\n      if (!restyp) {\n        ut.expr.type = t // restore original which might have refs\n        // Note: This normally happens when the expression contains something\n        // that itself failed to resolve, like an undefined variable.\n        dlog(\n          `cannot resolve type of ${ut.expr} ${b.fset.position(ut.expr.pos)}`\n        )\n        continue\n      }\n\n      // succeeded in resolving the type.\n      // delegate type to any expressions that reference this type.\n      if (t.refs) for (let ref of t.refs) {\n        if (ref instanceof FunSig || ref instanceof FunType) {\n          ref.result = restyp\n        } else {\n          ref.type = restyp\n        }\n      }\n    }\n  }\n\n  error(msg :string, pos :Pos, c? :ErrorCode) {\n    const b = this\n    b.errorAt(msg, b.fset.position(pos), c)\n  }\n}\n\n\n// bindpkg resolves any undefined names (usually across source files) and,\n// unless there are errors, all identifiers in the package will have Ident.ent\n// set, pointing to whatever entity a name references.\n//\n// Returns false if there were errors\n//\nexport function bindpkg(\n  pkg      :Package,\n  fset     :SrcFileSet,\n  importer :Importer|null,\n  typeres  :TypeResolver,\n  errh     :ErrorHandler,\n) :Promise<bool> {\n  const b = new pkgBinder(pkg, fset, importer, typeres, errh)\n  return b.bind().then(() => b.errorCount != 0)\n}\n","import * as util from './util'\n\n// Pos is a compact encoding of a source position within a file set.\n// It can be converted into a Position for a more convenient, but much\n// larger, representation.\n//\n// The Pos value for a given file is a number in the range [base, base+size],\n// where base and size are specified when adding the file to the file set via\n// addFile.\n//\n// To create the Pos value for a specific source offset (measured in bytes),\n// first add the respective file to the current file set using\n// SrcFileSet.addFile and then call File.Pos(offset) for that file.\n// Given a Pos value p for a specific file set fset, the corresponding Position\n// value is obtained by calling fset.Position(p).\n//\n// Pos values can be compared directly with the usual comparison operators:\n// If two Pos values p and q are in the same file, comparing p and q is\n// equivalent to comparing the respective source file offsets. If p and q\n// are in different files, p < q is true if the file implied by p was added\n// to the respective file set before the file implied by q.\n//\nexport type Pos = int\n\n// The zero value for Pos is NoPos; there is no file and line information\n// associated with it, and NoPos().IsValid() is false. NoPos is always\n// smaller than any other Pos value. The corresponding Position value\n// for NoPos is the zero value for Position.\n//\nexport const NoPos :Pos = 0\n\n// IsValid reports whether the position is valid.\nexport function PosIsValid(p :Pos) :bool {\n  return p != NoPos\n}\n\n// Position describes an arbitrary source position\n// including the file, line, and column location.\n// A Position is valid if the line number is > 0.\nexport class Position { constructor(\n  public readonly filename :string = '', // filename, if any\n  public readonly offset   :int = 0,    // offset, starting at 0\n  public readonly line     :int = 0,    // line number, starting at 1\n  public readonly column   :int = 0,    // column number, starting at 1 (byte count)\n  ) {}\n\n  // IsValid reports whether the position is valid.\n  isValid() :bool {\n    return this.line > 0\n  }\n\n  // toString returns a string in one of several forms:\n  //\n  //  file:line:column    valid position with file name\n  //  line:column         valid position without file name\n  //  file                invalid position with file name\n  //  -                   invalid position without file name\n  //\n  toString() :string {\n    let p = this\n    let s = p.filename\n    if (p.isValid()) {\n      if (s) {\n        s += \":\"\n      }\n      s += `${p.line}:${p.column}`\n    }\n    return s || \"-\"\n  }\n}\n\nconst invalidPosition = new Position()\n\n// -----------------------------------------------------------------\n\n// A lineInfo object describes alternative file and line number\n// information (such as provided via a //line comment in a .go\n// file) for a given file offset.\ninterface lineInfo {\n  offset   :int\n  filename :string\n  line     :int\n}\n\n// A SrcFile is a handle for a file belonging to a FileSet.\n// A SrcFile has a name, size, and line offset table.\nexport class SrcFile {\n  private infos :lineInfo[] = []\n\n  constructor(\n  public name  :string,  // file name as provided to addFile\n  public base  :int,     // Pos value range for this file is [base...base+size]\n  public size  :int,     // file size as provided to addFile\n  public lines :int[],\n  ) {}\n\n  // Number of lines in file\n  get lineCount() :int {\n    return this.lines.length\n  }\n\n  // addLine adds the line offset for a new line.\n  // The line offset must be larger than the offset for the previous line\n  // and smaller than the file size; otherwise the line offset is ignored.\n  //\n  addLine(offset :int) {\n    const f = this\n    const i = f.lines.length\n    if ((i === 0 || f.lines[i-1] < offset) && offset < f.size) {\n      f.lines.push(offset)\n    }\n  }\n\n  // AddLineInfo adds alternative file and line number information for\n  // a given file offset. The offset must be larger than the offset for\n  // the previously added alternative line info and smaller than the\n  // file size; otherwise the information is ignored.\n  //\n  // AddLineInfo is typically used to register alternative position\n  // information for //line filename:line comments in source files.\n  //\n  addLineInfo(offset :int, filename :string, line :int) {\n    const f = this\n    const i = f.infos.length\n    if (i == 0 || f.infos[i-1].offset < offset && offset < f.size) {\n      f.infos.push({offset, filename, line})\n    }\n  }\n\n  // Pos returns the Pos value for the given file offset;\n  // the offset must be <= f.size.\n  // f.pos(f.offset(p)) == p.\n  //\n  pos(offset :int) :Pos {\n    const f = this\n    if (offset > f.size) {\n      panic(\"illegal file offset\")\n    }\n    return f.base + offset\n  }\n\n  // Offset returns the offset for the given file position p;\n  // p must be a valid Pos value in that file.\n  // f.offset(f.pos(offset)) == offset.\n  //\n  offset(p :Pos) :int {\n    const f = this\n    if (p < f.base || p > f.base + f.size) {\n      panic(\"illegal Pos value\")\n    }\n    return p - f.base\n  }\n\n  // position returns the Position value for the given file position p.\n  // If adjusted is set, the position may be adjusted by position-altering\n  // //!line comments; otherwise those comments are ignored.\n  // p must be a Pos value in f or NoPos.\n  //\n  position(p :Pos, adjusted :bool = true) :Position {\n    const f = this\n    if (p == NoPos) {\n      return invalidPosition\n    }\n    if (p < f.base || p > f.base + f.size) {\n      panic(\"illegal Pos value\")\n    }\n    return f._position(p, adjusted)\n  }\n\n  // If adjusted is set, will return the filename and line information possibly\n  // adjusted by //line comments; otherwise those comments are ignored.\n  //\n  private _position(p :Pos, adjusted :bool) :Position {\n    const f = this\n    const offset = p - f.base\n\n    let filename = f.name\n    let line = 0, column = 0\n    \n    let i = searchInts(f.lines, offset)\n\n    if (i >= 0) {\n      line = i + 1\n      column = offset - f.lines[i] + 1\n    }\n\n    if (adjusted && f.infos.length > 0) {\n      // file has extra line infos\n      let i = searchLineInfos(f.infos, offset)\n      if (i >= 0) {\n        const alt = f.infos[i]\n        filename = alt.filename\n        i = searchInts(f.lines, alt.offset)\n        if (i >= 0) {\n          line += alt.line - i - 1\n        }\n      }\n    }\n\n    return new Position(filename, offset, line, column)\n  }\n\n}\n\nfunction searchLineInfos(a :lineInfo[], x :int) :int {\n  return util.search(a.length, (i :int) => a[i].offset > x) - 1\n}\n\n// -----------------------------------------------------------------\n\n// A SrcFileSet represents a set of source files\nexport class SrcFileSet { constructor(\n  public base:  int = 1,      // base offset for the next file. 0 == NoPos\n    // Base is the minimum base offset that must be provided to\n    // addFile when adding the next file.\n\n  public files: SrcFile[] = [],  // list of files in the order added to the set\n  public last:  SrcFile|null = null,  // cache of last file looked up\n  ) {}\n\n  // addFile adds a new file with a given filename, base offset, and file size\n  // to the file set s and returns the file. Multiple files may have the same\n  // name. The base offset must not be smaller than the SrcFileSet's Base(), and\n  // size must not be negative. As a special case, if a negative base is\n  // provided, the current value of the SrcFileSet's base() is used instead.\n  //\n  // Adding the file will set the file set's Base() value to base + size + 1\n  // as the minimum base value for the next file. The following relationship\n  // exists between a Pos value p for a given file offset offs:\n  //\n  //  int(p) = base + offs\n  //\n  // with offs in the range [0, size] and thus p in the range [base, base+size].\n  // For convenience, SrcFile.pos may be used to create file-specific position\n  // values from a file offset.\n  //\n  addFile(filename :string, size :int, base :int = -1) :SrcFile {\n    const s = this\n    if (base < 0) {\n      base = s.base\n    }\n    if (base < s.base || size < 0) {\n      panic(\"illegal base or size\")\n    }\n    // base >= s.base && size >= 0\n    const f = new SrcFile(filename, base, size, [0])\n    base += size + 1 // +1 because EOF also has a position\n    if (base < 0) {\n      panic(\"Pos offset overflow (too much source code in file set)\")\n    }\n    // add the file to the file set\n    s.base = base\n    s.files.push(f)\n    s.last = f\n    return f\n  }\n\n  // findFile returns the file that contains the position p.\n  // If no such file is found (for instance for p == NoPos),\n  // the result is null.\n  //\n  findFile(p :Pos) :SrcFile|null {\n    if (p == NoPos) {\n      return null\n    }\n    const s = this\n    // common case: p is in last file\n    let f = s.last\n    if (f && f.base <= p && p <= f.base + f.size) {\n      return f\n    }\n    // p is not in last file - search all files\n    let i = searchFiles(s.files, p)\n    if (i >= 0) {\n      f = s.files[i]\n      // f.base <= p  by definition of searchFiles\n      if (p <= f.base + f.size) {\n        s.last = f\n        return f\n      }\n    }\n    return null\n  }\n\n  // position converts a Pos p in the fileset into a Position value.\n  // If adjusted is set, the position may be adjusted by position-altering\n  // //line comments; otherwise those comments are ignored.\n  // p must be a Pos value in s or NoPos.\n  //\n  position(p :Pos, adjusted :bool = true) :Position {\n    const f = this.findFile(p)\n    return f ? f.position(p, adjusted) : invalidPosition\n  }\n}\n\n\nfunction searchFiles(a :SrcFile[], x :int) :int {\n  return util.search(a.length, (i :int) => a[i].base > x ) - 1\n}\n\n\nfunction searchInts(a :ArrayLike<int>, x :int) :int {\n  // Inlined version of\n  //  return util.search(a.length, i => a[i] > x) - 1\n  //\n  let i = 0, j = a.length\n  while (i < j) {\n    const h = i + (((j-i)/2) >> 0) // avoid overflow when computing h\n    // i ≤ h < j\n    if (a[h] <= x) {\n      i = h + 1\n    } else {\n      j = h\n    }\n  }\n  return i - 1\n}\n","import { bufcmp, asciibuf } from './util'\nimport * as utf8 from './utf8'\n//\n// Interned byte strings\n//\n\nlet _nextId = 0\n\nexport class ByteStr {\n  readonly _id :int = _nextId++ // only for debugging\n  constructor(\n  readonly hash  :int,\n  readonly bytes :Uint8Array,\n  ){}\n\n  toString() :string {\n    return utf8.decodeToString(this.bytes)\n  }\n\n  equals(other :ByteStr) :bool {\n    return (\n      this.hash == other.hash &&\n      this.bytes.length == other.bytes.length &&\n      bufcmp(this.bytes, other.bytes) == 0\n    )\n  }\n}\n\nexport class ByteStrSet {\n  _m = new Map<int,ByteStr[]>() // naive implementation\n  // TODO: use a rb-tree or something like that\n\n  emplace(value :Uint8Array, hash :int = 0) :ByteStr {\n    if (!hash) {\n      hash = hashBytes(value, 0, value.length)\n    }\n    let v = this._m.get(hash)\n    if (v) {\n      for (let bs of v) {\n        if (bs.bytes.length == value.length && bufcmp(bs.bytes, value) == 0) {\n          return bs\n        }\n      }\n      const bs = new ByteStr(hash, value)\n      v.push(bs)\n      return bs\n    } else {\n      const bs = new ByteStr(hash, value)\n      this._m.set(hash, [bs])\n      return bs\n    }\n  }\n}\n\n// hashBytes returns an unsigned 31 bit integer hash of an array of bytes.\n// It's using the FNV1a algorithm which is very fast and has good distribution\n// for common short names (based on tests on a large corpus of go source code.)\n//\nexport function hashBytes(buf :ArrayLike<byte>, offs :int, length :int) {\n  // This function must exactly match what's in scanner.\n  var h = 0x811c9dc5, i = offs, e = offs + length\n  while (i < e) {\n    h = (h ^ buf[i++]) * 0x1000193\n  }\n  return h >>> 0\n}\n\n\nexport function asciiByteStr(s :string) :ByteStr {\n  let b = asciibuf(s)\n  return new ByteStr(hashBytes(b, 0, b.length), b)\n}\n","import { Type } from './ast'\n\n// TypeSet provides interning of types based on equality on a per-constructor\n// basis.\n//\nexport class TypeSet {\n  types = new Map<Object,Set<Type>>() // type constructor => type instance\n\n  intern<T extends Type>(t :T) :T {\n    let s = this.types.get(t.constructor)\n    if (s) {\n      for (let i of s) {\n        if (i.equals(t)) {\n          assert(i instanceof t.constructor)\n          return i as T\n        }\n      }\n      s.add(t)\n    } else {\n      this.types.set(t.constructor, new Set<Type>([t]))\n    }\n    return t\n  }\n}\n","//\n// Produces a human-readable format of an AST, meant for debugging.\n//\nimport * as utf8 from './utf8'\nimport { tokstr, token } from './token'\nimport { termColorSupport, style, noStyle } from './termstyle'\nimport {\n  Package,\n  File,\n  Group,\n  Node,\n\n  Field,\n  ReturnStmt,\n  WhileStmt,\n\n  // Decl,\n  ImportDecl,\n  VarDecl,\n  TypeDecl,\n  MultiDecl,\n\n  Expr,\n  Ident,\n  RestExpr,\n  BasicLit,\n  StringLit,\n  FunExpr,\n  FunSig,\n  NoOpStmt,\n  Block,\n  IfExpr,\n  Assignment,\n  Operation,\n  CallExpr,\n  // ParenExpr,\n  TupleExpr,\n  BadExpr,\n  SelectorExpr,\n  IndexExpr,\n  SliceExpr,\n  TypeConvExpr,\n\n  Type,\n  UnresolvedType,\n  BasicType,\n  // StrType,\n  RestType,\n  TupleType,\n  FunType,\n  // UnionType,\n} from './ast'\n\n\nclass ReprCtx {\n  // This is a hack for creating printable group identifiers\n  groupIds = new Map<Group,int>()\n  nextGroupId = 0\n  ind :string = '  '\n  typedepth = 0\n  style = termColorSupport ? style : noStyle\n\n  groupId(g :Group) :string {\n    let gid = (g as any).id || this.groupIds.get(g)\n    if (gid === undefined) {\n      gid = this.nextGroupId++\n      this.groupIds.set(g, gid)\n    }\n    return gid.toString(36)\n  }\n}\n\n\nconst defaultCtx = new ReprCtx()\n\n\nexport interface ReprOptions {\n  colors?: bool\n}\n\n\nexport function astRepr(n :Package|File|Node, options? :ReprOptions) :string {\n  let ctx = defaultCtx\n  if (options) {\n    ctx = new ReprCtx()\n    if (options.colors !== undefined) {\n      ctx.style = options.colors ? style : noStyle\n    }\n  }\n  if (n instanceof Package) {\n    return reprpkg(n, ctx)\n  } if (n instanceof File) {\n    return reprfile(n, '\\n', ctx)\n  } else {\n    return repr1(n, '\\n', ctx).trim()\n  }\n}\n\n\nfunction reprpkg(n :Package, c :ReprCtx) :string {\n  let s = `(pkg \"${n.name.replace(/\"/g,'\\\\\"')}\"`\n  if (n.files.length) {\n    let nl = '\\n  '\n    for (let f of n.files) {\n      s += nl + reprfile(f, nl, c)\n    }\n    s = s.trimRight() + '\\n'\n  }\n  return s + ')'\n}\n\n\nfunction reprfile(n :File, nl :string, c :ReprCtx) :string {\n  let s = `(file \"${n.sfile.name.replace(/\"/g,'\\\\\"')}\"`\n  if (n.decls.length) {\n    let nl2 = nl + '  '\n    for (let d of n.decls) {\n      s += nl2 + repr1(d, nl2, c)\n    }\n    s = s.trimRight() + nl\n  }\n  return s + ')'\n}\n\n\nfunction _reprt(t :Type, nl :string, c :ReprCtx) :string {\n  if (t instanceof BasicType) {\n    return c.style.bold(t.name)\n  }\n  if (t instanceof TupleType) {\n    return '(' + t.types.map(t => _reprt(t, nl, c)).join(', ') + ')'\n  }\n  if (t instanceof RestType) {\n    return '...' + _reprt(t.type, nl, c)\n  }\n  if (t instanceof FunType) {\n    return (\n      '(' + t.inputs.map(it => _reprt(it, nl, c)).join(', ') + ')' +\n      '->' + _reprt(t.result, nl, c)\n    )\n  }\n  if (t instanceof UnresolvedType) {\n    return '~'\n  }\n  return t.toString()\n}\n\n\nfunction reprt0(tx :Expr|null, nl :string, c :ReprCtx) :string {\n  if (!tx) {\n    return '?'\n  }\n\n  let t :Type|null = (\n    tx instanceof Type ? tx :\n    tx.type && tx.type !== tx && tx.type instanceof Type ? tx.type :\n    null\n  )\n\n  if (t) {\n    c.typedepth++\n    const v = _reprt(t, nl, c)\n    c.typedepth--\n    return v\n  }\n\n  // unresolved\n  return '~' + repr1(tx, nl, c)\n}\n\nfunction reprt(tx :Expr|null, newline :string, c :ReprCtx) :string {\n  return c.style.blue(`<${reprt0(tx, newline, c)}>`)\n}\n\n\nfunction reprv(nv :Node[], newline :string, c :ReprCtx, delims :string='()') :string {\n  return (\n    (delims[0] || '') +\n    nv.map(n => repr1(n, newline, c)).join(' ') +\n    (delims[1] || '')\n  )\n}\n\n\n// function subscriptnum(n :int) :string {\n//   // ASCII 0-9 Unicode range: [U+0030 .. U+0039]\n//   // superscript 0-9 Unicode range: [U+2070 .. U+2079]\n//   // subscript 0-9 Unicode range: [U+2080 .. U+2089]\n//   let s = n.toString(10)\n//   let r = ''\n//   let ss0 = 0x2080 - 0x30\n//   for (let i = 0; i < s.length; ++i) {\n//     let c = s.charCodeAt(i) + ss0\n//     r += String.fromCharCode(c)\n//   }\n//   return r\n// }\n\n\nfunction reprid(id :Ident, c :ReprCtx) :string {\n  return (\n    utf8.decodeToString(id.value.bytes)\n    // + c.style.pink(subscriptnum(id.ver))\n  )\n}\n\n\nfunction reprcons(n :Node, c :ReprCtx) :string {\n  return c.style.grey(n.constructor.name)\n}\n\n\nfunction repr1(n :Node, newline :string, c :ReprCtx, flag :int = 0) :string {\n  assert(n)\n\n  if (n instanceof BasicType) {\n    return c.style.purple(c.style.bold(n.name))\n  }\n\n  if (n instanceof BasicLit || n instanceof StringLit) {\n    let s = JSON.stringify(utf8.decodeToString(n.value))\n    if (!(n instanceof StringLit)) {\n      // trim \"\n      s = s.substr(1, s.length-2)\n    }\n    return reprt(n.type, newline, c) + c.style.green(s)\n  }\n\n  if (n instanceof Ident) {\n    return (c.typedepth ? '' : reprt(n.type, newline, c)) + reprid(n, c)\n  }\n\n  if (n instanceof RestExpr) {\n    return '...' + repr1(n.expr, newline, c)\n  }\n\n  if (n instanceof BadExpr) {\n    return 'BAD'\n  }\n\n  const nl2 = newline + c.ind\n\n  if (n instanceof Field) {\n    let s = repr1(n.type, nl2, c)\n    if (n.name) {\n      s = '(' + repr1(n.name, nl2, c) + ' ' + s + ')'\n    }\n    return s\n  }\n\n  if (n instanceof Block) {\n    return (\n      n.list.length ?\n        newline + '(' + reprt(n.type, newline, c) + 'block ' +\n        n.list.map(n => nl2 + repr1(n, nl2, c).trim()).join('') +\n        newline + ')' :\n        '(block)'\n    )\n  }\n\n  if (n instanceof WhileStmt) {\n    return (\n      '(while ' + repr1(n.cond, nl2, c) + ' ' +\n      repr1(n.body, nl2, c) + newline + ')'\n    )\n  }\n\n  if (n instanceof ReturnStmt) {\n    if (n.result) {\n      return newline + `(return ${repr1(n.result, nl2, c)})`\n    }\n    return newline + reprcons(n, c)\n  }\n\n  if (n instanceof IfExpr) {\n    // flag=1 means \"else if\" branch\n    let s = (\n      ( flag ? '' :\n        newline + '(' + reprt(n.type, newline, c)\n      ) +\n      'if ' + repr1(n.cond, nl2, c) +\n      repr1(n.then, newline, c)\n    )\n    if (n.els_) {\n      s += newline + 'else ' + repr1(n.els_, newline, c, /*flag*/1)\n    }\n    return flag ? s : s + ')'\n  }\n\n  // if (n instanceof ExprStmt) {\n  //   return newline + `(${reprcons(n, c)} ${repr1(n.expr, nl2, c)})`\n  // }\n\n  if (n instanceof FunSig) {\n    return reprv(n.params, nl2, c) + ' -> ' + reprt(n.result, nl2, c)\n  }\n\n  if (n instanceof Assignment) {\n    let s = newline + `(${reprcons(n, c)} `\n    s += reprv(n.lhs, nl2, c)\n    if (n.op == token.ILLEGAL) {\n      s += ' = '\n    } else {\n      s += ' ' + tokstr(n.op) + ' '\n    }\n    s += reprv(n.rhs, nl2, c)\n    return s + ')'\n  }\n\n  if (n instanceof MultiDecl) {\n    return newline + `(${reprcons(n, c)}` + ' ' + reprv(n.decls, nl2, c, '') + ')'\n  }\n\n  // if (n instanceof UnresolvedType) {\n  //   return '<~>'\n  // }\n\n  if (n instanceof SelectorExpr) {\n    return (\n      '(SEL ' +\n      repr1(n.lhs, newline, c) + '.' +\n      repr1(n.rhs, newline, c) + ')'\n    )\n  }\n\n  if (n instanceof IndexExpr) {\n    return (\n      `(${reprt(n.type, newline, c)}index ` +\n      repr1(n.operand, newline, c) + ' ' +\n      repr1(n.index, newline, c) +\n      ')'\n    )\n  }\n\n  if (n instanceof SliceExpr) {\n    return (\n      `(${reprt(n.type, newline, c)}slice ` +\n      repr1(n.operand, newline, c) + ' ' +\n      (n.start ? repr1(n.start, newline, c) : 'nil') + ' ' +\n      (n.end ? repr1(n.end, newline, c) : 'nil') +\n      ')'\n    )\n  }\n\n  if (n instanceof Operation) {\n    let ts = c.typedepth ? '' : reprt(n.type, newline, c)\n    let s = '(' + ts + c.style.orange(token[n.op]) + ' ' + repr1(n.x, nl2, c)\n    if (n.y) {\n      s += ' ' + repr1(n.y, nl2, c)\n    }\n    return s + ')'\n  }\n\n\n  // --------\n\n  let s = '('\n  if (n instanceof Expr && !c.typedepth) {\n    s += reprt(n.type, newline, c)\n  }\n\n\n  if (n instanceof FunExpr) {\n    s += 'fun '\n    if (n.isInit) {\n      s += 'init '\n    } else if (n.name) {\n      s += reprid(n.name, c) + ' '\n    }\n    s += repr1(n.sig, newline, c)\n    if (n.body) {\n      s += ' ' + repr1(n.body, nl2, c)\n    }\n    return s + ')'\n  }\n\n\n  // --------\n\n  s += reprcons(n, c)\n\n  if (n instanceof ImportDecl) {\n    s += ' path: ' + repr1(n.path, nl2, c)\n    if (n.localIdent) {\n      s += newline +\n        c.ind + 'localIdent: ' + repr1(n.localIdent, nl2, c)\n    }\n    return s + ' )'\n  }\n\n  if (n instanceof VarDecl) {\n    if (n.group) {\n      s += ' [#' + c.groupId(n.group) + ']'\n    }\n    if (n.type) {\n      s += reprt(n.type, newline, c) + ' ' + reprv(n.idents, nl2, c)\n    } else {\n      s += ' (' + n.idents.map(id =>\n        reprt(id, newline, c) + reprid(id, c)\n      ).join(' ') + ')'\n    }\n    if (n.values) {\n      s += ' ' + reprv(n.values, nl2, c)\n    }\n    return s + ')'\n  }\n\n  if (n instanceof TypeDecl) {\n    if (n.group) {\n      s += ' [#' + c.groupId(n.group) + ']'\n    }\n    s += ' ' + repr1(n.ident, nl2, c)\n    if (n.alias) {\n      s += ' ='\n    }\n    return s + ' ' + repr1(n.type, nl2, c) + ')'\n  }\n\n  if (n instanceof CallExpr) {\n    s += ' ' + repr1(n.fun, newline, c) + ' ('\n    s += reprv(n.args, nl2, c, '')\n    if (n.hasDots) {\n      s += '...'\n    }\n    return s + '))'\n  }\n\n  // if (n instanceof ParenExpr) {\n  //   return s + ' ' + repr1(n.x, newline, c) + ')'\n  // }\n\n  if (n instanceof TypeConvExpr) {\n    return s + ' ' + repr1(n.expr, newline, c) + ')'\n  }\n\n  if (n instanceof TupleExpr) {\n    return s + ' ' + reprv(n.exprs, nl2, c, '') + ')'\n  }\n\n  if (n.constructor === NoOpStmt) {\n    return 'noop'\n  }\n\n  return '(???'+ reprcons(n, c) + ' ' + repr(n) + ')'\n}\n","import { ByteStr, ByteStrSet } from './bytestr'\nimport { asciibuf, bufcmp } from './util'\nimport { token, tokstr } from './token'\nimport { Pos } from './pos'\nimport { TypeSet } from './typeset'\nimport {\n  Scope,\n  Ent,\n  BasicLit,\n  IntrinsicVal,\n  Type,\n  BasicType,\n  IntType,\n  u_t_nil,\n  u_t_bool,\n  u_t_uint,\n  u_t_int,\n  u_t_i8,\n  u_t_i16,\n  u_t_i32,\n  u_t_i64,\n  u_t_u8,\n  u_t_u16,\n  u_t_u32,\n  u_t_u64,\n  u_t_f32,\n  u_t_f64,\n  u_t_str,\n} from './ast'\n\nexport const universeTypes = new Map<string,Type>()\nexport const universeValues = new Map<string,IntrinsicVal>()\n\nfunction namedtype(x :Type, name :string) {\n  assert(!universeTypes.has(name))\n  universeTypes.set(name, x)\n  return x\n}\n\nfunction ival(name :string, typ :BasicType) :IntrinsicVal {\n  const x = new IntrinsicVal(name, typ)\n  assert(!universeValues.has(name))\n  universeValues.set(name, x)\n  return x\n}\n\n// universe values\nexport const\n  u_v_true  = ival('true', u_t_bool)\n, u_v_false = ival('false', u_t_bool)\n, u_v_nil   = ival('nil', u_t_nil)\n\nconst uintz :number = 32 // TODO: target-dependant\n\n// basic types\nnamedtype(u_t_bool, 'bool')\nnamedtype(u_t_uint, 'uint')\nnamedtype(u_t_int,  'int')\nnamedtype(u_t_i8,   'i8')\nnamedtype(u_t_i16,  'i16')\nnamedtype(u_t_i32,  'i32')\nnamedtype(u_t_i64,  'i64')\nnamedtype(u_t_u8,   'u8')\nnamedtype(u_t_u16,  'u16')\nnamedtype(u_t_u32,  'u32')\nnamedtype(u_t_u64,  'u64')\nnamedtype(u_t_f32,  'f32')\nnamedtype(u_t_f64,  'f64')\nnamedtype(u_t_str,  'str')\n\nexport const universeTypeAliases = new Map<string,string>([\n  ['byte', 'u8'],\n  ['char', 'u32'],\n])\n\n\n// type compatibility\nexport enum TypeCompat {\n  NO = 0,   // not compatible\n  LOSSY,    // can be converted at a loss\n  LOSSLESS, // can be converted safely without loss\n}\n\n// maps destination type to receiver types and their compatbility type\nconst typeCompatMap = new Map<BasicType,Map<BasicType,TypeCompat>>([\n\n  [u_t_u64, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSLESS],\n    [u_t_int,  TypeCompat.LOSSLESS],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSLESS],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSLESS],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i64, new Map<BasicType,TypeCompat>([\n    [u_t_uint, uintz <= 63 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSLESS],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSLESS],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_u32, new Map<BasicType,TypeCompat>([\n    [u_t_uint, uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i32, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_uint, new Map<BasicType,TypeCompat>([\n    [u_t_int, TypeCompat.LOSSLESS],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, uintz >= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_u64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_int, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, uintz >= 64 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, uintz >= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_u16, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i16, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSY],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_u8, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSY],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u16, TypeCompat.LOSSY],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_i8, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i16, TypeCompat.LOSSY],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSY],\n    [u_t_u16, TypeCompat.LOSSY],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSY],\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_f32, new Map<BasicType,TypeCompat>([\n    [u_t_uint, TypeCompat.LOSSY],\n    [u_t_int,  TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSY],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSY],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f64, TypeCompat.LOSSY],\n  ])],\n\n  [u_t_f64, new Map<BasicType,TypeCompat>([\n    [u_t_uint, uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n    [u_t_int,  uintz <= 32 ? TypeCompat.LOSSLESS : TypeCompat.LOSSY],\n\n    [u_t_i8,  TypeCompat.LOSSLESS],\n    [u_t_i16, TypeCompat.LOSSLESS],\n    [u_t_i32, TypeCompat.LOSSLESS],\n    [u_t_i64, TypeCompat.LOSSY],\n\n    [u_t_u8,  TypeCompat.LOSSLESS],\n    [u_t_u16, TypeCompat.LOSSLESS],\n    [u_t_u32, TypeCompat.LOSSLESS],\n    [u_t_u64, TypeCompat.LOSSY],\n\n    [u_t_f32, TypeCompat.LOSSLESS],\n  ])],\n])\n\nexport function basicTypeCompat(dst :BasicType, src :BasicType) :TypeCompat {\n  assert(dst !== src, \"same type is always compatible\")\n  let s = typeCompatMap.get(dst)\n  return s && s.get(src) || TypeCompat.NO\n}\n\nTEST(\"basicTypeCompat\", () => {\n  function assertTypeCompat(\n    dst :BasicType,\n    src :BasicType,\n    expect :TypeCompat,\n    cons :Function,\n  ) {\n    const r = basicTypeCompat(dst, src)\n    assert(\n      r === expect,\n      `${dst}(${src}) == ${TypeCompat[r]} (expected ${TypeCompat[expect]})`,\n      cons\n    )\n  }\n\n  function assert_LOSSLESS(dst :BasicType, src :BasicType) {\n    assertTypeCompat(dst, src, TypeCompat.LOSSLESS, assert_LOSSLESS)\n  }\n\n  function assert_LOSSY(dst :BasicType, src :BasicType) {\n    assertTypeCompat(dst, src, TypeCompat.LOSSY, assert_LOSSY)\n  }\n\n  // u64\n  assert_LOSSLESS(u_t_u64, u_t_uint)\n  assert_LOSSLESS(u_t_u64, u_t_int)\n  assert_LOSSLESS(u_t_u64, u_t_i64)\n  assert_LOSSLESS(u_t_u64, u_t_u32)\n  assert_LOSSLESS(u_t_u64, u_t_i32)\n  assert_LOSSLESS(u_t_u64, u_t_u16)\n  assert_LOSSLESS(u_t_u64, u_t_i16)\n  assert_LOSSLESS(u_t_u64, u_t_u8)\n  assert_LOSSLESS(u_t_u64, u_t_i8)\n  assert_LOSSY   (u_t_u64, u_t_f32)\n  assert_LOSSY   (u_t_u64, u_t_f64)\n\n  // i64\n  assert_LOSSLESS(u_t_i64, u_t_uint)\n  if (uintz == 64) {\n    assert_LOSSY(u_t_i64, u_t_int)\n  } else {\n    assert_LOSSLESS(u_t_i64, u_t_int)\n  }\n  assert_LOSSY   (u_t_i64, u_t_u64)\n  assert_LOSSLESS(u_t_i64, u_t_u32)\n  assert_LOSSLESS(u_t_i64, u_t_i32)\n  assert_LOSSLESS(u_t_i64, u_t_u16)\n  assert_LOSSLESS(u_t_i64, u_t_i16)\n  assert_LOSSLESS(u_t_i64, u_t_u8)\n  assert_LOSSLESS(u_t_i64, u_t_i8)\n  assert_LOSSY   (u_t_i64, u_t_f32)\n  assert_LOSSY   (u_t_i64, u_t_f64)\n\n  // u32\n  if (uintz == 64) {\n    assert_LOSSY(u_t_u32, u_t_uint)\n    assert_LOSSY(u_t_u32, u_t_int)\n  } else {\n    assert_LOSSLESS(u_t_u32, u_t_uint)\n    assert_LOSSLESS(u_t_u32, u_t_int)\n  }\n  assert_LOSSY   (u_t_u32, u_t_u64)\n  assert_LOSSY   (u_t_u32, u_t_i64)\n  assert_LOSSLESS(u_t_u32, u_t_i32)\n  assert_LOSSLESS(u_t_u32, u_t_u16)\n  assert_LOSSLESS(u_t_u32, u_t_i16)\n  assert_LOSSLESS(u_t_u32, u_t_u8)\n  assert_LOSSLESS(u_t_u32, u_t_i8)\n  assert_LOSSY   (u_t_u32, u_t_f32)\n  assert_LOSSY   (u_t_u32, u_t_f64)\n\n  // i32\n  assert_LOSSY   (u_t_i32, u_t_uint)\n  if (uintz == 64) {\n    assert_LOSSY(u_t_i32, u_t_int)\n  } else {\n    assert_LOSSLESS(u_t_i32, u_t_int)\n  }\n  assert_LOSSY   (u_t_i32, u_t_u64)\n  assert_LOSSY   (u_t_i32, u_t_i64)\n  assert_LOSSY   (u_t_i32, u_t_u32)\n  assert_LOSSLESS(u_t_i32, u_t_u16)\n  assert_LOSSLESS(u_t_i32, u_t_i16)\n  assert_LOSSLESS(u_t_i32, u_t_u8)\n  assert_LOSSLESS(u_t_i32, u_t_i8)\n  assert_LOSSY   (u_t_i32, u_t_f32)\n  assert_LOSSY   (u_t_i32, u_t_f64)\n\n  // u16\n  assert_LOSSY   (u_t_u16, u_t_uint)\n  assert_LOSSY   (u_t_u16, u_t_int)\n  assert_LOSSY   (u_t_u16, u_t_u64)\n  assert_LOSSY   (u_t_u16, u_t_i64)\n  assert_LOSSY   (u_t_u16, u_t_u32)\n  assert_LOSSY   (u_t_u16, u_t_i32)\n  assert_LOSSLESS(u_t_u16, u_t_i16)\n  assert_LOSSLESS(u_t_u16, u_t_u8)\n  assert_LOSSLESS(u_t_u16, u_t_i8)\n  assert_LOSSY   (u_t_u16, u_t_f32)\n  assert_LOSSY   (u_t_u16, u_t_f64)\n\n  // i16\n  assert_LOSSY   (u_t_i16, u_t_uint)\n  assert_LOSSY   (u_t_i16, u_t_int)\n  assert_LOSSY   (u_t_i16, u_t_u64)\n  assert_LOSSY   (u_t_i16, u_t_i64)\n  assert_LOSSY   (u_t_i16, u_t_u32)\n  assert_LOSSY   (u_t_i16, u_t_i32)\n  assert_LOSSY   (u_t_i16, u_t_u16)\n  assert_LOSSLESS(u_t_i16, u_t_u8)\n  assert_LOSSLESS(u_t_i16, u_t_i8)\n  assert_LOSSY   (u_t_i16, u_t_f32)\n  assert_LOSSY   (u_t_i16, u_t_f64)\n\n  // u8\n  assert_LOSSY   (u_t_u8, u_t_uint)\n  assert_LOSSY   (u_t_u8, u_t_int)\n  assert_LOSSY   (u_t_u8, u_t_u64)\n  assert_LOSSY   (u_t_u8, u_t_i64)\n  assert_LOSSY   (u_t_u8, u_t_u32)\n  assert_LOSSY   (u_t_u8, u_t_i32)\n  assert_LOSSY   (u_t_u8, u_t_u16)\n  assert_LOSSY   (u_t_u8, u_t_i16)\n  assert_LOSSLESS(u_t_u8, u_t_i8)\n  assert_LOSSY   (u_t_u8, u_t_f32)\n  assert_LOSSY   (u_t_u8, u_t_f64)\n\n  // i8\n  assert_LOSSY   (u_t_i8, u_t_uint)\n  assert_LOSSY   (u_t_i8, u_t_int)\n  assert_LOSSY   (u_t_i8, u_t_u64)\n  assert_LOSSY   (u_t_i8, u_t_i64)\n  assert_LOSSY   (u_t_i8, u_t_u32)\n  assert_LOSSY   (u_t_i8, u_t_i32)\n  assert_LOSSY   (u_t_i8, u_t_u16)\n  assert_LOSSY   (u_t_i8, u_t_i16)\n  assert_LOSSY   (u_t_i8, u_t_u8)\n  assert_LOSSY   (u_t_i8, u_t_f32)\n  assert_LOSSY   (u_t_i8, u_t_f64)\n\n  // f64\n  if (uintz <= 32) {\n    assert_LOSSLESS(u_t_f64, u_t_uint)\n    assert_LOSSLESS(u_t_f64, u_t_int)\n  } else {\n    assert_LOSSY   (u_t_f64, u_t_uint)\n    assert_LOSSY   (u_t_f64, u_t_int)\n  }\n  assert_LOSSY   (u_t_f64, u_t_u64)\n  assert_LOSSY   (u_t_f64, u_t_i64)\n  assert_LOSSLESS(u_t_f64, u_t_u32)\n  assert_LOSSLESS(u_t_f64, u_t_i32)\n  assert_LOSSLESS(u_t_f64, u_t_u16)\n  assert_LOSSLESS(u_t_f64, u_t_i16)\n  assert_LOSSLESS(u_t_f64, u_t_u8)\n  assert_LOSSLESS(u_t_f64, u_t_i8)\n  assert_LOSSLESS(u_t_f64, u_t_f32)\n\n  // f32\n  assert_LOSSY   (u_t_f32, u_t_uint)\n  assert_LOSSY   (u_t_f32, u_t_int)\n  assert_LOSSY   (u_t_f32, u_t_u64)\n  assert_LOSSY   (u_t_f32, u_t_i64)\n  assert_LOSSY   (u_t_f32, u_t_u32)\n  assert_LOSSY   (u_t_f32, u_t_i32)\n  assert_LOSSLESS(u_t_f32, u_t_u16)\n  assert_LOSSLESS(u_t_f32, u_t_i16)\n  assert_LOSSLESS(u_t_f32, u_t_u8)\n  assert_LOSSLESS(u_t_f32, u_t_i8)\n  assert_LOSSY   (u_t_f32, u_t_f64)\n})\n\n\n// ————————————————————————————————————————————————————————————————\n// literal types\n\nfunction intBinBits(v :Uint8Array, neg :bool) :number {\n  let start = 2 // skip 0b or 0B\n  while (v[start] == 0x30) { start++ } // skip leading zeroes\n  let n = v.length - start\n  if (n > 64) {\n    return 0\n  }\n  if (n == 0) {\n    return 1\n  }\n  if (neg) {\n    if (n == 64) {\n      // check for special-case I64_MIN\n      let i = start\n      // ++i: skip first byte whoch we know to be '1'\n      while (v[++i] == 0x30) {}\n      if (i - start == 64) {\n        // matches \"-0b10000000000000000000000000000...\"\n        return 63\n      }\n      return 0\n    }\n\n    if (n > 31) {\n      // check for special-case I32_MIN\n      let i = start\n      // ++i: skip first byte whoch we know to be '1'\n      while (v[++i] == 0x30) {}\n      if (i - start == 32) {\n        // matches \"-0b10000000000000000000000000000000\"\n        return 31\n      }\n      return 63\n    }\n\n    n--\n  }\n  return n\n}\n\nfunction testIntBits(fn :(v :Uint8Array, neg :bool)=>int, v :(string|int)[]) {\n  let input = v[0] as string\n  let expected = v[1] as int\n  let neg = false\n  if (input[0] == '-') {\n    neg = true\n    input = input.substr(1)\n  }\n  let actual = fn(asciibuf(input), neg)\n  assert(\n    actual == expected,\n    JSON.stringify(v[0] as string) + ` => ${actual}; expected ${expected}`\n  )\n}\n\nTEST(\"intBinBits\", () => {\n  [\n    [\"0b0\",         1], // 0x0\n    [\"0b1111111\",   7], // 0x7F\n    [\"0b10000000\",  8], // 0x80\n    [\"0b11111111\",  8], // 0xFF\n    \n    [\"0b100000000\", 9],          // 0x100\n    [\"0b111111111111111\",   15], // 0x7FFF\n    [\"0b1000000000000000\",  16], // 0x8000\n    [\"0b1111111111111111\",  16], // 0xFFFF\n    \n    [\"0b10000000000000000\", 17],                 // 0x10000\n    [\"0b1111111111111111111111111111111\",   31], // 0x7FFFFFFF (I32_MAX)\n    [\"0b10000000000000000000000000000000\",  32], // 0x80000000\n    [\"0b11111111111111111111111111111111\",  32], // 0xFFFFFFFF\n\n    [\"0b100000000000000000000000000000000\", 33], // 0x100000000\n    [\"0b11111111111111111111111111111111111111111111111111111\", 53],\n      // 0x1FFFFFFFFFFFFF (js MAX_SAFE_INTEGER)\n    [\"0b111111111111111111111111111111111111111111111111111111111111111\", 63],\n      // 0x7FFFFFFFFFFFFFFF\n    [\"0b1000000000000000000000000000000000000000000000000000000000000000\", 64],\n      // 0x8000000000000000\n    [\"0b1111111111111111111111111111111111111111111111111111111111111111\", 64],\n      // 0xFFFFFFFFFFFFFFFF\n    [\"0b10000000000000000000000000000000000000000000000000000000000000000\", 0],\n      // 0x10000000000000000 too large\n\n    // negative\n    [\"-0b10000000000000000000000000000000\", 31], // -0x80000000 (I32_MIN)\n    [\"-0b10000000000000000000000000000001\", 63], // I32_MIN+1\n    [\"-0b1000000000000000000000000000000000000000000000000000000000000000\", 63],\n      // -0x8000000000000000 (I64_MIN)\n    [\"-0b1000000000000000000000000000000000000000000000000000000000000001\", 0],\n      // I64_MIN+1\n  ].map(v => testIntBits(intBinBits, v))\n})\n\n\nconst i32minOctBuf = new Uint8Array([ // \"20000000000\"\n  50 ,48,48,48,48 ,48,48,48,48 ,48,48\n])\nconst i64minOctBuf = new Uint8Array([ // \"1000000000000000000000\"\n  49 ,48,48,48,48 ,48,48,48,48 ,48,48,48,48 ,48,48,48,48 ,48,48,48,48 ,48\n\n  // 1   0000         0000         0000         0000         0000       0\n])\n\nfunction intOctBits(b :Uint8Array, neg :bool) :number {\n  let start = 2 // skip 0o or 0O\n  while (b[start] == 0x30) { start++ } // skip leading zeroes\n  let z = b.length - start\n  //\n  //         bits   hexadecimal             octal\n  // ------  ---  ---------------  -----------------------\n  // i8max    7   7F                177\n  // u8max    8   FF                377\n  // i16max  15   7FFF              77777\n  // u16max  16   FFFF              177777\n  // i32max  31   7FFFFFFF          17777777777\n  // u32max  32   FFFFFFFF          37777777777\n  // i64max  63   7FFFFFFFFFFFFFFF  777777777777777777777\n  // u64max  64   FFFFFFFFFFFFFFFF  1777777777777777777777\n  //\n  return (\n    z < 3 ? 7 :\n    z == 3 ? (\n      b[start] < 0x32 ? 7 : // <= 177 0x7F\n      b[start] < 0x34 ? 8 : // <= 377 0xFF\n      15 // > 377 0xFF\n    ) :\n    z < 6 ? 15 : // <= 77777 0x7FFF\n    z == 6 && b[start] < 0x32 ? 16 : // <= 177777 0xFFFF\n    z < 11 ? 31 : // > 177777 0xFFFF && < 10000000000 0x40000000\n    z == 11 ? (\n      // special case for I32_MIN \"-0o20000000000\":\n      neg ? (bufcmp(b, i32minOctBuf, start) <= 0 ? 31 : 63) :\n\n      b[start] < 0x32 ? 31 : // <= 17777777777 0x7FFFFFFF\n      b[start] < 0x34 ? 32 : // <= 37777777777 0xFFFFFFFF\n      63\n    ) :\n    z < 22 ? 63 : // <= 777777777777777777777 0x7FFFFFFFFFFFFFFF\n    z == 22 ? (\n      // special case for I64_MIN \"-0o1000000000000000000000\"\n      neg ? (bufcmp(b, i64minOctBuf, start) <= 0 ? 63 : 0) :\n\n      b[start] < 0x32 ? 64 : // <= 1777777777777777777777\n      0\n    ) :\n    0\n  )\n}\n\nTEST(\"intOctBits\", () => {\n  [\n    [\"0o0\",   7], // 0x0\n    [\"0o177\", 7], // 0x7F\n    [\"0o200\", 8], // 0x80\n    [\"0o377\", 8], // 0xFF\n    \n    [\"0o400\", 15],    // 0x100\n    [\"0o77777\",  15], // 0x7FFF\n    [\"0o100000\", 16], // 0x8000\n    [\"0o177777\", 16], // 0xFFFF\n    \n    [\"0o200000\", 31],      // 0x10000\n    [\"0o17777777777\", 31], // 0x7FFFFFFF (I32_MAX)\n    [\"0o20000000000\", 32], // 0x80000000\n    [\"0o37777777777\", 32], // 0xFFFFFFFF\n\n    [\"0o40000000000\", 63],            // 0x100000000\n    [\"0o377777777777777777\", 63],     // 0x1FFFFFFFFFFFFF (js MAX_SAFE_INTEGER)\n    [\"0o777777777777777777777\", 63],  // 0x7FFFFFFFFFFFFFFF (I64_MAX)\n    [\"0o1000000000000000000000\", 64], // 0x8000000000000000\n    [\"0o1777777777777777777777\", 64], // 0xFFFFFFFFFFFFFFFF (U64_MAX)\n    [\"0o2000000000000000000000\", 0],  // 0x10000000000000000 too large\n\n    // negative\n    [\"-0o20000000000\", 31], // -0x80000000 (I32_MIN)\n    [\"-0o20000000001\", 63], // I32_MIN+1\n    [\"-0o1000000000000000000000\", 63], // -0x8000000000000000 (I64_MIN)\n    [\"-0o1000000000000000000001\", 0], // I64_MIN+1\n  ].map(v => testIntBits(intOctBits, v))\n})\n\n\nconst i64maxDecBuf = new Uint8Array([ // \"9223372036854775807\"\n  57,50,50,51,51,55,50,48,51,54,56,53,52,55,55,53,56,48,55\n])\nconst i64minDecBuf = new Uint8Array([ // \"9223372036854775808\"\n  57,50,50,51,51,55,50,48,51,54,56,53,52,55,55,53,56,48,56\n])\n\nconst u64maxDecBuf = new Uint8Array([ // \"18446744073709551615\"\n  49,56,52,52,54,55,52,52,48,55,51,55,48,57,53,53,49,54,49,53\n])\n\n\nfunction intDecBits(b :Uint8Array, neg :bool) :number {\n  let v = 0, z = b.length\n  for (let i = 0; i < z; i++) {\n    v = v * 10 + (b[i] - 0x30)\n  }\n  if (v < 0x80) {\n    return 7\n  }\n  if (v < 0x1FFFFFFFFFFFFF) {\n    let bits = Math.floor(Math.log2(neg ? v-1 : v)) + 1\n    // v-1: negative extreme is one larger than positive for signed integers\n    if (neg && bits > 31) {\n      bits = 63\n    }\n    return bits\n  }\n  // Beyond js integer precision. We have to look at the bytes.\n  let start = 0\n  while (b[start] == 0x30) { start++ } // skip leading zeroes\n  z = b.length - start\n  return  (\n    z < 19 ? 63 :\n    z == 19 ?\n      bufcmp(b, neg ? i64minDecBuf : i64maxDecBuf, start) <= 0 ? 63 :\n      neg ? 0 : 64 :\n    z == 20 && bufcmp(b, u64maxDecBuf, start) <= 0 ? 64 : 0\n  )\n}\n\nTEST(\"intDecBits\", () => {\n  [\n    [\"0\",   7],  // 0x0\n    [\"127\", 7],  // 0x7F\n    [\"128\", 8],  // 0x80\n    [\"255\", 8],  // 0xFF\n    \n    [\"256\", 9],     // 0x100\n    [\"32767\", 15],  // 0x7FFF\n    [\"32768\", 16],  // 0x8000\n    [\"65535\", 16],  // 0xFFFF\n    \n    [\"65536\", 17],      // 0x10000\n    [\"2147483647\", 31], // 0x7FFFFFFF (I32_MAX)\n    [\"2147483648\", 32], // 0x80000000\n    [\"4294967295\", 32], // 0xFFFFFFFF\n\n    [\"4294967296\", 33],           // 0x100000000\n    [\"9007199254740991\", 63],     // 0x1FFFFFFFFFFFFF (js MAX_SAFE_INTEGER)\n    [\"9223372036854775807\", 63],  // 0x7FFFFFFFFFFFFFFF (I64_MAX)\n    [\"9223372036854775808\", 64],  // 0x8000000000000000\n    [\"18446744073709551615\", 64], // 0xFFFFFFFFFFFFFFFF\n    [\"18446744073709551616\", 0],  // 0x10000000000000000 too large\n\n    // negative\n    [\"-2147483648\", 31], // -0x80000000 (I32_MIN)\n    [\"-2147483649\", 63], // I32_MIN+1\n    [\"-9223372036854775808\", 63], // -0x8000000000000000 (I64_MIN)\n    [\"-9223372036854775809\", 0], // I64_MIN+1\n  ].map(v => testIntBits(intDecBits, v))\n})\n\nconst i64minHexBuf = new Uint8Array([ // \"8000000000000000\"\n  56, 48,48,48,48, 48,48,48,48, 48,48,48,48, 48,48,48\n])\n\nfunction intHexBits(b :Uint8Array, neg :bool) :number {\n  let v = 0, z = b.length\n  for (let n = 0, i = 2; i < z; i++) {\n    n = b[i]\n    n = (\n      n >= 0x30 && n <= 0x39 ? n - 0x30 :  // 0..9\n      n >= 0x41 && n <= 0x46 ? n - 0x41 + 10 :  // A..F\n      n - 0x61 + 10  // a..f -- scanner guarantees 0-9A-Fa-f\n    )\n    v = v * 16 + n\n  }\n  if (v < 0x80) {\n    return 7\n  }\n  if (v < 0x1FFFFFFFFFFFFF) {\n    let bits = Math.floor(Math.log2(neg ? v-1 : v)) + 1\n    // v-1: negative extreme is one larger than positive for signed integers\n    if (neg && bits > 31) {\n      bits = 63\n    }\n    return bits\n  }\n  // Beyond js integer precision. We have to look at the bytes.\n  let start = 2 // skip 0x or 0X\n  while (b[start] == 0x30) { start++ } // skip leading zeroes\n  z = b.length - start\n  return (\n    z < 16 || (z == 16 && b[start] <= 0x37) ? 63 :\n    z == 16 ?\n      // special case for I64_MIN \"-0x8000000000000000\"\n      neg ? (bufcmp(b, i64minHexBuf, start) <= 0 ? 63 : 0) :\n      64 :\n    0\n  )\n}\n\nTEST(\"intHexBits\", () => {\n  [\n    [\"0x0\",  7],\n    [\"0x7F\", 7],\n    [\"0x80\", 8],\n    [\"0xFF\", 8],\n    \n    [\"0x100\", 9],\n    [\"0x7FFF\", 15],\n    [\"0x8000\", 16],\n    [\"0xFFFF\", 16],\n    \n    [\"0x10000\", 17],\n    [\"0x7FFFFFFF\", 31], // I32_MAX\n    [\"0x80000000\", 32],\n    [\"0xFFFFFFFF\", 32], // U32_MAX\n\n    [\"0x100000000\", 33],\n    [\"0x1FFFFFFFFFFFFF\", 63],   // (js MAX_SAFE_INTEGER)\n    [\"0x7FFFFFFFFFFFFFFF\", 63], // I64_MAX\n    [\"0x8000000000000000\", 64],\n    [\"0xFFFFFFFFFFFFFFFF\", 64], // U64_MAX\n    [\"0x10000000000000000\", 0], // too large\n\n    // negative\n    [\"-0x80000000\", 31], // I32_MIN\n    [\"-0x80000001\", 63], // I32_MIN+1\n    [\"-0x8000000000000000\", 63], // I64_MIN\n    [\"-0x8000000000000001\", 0], // I64_MIN+1\n  ].map(v => testIntBits(intHexBits, v))\n})\n\n\nexport type ErrorHandler = (msg :string, pos :Pos) => any\n\n// basicLitTypeStorageMap maps storage types to all possible values types that\n// can be stored (in the storage type) losslessly.\n//\n// const basicLitTypeStorageMap = new Map<BasicType,Set<BasicType>>([\n//   // storageType => valueTypes[]\n//   [u_t_i64, new Set([\n//     u_t_char,\n//     u_t_i8, u_t_i16, u_t_i32, u_t_i64,\n//     u_t_u8, u_t_u16, u_t_u32\n//   ])],\n// ])\n\n// basicLitTypeFitter is a function that produces the most fitting type\n// for a basic literal. It may receive a \"requested type\", in which case the\n// reqt should be reutned if the literal can safely be represented as reqt.\n//\ntype basicLitTypeFitter = (\n  x :BasicLit,\n  reqt :Type|null,\n  errh? :ErrorHandler,\n  op? :token,\n) => BasicType\n\n\nfunction intBits(x :BasicLit, neg :bool) :int {\n  // calculate minimum bit length\n  switch (x.kind) {\n    case token.INT_BIN: return intBinBits(x.value, neg)\n    case token.INT_OCT: return intOctBits(x.value, neg)\n    case token.INT:     return intDecBits(x.value, neg)\n    case token.INT_HEX: return intHexBits(x.value, neg)\n    default: return 0\n  }\n}\n\n\n// function smallestIntType(bits :int, neg :bool) :IntType {\n//   return (\n//     bits <= 7 ? u_t_i8 :\n//     bits <= 8 && !neg ? u_t_u8 :\n//     bits <= 15 ? u_t_i16 :\n//     bits <= 16 && !neg ? u_t_u16 :\n//     bits <= 31 ? u_t_i32 :\n//     bits <= 32 && !neg ? u_t_u32 :\n//     bits > 63 && !neg ? u_t_u64 :\n//     u_t_i64\n//   )\n// }\n\n\nfunction intLitTypeFitter(\n  x :BasicLit,\n  reqt :Type|null,\n  errh? :ErrorHandler,\n  op? :token,\n) :BasicType {\n  const neg = op == token.SUB\n  let bits = intBits(x, neg)\n  const maxtype = neg ? u_t_i64 : u_t_u64\n\n  if (bits == 0) {  // literal is too large\n    // TODO: support bigint transparently\n    if (errh) {\n      let t = reqt instanceof BasicType ? reqt : maxtype\n      errh(`constant ${x} overflows ${t.name}`, x.pos)\n      bits = 64\n    }\n  } else if (reqt) {\n    if (reqt instanceof IntType) {\n      if (reqt.bitsize >= bits && (!neg || reqt.signed)) {\n        // yay! requested type is large enough for the literal\n        return reqt\n      }\n      if (errh) {\n        errh(`constant ${x} overflows ${reqt.name}`, x.pos)\n        bits = 64\n      }\n    } else if (reqt === u_t_f64 || reqt === u_t_f32) {\n      return reqt as BasicType\n    } else if (errh) {\n      errh(`cannot use ${x} as type ${reqt}`, x.pos)\n    }\n  } else if (neg && bits >= 64 && errh) {\n    errh(`constant ${x} overflows i64`, x.pos)\n  }\n\n  // pick type that matches the bit length\n  return (\n    bits <= 31 ? u_t_int :\n    bits <= 63 ? u_t_i64 :\n    maxtype\n  )\n}\n\n\nfunction floatLitTypeFitter(\n  x :BasicLit,\n  reqt :Type|null,\n  errh? :ErrorHandler,\n  op? :token,\n) :BasicType {\n  if (reqt && reqt !== u_t_f32 && reqt !== u_t_f64) {\n    if (reqt instanceof IntType) {\n      errh && errh(`constant ${x} truncated to ${reqt.name}`, x.pos)\n      return reqt\n    } else if (errh) {\n      errh(`cannot use ${x} as type ${reqt}`, x.pos)\n    }\n  }\n  return reqt === u_t_f32 ? u_t_f32 : u_t_f64\n}\n\n\nfunction charLitTypeFitter(\n  x :BasicLit,\n  reqt :Type|null,\n  errh? :ErrorHandler,\n  op? :token,\n) :BasicType {\n  if (reqt) {\n    if (reqt instanceof IntType) {\n      // TODO: actually check if it fits\n      return reqt\n    }\n    errh && errh(`cannot use ${x} as type ${reqt}`, x.pos)\n  }\n  return op == token.SUB ? u_t_i32 : u_t_u32\n}\n\n\nconst basicLitTypesFitters = new Map<token,basicLitTypeFitter>([\n  [token.CHAR, charLitTypeFitter],\n  \n  [token.INT,     intLitTypeFitter],\n  [token.INT_BIN, intLitTypeFitter],\n  [token.INT_OCT, intLitTypeFitter],\n  [token.INT_HEX, intLitTypeFitter],\n\n  [token.FLOAT, floatLitTypeFitter],\n])\n\n\n\nexport class Universe {\n  readonly strSet  :ByteStrSet\n  readonly typeSet :TypeSet\n  readonly scope   :Scope\n\n  constructor(strSet :ByteStrSet, typeSet :TypeSet) {\n    this.strSet = strSet\n    this.typeSet = typeSet\n\n    // r.universe.internType(u_t_optstr)\n\n    // build scope\n    const unidecls = new Map<ByteStr,Ent>()\n\n    for (let [name, t] of universeTypes) {\n      // console.log(`DEF UNIVERSE TYPE \"${name}\"`)\n      let n = strSet.emplace(asciibuf(name))\n      unidecls.set(n, new Ent(n, t, t))\n    }\n\n    for (let [aliasName, canonName] of universeTypeAliases) {\n      // console.log(`DEF UNIVERSE TYPE ALIAS \"${aliasName}\" for \"${canonName}\"`)\n      let aliasNameBuf = strSet.emplace(asciibuf(aliasName))\n      let canonNameBuf = strSet.emplace(asciibuf(canonName))\n      const obj = unidecls.get(canonNameBuf)\n      assert(obj)\n      unidecls.set(aliasNameBuf, obj as Ent)\n    }\n\n    for (let [name, x] of universeValues) {\n      // console.log(`DEF UNIVERSE VAL \"${name}\"`)\n      let n = strSet.emplace(asciibuf(name))\n      unidecls.set(n, new Ent(n, x, x))\n    }\n\n    this.scope = new Scope(null, unidecls)\n  }\n\n  // basicLitType returns the most suitable type for a literal.\n  //\n  // If reqt is provided, this function will attempt to fit the literal\n  // into the reqt. If that fails, the most suitable type for the literal\n  // alone is returned, and an error message is produces if errh is provided\n  // You can thus check if contextual type fitting succeeded by comparing\n  // reqt with the result.\n  //\n  basicLitType(\n    x :BasicLit,\n    reqt? :Type|null,\n    errh? :ErrorHandler,\n    op? :token, // e.g. token.SUB for \"-\", token.NOT for \"!\", etc.\n  ) :BasicType {\n    let f = basicLitTypesFitters.get(x.kind) as basicLitTypeFitter\n    assert(f, `missing type fitter for ${tokstr(x.kind)}`)\n    return f(x, reqt || null, errh, op)\n  }\n\n  // internType potentially returns an equivalent type (t1.equals(t2) == true)\n  // if previously seen. Otherwise it registers t for future calls to this\n  // function and returns t as-is. Populates typeSet.\n  //\n  // The trade-offs are as follows:\n  //\n  //  [-] slower to parse files with many different types because of\n  //      intern-miss overhead.\n  //\n  //  [+] faster to parse files with few types that are used many times\n  //      (common case), since type equality testing is cheap for correct code.\n  //\n  //  [+] uses less memory (fewer resident Type instances).\n  //\n  internType<T extends Type>(t :T) :T {\n    return this.typeSet.intern(t)\n  }\n\n}\n","import { SrcFileSet, Pos, NoPos } from './pos'\nimport { TypeCompat, basicTypeCompat, Universe } from './universe'\nimport { ErrorCode, ErrorReporter, ErrorHandler } from './error'\nimport { debuglog, asciibuf } from './util'\nimport { token } from './token'\nimport {\n  Scope,\n  Ent,\n  ReturnStmt,\n\n  Expr,\n  Ident,\n  BasicLit,\n  // ParenExpr,\n  RestExpr,\n  FunExpr,\n  LiteralExpr,\n  TupleExpr,\n  Block,\n  SelectorExpr,\n  TypeConvExpr,\n  Assignment,\n  CallExpr,\n  Operation,\n  IfExpr,\n  IndexExpr,\n  // SliceExpr,\n  \n  Type,\n  UnresolvedType,\n  BasicType,\n  IntType,\n  StrType,\n  RestType,\n  TupleType,\n  FunType,\n  OptionalType,\n  UnionType,\n\n  u_t_nil, // u_t_void,\n  u_t_bool,\n  u_t_str,\n  u_t_optstr,\n} from './ast'\n\n\n\ntype Evaluator = (op :token, x :EvalArg, y? :EvalArg) => EvalArg|null\n\ntype EvalArg = LiteralExpr | EvalConst\n\n// EvalConst is a simple struct for holding evaluator results\n//\nclass EvalConst {}\nclass IntEvalConst extends EvalConst {\n  constructor(\n    public value :int,\n  ) { super() }\n}\n\n\nexport class TypeResolver extends ErrorReporter {\n  fset       :SrcFileSet\n  universe   :Universe\n  unresolved :Set<UnresolvedType>\n\n  constructor() {\n    super('E_RESOLVE')\n  }\n\n  init(fset :SrcFileSet, universe :Universe, errh :ErrorHandler|null) {\n    // note: normally initialized per package (not per file)\n    const r = this\n    r.errh = errh\n    r.fset = fset\n    r.universe = universe\n    r.unresolved = new Set<UnresolvedType>()\n  }\n\n  // error resports an error\n  //\n  error(msg :string, pos :Pos = NoPos, typ? :ErrorCode) {\n    const r = this\n    r.errorAt(msg, r.fset.position(pos), typ)\n  }\n\n  // syntaxError reports a syntax error.\n  // Interface is compatible with that of Parser.syntaxError\n  //\n  syntaxError(msg :string, pos :Pos = NoPos) {\n    this.error(msg, pos, 'E_SYNTAX')\n  }\n\n  // resolve attempts to resolve or infer the type of n.\n  // Returns UnresolvedType if the type refers to an undefined identifier.\n  // May mutate n.type, and may call ErrorHandler for undefined fields.\n  //\n  resolve(n :Expr) :Type {\n    if (n instanceof Type) {\n      return n\n    }\n\n    if (n.type instanceof Type /*&& (n.type.constructor !== UnresolvedType)*/) {\n      return n.type\n    }\n\n    const r = this\n    let t = r.maybeResolve(n)\n\n    if (!t) {\n      // if (n.type) {\n      //   if (n.type instanceof UnresolvedType) {\n      //     n.type.addRef(n)\n      //   }\n      //   return n.type\n      // }\n\n      t = r.markUnresolved(n)\n\n      // error failing to resolve field of known type\n      if (\n        n instanceof SelectorExpr &&\n        n.lhs instanceof Ident &&\n        n.lhs.ent\n      ) {\n        // Partially resolved selector, e.g.\n        // \"a.B undefined (type <typeof(a)> has no field or method B)\"\n        r.error(`${n} undefined`, n.pos)\n      }\n    }\n\n    n.type = t\n\n    return t\n  }\n\n  // maybeResolve attempts to resolve or infer the type of n.\n  // Returns null if the type can't be resolved or inferred.\n  // May mutate n.type and may call ErrorHandler.\n  //\n  maybeResolve(n :Expr|ReturnStmt) :Type|null {\n    const r = this\n\n    if (n instanceof Type) {\n      return n\n    }\n\n    if (n.type && n.type.constructor !== UnresolvedType) {\n      return r.resolve(n.type)\n    }\n\n    if (n instanceof Ident) {\n      if (n.ent) {\n        const tx = n.ent.getTypeExpr()\n        return tx && r.maybeResolve(tx) || null\n      }\n      // else: unresolved -- unknown type\n      return null\n    }\n\n    // if (n instanceof ParenExpr) {\n    //   return r.resolve(n.x)\n    // }\n\n    if (n instanceof Block) {\n      // type of block is the type of the last statement, or in the case\n      // of return, the type of the returned value.\n      if (n.list.length == 0) {\n        // empty block\n        return u_t_nil //u_t_void\n      }\n      let s = n.list[n.list.length-1]\n      if (s instanceof Expr) {\n        return r.resolve(s)\n      }\n      // last statement is a declaration\n      // debuglog(`TODO handle Block with declaration at end`)\n      return u_t_nil //u_t_void\n    }\n\n    if (n instanceof FunExpr) {\n      const s = n.sig\n      let t = r.universe.internType(new FunType(\n        s.pos,\n        s.scope,\n        s.params.map(field => r.resolve(field.type)),\n        r.resolve(s.result),\n      ))\n      if (t.result instanceof UnresolvedType) {\n        t.result.addRef(t)\n      }\n      return t\n    }\n\n    if (n instanceof TupleExpr) {\n      return r.maybeResolveTupleType(n.pos, n.scope, n.exprs)\n    }\n\n    if (n instanceof RestExpr) {\n      if (n.expr) {\n        let t = r.resolve(n.expr)\n        return r.universe.internType(new RestType(n.pos, n.scope, t))\n      }\n      return null\n    }\n\n    if (n instanceof CallExpr) {\n      const funtype = r.resolve(n.fun)\n      for (let arg of n.args) {\n        r.resolve(arg)\n      }\n      if (funtype instanceof FunType) {\n        return funtype.result\n      }\n      return null  // unknown\n    }\n\n    if (n instanceof Operation) {\n      const xt = r.resolve(n.x)\n      if (!n.y) {\n        // unary, e.g. x++\n        return xt\n      } else {\n        const yt = r.resolve(n.y)\n\n        if (n.op > token.cmpop_beg && n.op < token.cmpop_end) {\n          // comparison operations always yield boolean values\n          return u_t_bool\n        }\n\n        if (xt instanceof UnresolvedType || yt instanceof UnresolvedType) {\n          // operation's effective type not yet know\n          return null\n        }\n\n        if (xt === yt || xt.equals(yt)) {\n          // both operands types are equivalent\n          return xt\n        }\n\n        let x = r.convert(xt, n.y)\n        if (x) {\n          return x === n.y ? yt : r.resolve(x)\n        }\n\n        r.error(`invalid operation (mismatched types ${xt} and ${yt})`, n.pos)\n      }\n      return null\n    }\n\n    if (n instanceof Assignment) {\n      if (n.lhs.length == 1) {\n        // single assignment (common case)\n        return r.resolve(n.lhs[0])\n      }\n      // multi-assignment yields tuple\n      // E.g.\n      //   a i32\n      //   b f64\n      //   t = a, b = 1, 2.3\n      //   typeof(t)  // => (i32, f64)\n      //\n      return r.maybeResolveTupleType(n.pos, n.scope, n.lhs)\n    }\n\n    if (n instanceof ReturnStmt) {\n      // return expressions always represents type of its results, if any\n      return n.result ? r.resolve(n.result) : u_t_nil //u_t_void\n    }\n\n    if (n instanceof IfExpr) {\n      return r.maybeResolveIfExpr(n)\n    }\n\n    if (n instanceof IndexExpr) {\n      r.resolveIndex(n)\n      return n.type\n    }\n\n    debuglog(`TODO handle ${n.constructor.name}`)\n    return null  // unknown type\n  }\n\n\n  maybeResolveTupleType(pos :Pos, scope :Scope, exprs :Expr[]) :TupleType|null {\n    const r = this\n    let types :Type[] = []\n    for (const x of exprs) {\n      const t = r.resolve(x)\n      if (!t) {\n        return null\n      }\n      types.push(t)\n    }\n    return r.universe.internType(new TupleType(pos, scope, types)) as TupleType\n  }\n\n\n  // joinOptional takes two types, one of them optional and the other not,\n  // and considers them as two branches that are merging into one type, thus\n  // this function returns an optional for t. The returned optional may be\n  // incompatible with `opt`, or it might be t in the case of a union type.\n  //\n  joinOptional(pos :Pos, opt :OptionalType, t :Type) :Type {\n    const r = this\n\n    if (opt.type.equals(t)) {\n      // return optional type since underlying type == t\n      return opt\n    }\n\n    if (opt.type instanceof StrType && t instanceof StrType) {\n      assert(opt.type.length != t.length,\n        \"str type matches but StrType.equals failed\")\n      // if the optional type is a string and the compile-time length\n      // differs, return an optional string type with unknown length.\n      return u_t_optstr\n    }\n\n    if (t instanceof UnionType) {\n      let ut = new UnionType(new Set<Type>([opt]))\n      for (let t1 of t.types) {\n        if (!(t1 instanceof OptionalType)) {\n          if (t1 instanceof BasicType) {\n            this.error(`mixing optional and ${t1} type`, pos, 'E_CONV')\n          } else {\n            t1 = (\n              t1 instanceof StrType ? u_t_optstr :\n              r.universe.internType(new OptionalType(t1))\n            )\n          }\n        }\n        ut.add(t1)\n      }\n      return ut\n    }\n\n    if (t instanceof BasicType) {\n      this.error(`mixing optional and ${t} type`, pos, 'E_CONV')\n      return t\n    }\n\n    // t is different than opt -- return optional of t\n    return (\n      t instanceof StrType ? u_t_optstr :\n      r.universe.internType(new OptionalType(t))\n    )\n  }\n\n\n  mergeOptionalUnions(a :UnionType, b :UnionType) :UnionType {\n    const r = this\n    let ut = new UnionType(new Set<Type>())\n    for (let t of a.types) {\n      if (!(t instanceof OptionalType)) {\n        t = (\n          t instanceof StrType ? u_t_optstr :\n          r.universe.internType(new OptionalType(t))\n        )\n      }\n      ut.add(t)\n    }\n    for (let t of b.types) {\n      if (!(t instanceof OptionalType)) {\n        t = (\n          t instanceof StrType ? u_t_optstr :\n          r.universe.internType(new OptionalType(t))\n        )\n      }\n      ut.add(t)\n    }\n    return r.universe.internType(ut)\n  }\n\n\n  mergeUnions(a :UnionType, b :UnionType) :UnionType {\n    const r = this\n    let ut = new UnionType(new Set<Type>())\n    for (let t of a.types) {\n      if (t instanceof OptionalType) {\n        return r.mergeOptionalUnions(a, b)\n      }\n      ut.add(t)\n    }\n    for (let t of b.types) {\n      if (t instanceof OptionalType) {\n        return r.mergeOptionalUnions(a, b)\n      }\n      ut.add(t)\n    }\n    return r.universe.internType(ut)\n  }\n\n\n  makeOptionalUnionType2(l :OptionalType, r :OptionalType) :UnionType {\n    return this.universe.internType(\n      new UnionType(new Set<Type>([\n        l.type instanceof StrType && l.type.length != -1 ? u_t_optstr : l,\n        r.type instanceof StrType && r.type.length != -1 ? u_t_optstr : r,\n      ]))\n    )\n  }\n\n  makeUnionType2(l :Type, r :Type) :UnionType {\n    return this.universe.internType(\n      new UnionType(new Set<Type>([\n        l instanceof StrType && l.length != -1 ? u_t_str : l,\n        r instanceof StrType && r.length != -1 ? u_t_str : r,\n      ]))\n    )\n  }\n\n\n  maybeResolveIfExpr(n :IfExpr) :Type|null {\n    const r = this\n\n    // resolve \"then\" branch type\n    let thentyp = r.resolve(n.then)\n\n    if (!n.els_) {\n      // e.g. `if x A => A`\n\n      // with only a single then branch, the result type is that branch.\n      // if the branch is not taken, the result is a zero-initialized T.\n\n      // special case: if thentyp is a string constant, we must resolve to\n      // just \"str\" (length only known at runtime) since if the branch is\n      // not taken, a zero-initialized string is returned, which is zero.\n      if (thentyp instanceof StrType && thentyp.length != 0) {\n        return u_t_str\n      }\n\n      return thentyp\n    }\n\n    // resolve \"else\" branch type\n    let eltyp = r.resolve(n.els_)\n    \n    if (eltyp.equals(thentyp)) {\n      // e.g. `if x A else A => A`\n      // e.g. `if x A? else A? => A?`\n      return thentyp\n    }\n\n    if (eltyp === u_t_nil) {\n      if (thentyp === u_t_nil) {\n        // both branches are nil/void\n        // e.g. `if x nil else nil => nil`\n        return u_t_nil\n      }\n      // e.g. `if x A else nil => A?`\n      if (thentyp instanceof BasicType) {\n        // e.g. `if x int else nil`\n        r.error(`mixing ${thentyp} and optional type`, n.pos, 'E_CONV')\n      }\n      // makes the type optional\n      return (\n        thentyp instanceof OptionalType ? thentyp :\n        thentyp instanceof StrType ? u_t_optstr :\n        r.universe.internType(new OptionalType(thentyp))\n      )\n    }\n\n    if (thentyp === u_t_nil) {\n      // e.g. `if x nil else A => A?`\n      if (eltyp instanceof BasicType) {\n        // e.g. `if x nil else int`\n        r.error(`mixing optional and ${eltyp} type`, n.pos, 'E_CONV')\n      }\n      return (\n        eltyp instanceof OptionalType ? eltyp :\n        eltyp instanceof StrType ? u_t_optstr :\n        r.universe.internType(new OptionalType(eltyp))\n      )\n    }\n\n    if (eltyp instanceof OptionalType) {\n      if (thentyp instanceof OptionalType) {\n        // e.g. `if x A? else B? => A?|B?`\n        //\n        // Invariant: NOT eltyp.type.equals(thentyp.type)\n        //   since we checked that already above with eltyp.equals(thentyp)\n        //\n\n        if (eltyp.type instanceof StrType &&\n            thentyp.type instanceof StrType\n        ) {\n          // e.g. `a str?; b str?; if x a else b => str`\n          assert(eltyp.type.length != thentyp.type.length,\n            \"str type matches but StrType.equals failed\")\n          return u_t_optstr\n        }\n\n        return r.makeOptionalUnionType2(thentyp, eltyp)\n      }\n      // e.g. `if x A else B? => A?|B?`\n      // e.g. `if x A else A? => A?`\n      // e.g. `if x A|B else A? => A?|B?`\n      return r.joinOptional(n.pos, eltyp, thentyp)\n    }\n\n    if (thentyp instanceof OptionalType) {\n      // e.g. `if x A? else B => A?|B?`\n      // e.g. `if x A? else B|C => A?|B?|C?`\n      return r.joinOptional(n.pos, thentyp, eltyp)\n    }\n\n    if (eltyp instanceof StrType && thentyp instanceof StrType) {\n      // e.g. `if x \"foo\" else \"x\" => str`\n      return u_t_str\n    }\n\n    if (eltyp instanceof UnionType) {\n      if (thentyp instanceof OptionalType) {\n        // e.g. `if x A? else B|C => A?|B?|C?`\n        return r.joinOptional(n.pos, thentyp, eltyp)\n      }\n      if (thentyp instanceof UnionType) {\n        // e.g. `if x A|B else A|C => A|B|C`\n        // e.g. `if x A|B? else A|C => A?|B?|C?`\n        return r.mergeUnions(thentyp, eltyp)\n      }\n      // else: e.g. `if x A else B|C => B|C|A`\n      eltyp.add(thentyp)\n      return eltyp\n    }\n\n    if (thentyp instanceof UnionType) {\n      // e.g. `if x A|B else C => A|B|C`\n      thentyp.add(eltyp)\n      return thentyp\n    }\n\n    // e.g. `if x A else B => A|B`\n    return r.makeUnionType2(thentyp, eltyp)\n  }\n\n\n  // resolveIndex attempts to resolve the type of an index expression.\n  // returns x as a convenience.\n  //\n  resolveIndex(x :IndexExpr) :IndexExpr {\n    const r = this\n\n    // resolve operand type\n    let opt = r.resolve(x.operand)\n\n    if (opt instanceof UnresolvedType) {\n      // defer to bind stage\n      debuglog(`[index type] deferred to bind stage`)\n    } else if (opt instanceof TupleType) {\n      r.resolveTupleIndex(x, opt)\n    } else {\n      debuglog(`TODO [index type] operand is not a tuple; opt = ${opt}`)\n    }\n\n    return x\n  }\n\n  // resolveTupleIndex attempts to resolve the type of an index expression\n  // on a tuple.\n  //\n  resolveTupleIndex(x :IndexExpr, opt :TupleType) {\n    const r = this\n\n    let it = r.resolve(x.index)\n    if (it instanceof UnresolvedType) {\n      debuglog(`index resolution deferred to post-resolve`)\n      x.type = r.markUnresolved(x)\n      return\n    }\n\n    const ix = x.index\n\n    // index must be constant for tuple access\n    let index = r.resolveLitConstant(ix, intEvaluator)\n    if (index == null) {\n      // TODO: somehow track this and complete the check during bind\n      r.syntaxError('non-constant tuple index', ix.pos)\n      return\n    }\n\n    if (index instanceof EvalConst) {\n      assert(index instanceof IntEvalConst, \"there is not other kind\")\n      x.indexv = (index as IntEvalConst).value\n    } else {\n      let index2 = index as LiteralExpr\n      assert(index2 instanceof LiteralExpr)\n      // check type to make sure index is an integer\n      if (\n        index2.type && !(index2.type instanceof IntType) ||\n        !(index2 instanceof BasicLit) ||\n        !index2.isInt()\n      ) {\n        r.syntaxError(`invalid index type ${index2.type || index2}`, ix.pos)\n        return\n      }\n\n      // parse the integer; returns -1 on failure\n      x.indexv = index2.parseUInt()\n      if (x.indexv == -1) {\n        r.syntaxError(`invalid index ${index2}`, ix.pos)\n        return\n      }\n    }\n\n    if (x.indexv < 0 || x.indexv >= opt.types.length) {\n      r.syntaxError(\n        `out-of-bounds tuple index ${x.indexv} on type ${opt}`,\n        ix.pos\n      )\n      return\n    }\n\n    // success -- type of IndexExpr found\n    x.type = opt.types[x.indexv]\n\n    // since we folded the constant, replace x.index if it's not already\n    // a constant\n    if (!(x.index instanceof BasicLit)) {\n      // Note: Simply skip this branch to disable on-the-fly optimizations\n      const bl = new BasicLit(\n        x.index.pos,\n        x.index.scope,\n        token.INT,\n        asciibuf(x.indexv.toString(10))\n      )\n      bl.type = r.universe.basicLitType(bl)\n      x.index = bl\n    }\n  }\n\n\n  // resolveLitConstant attempts to resolve the constant value of x, expected\n  // to be a LiteralExpr. If x or anything x might refer to is not constant,\n  // null is returned.\n  //\n  resolveLitConstant(x :Expr, evaluator :Evaluator) :EvalArg|null {\n    const r = this\n\n    if (x instanceof LiteralExpr) {\n      return x\n    }\n\n    if (x instanceof Ident) {\n      if (x.ent && x.ent.writes == 0 && x.ent.value) {\n        // Note: we check `x.ent.writes == 0` to make sure that x is a constant\n        // i.e. that there are no potential conditional branches that might\n        // change the value of x.\n        return r.resolveLitConstant(x.ent.value, evaluator)\n      }\n    } else if (x instanceof IndexExpr) {\n      let opt = r.resolve(x.operand)\n\n      if (opt instanceof TupleType) {\n        let tuple :TupleExpr\n        if (x.operand instanceof Ident) {\n          assert(x.operand.ent != null) // should have been resolved\n          const ent = x.operand.ent as Ent\n          assert(ent.value instanceof TupleExpr)\n          tuple = ent.value as TupleExpr\n        } else {\n          // TODO: handle selectors to fields\n          assert(x.operand instanceof TupleExpr)\n          tuple = x.operand as TupleExpr\n        }\n\n        if (x.indexv >= 0) {\n          assert(x.indexv < tuple.exprs.length) // bounds checked when resolved\n          return r.resolveLitConstant(tuple.exprs[x.indexv], evaluator)\n        } else {\n          debuglog(`x.indexv < 0 for IndexExpr ${x}`)\n        }\n      } else {\n        debuglog(`TODO ${x.constructor.name} operand ${opt}`)\n      }\n    } else if (x instanceof Operation) {\n      const lval = r.resolveLitConstant(x.x, evaluator)\n      if (lval) {\n        if (!x.y) {\n          // unary operation\n          return evaluator(x.op, lval)\n        } else {\n          const rval = r.resolveLitConstant(x.y, evaluator)\n          if (rval) {\n            // attempt evaluation\n            return evaluator(x.op, lval, rval)\n          }\n        }\n      }\n    } else {\n      debuglog(`TODO ${x.constructor.name}`)\n    }\n\n    return null\n  }\n\n\n  // registerUnresolved registers expr as having an unresolved type.\n  // Does NOT set expr.type but instead returns an UnresolvedType object.\n  //\n  markUnresolved(expr :Expr) :UnresolvedType {\n    const t = new UnresolvedType(expr.pos, expr.scope, expr)\n    debuglog(`expr ${expr} as ${this.fset.position(expr.pos)}`)\n    this.unresolved.add(t)\n    return t\n  }\n\n  // isConstant returns true if the expression is a compile-time constant\n  //\n  isConstant(x :Expr) :bool {\n    return (\n      x instanceof LiteralExpr ||\n      (x instanceof Ident && x.ent != null && x.ent.isConstant)\n    )\n    // TODO: expand\n  }\n\n  // convertType attempts to convert expression x to type t.\n  // If x is already of type t, x is returned unchanged.\n  // If conversion is needed, a TypeConvExpr is returned,\n  // encapsulating x.\n  // If conversion is impossible, null is returned to indicate error.\n  //\n  convert(t :Type, x :Expr) :Expr|null {\n    const r = this\n    const xt = r.resolve(x)\n\n    if (xt === t || xt.equals(t)) {\n      return x\n    }\n\n    if (\n      r.isConstant(x) &&\n      t instanceof BasicType &&\n      xt instanceof BasicType\n    ) {\n      // expression with basic types\n      switch (basicTypeCompat(t, xt)) { // TypeCompat\n        case TypeCompat.NO: {\n          // Note: caller should report error\n          return null\n        }\n        case TypeCompat.LOSSY: {\n          r.error(`constant ${x} truncated to ${t}`, x.pos, 'E_CONV')\n          // TODO: ^ use diag instead with DiagKind.ERROR as the default, so\n          // that user code can override this error into a warning instead, as\n          // it's still valid to perform a lossy conversion.\n          return new TypeConvExpr(x.pos, x.scope, x, t)\n        }\n        case TypeCompat.LOSSLESS: {\n          return new TypeConvExpr(x.pos, x.scope, x, t)\n        }\n      }\n    }\n\n    debuglog(`TODO conversion of ${x} into type ${t}`)\n\n    // TODO: figure out a scalable type conversion system\n    // TODO: conversion of other types\n\n    return null\n  }\n}\n\n\n// intEvaluator is an Evaluator that can perform operations on integers\n//\nfunction intEvaluator(op :token, x  :EvalArg, y? :EvalArg) :EvalArg|null {\n  if (!(x instanceof BasicLit) || !x.isInt()) {\n    return null\n  }\n\n  // interpret x\n  const xs = x.isSignedInt()\n  let xv = xs ? x.parseSInt() : x.parseUInt()\n  // const xneg = x.op == token.SUB\n  if ((!xs && xv < 0) || isNaN(xv)) {\n    return null\n  }\n\n  if (y) {\n    // binary operation\n    if (!(y instanceof BasicLit) || !y.isInt()) {\n      return null\n    }\n\n    // interpret y\n    const ys = y.isSignedInt()\n    let yv = ys ? y.parseSInt() : y.parseUInt()\n    // const yneg = y.op == token.SUB\n    if ((!ys && yv < 0) || isNaN(yv)) {\n      return null\n    }\n\n    switch (op) {\n      case token.ADD: return new IntEvalConst(xv + yv)\n      case token.SUB: return new IntEvalConst(xv - yv)\n      case token.OR:  return new IntEvalConst(xv | yv)\n      case token.XOR: return new IntEvalConst(xv ^ yv)\n      case token.MUL: return new IntEvalConst(Math.round(xv * yv))\n      case token.QUO: return new IntEvalConst(Math.round(xv / yv))\n      case token.REM: return new IntEvalConst(xv % yv)\n      case token.AND: return new IntEvalConst(xv & yv)\n      default:\n        debuglog(`TODO eval binary op (${token[op]} ${x} (${xv}) ${y})`)\n    }\n\n  } else {\n    // unary operation\n    switch (op) {\n      case token.ADD: return new IntEvalConst(+xv)\n      case token.SUB: return new IntEvalConst(-xv)\n      case token.INC: return new IntEvalConst(++xv)\n      case token.DEC: return new IntEvalConst(--xv)\n      default:\n        debuglog(`TODO eval unary op (${token[op]} ${x})`)\n    }\n  }\n\n  return null  // error\n}\n\n","import { debuglog as dlog } from './util'\nimport { ByteStr, asciiByteStr } from './bytestr'\nimport { Pos, SrcFile } from './pos'\nimport { token } from './token'\nimport { DiagKind, DiagHandler } from './diag'\nimport * as ast from './ast'\nimport { Type, FunType, BasicType, IntType, RegType } from './ast'\n\n\n// const byteStr__ = asciiByteStr(\"_\")\nconst byteStr_anonfun = asciiByteStr('anonfun')\n\n// operators\nexport enum Op {\n  // special\n  None = 0, // nothing (invalid)\n  // FwdRef,   // forward reference (SSA)\n  Copy,\n  Phi,\n  LoadParam,   // read function parameter (inside callee)\n  PushParam,   // push a parameter for a function call\n  Call,        // call a function\n\n  // constants\n  i32Const, // load an integer as i32\n  i64Const, // load an integer as i64\n  f32Const, // load a number as f32\n  f64Const, // load a number as f64\n\n  // memory load\n  i32Load,     // load 4 bytes as i32\n  i32load8_s,  // load 1 byte and sign-extend i8 to i32\n  i32load8_u,  // load 1 byte and zero-extend i8 to i32\n  i32load16_s, // load 2 bytes and sign-extend i16 to i32\n  i32load16_u, // load 2 bytes and zero-extend i16 to i32\n  i64Load,     // load 8 bytes as i64\n  i64load8_s,  // load 1 byte and sign-extend i8 to i64\n  i64load8_u,  // load 1 byte and zero-extend i8 to i64\n  i64load16_s, // load 2 bytes and sign-extend i16 to i64\n  i64load16_u, // load 2 bytes and zero-extend i16 to i64\n  i64load32_s, // load 4 bytes and sign-extend i32 to i64\n  i64load32_u, // load 4 bytes and zero-extend i32 to i64\n  f32Load,     // load 4 bytes as f32\n  f64Load,     // load 8 bytes as f64\n\n  // memory store\n  i32Store,    // store 4 bytes (no conversion)\n  i32Store8,   // wrap i32 to i8 and store 1 byte\n  i32Store16,  // wrap i32 to i16 and store 2 bytes\n  i64Store,    // store 8 bytes (no conversion)\n  i64Store8,   // wrap i64 to i8 and store 1 byte\n  i64Store16,  // wrap i64 to i16 and store 2 bytes\n  i64Store32,  // wrap i64 to i32 and store 4 bytes\n  f32Store,    // store 4 bytes (no conversion)\n  f64Store,    // store 8 bytes (no conversion)\n\n  // integer operators\n  i32Add,    // +  sign-agnostic addition\n  i32Sub,    // -  sign-agnostic subtraction\n  i32Mul,    // *  sign-agnostic multiplication (lower 32-bits)\n  i32Div_s,  // /  signed division (result is truncated toward zero)\n  i32Div_u,  // /  unsigned division (result is floored)\n  i32Rem_s,  // %  signed remainder (result has the sign of the dividend)\n  i32Rem_u,  // %  unsigned remainder\n  i32Neg,   // -N negation\n  i32And,    // &  sign-agnostic bitwise and\n  i32Or,     // |  sign-agnostic bitwise inclusive or\n  i32Xor,    // ^  sign-agnostic bitwise exclusive or\n  i32Shl,    // << sign-agnostic shift left\n  i32Shr_u,  // >>> zero-replicating (logical) shift right\n  i32Shr_s,  // >> sign-replicating (arithmetic) shift right\n  i32Rotl,   //    sign-agnostic rotate left\n  i32Rotr,   //    sign-agnostic rotate right\n  i32Eq,     // == sign-agnostic compare equal\n  i32Ne,     // != sign-agnostic compare unequal\n  i32Lt_s,   // <  signed less than\n  i32Lt_u,   // <  unsigned less than\n  i32Le_s,   // <= signed less than or equal\n  i32Le_u,   // <= unsigned less than or equal\n  i32Gt_s,   // >  signed greater than\n  i32Gt_u,   // >  unsigned greater than\n  i32Ge_s,   // >= signed greater than or equal\n  i32Ge_u,   // >= unsigned greater than or equal\n  i32Clz,    //    sign-agnostic count leading zero bits\n             //    (All zero bits are considered leading if the value is zero)\n  i32Ctz,    //    sign-agnostic count trailing zero bits\n             //    (All zero bits are considered trailing if the value is zero)\n  i32Popcnt, //    sign-agnostic count number of one bits\n  i32Eqz,    // == compare equal to zero\n\n  i64Add, i64Sub, i64Mul, i64Div_s, i64Div_u, i64Rem_s, i64Rem_u, i64And,\n  i64Neg, i64Or, i64Xor, i64Shl, i64Shr_u, i64Shr_s, i64Rotl, i64Rotr, i64Eq,\n  i64Ne, i64Lt_s, i64Lt_u, i64Le_s, i64Le_u, i64Gt_s, i64Gt_u, i64Ge_s,\n  i64Ge_u, i64Clz, i64Ctz, i64Popcnt, i64Eqz,\n\n  // floating-point operators\n  f32Add,   // +  addition\n  f32Sub,   // -  subtraction\n  f32Mul,   // *  multiplication\n  f32Div,   // /  division\n  f32Abs,   //    absolute value\n  f32Neg,   // -N negation\n  f32Cps,   //    copysign\n  f32Ceil,  //    ceiling operator\n  f32Floor, //    floor operator\n  f32Trunc, //    round to nearest integer towards zero\n  f32Near,  //    round to nearest integer, ties to even\n  f32Eq,    // == compare ordered and equal\n  f32Ne,    // != compare unordered or unequal\n  f32Lt,    // <  compare ordered and less than\n  f32Le,    // <= compare ordered and less than or equal\n  f32Gt,    // >  compare ordered and greater than\n  f32Ge,    // >= compare ordered and greater than or equal\n  f32Sqrt,  //    square root\n  f32Min,   //    minimum (binary operator); if either operand is NaN, ret NaN\n  f32Max,   //    maximum (binary operator); if either operand is NaN, ret NaN\n\n  f64Add, f64Sub, f64Mul, f64Div, f64Abs, f64Neg, f64Cps, f64Ceil, f64Floor,\n  f64Trunc, f64Near, f64Eq, f64Ne, f64Lt, f64Le, f64Gt, f64Ge, f64Sqrt, f64Min,\n  f64Max,\n\n  // conversion\n  i32Wrap_i64,      // wrap a 64-bit int to a 32-bit int\n  i32Trunc_s_f32,   // truncate a 32-bit float to a signed 32-bit int\n  i32Trunc_s_f64,   // truncate a 64-bit float to a signed 32-bit int\n  i32Trunc_u_f32,   // truncate a 32-bit float to an unsigned 32-bit int\n  i32Trunc_u_f64,   // truncate a 64-bit float to an unsigned 32-bit int\n  i32Rein_f32,      // reinterpret the bits of a 32-bit float as a 32-bit int\n  i64Extend_s_i32,  // extend a signed 32-bit int to a 64-bit int\n  i64Extend_u_i32,  // extend an unsigned 32-bit int to a 64-bit int\n  i64Trunc_s_f32,   // truncate a 32-bit float to a signed 64-bit int\n  i64Trunc_s_f64,   // truncate a 64-bit float to a signed 64-bit int\n  i64Trunc_u_f32,   // truncate a 32-bit float to an unsigned 64-bit int\n  i64Trunc_u_f64,   // truncate a 64-bit float to an unsigned 64-bit int\n  i64Rein_f64,      // reinterpret the bits of a 64-bit float as a 64-bit int\n  f32Demote_f64,    // demote a 64-bit float to a 32-bit float\n  f32Convert_s_i32, // convert a signed 32-bit int to a 32-bit float\n  f32Convert_s_i64, // convert a signed 64-bit int to a 32-bit float\n  f32Convert_u_i32, // convert an unsigned 32-bit int to a 32-bit float\n  f32Convert_u_i64, // convert an unsigned 64-bit int to a 32-bit float\n  f32Rein_i32,      // reinterpret the bits of a 32-bit int as a 32-bit float\n  f64Promote_f32,   // promote a 32-bit float to a 64-bit float\n  f64Convert_s_i32, // convert a signed 32-bit int to a 64-bit float\n  f64Convert_s_i64, // convert a signed 64-bit int to a 64-bit float\n  f64Convert_u_i32, // convert an unsigned 32-bit int to a 64-bit float\n  f64Convert_u_i64, // convert an unsigned 64-bit int to a 64-bit float\n  f64Rein_i64,      // reinterpret the bits of a 64-bit int as a 64-bit float\n\n  // misc\n  Trap,             // aka \"unreachable\". Trap/crash\n}\n\n// getop returns the IR operator for the corresponding token operator and type\n//\nfunction getop(tok :token, t :BasicType) :Op {\n  switch (tok) {\n  case token.EQL: switch (t.regtype) { // ==\n    case RegType.i32: return Op.i32Eq\n    case RegType.i64: return Op.i64Eq\n    case RegType.f32: return Op.f32Eq\n    case RegType.f64: return Op.f64Eq\n  }; break\n  case token.NEQ: switch (t.regtype) { // !=\n    case RegType.i32: return Op.i32Ne\n    case RegType.i64: return Op.i64Ne\n    case RegType.f32: return Op.f32Ne\n    case RegType.f64: return Op.f64Ne\n  }; break\n  case token.LSS: switch (t.regtype) { // <\n    case RegType.i32: return (t as IntType).signed ? Op.i32Lt_s : Op.i32Lt_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Lt_s : Op.i64Lt_u\n    case RegType.f32: return Op.f32Lt\n    case RegType.f64: return Op.f64Lt\n  }; break\n  case token.LEQ: switch (t.regtype) { // <=\n    case RegType.i32: return (t as IntType).signed ? Op.i32Le_s : Op.i32Le_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Le_s : Op.i64Le_u\n    case RegType.f32: return Op.f32Le\n    case RegType.f64: return Op.f64Le\n  }; break\n  case token.GTR: switch (t.regtype) { // >\n    case RegType.i32: return (t as IntType).signed ? Op.i32Gt_s : Op.i32Gt_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Gt_s : Op.i64Gt_u\n    case RegType.f32: return Op.f32Gt\n    case RegType.f64: return Op.f64Gt\n  }; break\n  case token.GEQ: switch (t.regtype) { // >=\n    case RegType.i32: return (t as IntType).signed ? Op.i32Ge_s : Op.i32Ge_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Ge_s : Op.i64Ge_u\n    case RegType.f32: return Op.f32Ge\n    case RegType.f64: return Op.f64Ge\n  }; break\n  case token.ADD: switch (t.regtype) { // +\n    case RegType.i32: return Op.i32Add\n    case RegType.i64: return Op.i64Add\n    case RegType.f32: return Op.f32Add\n    case RegType.f64: return Op.f64Add\n  }; break\n  case token.SUB: switch (t.regtype) { // -\n    case RegType.i32: return Op.i32Sub\n    case RegType.i64: return Op.i64Sub\n    case RegType.f32: return Op.f32Sub\n    case RegType.f64: return Op.f64Sub\n  }; break\n  case token.MUL: switch (t.regtype) { // *\n    case RegType.i32: return Op.i32Mul\n    case RegType.i64: return Op.i64Mul\n    case RegType.f32: return Op.f32Mul\n    case RegType.f64: return Op.f64Mul\n  }; break\n  case token.QUO: switch (t.regtype) { // /\n    case RegType.i32: return (t as IntType).signed ? Op.i32Div_s : Op.i32Div_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Div_s : Op.i64Div_u\n    case RegType.f32: return Op.f32Div\n    case RegType.f64: return Op.f64Div\n  }; break\n  // The remaining operators are only available for integers\n  case token.REM: switch (t.regtype) { // %\n    case RegType.i32: return (t as IntType).signed ? Op.i32Rem_s : Op.i32Rem_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Rem_s : Op.i64Rem_u\n  }; break\n  case token.OR: switch (t.regtype) { // |\n    case RegType.i32: return Op.i32Or\n    case RegType.i64: return Op.i64Or\n  }; break\n  case token.XOR: switch (t.regtype) { // ^\n    case RegType.i32: return Op.i32Xor\n    case RegType.i64: return Op.i64Xor\n  }; break\n  case token.AND: switch (t.regtype) { // &\n    case RegType.i32: return Op.i32And\n    case RegType.i64: return Op.i64And\n  }; break\n  case token.SHL: switch (t.regtype) { // <<\n    case RegType.i32: return Op.i32Shl\n    case RegType.i64: return Op.i64Shl\n  }; break\n  case token.SHR: switch (t.regtype) { // >>\n    case RegType.i32: return (t as IntType).signed ? Op.i32Shr_s : Op.i32Shr_u\n    case RegType.i64: return (t as IntType).signed ? Op.i64Shr_s : Op.i64Shr_u\n  }; break\n  case token.AND_NOT: // &^  TODO implement (need to generalize/unroll)\n    assert(false, 'AND_NOT \"&^\" not yet supported')\n    return Op.None\n  default:\n    // unknown operator token\n    assert(false, `unexpected operator token ${token[tok]}`)\n    return Op.None\n  }\n\n  // fallthrough from unhandled (but known) operator token\n  assert(false, `invalid operation for floating-point number`)\n  return Op.None\n}\n\n\n// // storeop maps value type to store operator\n// //\n// function storeop(t :BasicType) :Op {\n//   // select store operation\n//   // i32Store,    // store 4 bytes (no conversion)\n//   // i32Store8,   // wrap i32 to i8 and store 1 byte\n//   // i32Store16,  // wrap i32 to i16 and store 2 bytes\n//   // i64Store,    // store 8 bytes (no conversion)\n//   // i64Store8,   // wrap i64 to i8 and store 1 byte\n//   // i64Store16,  // wrap i64 to i16 and store 2 bytes\n//   // i64Store32,  // wrap i64 to i32 and store 4 bytes\n//   // f32Store,    // store 4 bytes (no conversion)\n//   // f64Store,    // store 8 bytes (no conversion)\n//   let bz :int\n//   switch (t.regtype) {\n\n//     case RegType.i32:\n//       bz = (t as IntType).bitsize\n//       if (bz <= 8) { return Op.i32Store8 }\n//       if (bz <= 16) { return Op.i32Store16 }\n//       assert(bz <= 32)\n//       return Op.i32Store\n\n//     case RegType.i64:\n//       bz = (t as IntType).bitsize\n//       if (bz <= 8) { return Op.i64Store8 }\n//       if (bz <= 16) { return Op.i64Store16 }\n//       if (bz <= 32) { return Op.i64Store32 }\n//       assert(bz <= 64)\n//       return Op.i64Store\n\n//     case RegType.f32:\n//       return Op.f32Store\n    \n//     case RegType.f64:\n//       return Op.f64Store\n//   }\n//   return Op.None\n// }\n\n\nexport type Aux = ByteStr | Uint8Array | number\n\n// Value is a three-address-code operation\n//\nexport class Value {\n  id      :int   // unique identifier\n  op      :Op    // operation that computes this value\n  type    :Type\n  b       :Block // containing block\n  aux     :Aux|null // auxiliary info for this value. Type depends on op & type.\n  args    :Value[]|null = null // arguments of this value\n  comment :string = '' // human readable short comment for IR formatting\n\n  // use count. Each appearance in args and Block.control counts once\n  uses :int = 0\n\n  users = new Set<Value>() // WIP\n\n  constructor(id :int, op :Op, type :Type, b :Block, aux :Aux|null) {\n    this.id = id\n    this.op = op\n    this.type = type\n    this.b = b\n    this.aux = aux\n  }\n\n  toString() {\n    return 'v' + this.id\n  }\n\n  appendArg(v :Value) {\n    // Note: Only used for Phi values. Assertion here to make sure we are\n    // intenational about use.\n    assert(this.op == Op.Phi, \"appendArg on non-phi value\")\n    assert(v !== this, `using self as arg to self`)\n    if (!this.args) {\n      this.args = [v]\n    } else {\n      this.args.push(v)\n    }\n    v.uses++\n    v.users.add(this)\n  }\n\n  // replaceBy replaces all uses of this value with v\n  //\n  replaceBy(v :Value) {\n    // FIXME link values using a doubly-linked list\n    // instead of an array owned by the block. Will\n    // make these operations a lot easier.\n\n    assert(v !== this, 'trying to replace V with V')\n\n    for (let user of this.users) {\n      // TODO FIXME linked-list instead of this complex & slow approach\n      if (user !== v && user.args) {\n        for (let i = 0; i < user.args.length; i++) {\n          if (user.args[i] === this) {\n            dlog(`replace ${this} in user ${user} with ${v}`)\n            user.args[i] = v\n            v.users.add(user)\n            v.uses++\n            this.uses--\n          }\n        }\n      } else if (user === v) {\n        assert(false,\n          `TODO user==v (v=${v} this=${this}) -- CYCLIC USE!`)\n        // this.uses--\n      }\n    }\n\n    // Remove self.\n    // Note that we don't decrement this.uses since the definition\n    // site doesn't count toward \"uses\".\n    let i = this.b.values.indexOf(this)\n    assert(i != -1, \"not in parent block but still references block\")\n    this.b.values.splice(i,1)\n\n    // Note: \"uses\" does not count for the value's ref to its block, so\n    // we don't decrement this.uses here.\n    if (DEBUG) { ;(this as any).b = null }\n  }\n}\n\n\n// BlockKind denotes what specific kind a block is\n//\n//     kind       control (x)    successors     notes\n//     ---------- -------------- -------------- --------\n//     Plain      (nil)          [next]         e.g. \"goto\"\n//     If         boolean        [then, else]\n//     Ret        memory         []\n//\nexport enum BlockKind {\n  Invalid = 0,\n  Plain,\n  If,\n  Ret,\n}\n\nexport class Block {\n  id       :int\n  kind     :BlockKind = BlockKind.Invalid // The kind of block\n  succs    :Block[]|null  // Subsequent blocks, if any; depends on kind\n  preds    :Block[] = []  // Predecessors\n  control  :Value|null = null\n    // A value that determines how the block is exited. Its value depends\n    // on the kind of the block. For instance, a BlockKind.If has a boolean\n    // control value and BlockKind.Exit has a memory control value.\n\n  values   :Value[] = [] // three-address code\n  f        :Fun // containing function\n  sealed   :bool = false\n    // true if no further predecessors will be added\n  comment  :string = '' // human readable short comment for IR formatting\n\n  constructor(kind :BlockKind, id :int, f :Fun) {\n    this.kind = kind\n    this.id = id\n    this.f = f\n  }\n\n  newPhi(t :Type) :Value {\n    let v = this.f.newValue(Op.Phi, t, this, null)\n    this.values.push(v)\n    return v\n  }\n\n  // newValue0 return a value with no args\n  newValue0(op :Op, t :Type, aux :Aux|null = null) :Value {\n    let v = this.f.newValue(op, t, this, aux)\n    this.values.push(v)\n    return v\n  }\n\n  // newValue1 returns a new value in the block with one argument\n  newValue1(op :Op, t :Type, arg0 :Value, aux :Aux|null = null) :Value {\n    let v = this.f.newValue(op, t, this, aux)\n    v.args = [arg0]\n    arg0.uses++ ; arg0.users.add(v)\n    this.values.push(v)\n    return v\n  }\n\n  // newValue2 returns a new value in the block with two arguments and zero\n  // aux values.\n  newValue2(\n    op :Op,\n    t :Type,\n    arg0 :Value,\n    arg1 :Value,\n    aux :Aux|null = null,\n  ) :Value {\n    let v = this.f.newValue(op, t, this, aux)\n    v.args = [arg0, arg1]\n    arg0.uses++ ; arg0.users.add(v)\n    arg1.uses++ ; arg1.users.add(v)\n    this.values.push(v)\n    return v\n  }\n\n  toString() :string {\n    return 'b' + this.id\n  }\n}\n\n\nexport class Fun {\n  blocks :Block[]  // blocks in generation order\n  type   :FunType\n  name   :ByteStr\n  bid    :int = 0  // block ID allocator\n  vid    :int = 0  // value ID allocator\n  consts :Map<int,Value[]>|null = null\n    // constants cache, keyed by constant value; users must check value's\n    // Op and Type\n\n  constructor(type :FunType, name :ByteStr) {\n    this.blocks = [\n      new Block(BlockKind.Plain, 0, this)\n    ]\n    this.type = type\n    this.name = name\n  }\n\n  newBlock(k :BlockKind) :Block {\n    assert(this.bid < 0xFFFFFFFF, \"too many block IDs generated\")\n    let b = new Block(k, ++this.bid, this)\n    this.blocks.push(b)\n    return b\n  }\n\n  newValue(op :Op, t :Type, b :Block, aux :Aux|null) :Value {\n    assert(this.vid < 0xFFFFFFFF, \"too many value IDs generated\")\n    // TODO we could use a free list and return values when they die\n    return new Value(++this.vid, op, t, b, aux)\n  }\n\n  // newPhi(t :Type, b :Block) :Phi {\n  //   assert(this.vid < 0xFFFFFFFF, \"too many value IDs generated\")\n  //   return new Phi(++this.vid, t, b)\n  // }\n\n  // constVal returns a constant value for c\n  // c must be smaller than Number.MAX_SAFE_INTEGER\n  // FIXME: work around the Number.MAX_SAFE_INTEGER limitation somehow\n  //\n  constVal(t :BasicType, c :int) :Value {\n    let f = this\n    let vv :Value[]|undefined\n\n    // Select operation based on type\n    let op :Op = Op.None\n    switch (t.regtype) {\n      case RegType.i32: op = Op.i32Const; break\n      case RegType.i64: op = Op.i64Const; break\n      case RegType.f32: op = Op.f32Const; break\n      case RegType.f64: op = Op.f64Const; break\n    }\n    assert(op != Op.None)\n\n    if (!f.consts) {\n      f.consts = new Map<int,Value[]>()\n    } else {\n      vv = f.consts.get(c)\n      if (vv) for (let v of vv) {\n        if (v.op == op && v.type.equals(t)) {\n          assert(v.aux === c, `cached const ${v} should have aux ${c}`)\n          return v\n        }\n      }\n    }\n\n    // create new const value in function's entry block\n    let v = f.blocks[0].newValue0(op, t, c)\n\n    // put into cache\n    if (!vv) {\n      f.consts.set(c, [v])\n    } else {\n      vv.push(v)\n    }\n    return v\n  }\n\n  toString() {\n    return this.name.toString()\n  }\n}\n\n\nexport class Pkg {\n  nI32 :int = 0         // number of 32-bit integer globals\n  nI64 :int = 0         // number of 64-bit integer globals\n  nF32 :int = 0         // number of 32-bit floating-point globals\n  nF64 :int = 0         // number of 64-bit floating-point globals\n  data :Uint8Array      // data  TODO wrap into some simple linear allocator\n  funs :Fun[] = []      // functions\n  init :Fun|null = null // init functions (merged into one)\n}\n\n\nexport enum IRFlags {\n  Default = 0,\n  Comments,     // include comments in some values, for formatting\n}\n\n\n// IRBuilder produces SSA IR for functions, taking AST as the input.\n//\n// The \"inline\"/\"single-pass\" Phi placement heuristic is based on the paper\n// \"Simple and Efficient Construction of Static Single Assignment Form\"\n// https://pp.info.uni-karlsruhe.de/uploads/publikationen/braun13cc.pdf\n//\nexport class IRBuilder {\n  pkg   :Pkg\n  sfile :SrcFile|null = null\n  diagh :DiagHandler|null = null\n  b     :Block       // current block\n  f     :Fun         // current function\n  flags :IRFlags = IRFlags.Default\n  \n  vars :Map<ByteStr,Value>\n    // variable assignments in the current block (map from variable symbol\n    // to ssa value)\n\n  defvars :(Map<ByteStr,Value>|null)[]\n    // all defined variables at the end of each block. Indexed by block id.\n    // null indicates there are no variables in that block.\n\n  incompletePhis :Map<Block,Map<ByteStr,Value>>|null\n    // tracks pending, incomplete phis that are completed by sealBlock for\n    // blocks that are sealed after they have started. This happens when preds\n    // are not known at the time a block starts, but is known and registered\n    // before the block ends.\n\n  init(diagh :DiagHandler|null = null, flags :IRFlags=IRFlags.Default) {\n    const r = this\n    r.pkg = new Pkg()\n    r.sfile = null\n    r.diagh = diagh\n    r.vars = new Map<ByteStr,Value>()\n    r.defvars = []\n    r.incompletePhis = null\n    r.flags = flags\n  }\n\n  // startBlock sets the current block we're generating code in\n  //\n  startBlock(b :Block) {\n    const r = this\n    assert(r.b == null, \"starting block without ending block\")\n    r.b = b\n  }\n\n  // startSealedBlock is a convenience for sealBlock followed by startBlock\n  //\n  startSealedBlock(b :Block) {\n    this.sealBlock(b)\n    this.startBlock(b)\n  }\n\n  // sealBlock sets b.sealed=true, indicating that no further predecessors\n  // will be added (no changes to b.preds)\n  //\n  sealBlock(b :Block) {\n    const s = this\n    assert(!b.sealed, `block ${b} already sealed`)\n    dlog(`${b}`)\n    if (s.incompletePhis) {\n      let entries = s.incompletePhis.get(b)\n      if (entries) {\n        for (let [name, phi] of entries) {\n          dlog(`complete pending phi ${phi} (${name})`)\n          s.addPhiOperands(name, phi)\n        }\n        s.incompletePhis.delete(b)\n      }\n    }\n    b.sealed = true\n  }\n\n  // endBlock marks the end of generating code for the current block.\n  // Returns the (former) current block. Returns null if there is no current\n  // block, i.e. if no code flows to the current execution point.\n  // The block sealed if not already sealed.\n  //\n  endBlock() :Block {\n    const r = this\n    let b = r.b\n    assert(b != null, \"no current block\")\n    while (r.defvars.length <= b.id) {\n      r.defvars.push(null)\n    }\n    r.defvars[b.id] = r.vars\n    r.vars = new Map<ByteStr,Value>()\n    ;(r as any).b = null\n    return b\n  }\n\n  startFun(f :Fun) {\n    const r = this\n    assert(r.f == null, \"starting function with existing function\")\n    r.f = f\n  }\n\n  endFun() {\n    const r = this\n    assert(r.f, \"ending function without a current function\")\n    ;(r as any).f = null\n  }\n\n  // nilValue returns a placeholder value.\n  // This is meant to be used only during development and should be removed\n  // when the IR builder is complete.\n  //\n  nilValue() :Value {\n    assert(this.b, \"no current block\")\n    return this.b.newValue0(Op.None, ast.u_t_nil)\n  }\n\n  // ------------------------------------------------------------\n  // primary interface to builder\n\n  addTopLevel(sfile :SrcFile, d :ast.Decl|ast.FunExpr) :Fun|null {\n    // Note: d must not contain unresolved references (including types).\n    // If there are unresolved references, behavior is undefined.\n    //\n    const r = this\n    r.sfile = sfile\n\n    if (d instanceof ast.MultiDecl) {\n      for (let d2 of d.decls) {\n        r.addTopLevel(sfile, d2)\n      }\n    } else if (d instanceof ast.VarDecl) {\n      r.global(d)\n    } else if (d instanceof ast.FunExpr) {\n      if (d.isInit) {\n        // Sanity checks (parser has already checked these things)\n        assert(d.sig.params.length == 0, 'init fun with parameters')\n        assert(d.sig.result === ast.u_t_nil, 'init fun with result')\n        assert(d.body, 'missing body')\n        r.initCode(d.body as ast.Expr)\n      } else if (d.body) {\n        // regular function with an implementation (d.body)\n        return r.fun(d)\n      } else {\n        dlog(`skipping pure function declaration ${d}`)\n      }\n    } else if (d instanceof ast.ImportDecl) {\n      dlog(`TODO ImportDecl`)\n    } else if (d instanceof ast.TypeDecl) {\n      dlog(`TODO TypeDecl`)\n    }\n    return null // TODO: return other top-level things\n  }\n\n  global(v :ast.VarDecl) {\n    dlog(`TODO`)\n  }\n\n  initCode(body :ast.Expr) {\n    // const r = this\n    // const f = r.pkg.init || (r.pkg.init = new Fun([], ast.u_t_nil, 'init'))\n    // r.block(f, null, body, 'init')\n    // console.log(`\\n-----------------------\\n${f}`)\n  }\n\n  fun(x :ast.FunExpr) :Fun {\n    const r = this\n    assert(x.body, `unresolved function ${x}`)\n    assert(x.type, \"unresolved function type\")\n\n    let funtype = x.type as FunType\n    let f = new Fun(funtype, x.name ? x.name.value : byteStr_anonfun)\n    let entryb = f.blocks[0]\n\n    // initialize locals\n    for (let i = 0; i < x.sig.params.length; i++) {\n      let p = x.sig.params[i]\n      if (p.name) {\n        let t = funtype.inputs[i] as Type\n        let name = p.name.value\n        let v = entryb.newValue0(Op.LoadParam, t, i)\n        if (r.flags & IRFlags.Comments) {\n          v.comment = name.toString()\n        }\n        r.vars.set(name, v)\n      }\n    }\n\n    r.startFun(f)\n    r.startSealedBlock(entryb)\n\n    let bodyval = r.block(x.body as ast.Expr)\n\n    if (r.b as any) {\n      // end last block if not already ended\n      r.b.kind = BlockKind.Ret\n      if (!(x.body instanceof ast.Block)) {\n        // body is a single expression -- control value is that expression\n        // assert(!(x.body instanceof ast.ReturnStmt),\n        //   \"'return' as function expression body should have called \"+\n        //   \"ret() to close block\")\n        r.b.control = bodyval\n      }\n      // when body is a block and it didn't end, it was empty and thus\n      // the return type is nil (no control value.)\n      r.endBlock()\n    }\n\n    assert((r as any).b == null, \"function exit block not ended\")\n    assert(f.blocks[f.blocks.length - 1].kind == BlockKind.Ret,\n      \"last block in function is not BlockKind.Ret\")\n    r.endFun()\n\n    r.pkg.funs.push(f)\n    return f\n  }\n\n\n  block(x :ast.Expr) :Value|null {\n    const r = this\n    if (x instanceof ast.Block) {\n      let end = x.list.length\n      let lasti = end - 1\n      for (let i = 0; i != end; ++i) {\n        if (!r.b) {\n          dlog('block ended early')\n          // block ended early (i.e. from \"return\")\n          r.diag('warn', `unreachable code`, x.list[i].pos)\n          break\n        }\n        r.stmt(x.list[i], i == lasti)\n      }\n      return null\n    } else {\n      return r.expr(x)\n      // r.stmt(x, /*isLast=*/true)\n    }\n  }\n\n\n  // stmt adds one or more TAC to block b in function f from statement s\n  //\n  stmt(s :ast.Stmt, isLast :bool = false) {\n    const r = this\n\n    if (s instanceof ast.IfExpr) {\n      r.if_(s)\n\n    } else if (s instanceof ast.ReturnStmt) {\n      r.ret(r.expr(s.result))\n\n    } else if (s instanceof ast.WhileStmt) {\n      r.while_(s)\n\n    } else if (s instanceof ast.Expr) {\n      if (!isLast && s instanceof ast.Ident) {\n        r.diag('warn', `unused expression`, s.pos)\n      } else {\n        r.expr(s)\n      }\n\n    } else if (s instanceof ast.VarDecl) {\n      if (s.values) {\n        // explicit value; e.g. \"x = 3\"\n        for (let i = 0; i < s.idents.length; i++) {\n          let id = s.idents[i]\n          let v = r.expr(s.values[i])\n          assert(!r.vars.has(id.value), `redeclaration of var ${id.value}`)\n          r.vars.set(id.value, v)\n        }\n      } else {\n        // default value; e.g. \"x i32\"  =>  \"x = 0\"\n        assert(s.type, 'var decl without type or values')\n        let t = (s.type as ast.Expr).type as BasicType\n        assert(t, 'unresolved type')\n        assert(t instanceof BasicType, 'non-basic type not yet supported')\n        let v = r.f.constVal(t, 0)\n        for (let id of s.idents) {\n          assert(!r.vars.has(id.value), `redeclaration of var ${id.value}`)\n          r.vars.set(id.value, v)\n        }\n      }\n\n    } else {\n      dlog(`TODO: handle ${s.constructor.name}`)\n    }\n  }\n\n\n  ret(val :Value|null) {\n    const r = this\n    let b = r.endBlock()\n    b.kind = BlockKind.Ret\n    b.control = val\n  }\n\n\n  while_(n: ast.WhileStmt) {\n    const s = this\n\n    // end \"entry\" block (whatever block comes before \"while\")\n    let entryb = s.endBlock()\n    assert(entryb.kind == BlockKind.Plain)\n    // create \"if\" block, for testing the while condition\n    let ifb = s.f.newBlock(BlockKind.If)\n    entryb.succs = [ifb] // entry -> if\n    ifb.preds = [entryb] // if <- entry[, then]\n    // start \"if\" block\n    s.startBlock(ifb) // note: not sealed\n    let control = s.expr(n.cond) // condition for looping\n    // TODO: inspect control and if constant, short-circuit branching.\n    // end \"if\" block and assign condition\n    ifb = s.endBlock()\n    ifb.control = control\n\n    // create \"then\" block, to be visited on each loop iteration\n    let thenb = s.f.newBlock(BlockKind.Plain)\n    thenb.preds = [ifb]\n    // start \"then\" block (seal as well; preds are complete)\n    s.startSealedBlock(thenb)\n    s.block(n.body) // body (note: ignore return value)\n    // end \"then\" block\n    thenb = s.endBlock()\n    thenb.succs = [ifb] // thenb -> ifb\n\n    // complete & seal \"if\" block late, since it depends on \"then\" block\n    ifb.preds = [entryb, thenb] // if <- entry, then\n    s.sealBlock(ifb) // \"if\" block sealed here\n\n    // create \"next\" block, for whatever comes after the \"while\"\n    let nextb = s.f.newBlock(BlockKind.Plain)\n    nextb.preds = [ifb] // next <- if, then\n    ifb.succs = [thenb, nextb] // if -> next, then\n    // start \"next\" block and return\n    s.startSealedBlock(nextb)\n\n    if (s.flags & IRFlags.Comments) {\n      ifb.comment = 'while'\n      thenb.comment = 'then'\n      nextb.comment = 'endwhile'\n    }\n  }\n\n\n  // if_ reads an if expression.\n  // Returns a new empty block that's the block after the if.\n  //\n  if_(s :ast.IfExpr) {\n    //\n    // if..end has the following semantics:\n    //\n    //   if cond b1 b2\n    //   b1:\n    //     <then-block>\n    //   goto b2\n    //   b2:\n    //     <continuation-block>\n    //\n    // if..else..end has the following semantics:\n    //\n    //   if cond b1 b2\n    //   b1:\n    //     <then-block>\n    //   goto b3\n    //   b2:\n    //     <else-block>\n    //   goto b3\n    //   b3:\n    //     <continuation-block>\n    // \n    const r = this\n\n    // generate control condition\n    let control = r.expr(s.cond)\n\n    // end predecessor block (leading up to and including \"if\")\n    let ifb = r.endBlock()\n    ifb.kind = BlockKind.If\n    ifb.control = control\n\n    // create blocks for then and else branches\n    let thenb = r.f.newBlock(BlockKind.Plain)\n    let elseb = r.f.newBlock(BlockKind.Plain)\n    ifb.succs = [thenb, elseb] // if -> then, else\n\n    // create \"then\" block\n    thenb.preds = [ifb] // then <- if\n    r.startSealedBlock(thenb)\n    r.block(s.then)\n    thenb = r.endBlock()\n\n    if (s.els_) {\n      // if cond then A else B end\n\n      // allocate \"cont\" block\n      let contb = r.f.newBlock(BlockKind.Plain)\n\n      // create \"else\" block\n      elseb.preds = [ifb] // else <- if\n      r.startSealedBlock(elseb)\n      r.block(s.els_)\n      elseb = r.endBlock()\n      elseb.succs = [contb]\n\n      thenb.succs = [contb] // then -> cont\n      contb.preds = [thenb, elseb] // cont <- then, else\n      r.startSealedBlock(contb)\n\n      if (r.flags & IRFlags.Comments) {\n        thenb.comment = 'then'\n        elseb.comment = 'else'\n        contb.comment = 'endif'\n      }\n    } else {\n      // if cond then A end\n      thenb.succs = [elseb] // then -> else\n      elseb.preds = [ifb, thenb] // else <- if, then\n      elseb.succs = null\n      r.startSealedBlock(elseb)\n\n      if (r.flags & IRFlags.Comments) {\n        thenb.comment = 'then'\n        elseb.comment = 'endif'\n      }\n    }\n  }\n\n\n  // assign does left = right.\n  // Right has already been evaluated to ssa, left has not.\n  assign(left :ast.Expr, right :Value) :Value {\n    const s = this\n\n    assert(left instanceof ast.Ident, `${left.constructor.name} not supported`)\n    let name = (left as ast.Ident).value\n    \n    // // Issue a \"copy\" to indicate \"store to variable\"\n    // let v = s.b.newValue1(Op.Copy, right.type, right)\n    // if (s.flags & IRFlags.Comments) {\n    //   v.comment = name.toString()\n    // }\n    //\n    // // dlog(`assign \"${name}\" ${left} <— ${right}`)\n    // s.writeVariable(name, v)\n\n    // s.addNamedValue(left, right)\n    // let t = rhs.type as BasicType\n    // assert(t instanceof BasicType, \"not a basic type\")\n    // let op = storeop(t)\n    // v = r.b.newValue1(op, t, src, dst)\n    // return right\n\n    // instead of issuing an intermediate \"store\", simply associate variable\n    // name with the value on the right-hand side.\n    s.writeVariable(name, right)\n    return right\n  }\n\n\n  // process an assignment node\n  assignment(s :ast.Assignment) :Value {\n    const r = this\n\n    if (s.op == token.INC || s.op == token.DEC) {\n      // e.g. \"x++\"  =>  \"x = x + 1\"\n      assert(s.lhs.length == 1)\n      assert(s.rhs.length == 0)\n      let lhs = s.lhs[0]\n\n      assert(lhs.type instanceof BasicType, `${lhs.type} is not BasicType`)\n      let t = lhs.type as BasicType\n      let x = r.expr(lhs)\n      let y = r.f.constVal(t, 1)\n\n      // generate \"x = x op 1\"\n      let op = getop(s.op == token.INC ? token.ADD : token.SUB, t)\n      let v = r.b.newValue2(op, t, x, y)\n      return r.assign(lhs, v)\n    }\n\n    if (s.op != token.ASSIGN) {\n      assert(\n        // i.e. not \"op=\"\n        s.op < token.assignop_beg || s.op > token.assignop_end,\n        `invalid assignment operation ${token[s.op]}`\n      )\n      // \"x += 4\", \"x *= 2\", etc  =>  \"x = x + 4\", \"x = x * 2\", etc.\n      assert(s.lhs.length == 1)\n      assert(s.rhs.length == 1)\n\n      let lhs = s.lhs[0]\n      let t = lhs.type as BasicType\n      assert(t instanceof BasicType, \"increment operation on complex type\")\n\n      let op = getop(s.op, t)\n      let x = r.expr(lhs)\n      let y = r.expr(s.rhs[0])\n      let v = r.b.newValue2(op, t, x, y)\n      return r.assign(lhs, v)\n    }\n\n    // if we get here, we're dealing with a regular assignment, e.g. \"x = y\"\n\n    // break up \"x, y = a, b\" assignments into simple \"x = a\", \"y = b\"\n    //\n    let z = s.lhs.length\n    let preloadRhs :(Value|undefined)[]|null = null  // \"holey\" array\n\n    if (z > 1) {\n      // potentially rewrite RHS with preloads and temps when an identifier\n      // appears on both the left and right side.\n      //\n      // e.g. \"x, y, z = y, x, 2\" causes x and y to be preloaded into\n      // temporaries:\n      //   t0 = load x\n      //   t1 = load y\n      //   store t1 x\n      //   store t0 y\n      //   z = 2\n      //\n      let leftnames = new Map<ByteStr,int>() // name => position\n      for (let i = 0; i < z; i++) {\n        let x = s.lhs[i]\n        if (x instanceof ast.Ident) {\n          leftnames.set(x.value, i)\n        }\n      }\n      for (let i = 0; i < z; i++) {\n        let x = s.rhs[i]\n        if (x instanceof ast.Ident) {\n          let Li = leftnames.get(x.value)\n          if (Li == i) {\n            // e.g. \"x, y = x, 2\"\n            r.diag('warn', `${x} assigned to itself`, x.pos)\n          } else if (Li !== undefined) {\n            // appears on the left -- preload\n            if (!preloadRhs) {\n              preloadRhs = new Array<Value|undefined>(s.rhs.length)\n            }\n            preloadRhs[i] = r.expr(x)\n          }\n        }\n      }\n    }\n\n    let v :Value|null = null\n\n    for (let i = 0; i < z; i++) {\n      let left = s.lhs[i]\n      let k :Value|undefined\n      if (preloadRhs && (k = preloadRhs[i])) {\n        v = k\n      } else {\n        v = r.expr(s.rhs[i])\n      }\n      v = r.assign(left, v)\n    }\n\n    return v as Value\n  }\n\n\n  expr(s :ast.Expr) :Value {\n    const r = this\n    assert(s.type, `type not resolved for ${s}`)\n\n    if (s instanceof ast.BasicLit) {\n      if (s.op != token.ILLEGAL) {\n        // e.g. negation\n        dlog(`TODO handle BasicLit.op`)\n      }\n      let t = s.type //as BasicType\n      let c :number = 0\n      if (s.isInt()) {\n        c = s.isSignedInt() ? s.parseSInt() : s.parseUInt()\n      } else {\n        c = s.parseFloat()\n      }\n      return r.f.constVal(t, c)\n    }\n\n    if (s instanceof ast.Ident) {\n      return r.readVariable(s.value, s.type as Type, null)\n    }\n\n    if (s instanceof ast.Assignment) {\n      return r.assignment(s)\n    }\n\n    if (s instanceof ast.Operation) {\n      // \"x op y\" => \"tmp = x op y\" -> tmp\n      if (s.op == token.OROR || s.op == token.ANDAND) {\n        return r.opAndAnd(s)\n      } else {\n        // Basic operation\n        let left = r.expr(s.x)\n        let t = s.type as BasicType; assert(t instanceof BasicType)\n        let op = getop(s.op, t)\n        if (s.y) {\n          // Basic binary operation\n          let right = r.expr(s.y)\n          return r.b.newValue2(op, t, left, right)\n        } else {\n          // Basic unary operation\n          return r.b.newValue1(op, t, left)\n        }\n      }\n    }\n\n    if (s instanceof ast.CallExpr) {\n      return r.funcall(s)\n    }\n\n    dlog(`TODO: handle ${s.constructor.name}`)\n    return r.nilValue()\n  }\n\n\n  opAndAnd(n :ast.Operation) :Value {\n    // high-level \"&&\" or \"||\" operation, lowered to branching.\n    //\n    // We implement \"||\" and \"&&\" via a temporary var and \"if\" branch.\n    // E.g. source code\n    //    x && y\n    // is converted to\n    //    t = x\n    //    if t {\n    //      t = y\n    //    }\n    // and t is unsed in place.\n    // OROR is converted in a similar manner:\n    //    x || y\n    // is converted to\n    //    t = x\n    //    if !t {\n    //      t = y\n    //    }\n    //\n    // Reference of Go AST -> IR for OROR and ANDAND:\n    //   https://github.com/golang/go/blob/\n    //   10d096fec2fe8f3e88f847fd0ac17c0601bf6442/src/cmd/compile/internal/\n    //   gc/ssa.go#L1957\n    //\n    // -------------------------------------------------------------------\n    // Note on WASM:\n    // WebAssembly provides a \"select\" operator with these semantics:\n    //   t1 = A<T>\n    //   t2 = B<T>\n    //   select C<i32> t1 t2 => D<T>\n    // Where if C is not zero, value of A is used, otherwise value of B is\n    // used, resulting in D. A and B must be of the same type and both A\n    // and B are evaluated prior to the operator (not short-circuiting.)\n    // This would make sense to use only for special cases where both A\n    // and B are constants.\n    // In order to target this operator in WASM, we need a higher-level\n    // construct to represent ANDAND and OROR. After this (current)\n    // if-construction, it won't be easy to later \"revert\" to ANDAND and\n    // OROR.\n    // Idea 1: Include target information when generating IR and only\n    //         unroll into \"if\" branches if the target doesn't support\n    //         something like WASM's \"select\".\n    // Idea 2: Perform this step later \n    //\n    // However, for now, since it's a possibly-small RoI optimization\n    // opportunity, we're ignoring this.\n    // -------------------------------------------------------------------\n    //\n    const s = this\n    assert(n.y != null)\n\n    let tmpname = asciiByteStr('tmp') // TODO: use `s` (just need a ref)\n\n    let left = s.expr(n.x)\n    s.writeVariable(tmpname, left)\n\n    let t = left.type\n\n    let rightb = s.f.newBlock(BlockKind.Plain)  // y\n    let contb = s.f.newBlock(BlockKind.Plain) // t\n\n    // end entry \"if\" block\n    let ifb = s.endBlock()\n    ifb.kind = BlockKind.If\n    ifb.control = left\n\n    if (n.op == token.OROR) {\n      // flip branches; equivalent to \"ifFalse\"/\"ifz\"\n      ifb.succs = [contb, rightb] // if -> contb, rightb\n    } else {\n      assert(n.op == token.ANDAND)\n      ifb.succs = [rightb, contb] // if -> rightb, contb\n    }\n\n    // gen \"right\" block\n    rightb.preds = [ifb] // rightb <- if\n    s.startSealedBlock(rightb)\n    let right = s.expr(n.y as ast.Expr)\n    let tmpv = s.b.newValue1(Op.Copy, right.type, right)\n    s.writeVariable(tmpname, tmpv)\n    rightb = s.endBlock()\n    rightb.succs = [contb] // rightb -> contb\n\n    assert(t.equals(right.type), \"operands have different types\")\n\n    // start continuation block\n    contb.preds = [ifb, rightb] // contb <- ifb, rightb\n    s.startSealedBlock(contb)\n\n    return s.readVariable(tmpname, ast.u_t_bool, null)\n  }\n\n\n  funcall(x :ast.CallExpr) :Value {\n    const s = this\n\n    if (x.hasDots) {\n      dlog(`TODO: handle call with hasDots`)\n    }\n\n    // first unroll argument values\n    let argvals :Value[] = []\n    for (let arg of x.args) {\n      argvals.push(s.expr(arg))\n    }\n\n    // then push params\n    for (let v of argvals) {\n      s.b.newValue1(Op.PushParam, v.type, v)\n    }\n\n    // TODO: handle any function by\n    // let fv = s.expr(x.fun)\n    // and implementing function resolution somehow in readGlobal et al.\n\n    assert(x.fun instanceof ast.Ident, \"non-id callee not yet supported\")\n    let funid = x.fun as ast.Ident\n    assert(funid.ent, \"unresolved callee\")\n\n    let ft = funid.type as FunType\n    assert(ft, \"unresolved function type\")\n\n    return s.b.newValue0(Op.Call, ft.result, funid.value)\n  }\n\n\n  readVariable(name :ByteStr, t :Type, b :Block|null) :Value {\n    const s = this\n\n    if (!b || b === s.b) {\n      let v = s.vars.get(name)\n      if (v) {\n        return v\n      }\n      b = s.b\n    } else {\n      let m = s.defvars[b.id]\n      if (m) {\n        let v = m.get(name)\n        if (v) {\n          return v\n        }\n      }\n    }\n\n    // global value numbering\n    return s.readVariableRecursive(name, t, b)\n  }\n\n\n  readGlobal(name :ByteStr) :Value {\n    const s = this\n    dlog(`TODO readGlobal ${name}`)\n    return s.nilValue() // FIXME\n  }\n\n\n  writeVariable(name :ByteStr, v :Value, b? :Block) {\n    const s = this\n    dlog(`${b || s.b} ${name} = ${Op[v.op]} ${v}`)\n    if (!b || b === s.b) {\n      s.vars.set(name, v)\n    } else {\n      while (s.defvars.length <= b.id) {\n        // fill any holes\n        s.defvars.push(null)\n      }\n      let m = s.defvars[b.id]\n      if (m) {\n        m.set(name, v)\n      } else {\n        s.defvars[b.id] = new Map<ByteStr,Value>([[name, v]])\n      }\n    }\n  }\n\n  addIncompletePhi(phi :Value, name :ByteStr, b :Block) {\n    const s = this\n    dlog(`${b} ${phi} var=${name}`)\n    let names = s.incompletePhis ? s.incompletePhis.get(b) : null\n    if (!names) {\n      names = new Map<ByteStr,Value>()\n      if (!s.incompletePhis) {\n        s.incompletePhis = new Map<Block,Map<ByteStr,Value>>()\n      }\n      s.incompletePhis.set(b, names)\n    }\n    names.set(name, phi)\n  }\n\n\n  readVariableRecursive(name :ByteStr, t :Type, b :Block) :Value {\n    const s = this\n    let val :Value\n\n    if (!b.sealed) {\n      // incomplete CFG\n      dlog(`${b} ${name} not yet sealed`)\n      val = b.newPhi(t)\n      s.addIncompletePhi(val, name, b)\n\n    } else if (b.preds.length == 1) {\n      dlog(`${b} ${name} common case: single predecessor ${b.preds[0]}`)\n      // Optimize the common case of one predecessor: No phi needed\n      val = s.readVariable(name, t, b.preds[0])\n      dlog(`found ${name} : ${val}`)\n\n    } else if (b.preds.length == 0) {\n      dlog(`${b} ${name} uncommon case: outside of function`)\n      // entry block\n      val = s.readGlobal(name)\n      // TODO: consider just returning the value here instead of falling\n      // through and causing writeVariable.\n\n    } else {\n      dlog(`${b} ${name} uncommon case: multiple predecessors`)\n      // Break potential cycles with operandless phi\n      val = b.newPhi(t)\n      s.writeVariable(name, val, b)\n      val = s.addPhiOperands(name, val)\n    }\n    s.writeVariable(name, val, b)\n    return val\n  }\n\n\n  addPhiOperands(name :ByteStr, phi :Value) :Value {\n    const s = this\n    assert(phi.op == Op.Phi)\n    // Determine operands from predecessors\n    dlog(`${name} phi=${phi}`)\n    for (let pred of phi.b.preds) {\n      dlog(`  ${pred}`)\n      let v = s.readVariable(name, phi.type, pred)\n      if (v !== phi) {\n        dlog(`  ${pred} ${v}<${Op[v.op]}>`)\n        phi.appendArg(v)\n      }\n    }\n    return s.tryRemoveTrivialPhi(phi)\n  }\n\n\n  tryRemoveTrivialPhi(phi :Value) :Value {\n    const s = this\n    assert(phi.op == Op.Phi)\n    let same :Value|null = null\n    dlog(`${phi.b} ${phi}`)\n\n    assert(phi.args != null, \"phi without operands\")\n    for (let operand of phi.args as Value[]) {\n      if (operand === same || operand === phi) {\n        continue // Unique value or self−reference\n      }\n      if (same != null) {\n        dlog(`${phi.b} ${phi} not trivial (keep)`)\n        return phi // The phi merges at least two values: not trivial\n      }\n      same = operand\n    }\n\n    dlog(`${phi.b} ${phi} is trivial (remove)`)\n\n    if (same == null) {\n      dlog(`${phi.b} ${phi} unreachable or in the start block`)\n      same = new Value(0, Op.None, ast.u_t_nil, phi.b, null) // dummy FIXME\n      // same = new Undef() // The phi is unreachable or in the start block\n    }\n\n    phi.users.delete(phi) // Remember all users except the phi itself\n    let users = phi.users\n    dlog(`${phi.b} replace ${phi} with ${same} (aux = ${same.aux})`)\n    phi.replaceBy(same) // Reroute all uses of phi to same and remove phi\n    assert(phi.uses == 0, `still used even after Value.replaceBy`)\n\n    // Try to recursively remove all phi users, which might have become trivial\n    for (let use of users) {\n      if (use.op == Op.Phi) {\n        s.tryRemoveTrivialPhi(use)\n      }\n    }\n\n    return same\n  }\n\n\n  // diag reports a diagnostic message, or an error if k is ERROR\n  //\n  diag(k :DiagKind, msg :string, pos :Pos) {\n    const r = this\n    assert(k != \"error\", \"unexpected DiagKind 'error'\")\n    if (r.diagh) {\n      assert(r.sfile)\n      r.diagh((r.sfile as SrcFile).position(pos), msg, k)\n    }\n  }\n\n}","import { Pkg, Fun, Block, BlockKind, Value, Op } from './ir'\nimport { Style, stdoutStyle, style, noStyle } from './termstyle'\n\nexport type LineWriter = (s :string) => any\n\nclass IRFmt {\n  rarr :string  // \" -> \"\n  larr :string  // \" <- \"\n\n  constructor(\n  public types :bool,\n  public style :Style,\n  public println :LineWriter,\n  ){\n    this.rarr = style.grey(' —> ')\n    this.larr = style.grey(' <— ')\n  }\n}\n\nfunction fmtval(f :IRFmt, v :Value) :string {\n  let s = `v${v.id} = `\n  s += Op[v.op]\n  if (f.types) {\n    s += ' ' + f.style.grey(`<${v.type}>`)\n  }\n  if (v.args) for (let arg of v.args) {\n    s += ' ' + arg\n  }\n  if (v.aux !== null) {\n    s += ' [' + v.aux + ']'\n  }\n  if (v.comment) {\n    s += '  // ' + v.comment\n  }\n  return s\n}\n\n\nfunction printval(f :IRFmt, v :Value, indent :string) {\n  f.println(indent + fmtval(f, v))\n}\n\n\nfunction printblock(f :IRFmt, b :Block, indent :string) {\n  let label = b.toString()\n  let preds = ''\n  if (b.preds && b.preds.length) {\n    preds = f.larr + b.preds.map(b => \n      f.style.lightyellow(b.toString()) ).join(', ')\n  }\n  let comment = b.comment ? '  // ' + b.comment : ''\n  f.println(indent + f.style.lightyellow(label + ':') + preds + comment)\n\n  let valindent = indent + '  '\n  for (let v of b.values) {\n    printval(f, v, valindent)\n  }\n\n  switch (b.kind) {\n\n    case BlockKind.Plain: {\n      // check & print successors\n      assert(b.succs != null, 'missing successor for plain block')\n      assert(b.succs && b.succs.length == 1,\n        `b.succs.length = ${b.succs && b.succs.length || 0}; expected 1`)\n      let succs = b.succs as Block[]\n      let contb = succs[0]\n      f.println(\n        indent +\n        f.style.cyan('cont') + f.rarr +\n        f.style.lightyellow(contb.toString())\n      )\n      break\n    }\n\n    case BlockKind.If: {\n      // check & print successors\n      assert(b.succs != null, 'missing successors for if block')\n      assert(b.succs && b.succs.length == 2,\n        `b.succs.length = ${b.succs && b.succs.length || 0}; expected 2`)\n      assert(b.control, \"missing control (condition) value\")\n      let succs = b.succs as Block[]\n      let thenb = succs[0]\n      let elseb = succs[1]\n      f.println(\n        indent +\n        f.style.cyan('if') +\n        ` ${b.control}${f.rarr}` +\n        f.style.lightyellow(thenb.toString()) + ' ' +\n        f.style.lightyellow(elseb.toString())\n      )\n      break\n    }\n\n    case BlockKind.Ret: {\n      // check successors\n      assert(b.succs == null, \"can't have successor to return block\")\n      f.println(\n        indent +\n        f.style.cyan('ret') + (b.control ? ' ' + b.control : '')\n      )\n      break\n    }\n\n    default:\n      assert(false, `unexpected block kind ${BlockKind[b.kind]}`)\n  }\n}\n\n\nfunction printfun(f :IRFmt, fn :Fun) {\n  f.println(\n    f.style.white(fn.toString()) +\n    ' (' + fn.type.inputs.join(' ') + ')->' + fn.type.result\n  )\n  let first = true\n  for (let b of fn.blocks) {\n    if (first) {\n      first = false\n    } else {\n      f.println('')\n    }\n    printblock(f, b, /*indent*/'  ')\n  }\n}\n\n\nfunction printpkg(f :IRFmt, pkg :Pkg) {\n  // data :Uint8Array      // data  TODO wrap into some simple linear allocator\n  // funs :Fun[] = []      // functions\n  // init :Fun|null = null // init functions (merged into one)\n  for (let i = 0; i < pkg.funs.length; i++) {\n    printfun(f, pkg.funs[i])\n    if (i+1 < pkg.funs.length) {\n      f.println('')\n    }\n  }\n}\n\n\nexport interface Options {\n  noTypes?  :bool  // include type annotations\n  colors? :bool\n    // true: always generate ANSI-styled output\n    // false: never generate ANSI-styled output\n    // undefined: generate ANSI-styled output if stdout is a TTY\n}\n\nexport function printir(v :Fun|Block|Value, w? :LineWriter, o? :Options) {\n  let f = new IRFmt(\n    /*types*/ !(o && o.noTypes),\n    /*style*/ (\n      o && o.colors ? style :\n      o && o.colors === false ? noStyle :\n      stdoutStyle\n    ),\n    /*println*/ w || console.log.bind(console) as LineWriter,\n  )\n  if      (v instanceof Pkg) {   printpkg(f, v) }\n  else if (v instanceof Fun) {   printfun(f, v) }\n  else if (v instanceof Block) { printblock(f, v, /*indent=*/'') }\n  else if (v instanceof Value) { printval(f, v, /*indent=*/'') }\n  else {\n    let o = v as any\n    assert(false,\n      `unexpected value ${o && typeof o == 'object' ? o.constructor.name : o}`\n    )\n  }\n}\n\nexport function fmtir(v :Fun|Block|Value, options? :Options) :string {\n  let str = ''\n  let w = (s :string) => { str += s + '\\n' }\n  printir(v, w, options)\n  return str\n}\n","import { Parser } from './parser'\nimport { bindpkg } from './bind'\nimport * as scanner from './scanner'\nimport { Position, SrcFileSet } from './pos'\nimport { ByteStrSet } from './bytestr'\nimport { TypeSet } from './typeset'\nimport { astRepr } from './ast-repr'\nimport { Package, Scope, Ent } from './ast'\nimport { Universe } from './universe'\nimport { TypeResolver } from './resolve'\nimport { stdoutStyle, stdoutSupportsStyle } from './termstyle'\nimport { IRBuilder, IRFlags } from './ir'\nimport * as ir from './ir'\nimport { printir, fmtir } from './ir-repr'\n\n\n// fs\ntype SyncFileReader = (fn :string, options? :{[k:string]:any}) => Uint8Array\nlet readFileSync :SyncFileReader\nlet isNodeJsLikeEnv = false\ntry {\n  const _readFileSync = require('fs').readFileSync\n  readFileSync = _readFileSync as SyncFileReader\n  isNodeJsLikeEnv = true\n} catch(_) {\n  // Hack to support the playground.\n  // TODO: export a nice API instead of this mess.\n  let global_readFileSync = global['readFileSync']\n  if (global_readFileSync && typeof global_readFileSync == 'function') {\n    readFileSync = global_readFileSync as SyncFileReader\n  } else {\n    readFileSync = (fn :string, options? :{[k:string]:any}) => {\n      // FIXME\n      return new Uint8Array(0)\n    }\n  }\n}\n\n\nconst reprOptions = {colors:stdoutSupportsStyle}\n\n// TODO FIXME this collects errors and diagnostics for the web playground.\n// replace this with a better API.\ninterface diaginfo {\n  type: string  // info | warn | error\n  errcode?: string // available when type==\"error\"\n  message: string\n  pos: Position\n}\nlet diagnostics :diaginfo[]\n\nfunction errh(pos :Position, message :string, errcode :string) {\n  if (isNodeJsLikeEnv) {\n    let msg = `${pos}: ${message} (${errcode})`\n    console.error(stdoutStyle.red(msg))\n  }\n  diagnostics.push({ type: 'error', errcode, message, pos })\n}\n\nfunction diagh(pos :Position, message :string, type :string) {\n  if (isNodeJsLikeEnv) {\n    const msg = `${pos}: ${type}: ${message}`\n    console.log(\n      '[diag] ' +\n      ( type == \"info\" ? stdoutStyle.cyan(msg) :\n        stdoutStyle.lightyellow(msg)\n      )\n    )\n  }\n  diagnostics.push({ type, message, pos })\n}\n\ninterface ParseResults {\n  pkg     :Package\n  success :bool\n}\n\nfunction parsePkg(\n  name     :string,\n  sources  :string[],\n  universe :Universe,\n  parser   :Parser,\n  typeres  :TypeResolver,\n) :Promise<ParseResults> {\n\n  const pkg = new Package(name, new Scope(universe.scope))\n  const fset = new SrcFileSet()\n\n  typeres.init(fset, universe, errh)\n\n  for (let filename of sources) {\n    if (isNodeJsLikeEnv) {\n      banner(`parse ${filename}`)\n    }\n\n    const sdata = readFileSync(filename, {flag:'r'}) as Uint8Array\n    const sfile = fset.addFile(filename, sdata.length)\n\n    parser.initParser(\n      sfile,\n      sdata,\n      universe,\n      pkg.scope,\n      typeres,\n      errh,\n      diagh,\n      scanner.Mode.ScanComments\n    )\n\n    const file = parser.parseFile()\n    pkg.files.push(file)\n\n    if (isNodeJsLikeEnv) {\n      if (file.imports) {\n        console.log(`${file.imports.length} imports`)\n        for (let imp of file.imports) {\n          console.log(astRepr(imp, reprOptions))\n        }\n      }\n\n      if (file.unresolved) {\n        console.log(`${file.unresolved.size} unresolved references`)\n        for (let ident of file.unresolved) {\n          console.log(' - ' + astRepr(ident, reprOptions))\n        }\n      }\n\n      console.log(`${file.decls.length} declarations`)\n      // for (let decl of file.decls) {\n      //   console.log(astRepr(decl, reprOptions))\n      // }\n      console.log(astRepr(file, reprOptions))\n    }\n  }\n\n  if (parser.errorCount > 0 || typeres.errorCount > 0) {\n    return Promise.resolve({ pkg, success: false })\n  }\n\n  // bind and assemble package\n  if (isNodeJsLikeEnv) {\n    banner(`bind & assemble ${pkg}`)\n  }\n  function importer(_imports :Map<string,Ent>, _path :string) :Promise<Ent> {\n    return Promise.reject(new Error(`not found`))\n  }\n\n  return bindpkg(pkg, fset, importer, typeres, errh)\n    .then(hasErrors => ( { pkg, success: !hasErrors } ))\n}\n\ninterface MainResult {\n  success     :bool\n  diagnostics :diaginfo[]\n  ast?        :Package\n  ir?         :ir.Pkg\n}\n\nfunction main(sources? :string[], noIR? :bool) :Promise<MainResult> {\n  const strSet = new ByteStrSet()\n  const typeSet = new TypeSet()\n  const universe = new Universe(strSet, typeSet)\n  const typeres = new TypeResolver()\n  const parser = new Parser()\n\n  const _sources = sources || ['example/ssa1.xl']\n  diagnostics = []\n\n  let p = parsePkg(\"example\", _sources, universe, parser, typeres).then(r => {\n    if (!r.success) {\n      return { success: false, diagnostics, ast: r.pkg }\n    }\n    if (noIR) {\n      return { success: true, diagnostics, ast: r.pkg }\n    }\n\n    const irb = new IRBuilder()\n    irb.init(diagh, IRFlags.Comments)\n\n    // print AST & build IR\n    try {\n      for (const file of r.pkg.files) {\n\n        if (isNodeJsLikeEnv) {\n          banner(`${r.pkg} ${file.sfile.name} ${file.decls.length} declarations`)\n          console.log(astRepr(r.pkg, reprOptions))\n          // for (let decl of file.decls) {\n          //   console.log(astRepr(decl, reprOptions))\n          // }\n          banner(`ssa-ir ${file.sfile.name}`)\n        }\n\n        // build IR\n        let sfile = file.sfile\n        for (let d of file.decls) {\n          let n = irb.addTopLevel(sfile, d)\n          if (isNodeJsLikeEnv) {\n            if (n) {\n              console.log(`\\n-----------------------\\n`)\n              printir(n)\n            }\n          }\n        }\n      }\n\n      return { success: true, diagnostics, ast: r.pkg, ir: irb.pkg }\n    } catch (error) {\n      if (isNodeJsLikeEnv) {\n        throw error\n      }\n      return { success: false, error, diagnostics, ast: r.pkg }\n    }\n  })\n\n  if (!sources && isNodeJsLikeEnv) {\n    return p.catch(err => {\n      console.error(err.stack || ''+err)\n      process.exit(1)\n      return { success: false, diagnostics }\n    })\n  }\n\n  return p\n}\n\n\n// banner prints a large message, using terminal styling when available.\n//\nfunction banner(message :string) {\n  if (stdoutSupportsStyle) {\n    // '\\x1b[47;30m'    black on white\n    // '\\x1b[40;37;1m'  bold white on black\n    // '\\x1b[44;37;1m'  bold white on blue\n    const s = (s :string) => '\\x1b[40m' + stdoutStyle.white(s) + '\\x1b[0m'\n    process.stdout.write(\n      s('\\n\\n  ' + message + '\\n') + '\\n\\n'\n    )\n  } else {\n    console.log(\n      '\\n========================================================\\n' +\n      message +\n      '\\n--------------------------------------------------------'\n    )\n  }\n}\n\n\nif (isNodeJsLikeEnv) {\n  main()\n} else {\n  global['colang'] = {\n    main,\n    fmtast: astRepr,\n    fmtir,\n    printir,\n  }\n}\n"],"names":["utf8.encodeAsString","path.dir","utf8.decode","utf8.UniSelf","unicode.repr","unicode.isEmojiModifier","unicode.isEmojiModifierBase","unicode.InvalidChar","unicode.MaxRune","utf8.UTFMax","utf8.encode","unicode.isLetter","unicode.isDigit","bufcmp","utf8.decodeToString","path.clean","path.isAbs","path.join","unicode.isEmojiPresentation","scanner.Scanner","scanner.Mode","dlog","util.search","uintz","Block","ast.u_t_nil","ast.MultiDecl","ast.VarDecl","ast.FunExpr","ast.ImportDecl","ast.TypeDecl","ast.Block","ast.IfExpr","ast.ReturnStmt","ast.WhileStmt","ast.Expr","ast.Ident","ast.BasicLit","ast.Assignment","ast.Operation","ast.CallExpr","ast.u_t_bool","style"],"mappings":"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zB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;QAC5B,CAAC,IAAI,MAAM;QACX,CAAC,IAAI,MAAM;SACV,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IA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SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;SACzB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3B,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC3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AC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;SAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;SACX,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;QAC9B,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;QACZ,CAAC,IAAI,OAAO;SACX,O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"}